<?xml version="1.0" encoding="UTF-8"?>
<bugrepository name="aspectj"><bug id="0" opendate="2003-01-03 10:28:00" fixdate="2003-01-14 19:31:02"><buginformation><summary>Compiler error when introducing a "final" field</summary><description>The aspect below fails to compile with 1.1b2, producing the compilation error: 
--------------------
$ ajc com/ibm/amc/*.java com/ibm/amc/ejb/*.java
d:/eclipse/runtime-workspace-ajsamples/Mock EJBs/com/ibm/amc/DemoBeanEJB.java:1:
 Cannot assign a value to the final field com.ibm.amc.DemoBean.ajc$interField$co
m_ibm_amc$verbose

!! no source information available !!

1 error
---------------------------


package com.ibm.amc;

import com.ibm.amc.ejb.SessionBean;
/**
 * @author colyer
 *
 * To change this generated comment edit the template variable "typecomment":
 * Window&gt;Preferences&gt;Java&gt;Templates.
 * To enable and disable the creation of type comments go to
 * Window&gt;Preferences&gt;Java&gt;Code Generation.
 */
public aspect DemoBeanEJB {

	declare parents: DemoBean implements SessionBean;
	
        // THIS NEXT LINE IS THE CULPRIT
	static final boolean DemoBean.verbose = true;
	
	private transient String DemoBean.ctx;
	
	public void DemoBean.ejbActivate( ) {
		if ( verbose ) {
			System.out.println( "ejbActivate Called" );	
		}	
	}
}


-------------------
Making the inter-type declaration non-final solves the problem...</description><comments/></buginformation><fixedCommits><commit id="99a873c3070bea836e8cd4bd33c610fb41efa2c6" author="default" date="2003-01-14 19:31:02"><file name="weaver/src/org/aspectj/weaver/AjcMemberMaker.java"><method name="makePublic" returnType="int" parameters="int"/><method name="interFieldClassField" returnType="ResolvedMember" parameters="ResolvedMember TypeX"/><method name="interFieldInterfaceField" returnType="ResolvedMember" parameters="ResolvedMember TypeX TypeX"/><method name="interMethod" returnType="ResolvedMember" parameters="ResolvedMember TypeX"/></file></commit></fixedCommits></bug><bug id="1" opendate="2002-12-30 16:40:00" fixdate="2003-01-14 20:02:43"><buginformation><summary>waever tries to weave into native methods ...</summary><description>If you don't find the exception below in a bug, please add a new bug
To make the bug a priority, please include a test program
that can reproduce this exception.
bad non-abstract method with no code: private native int 
nativeMessagePumpInitialize() on public class 
plc.comm.pvi.PviCom$LinkEventHandlerImpl
bad non-abstract method with no code: private native int 
nativeMessagePumpInitialize() on public class 
plc.comm.pvi.PviCom$LinkEventHandlerImpl
java.lang.RuntimeException: bad non-abstract method with no code: private 
native int nativeMessagePumpInitialize() on public class 
plc.comm.pvi.PviCom$LinkEventHandlerImpl
        at org.aspectj.weaver.bcel.LazyMethodGen.&lt;init&gt;(Unknown Source)
        at org.aspectj.weaver.bcel.LazyClassGen.&lt;init&gt;(Unknown Source)
        at org.aspectj.weaver.bcel.BcelObjectType.getLazyClassGen(Unknown 
Source)
        at org.aspectj.weaver.bcel.BcelWeaver.weave(Unknown Source)
        at org.aspectj.weaver.bcel.BcelWeaver.weave(Unknown Source)
        at 
org.aspectj.ajdt.internal.core.builder.AjBuildManager.weaveAndGenerateClassFiles
(Unknown Source)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild
(Unknown Source)
        at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(Unknown Source)
        at org.aspectj.tools.ajc.Main.run(Unknown Source)
        at org.aspectj.tools.ajc.Main.runMain(Unknown Source)
        at org.aspectj.tools.ajc.Main.main(Unknown Source)</description><comments/></buginformation><fixedCommits><commit id="27817202657a92778479de5063097086b511385b" author="default" date="2003-01-14 20:02:43"><file name="weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"><method name="packBody" returnType="void" parameters="MethodGen"/><method name="run" returnType="void" parameters=""/><method name="calculateMaxLocals" returnType="int" parameters=""/><method name="pack" returnType="MethodGen" parameters=""/></file></commit></fixedCommits></bug><bug id="2" opendate="2003-01-08 21:22:00" fixdate="2003-01-14 21:36:18"><buginformation><summary>ajc -emacssym chokes on pointcut that includes an intertype method</summary><description>This works fine without -emacssym, but dies with it:

aspect Foo {
  before() : call(void foo()) { }
  void Bar.bar() { foo(); }
}
class Bar {
  void foo() { }
}

munger: (before: (persingleton(Foo) &amp;&amp; call(ExactTypePattern(void) foo()))-&gt;void Foo.ajc$before$Foo$f()) on method-call(void Bar.foo())
trouble in: 
public class Foo extends java.lang.Object:
  TypeMungers: [(BcelTypeMunger ResolvedTypeMunger(Method, void Bar.bar()))]
  public static final Foo ajc$perSingletonInstance
  static void &lt;clinit&gt;():
                    INVOKESTATIC Foo.ajc$clinit ()V   (line 1)
    staticinitialization(void Foo.&lt;clinit&gt;())
    |               RETURN
    staticinitialization(void Foo.&lt;clinit&gt;())
  end static void &lt;clinit&gt;()

  void &lt;init&gt;():
                    ALOAD_0     // Foo this   (line 1)
                    INVOKESPECIAL java.lang.Object.&lt;init&gt; ()V
    constructor-execution(void Foo.&lt;init&gt;())
    |               RETURN
    constructor-execution(void Foo.&lt;init&gt;())
  end void &lt;init&gt;()

  public void ajc$before$Foo$f()    AdviceAttribute(before, call(ExactTypePattern(void) foo()), 0, 15)
:
    advice-execution(void Foo.ajc$before$Foo$f())
    |               RETURN   (line 2)
    advice-execution(void Foo.ajc$before$Foo$f())
  end public void ajc$before$Foo$f()

  public static void ajc$interMethod$Foo$Bar$bar(Bar)    EffectiveSignatureAttribute(void Bar.bar(), method-execution)
:
    method-execution(void Bar.bar())
    |               ALOAD_0     // Bar arg0   (line 3)
    | method-call(void Bar.foo())
    | |             GETSTATIC Foo.ajc$perSingletonInstance LFoo;
    | |             INVOKEVIRTUAL Foo.ajc$before$Foo$f ()V
    | |             INVOKEVIRTUAL Bar.foo ()V
    | method-call(void Bar.foo())
    |               RETURN
    method-execution(void Bar.bar())
  end public static void ajc$interMethod$Foo$Bar$bar(Bar)

  public static void ajc$interMethodDispatch1$Foo$Bar$bar(Bar)    EffectiveSignatureAttribute(void Bar.bar(), method-call)
:
                    ALOAD_0     // Bar arg0
                    INVOKEVIRTUAL Bar.ajc$interMethodDispatch2$$bar ()V
                    RETURN
  end public static void ajc$interMethodDispatch1$Foo$Bar$bar(Bar)

  public static Foo aspectOf()    org.aspectj.weaver.AjAttribute$AjSynthetic@f8f7db
:
                    GETSTATIC Foo.ajc$perSingletonInstance LFoo;
                    ARETURN
  end public static Foo aspectOf()

  public static boolean hasAspect()    org.aspectj.weaver.AjAttribute$AjSynthetic@5856a5
:
                    GETSTATIC Foo.ajc$perSingletonInstance LFoo;
                    IFNULL L0
                    ICONST_1
                    IRETURN
                L0: ICONST_0
                    IRETURN
  end public static boolean hasAspect()

  private static void ajc$clinit()    org.aspectj.weaver.AjAttribute$AjSynthetic@c39a20
:
                    NEW Foo
                    DUP
                    INVOKESPECIAL Foo.&lt;init&gt; ()V
                    PUTSTATIC Foo.ajc$perSingletonInstance LFoo;
                    RETURN
  end private static void ajc$clinit()
end public class Foo
Exception thrown from AspectJ 1.1b2

This might be logged as a bug already -- see the bug database at
   http://dev.eclipse.org  (product: AspectJ, component: compiler)

Bugs for exceptions thrown have titles File:line from the top stack, 
e.g., "SomeFile.java:243"

If you don't find the exception below in a bug, please add a new bug
To make the bug a priority, please include a test program
that can reproduce this exception.
null
java.lang.NullPointerException
	at org.aspectj.weaver.AsmAdaptor.findOrCreateBodyNode(Unknown Source)
	at org.aspectj.weaver.AsmAdaptor.getNode(Unknown Source)
	at org.aspectj.weaver.AsmAdaptor.noteMunger(Unknown Source)
	at org.aspectj.weaver.Shadow.implementMungers(Unknown Source)
	at org.aspectj.weaver.Shadow.implement(Unknown Source)
	at org.aspectj.weaver.bcel.BcelClassWeaver.implement(Unknown Source)
	at org.aspectj.weaver.bcel.BcelClassWeaver.weave(Unknown Source)
	at org.aspectj.weaver.bcel.BcelClassWeaver.weave(Unknown Source)
	at org.aspectj.weaver.bcel.BcelWeaver.weave(Unknown Source)
	at org.aspectj.weaver.bcel.BcelWeaver.weave(Unknown Source)
	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.weaveAndGenerateClassFiles(Unknown Source)
	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(Unknown Source)
	at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(Unknown Source)
	at org.aspectj.tools.ajc.Main.run(Unknown Source)
	at org.aspectj.tools.ajc.Main.runMain(Unknown Source)
	at org.aspectj.tools.ajc.Main.main(Unknown Source)


1 fail|abort</description><comments/></buginformation><fixedCommits><commit id="c1260e6b26b78f0f431b778cd8f22d3493e97f3f" author="default" date="2003-01-14 21:36:18"><file name="weaver/src/org/aspectj/weaver/Shadow.java"><method name="implementMungers" returnType="void" parameters=""/></file><file name="asm/src/org/aspectj/asm/StructureModel.java"><method name="findNodeForClass" returnType="ProgramElementNode" parameters="String String"/></file><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmBuilder.java"><method name="visit" returnType="boolean" parameters="TypeDeclaration CompilationUnitScope"/><method name="visit" returnType="boolean" parameters="MethodDeclaration ClassScope"/><method name="visit" returnType="boolean" parameters="MemberTypeDeclaration ClassScope"/></file><file name="weaver/src/org/aspectj/weaver/AsmAdaptor.java"><method name="getNode" returnType="ProgramElementNode" parameters="StructureModel Advice"/><method name="findMemberInClass" returnType="ProgramElementNode" parameters=""/><method name="findOrCreateBodyNode" returnType="ProgramElementNode" parameters=""/><method name="getNode" returnType="ProgramElementNode" parameters="StructureModel Shadow"/></file><file name="weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java"><method name="weave" returnType="LazyClassGen" parameters="UnwovenClassFile BcelObjectType"/></file></commit></fixedCommits></bug><bug id="3" opendate="2003-01-19 11:42:00" fixdate="2003-01-25 01:25:30"><buginformation><summary>Ajde does not support new AspectJ 1.1 compiler options</summary><description>The org.aspectj.ajde.BuildOptionsAdapter interface does not yet support the new 
AspectJ 1.1 compiler options. These need to be added to the interface, any old 
or renamed options deprecated, and then the correct processing needs to happen 
within Ajde to pass these options to the compiler.

This enhancement is needed by the various IDE projects for there AspectJ 1.1
support.</description><comments/></buginformation><fixedCommits><commit id="85a827a7f269a18a0c80802811bbc2aa3766c2e4" author="default" date="2003-01-25 01:25:30"><file name="ajde/src/org/aspectj/ajde/ProjectPropertiesAdapter.java"><method name="getVmArgs" returnType="String" parameters=""/></file><file name="ajbrowser/src/org/aspectj/tools/ajbrowser/BrowserProperties.java"><method name="setAjcWorkingDir" returnType="void" parameters="String"/></file><file name="ajde/src/org/aspectj/ajde/internal/AspectJBuildManager.java"><method name="getFormattedOptionsString" returnType="String" parameters="BuildOptionsAdapter ProjectPropertiesAdapter"/><method name="run" returnType="void" parameters=""/></file><file name="ajde/src/org/aspectj/ajde/BuildOptionsAdapter.java"><method name="getPreprocessMode" returnType="boolean" parameters=""/><method name="getStrictSpecMode" returnType="boolean" parameters=""/><method name="getUseJavacMode" returnType="boolean" parameters=""/><method name="getLenientSpecMode" returnType="boolean" parameters=""/><method name="getWorkingOutputPath" returnType="String" parameters=""/><method name="getSourceOnePointFourMode" returnType="boolean" parameters=""/><method name="getNonStandardOptions" returnType="String" parameters=""/></file></commit></fixedCommits></bug><bug id="4" opendate="2003-01-22 07:10:00" fixdate="2003-02-13 21:00:35"><buginformation><summary>super call in intertype method declaration body causes VerifyError</summary><description>AspectJ Compiler 1.1beta4
This program:

aspect Foo {
  void A.foo() { }
  void B.foo() { super.foo(); }
}

class A { }
class B extends A { }

class Main {
  public static void main(String[] args) {
    new B();
  }
}

causes this error at runtime:

Exception in thread "main" java.lang.VerifyError: (class: B, method: ajc$superDispatch$B$foo signature: ()V) Illegal use of nonvirtual function call
	at Main.main(Foo.java:11)

Note that foo is never even called; the error happens at load time when the new B() expression causes class B to be loaded.  There's no error if either one of the foo methods is declared in its class directly.

This is kind of a showstopper...

--Doug</description><comments/></buginformation><fixedCommits><commit id="3e2801ad504e8f6b3fa7b50a42bf2706994e1727" author="default" date="2003-02-13 21:00:35"><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/SuperFixerVisitor.java"><method name="endVisit" returnType="void" parameters="MessageSend BlockScope"/></file><file name="org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodBinding.java"><method name="getAccessMethod" returnType="MethodBinding" parameters=""/></file><file name="org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java"><method name="manageSyntheticAccessIfNecessary" returnType="void" parameters="BlockScope"/></file></commit></fixedCommits></bug><bug id="5" opendate="2003-01-24 07:25:00" fixdate="2003-02-13 22:00:34"><buginformation><summary>Error with certain combination of advice</summary><description>This program causes the java VM to crash. It is a minimal example -- if you remove anything in the aspects it works. 

1. PROGRAM CODE

package test;
import org.aspectj.lang.*;
import org.aspectj.lang.reflect.*;

public class Test3 {
   public static void main(String[] args) throws Exception {
      Test3 a = new Test3();
      a.foo(-3);
   }
   public void foo(int i) {
      this.x=i;
   }
   int x;
   

}

aspect Log {
   pointcut assign(Object newval, Object targ):
      set(* test..*)  &amp;&amp; args(newval) &amp;&amp; target(targ);

   before(Object newval, Object targ): assign(newval,targ) {
      Signature sign = thisJoinPoint.getSignature();
      System.out.println(targ.toString() + "." + sign.getName() + ":=" + newval);
   }
   /*
}
// Different error message if you divide into two aspects
aspect Tracing {
   */
   pointcut tracedCall():
      call(* test..*(..))/* &amp;&amp; !within(Tracing)*/ &amp;&amp; !within(Log);

   after() returning (Object o):  tracedCall() {
      // Works if you comment out either of these two lines
      thisJoinPoint.getSignature();
      System.out.println(thisJoinPoint);
   }
} 

2. RESULTS ON SOLARIS

[erik@oden test] java test.Test3 
 test.Test3@b8df17.x :=-3
 
Unexpected Signal : 11 occurred at PC=0xFA415A00
Function=[Unknown.]
Library=(N/A)
 
NOTE: We are unable to locate the function name symbol for the error
      just occurred. Please refer to release documentation for possible
      reason and solutions.
 
 
Current Java thread:
 
Dynamic libraries:
0x10000         java
0xff350000      /usr/lib/libthread.so.1
0xff390000      /usr/lib/libdl.so.1
0xff200000      /usr/lib/libc.so.1
0xff330000      /usr/platform/SUNW,Ultra-250/lib/libc_psr.so.1
0xfe000000      /usr/j2se/jre/lib/sparc/client/libjvm.so
0xff2e0000      /usr/lib/libCrun.so.1
0xff1e0000      /usr/lib/libsocket.so.1
0xff100000      /usr/lib/libnsl.so.1
0xff0d0000      /usr/lib/libm.so.1
0xff310000      /usr/lib/libw.so.1
0xff0b0000      /usr/lib/libmp.so.2
0xff080000      /usr/j2se/jre/lib/sparc/native_threads/libhpi.so
0xff050000      /usr/j2se/jre/lib/sparc/libverify.so
0xff020000      /usr/j2se/jre/lib/sparc/libjava.so
0xfe7e0000      /usr/j2se/jre/lib/sparc/libzip.so
0xfe5b0000      /usr/lib/locale/sv_SE/sv_SE.so.2
 
Local Time = Fri Jan 24 13:38:29 2003
Elapsed Time = 2
#
# HotSpot Virtual Machine Error : 11
# Error ID : 4F530E43505002D3 01
# Please report this error at
#  http://java.sun.com/cgi-bin/bugreport.cgi 
#
# Java VM: Java HotSpot(TM) Client VM (1.4.0-b92 mixed mode)
#
# An error report file has been saved as hs_err_pid15099.log.
# Please refer to the file for further information.
#
Abort
[erik@oden test] 
[erik@oden test] /usr/j2se.old/bin/java test.Test3
 test.Test3@1afa3.x :=-3
 
Unexpected Signal : 11 occurred at PC=0x85c24
Function name=(N/A)
Library=(N/A)
 
NOTE: We are unable to locate the function name symbol for the error
      just occurred. Please refer to release documentation for possible
      reason and solutions.
 
 
 
Current Java thread:
 
Dynamic libraries:
0x10000         /usr/j2se.old/bin/../bin/sparc/native_threads/java
0xff350000      /usr/lib/libthread.so.1
0xff390000      /usr/lib/libdl.so.1
0xff200000      /usr/lib/libc.so.1
0xff330000      /usr/platform/SUNW,Ultra-250/lib/libc_psr.so.1
0xfe480000      /usr/j2se.old/jre/lib/sparc/client/libjvm.so
0xff2e0000      /usr/lib/libCrun.so.1
0xff1e0000      /usr/lib/libsocket.so.1
0xff100000      /usr/lib/libnsl.so.1
0xff0d0000      /usr/lib/libm.so.1
0xff310000      /usr/lib/libw.so.1
0xff0b0000      /usr/lib/libmp.so.2
0xff080000      /usr/j2se.old/jre/lib/sparc/native_threads/libhpi.so
0xff050000      /usr/j2se.old/jre/lib/sparc/libverify.so
0xfe440000      /usr/j2se.old/jre/lib/sparc/libjava.so
0xff020000      /usr/j2se.old/jre/lib/sparc/libzip.so
0xfe260000      /usr/lib/locale/sv_SE/sv_SE.so.2
 
Local Time = Fri Jan 24 13:39:20 2003
Elapsed Time = 2
#
# HotSpot Virtual Machine Error : 11
# Error ID : 4F530E43505002C4 01
# Please report this error at
#  http://java.sun.com/cgi-bin/bugreport.cgi 
#
# Java VM: Java HotSpot(TM) Client VM (1.3.1_02-b02 mixed mode)
#
# An error report file has been saved as hs_err_pid15100.log.
# Please refer to the file for further information.
#
Abort
[erik@oden test] 

3. RESULTS ON WINDOWS 2000

Results on Windows 2000 (If I have copied it correctly)
 &gt;java -classpath ..\..\aspectj1.1\lib\aspectjrt.jar;. test.Test3 
 test.Test3@1a8c4e7.x :=-3
Exception in thread "main" java.lang.NullPointerException
        at test.Log.ajc$afterReturning$test_Log$30d(Test3.java:37)
        at test.Test3.main(Test3.java:8)
 &gt;java -version 
java version "1.4.1_01"
Java(TM) 2 Runtime Environment, Standard Edition (build 1.4.1_01-b01)
Java HotSpot(TM) Client VM (build 1.4.1_01-b01, mixed mode)
java</description><comments/></buginformation><fixedCommits><commit id="d15eb325fc77d9f1eb0ac9ec1f6886562d531105" author="default" date="2003-02-13 22:00:34"><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/ThisJoinPointVisitor.java"><method name="replaceEffectivelyStaticRef" returnType="void" parameters="MessageSend"/><method name="isRef" returnType="boolean" parameters="NameReference Binding"/><method name="computeJoinPointParams" returnType="void" parameters=""/><method name="isRef" returnType="boolean" parameters="Expression Binding"/><method name="endVisit" returnType="void" parameters="SingleNameReference BlockScope"/></file></commit></fixedCommits></bug><bug id="6" opendate="2003-02-09 12:29:00" fixdate="2003-02-13 22:24:56"><buginformation><summary>Pointcut adviceexecution() does not work</summary><description>Pointcut adviceexecution() does not seem to pick advice execution
join points in beta4. Here is a program that shows the problem:

public class Test {
    public static void main(String[] args) {
    }
}

aspect Aspect1 {
    before() : execution(* Test.*(..)) {
	System.out.println("Reached " + thisJoinPoint);
    }
}

aspect Aspect2 {
    before() : adviceexecution() &amp;&amp; !within(Aspect2) {
	System.out.println("Reached " + thisJoinPoint);
    }
}

F:\aop\bugs\1.1\b4\adviceexecution&gt;ajc -version
AspectJ Compiler 1.1beta4

F:\aop\bugs\1.1\b4\adviceexecution&gt;ajc Test.java

F:\aop\bugs\1.1\b4\adviceexecution&gt;java Test
Reached execution(void Test.main(String[]))</description><comments/></buginformation><fixedCommits><commit id="19c3e16d2212bdd41144da2150c8ef46b4a759a5" author="default" date="2003-02-13 22:24:56"><file name="weaver/src/org/aspectj/weaver/patterns/SignaturePattern.java"><method name="matches" returnType="boolean" parameters="Member World"/></file></commit></fixedCommits></bug><bug id="7" opendate="2003-03-02 20:01:00" fixdate="2003-03-05 21:46:49"><buginformation><summary>Negation of if pointcut does not work</summary><description>In "!if(expression)" the negation part is ignored. I am using beta4.

How to reproduce:

public class Test {
    public static void main(String args[]) {
    }
}

aspect NotIfBugAspect {
    before() : execution(* main(..)) &amp;&amp; !if(true) {
	System.out.println("NotIfBugAspect message");
    }
}

 &gt; ajc *.java
&gt; java Test 
NotIfBugAspect message

If I change the pointcut in before advice to move negation inside if(), 
everything works fine:
aspect NotIfBugAspect {
    before() : execution(* main(..)) &amp;&amp; if(!true) {
	System.out.println("NotIfBugAspect message");
    }
}

 &gt; ajc *.java
&gt; java Test 
  &lt;no output&gt;</description><comments/></buginformation><fixedCommits><commit id="cb775240056309c20aac308be5ab2abd9696be84" author="default" date="2003-03-05 21:46:49"><file name="weaver/src/org/aspectj/weaver/patterns/IfPointcut.java"><method name="toString" returnType="String" parameters=""/><method name="findResidue" returnType="Test" parameters="Shadow ExposedState"/></file></commit></fixedCommits></bug><bug id="8" opendate="2003-02-21 05:59:00" fixdate="2003-03-06 00:24:39"><buginformation><summary>ajc reports error when encountering static declaration of nested classes</summary><description>Version: AspectJ Compiler 1.1beta4

The ajc compiler issues a spurious error message and exits with a negative 
error code when weaving code containing static declaration of a nested class. 
The compiler seem to write the classfiles correctly but the negative exit 
status causes problems when e.g. using the AjcCompilerAdapter in ant.

To reproduce:
1) Extract the following two files into an empty directory:
// File: A.aj:
aspect A  {

    pointcut withinTest(): within(Test);
    pointcut callToHandleOrder() : (withinTest() &amp;&amp;
                             call(* handleOrder(..)));

    Object around(): callToHandleOrder() {

      return "DUMMY inserted by ASPECT" ;
   }
}
// End of File A.aj

// File : Test.java
public class Test
{
    // Commenting out the static declaration makes everything work OK
    static
    {
        class StaticNestedClass
        {
        }
    }
    
    public static void main(String[] args)
    {
      System.out.println(new Test().handleOrder("test"));
    }

    private String handleOrder(String t)
    {
      return t;
    }

}
// End of Test.java

2) Compile the files 
   ajc -sourceroots . -verbose

Output:
-----
compiling c:/aspectj1.1/doc/examples/bug/./A.aj
compiling c:/aspectj1.1/doc/examples/bug/./Test.java
weaving
might need to weave [UnwovenClassFile(null, Test$1$StaticNestedClass), 
UnwovenClassFile(null, A), UnwovenClassFile(null, Test)](world=true)
wrote class file: c:\aspectj1.1\doc\examples\bug\A.class
can't find type Test$1
wrote class file: c:\aspectj1.1\doc\examples\bug\Test$1$StaticNestedClass.class
wrote class file: c:\aspectj1.1\doc\examples\bug\Test.class

1 error
------</description><comments/></buginformation><fixedCommits><commit id="d1e5c0a57c5da220b8f7357550db84f1009dbe2e" author="default" date="2003-03-06 00:24:39"><file name="weaver/testsrc/org/aspectj/weaver/TypeXTestCase.java"><method name="testNameAndSigWithInners" returnType="void" parameters=""/></file><file name="weaver/src/org/aspectj/weaver/TypeX.java"><method name="getDeclaringType" returnType="TypeX" parameters=""/><method name="getSignature" returnType="String" parameters=""/></file><file name="weaver/src/org/aspectj/weaver/ResolvedTypeX.java"><method name="isVisible" returnType="boolean" parameters="int ResolvedTypeX ResolvedTypeX"/><method name="getOutermostType" returnType="ResolvedTypeX" parameters="ResolvedTypeX"/></file><file name="weaver/src/org/aspectj/weaver/NameMangler.java"><method name="getOutermostType" returnType="TypeX" parameters="TypeX"/><method name="makeVisibilityName" returnType="String" parameters="int TypeX"/></file><file name="weaver/src/org/aspectj/weaver/patterns/WithinPointcut.java"><method name="match" returnType="FuzzyBoolean" parameters="Shadow"/></file></commit></fixedCommits></bug><bug id="9" opendate="2003-02-20 17:33:00" fixdate="2003-03-06 22:12:00"><buginformation><summary>can't resolve nested public interfaces</summary><description>This may be caused by the bug as 32399

file TransactionTest.java:
import sub.ExecutionMonitor;

public class TransactionTest {
    static Transaction theTransaction;

    private void assertCommitted() {
        theTransaction.getCount("method-execution", "commit");
    }

    static aspect MonitorTest {
        declare parents: Transaction implements ExecutionMonitor.MonitoredItem;
    }
}

class Transaction {
}

file sub/ExecutionMonitor.aj:
package sub;

public aspect ExecutionMonitor {
    public interface MonitoredItem {
        int getCount(String eventType, String eventName);
    }

    public int MonitoredItem.getCount(String eventType, String eventName) {
            return 0;
    } 
}         

sample compilation:
C:\devel&gt;ajc -1.4 TransactionTest.java sub\ExecutionMonitor.aj
can't bind type name 'ExecutionMonitor$MonitoredItem'
C:/devel/TransactionTest.java:7: The method getCount(java.lang.String, java.lang
.String) is undefined for the type Transaction
theTransaction.getCount("method-execution", "commit");
               ^^^^^^^^

2 errors</description><comments/></buginformation><fixedCommits><commit id="0a175d2d0330eb9843ad17c917bb2434faab59e7" author="default" date="2003-03-06 22:12:00"><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseScope.java"><method name="lookupType" returnType="TypeX" parameters="String IHasPosition"/></file></commit></fixedCommits></bug><bug id="10" opendate="2003-02-19 10:07:00" fixdate="2003-03-11 06:06:56"><buginformation><summary>Dumps assembly code if Object[] used in args (BcelRenderer.java:152)</summary><description>PROGRAM


import org.aspectj.lang.*;


import java.lang.reflect.*;


import org.aspectj.lang.reflect.*;




public class Test4 {


   public static void main(String[] args) throws Exception {


      Test4 t = new Test4();


            System.out.println(t.foo("a"));


   }


   String foo(Object s) {


      return "x"+s;


   }


}




aspect profile {


   // It's the [] that is offending the compiler


   Object around(Object targ, Object[] x): call(* *(..)) &amp;&amp; target(targ) &amp;&amp; 
!within(profile) &amp;&amp; args(x) {


      System.out.println("" + targ + "," + x);


      return proceed(targ,x);


   }


   


}




RESULT OF COMPILATION




[erik@oden test] ajc Test4.java


trouble in: 


public class Test4 extends java.lang.Object:


  public void &lt;init&gt;():


                    ALOAD_0     // Test4 this   (line 5)


                    INVOKESPECIAL java.lang.Object.&lt;init&gt; ()V


    constructor-execution(void Test4.&lt;init&gt;())


    |               RETURN


    constructor-execution(void Test4.&lt;init&gt;())


  end public void &lt;init&gt;()


 


  public static void main(String[]) throws java.lang.Exception:


    method-execution(void Test4.main(java.lang.String[]))


    |               NEW Test4   (line 7)


    |               DUP


    | constructor-call(void Test4.&lt;init&gt;())


    | |             INVOKESPECIAL Test4.&lt;init&gt; ()V


    | constructor-call(void Test4.&lt;init&gt;())


    |               ASTORE_1


    | field-get(java.io.PrintStream java.lang.System.out)


    | |             GETSTATIC java.lang.System.out Ljava/io/PrintStream;   (line 
8)


    | field-get(java.io.PrintStream java.lang.System.out)


    |               ALOAD_1     // Test4 t


    |               LDC "a"


    |               ASTORE_2


    |               ASTORE_3


    | method-call(void java.io.PrintStream.println(java.lang.String))


    | |             INVOKEVIRTUAL java.io.PrintStream.println 
(Ljava/lang/String;)V


    | method-call(void java.io.PrintStream.println(java.lang.String))


    |               RETURN   (line 9)


    method-execution(void Test4.main(java.lang.String[]))


  end public static void main(String[]) throws java.lang.Exception


 


  String foo(Object):


    method-execution(java.lang.String Test4.foo(java.lang.Object))


    |               NEW java.lang.StringBuffer   (line 11)


    |               DUP


    |               LDC "x"


    | constructor-call(void java.lang.StringBuffer.&lt;init&gt;(java.lang.String))


    | |             INVOKESPECIAL java.lang.StringBuffer.&lt;init&gt; 
(Ljava/lang/String;)V


    | constructor-call(void java.lang.StringBuffer.&lt;init&gt;(java.lang.String))


    |               ALOAD_1     // java.lang.Object s


    | method-call(java.lang.StringBuffer 
java.lang.StringBuffer.append(java.lang.Object))


    | |             INVOKEVIRTUAL java.lang.StringBuffer.append 
(Ljava/lang/Object;)Ljava/lang/StringBuffer;


    | method-call(java.lang.StringBuffer 
java.lang.StringBuffer.append(java.lang.Object))


    | method-call(java.lang.String java.lang.StringBuffer.toString())


    | |             INVOKEVIRTUAL java.lang.StringBuffer.toString 
()Ljava/lang/String;


    | method-call(java.lang.String java.lang.StringBuffer.toString())


    |               ARETURN


    method-execution(java.lang.String Test4.foo(java.lang.Object))


  end String foo(Object)


 


  static final String foo_aroundBody0(Test4, Object):


                    ALOAD_0


                    ALOAD_1


                    INVOKEVIRTUAL Test4.foo 
(Ljava/lang/Object;)Ljava/lang/String;   (line 8)


                    ARETURN


  end static final String foo_aroundBody0(Test4, Object)


end public class Test4


Exception thrown from AspectJ 1.1beta4


 


This might be logged as a bug already -- see the bug database at


   http://dev.eclipse.org  (product: AspectJ, component: compiler)


 


Bugs for exceptions thrown have titles File:line from the top stack, 


e.g., "SomeFile.java:243"


 


If you don't find the exception below in a bug, please add a new bug


To make the bug a priority, please include a test program


that can reproduce this exception.


org.apache.bcel.generic.ArrayType


org.apache.bcel.generic.ArrayType


java.lang.ClassCastException: org.apache.bcel.generic.ArrayType


        at org.aspectj.weaver.bcel.BcelRenderer.visit(BcelRenderer.java:152)


        at org.aspectj.weaver.ast.Instanceof.accept(Instanceof.java:29)


        at org.aspectj.weaver.bcel.BcelRenderer.recur(BcelRenderer.java:128)


        at org.aspectj.weaver.bcel.BcelRenderer.renderTest(BcelRenderer.java:94)


        at 
org.aspectj.weaver.bcel.BcelAdvice.getTestInstructions(BcelAdvice.java:271)


        at 
org.aspectj.weaver.bcel.BcelShadow.weaveAroundInline(BcelShadow.java:1199)


        at org.aspectj.weaver.bcel.BcelAdvice.implementOn(BcelAdvice.java:117)


        at org.aspectj.weaver.Shadow.implementMungers(Shadow.java:306)


        at org.aspectj.weaver.Shadow.implement(Shadow.java:278)


        at 
org.aspectj.weaver.bcel.BcelClassWeaver.implement(BcelClassWeaver.java:917)


        at 
org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:244)


        at 
org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:35)


        at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:312)


        at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:264)


        at 
org.aspectj.ajdt.internal.core.builder.AjBuildManager.weaveAndGenerateClassFiles
(AjBuildManager.java:351)


        at 
org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.
java:112)


        at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:54)


        at org.aspectj.tools.ajc.Main.run(Main.java:199)


        at org.aspectj.tools.ajc.Main.runMain(Main.java:138)


        at org.aspectj.tools.ajc.Main.main(Main.java:58)


 


 


1 fail|abort</description><comments/></buginformation><fixedCommits><commit id="ae0ef30e2a9c8a4ef7ff59219b15b5109c956d22" author="default" date="2003-03-11 06:06:56"><file name="weaver/src/org/aspectj/weaver/bcel/BcelRenderer.java"><method name="visit" returnType="void" parameters="Instanceof"/></file><file name="weaver/src/org/aspectj/weaver/bcel/Utility.java"><method name="createInstanceof" returnType="Instruction" parameters="InstructionFactory ObjectType"/></file></commit></fixedCommits></bug><bug id="11" opendate="2003-01-21 20:13:00" fixdate="2003-03-12 00:48:57"><buginformation><summary>runtime NullPointerException when applying around advice to other around advice</summary><description>When the program below is run, it produces a NullPointerException...
java.lang.NullPointerException
	at A2.ajc$around$A2$3b6proceed(CflowCycles.java)
	at A2.ajc$around$A2$3b6_aroundBody3(CflowCycles.java:35)
	at Target.run(CflowCycles.java:24)
	at CflowCycles.run_aroundBody4(CflowCycles.java:8)
	at CflowCycles.main_aroundBody6(CflowCycles.java:24)
	at CflowCycles.main(CflowCycles.java:24)

---(in new/CflowCycles.java and in ajcTestsFailing.xml)

import org.aspectj.testing.Tester; 

/** @testcase cflow cycles in advice from different aspects */
public class CflowCycles {
  public static void main( String args[] ) {
        Tester.expectEvent("target A1");
        Tester.expectEvent("target A2");
        new Target().run();
        Tester.checkAllEventsIgnoreDups();
  }
}

class Target {
    public void run(){ }
}

aspect A1 {
    pointcut TargetRunFlow () 
        // ok if no cflow: within(Target) &amp;&amp; execution(* *(..)) &amp;&amp; !within
(A1+);
        : !within(A1+) &amp;&amp; !preinitialization(new(..)) &amp;&amp; !initialization(new
(..))//cflow(within(Target) &amp;&amp; execution(* *(..))) &amp;&amp; !within(A1+)
        ;
    Object around () : TargetRunFlow() {
        Tester.event("target A1");
        return proceed();
    }
    // ok if in the same class
}

aspect A2 {
    pointcut TargetRun () 
        : within(Target) &amp;&amp; execution(* *(..)) &amp;&amp; !within(A2+);
        ;
    Object around () : TargetRun() {
        Tester.event("target A2");
        return proceed();
    }
}</description><comments/></buginformation><fixedCommits><commit id="0fb5f693794e571ab693813cbc80578b2bc7b470" author="default" date="2003-03-12 00:48:57"><file name="weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"><method name="weaveAroundInline" returnType="void" parameters=""/></file></commit></fixedCommits></bug><bug id="12" opendate="2003-03-12 10:36:00" fixdate="2003-03-12 19:52:13"><buginformation><summary>ajc -aspectpath fails with NPE for cflow pointcuts</summary><description>ajc version: AspectJ Compiler DEVELOPMENT CVS build 20030311 20:00 GMT+1
(This is probably a regression bug since it does not appear in ajc 1.1b4)

When using the ajc -aspectpath option, the compiler crashes with a NPE. This
does not occur when compiling without the -aspectpath option.

To reproduce:
Extract the two files to en empty directory:
//  File: A.aj
aspect A  {

    pointcut withinTest(): within(Test);
    pointcut callToHandleOrder() : 
       (cflow(withinTest()) &amp;&amp; call(* *.handleOrder(..)));

    Object around(): callToHandleOrder() {
      return "test";
    }
// End of A.aj
// File: Test.java
public class Test
{
    public static void main(String[] args)
    {
      System.out.println(new Test().handleOrder("test")) ;
    }
    private String handleOrder(String t)
    {
      return t;
    }

}
// End of Test.java

2. Verify that the "standard" compile option works:
 &gt; ajc -sourceroots . 
No errors are generated
3.a Now try the -aspectpath options. I.e first put the A.aj in an aspect "read-
only" jar and then weave in the jar.
 &gt; ajc A.aj  -outjar tmp.jar 
C:\aspectj1.1\doc\examples\bug\A.aj:5 no match for this type name: Test 
[Xlint:invalidAbsoluteTypeName]

1 warning
 &gt; ajc Test.java -aspectpath tmp.jar 
java.lang.NullPointerException
	at 
org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.makeEclipseTypeMunger
(EclipseFactory.java:163)
	at 
org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.finishTypeMungers
(EclipseFactory.java:147)
	at 
org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.completeTypeBindin
gs(AjLookupEnvironment.java:91)
	at org.eclipse.jdt.internal.compiler.Compiler.beginToCompile
(Compiler.java:312)
	at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:326)
	at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile
(AbstractImageBuilder.java:232)
	at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile
(AbstractImageBuilder.java:171)
	at 
org.aspectj.ajdt.internal.core.builder.AjBuildManager$BatchBuilder.run
(AjBuildManager.java:655)
	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild
(AjBuildManager.java:139)
	at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:55)
	at org.aspectj.tools.ajc.Main.run(Main.java:216)
	at org.aspectj.tools.ajc.Main.runMain(Main.java:155)
	at org.aspectj.tools.ajc.Main.main(Main.java:72)
C:\aspectj1.1\doc\examples\bug\Test.java:0 Internal compiler error
java.lang.NullPointerException
	at 
org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.makeEclipseTypeMunger
(EclipseFactory.java:163)
	at 
org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.finishTypeMungers
(EclipseFactory.java:147)
	at 
org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.completeTypeBindin
gs(AjLookupEnvironment.java:91)
	at org.eclipse.jdt.internal.compiler.Compiler.beginToCompile
(Compiler.java:312)
	at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:326)
	at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile
(AbstractImageBuilder.java:232)
	at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile
(AbstractImageBuilder.java:171)
	at 
org.aspectj.ajdt.internal.core.builder.AjBuildManager$BatchBuilder.run
(AjBuildManager.java:655)
	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild
(AjBuildManager.java:139)
	at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:55)
	at org.aspectj.tools.ajc.Main.run(Main.java:216)
	at org.aspectj.tools.ajc.Main.runMain(Main.java:155)
	at org.aspectj.tools.ajc.Main.main(Main.java:72)


!! no source information available !!
Exception thrown from AspectJ DEVELOPMENT

This might be logged as a bug already -- find current bugs at
   http://bugs.eclipse.org/bugs/buglist.cgi?product=AspectJ&amp;component=Compiler 

Bugs for exceptions thrown have titles File:line from the top stack, 
e.g., "SomeFile.java:243"

If you don't find the exception below in a bug, please add a new bug
at  http://bugs.eclipse.org/bugs/enter_bug.cgi?product=AspectJ 
To make the bug a priority, please include a test program
that can reproduce this exception.
null
java.lang.NullPointerException
	at 
org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.makeEclipseTypeMunger
(EclipseFactory.java:163)
	at 
org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.finishTypeMungers
(EclipseFactory.java:147)
	at 
org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.completeTypeBindin
gs(AjLookupEnvironment.java:91)
	at org.eclipse.jdt.internal.compiler.Compiler.beginToCompile
(Compiler.java:312)
	at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:326)
	at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile
(AbstractImageBuilder.java:232)
	at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile
(AbstractImageBuilder.java:171)
	at 
org.aspectj.ajdt.internal.core.builder.AjBuildManager$BatchBuilder.run
(AjBuildManager.java:655)
	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild
(AjBuildManager.java:139)
	at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:55)
	at org.aspectj.tools.ajc.Main.run(Main.java:216)
	at org.aspectj.tools.ajc.Main.runMain(Main.java:155)
	at org.aspectj.tools.ajc.Main.main(Main.java:72)


1 fail|abort, 1 error
Signal 127
-----------------------
Possible fix:
The NullPointerException happens because concret.getMunger() returns null
just before calling EclipseTypeMunger.supportsKind.
The following guard in the EclipseFactory.makeEclipseTypeMunger fixes
the problem:

public EclipseTypeMunger makeEclipseTypeMunger(ConcreteTypeMunger concrete) {
		if (concrete instanceof EclipseTypeMunger) return 
(EclipseTypeMunger)concrete;
        if ( concrete.getMunger() == null)
        {
          System.err.println("TODO (per.hustad):" + this.getClass().getName() +
              " concrete.getMunger() returned null for " + concrete + " - will 
return null now!");
          return null;
        }

        if (EclipseTypeMunger.supportsKind(concrete.getMunger().getKind())) {
			return new EclipseTypeMunger(this, concrete.getMunger
(), concrete.getAspectType(), null);
		} else {
			return null;
		}
	}</description><comments/></buginformation><fixedCommits><commit id="db37189cebba13a30b7ccdabe70565caa7506c00" author="default" date="2003-03-12 19:52:13"><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"><method name="makeEclipseTypeMunger" returnType="EclipseTypeMunger" parameters="ConcreteTypeMunger"/></file></commit></fixedCommits></bug><bug id="13" opendate="2003-03-12 14:50:00" fixdate="2003-03-12 23:07:08"><buginformation><summary>Weaver crash</summary><description>this test file (Test.java) crashes the weaver:

public class Test {
    static aspect MockProcessing {
        pointcut testFlow(final Thread thread) : 
            cflow(execution(void run()) &amp;&amp; this(thread) &amp;&amp; within(Thread)); // 
the within is an optimization

        Object around() :
                call(* DummyConfiguration.createRootApplicationModule(..)) &amp;&amp; 
testFlow(Thread)
        {
            return null;
        }
    }
}

class Bar {
    void foo() {
        DummyConfiguration.createRootApplicationModule();
    }
}

class DummyConfiguration {
    static Object createRootApplicationModule() {
        return null;
    }
}

prompt&gt;ajc -d 11bin -1.4 Test.java
Exception thrown from AspectJ 1.1rc1

This might be logged as a bug already -- find current bugs at
   http://bugs.eclipse.org/bugs/buglist.cgi?product=AspectJ&amp;component=Compiler 

Bugs for exceptions thrown have titles File:line from the top stack,
e.g., "SomeFile.java:243"

If you don't find the exception below in a bug, please add a new bug
at  http://bugs.eclipse.org/bugs/enter_bug.cgi?product=AspectJ 
To make the bug a priority, please include a test program
that can reproduce this exception.
0
0
java.lang.ArrayIndexOutOfBoundsException: 0
        at org.aspectj.weaver.IntMap.get(IntMap.java:109)
        at org.aspectj.weaver.patterns.CflowPointcut.concretize1(CflowPointcut.j
ava:170)
        at org.aspectj.weaver.patterns.ReferencePointcut.concretize1(ReferencePo
intcut.java:270)
        at org.aspectj.weaver.patterns.AndPointcut.concretize1(AndPointcut.java:
88)
        at org.aspectj.weaver.patterns.Pointcut.concretize(Pointcut.java:127)
        at org.aspectj.weaver.patterns.Pointcut.concretize(Pointcut.java:120)
        at org.aspectj.weaver.Advice.concretize(Advice.java:207)
        at org.aspectj.weaver.CrosscuttingMembers.addShadowMunger(CrosscuttingMe
mbers.java:78)
        at org.aspectj.weaver.CrosscuttingMembers.addShadowMungers(CrosscuttingM
embers.java:72)
        at org.aspectj.weaver.ResolvedTypeX.collectCrosscuttingMembers(ResolvedT
ypeX.java:328)
        at org.aspectj.weaver.CrosscuttingMembersSet.addOrReplaceAspect(Crosscut
tingMembersSet.java:54)
        at org.aspectj.weaver.bcel.BcelWeaver.prepareForWeave(BcelWeaver.java:16
4)
        at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:214)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.weaveAndGenerat
eClassFiles(AjBuildManager.java:394)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBu
ildManager.java:149)
        at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:55)
        at org.aspectj.tools.ajc.Main.run(Main.java:216)
        at org.aspectj.tools.ajc.Main.runMain(Main.java:155)
        at org.aspectj.tools.ajc.Main.main(Main.java:72)


1 fail|abort</description><comments/></buginformation><fixedCommits><commit id="7746fcb7e977c7a91bd70081a2197a999ec18ad3" author="default" date="2003-03-12 23:07:08"><file name="weaver/src/org/aspectj/weaver/patterns/CflowPointcut.java"><method name="concretize1" returnType="Pointcut" parameters="ResolvedTypeX IntMap"/></file></commit></fixedCommits></bug><bug id="14" opendate="2003-03-13 11:58:00" fixdate="2003-03-13 19:16:53"><buginformation><summary>compiler crash on yesterday's rc1 build</summary><description>These test files crash the compiler (in fact if you just compile 
ConvertToUnchecked it crashes it):

ConvertToUnchecked.java:

import java.io.IOException;

// example 3
aspect ConvertToUnchecked {
  // make all exceptions in an application unchecked; "soft"
  //declare soft: (Exception &amp;&amp; !RuntimeException): within(com.foo.app..*);

  // convert IOExceptions in a package to PersistenceException
  pointcut module() : within(test.*); // within
(com.foo.framework.persistence.*);
  // convert exceptions
  // within(test.*) would work to allow an immediate catch, except for
  // the last statement in a try block
  // however, I suspect that would also generate inefficient code
  // even this might be inefficient: it needs to wrap every method body in a
  // try ... catch block
  after() throwing (IOException e) : within(test.*) {
    throw new PersistenceException(e);
  }
  declare soft: (IOException): module();
}
// tested by: test.ConvertToUnchecked
----

PersistenceException.java
public class PersistenceException extends Exception 
{
  public PersistenceException(Throwable cause) {
    super(cause);
  }
}

---
sample run:
C:\ron\devel\articles\errorHandling&gt;ajc -1.4 ConvertToUnchecked.java 
Persistence
Exception.java
java.lang.RuntimeException: unimplemented: throw new PersistenceException(e)
        at org.aspectj.ajdt.internal.compiler.lookup.EclipseShadow.makeShadow
(Ec
lipseShadow.java:148)
        at org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.makeShadow
(E
clipseFactory.java:292)
        at 
org.aspectj.ajdt.internal.compiler.problem.AjProblemReporter.unhandle
dException(AjProblemReporter.java:67)
        at 
org.eclipse.jdt.internal.compiler.flow.FlowContext.checkExceptionHand
lers(FlowContext.java:249)
        at org.eclipse.jdt.internal.compiler.ast.ThrowStatement.analyseCode
(Thro
wStatement.java:35)
        at 
org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.analy
seCode(AbstractMethodDeclaration.java:106)
        at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode
(Typ
eDeclaration.java:445)
        at 
org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.anal
yseCode(CompilationUnitDeclaration.java:76)
        at org.eclipse.jdt.internal.compiler.Compiler.process
(Compiler.java:539)

        at org.aspectj.ajdt.internal.compiler.AjCompiler.process
(AjCompiler.java
:65)
        at org.eclipse.jdt.internal.compiler.Compiler.compile
(Compiler.java:340)

        at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile
(Ab
stractImageBuilder.java:232)
        at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile
(Ab
stractImageBuilder.java:171)
        at 
org.aspectj.ajdt.internal.core.builder.AjBuildManager$BatchBuilder.ru
n(AjBuildManager.java:656)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild
(AjBu
ildManager.java:139)
        at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:55)
        at org.aspectj.tools.ajc.Main.run(Main.java:216)
        at org.aspectj.tools.ajc.Main.runMain(Main.java:155)
        at org.aspectj.tools.ajc.Main.main(Main.java:72)
C:\ron\devel\articles\errorHandling\ConvertToUnchecked.java:0 Internal compiler
error
java.lang.RuntimeException: unimplemented: throw new PersistenceException(e)
        at org.aspectj.ajdt.internal.compiler.lookup.EclipseShadow.makeShadow
(Ec
lipseShadow.java:148)
        at org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.makeShadow
(E
clipseFactory.java:292)
        at 
org.aspectj.ajdt.internal.compiler.problem.AjProblemReporter.unhandle
dException(AjProblemReporter.java:67)
        at 
org.eclipse.jdt.internal.compiler.flow.FlowContext.checkExceptionHand
lers(FlowContext.java:249)
        at org.eclipse.jdt.internal.compiler.ast.ThrowStatement.analyseCode
(Thro
wStatement.java:35)
        at 
org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.analy
seCode(AbstractMethodDeclaration.java:106)
        at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode
(Typ
eDeclaration.java:445)
        at 
org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.anal
yseCode(CompilationUnitDeclaration.java:76)
        at org.eclipse.jdt.internal.compiler.Compiler.process
(Compiler.java:539)

        at org.aspectj.ajdt.internal.compiler.AjCompiler.process
(AjCompiler.java
:65)
        at org.eclipse.jdt.internal.compiler.Compiler.compile
(Compiler.java:340)

        at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile
(Ab
stractImageBuilder.java:232)
        at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile
(Ab
stractImageBuilder.java:171)
        at 
org.aspectj.ajdt.internal.core.builder.AjBuildManager$BatchBuilder.ru
n(AjBuildManager.java:656)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild
(AjBu
ildManager.java:139)
        at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:55)
        at org.aspectj.tools.ajc.Main.run(Main.java:216)
        at org.aspectj.tools.ajc.Main.runMain(Main.java:155)
        at org.aspectj.tools.ajc.Main.main(Main.java:72)


!! no source information available !!
ABORT
Exception thrown from AspectJ 1.1rc1

This might be logged as a bug already -- find current bugs at
   http://bugs.eclipse.org/bugs/buglist.cgi?product=AspectJ&amp;component=Compiler 

Bugs for exceptions thrown have titles File:line from the top stack,
e.g., "SomeFile.java:243"

If you don't find the exception below in a bug, please add a new bug
at  http://bugs.eclipse.org/bugs/enter_bug.cgi?product=AspectJ 
To make the bug a priority, please include a test program
that can reproduce this exception.
unimplemented: throw new PersistenceException(e)
unimplemented: throw new PersistenceException(e)
java.lang.RuntimeException: unimplemented: throw new PersistenceException(e)
        at org.aspectj.ajdt.internal.compiler.lookup.EclipseShadow.makeShadow
(Ec
lipseShadow.java:148)
        at org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.makeShadow
(E
clipseFactory.java:292)
        at 
org.aspectj.ajdt.internal.compiler.problem.AjProblemReporter.unhandle
dException(AjProblemReporter.java:67)
        at 
org.eclipse.jdt.internal.compiler.flow.FlowContext.checkExceptionHand
lers(FlowContext.java:249)
        at org.eclipse.jdt.internal.compiler.ast.ThrowStatement.analyseCode
(Thro
wStatement.java:35)
        at 
org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.analy
seCode(AbstractMethodDeclaration.java:106)
        at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode
(Typ
eDeclaration.java:445)
        at 
org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.anal
yseCode(CompilationUnitDeclaration.java:76)
        at org.eclipse.jdt.internal.compiler.Compiler.process
(Compiler.java:539)

        at org.aspectj.ajdt.internal.compiler.AjCompiler.process
(AjCompiler.java
:65)
        at org.eclipse.jdt.internal.compiler.Compiler.compile
(Compiler.java:340)

        at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile
(Ab
stractImageBuilder.java:232)
        at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile
(Ab
stractImageBuilder.java:171)
        at 
org.aspectj.ajdt.internal.core.builder.AjBuildManager$BatchBuilder.ru
n(AjBuildManager.java:656)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild
(AjBu
ildManager.java:139)
        at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:55)
        at org.aspectj.tools.ajc.Main.run(Main.java:216)
        at org.aspectj.tools.ajc.Main.runMain(Main.java:155)
        at org.aspectj.tools.ajc.Main.main(Main.java:72)


1 fail|abort, 1 error</description><comments/></buginformation><fixedCommits><commit id="56cc4f27afaf591f8cebb2450513cc6eb7d51299" author="default" date="2003-03-13 19:16:53"><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/problem/AjProblemReporter.java"><method name="unhandledException" returnType="void" parameters=""/></file><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseShadow.java"><method name="makeShadow" returnType="EclipseShadow" parameters="EclipseFactory AstNode"/><method name="getEnclosingCodeSignature" returnType="Member" parameters=""/><method name="getEnclosingType" returnType="TypeX" parameters=""/></file></commit></fixedCommits></bug><bug id="15" opendate="2003-02-27 14:03:00" fixdate="2003-03-27 15:43:01"><buginformation><summary>bad source locations for declare error/warning</summary><description>[Submitted on behalf of Adrian Colyer and Jim Hugunin]

 &gt; ...- there's one thing in the weaver I
&gt; couldn't solve tonight (Jim/Mik) : org.aspectj.weaver.Checker.match(..) is
&gt; called when checking whether a declare warning /error pointcut matches a
&gt; given shadow. If t does, a Message is created whose sourceLocation is
&gt; shadow.getSourceLocation(). The implementation of getSourceLocation in
&gt; BcelShadow returns the unqualified file name rather than the qualified one
&gt; (e.g "Point.java" rather than
&gt; "org.eclipse.ajdt.demo/src/figures/Point.java") which means that later on
&gt; eclipse can't find the resource the marker is supposed to be attached to.
&gt; I've patched it in AJDT by scanning the project for the first resource
&gt; that
&gt; ends in the given name and using that, which we will get away with for
&gt; many
&gt; projects. I couldn't find an easy way to fix it properly in the weaver. 

This is an issue with the weaver operating on bytecode, where the only 
information about the actual source file is the FILENAME attribute in 
the .class file which just contains the final unqualified portion of the 
name.  I can think of three solutions to this:

1. Change the code for getSourceLocation to use the current package in order 
to produce a more complete filename, i.e. figures/Point.java instead of just 
Point.java.  This should be a relatively straightforward and localized change 
and is the only solution that would help the case of weaving into .jar files.

2. Pass some additional information from the eclipse compiler phase to the 
bytecode weaver to let it know the actual source locations of files.  This 
could give you the actual source file, but is a crosscutting change that would 
affect a lot of the system.

3. Handle declare error and warning in a special pass that performs weaving on 
the AST rather than the .class file.  This is the only solution that will give 
you correct column information which can make these messages easier to 
understand, but it is a LOT of work.

I'd recommend that you consider doing #1 in order to improve the quality of 
your hack in the short-term.  I plan to look at #2 as part of a final clean-up 
of the incremental compilation code before the candidate1 release.  I think 
that ultimately #3 is the right answer, but it would be a very large amount of 
work and could only happen post-1.1.</description><comments/></buginformation><fixedCommits><commit id="989aaf7855fdb2e4f176d6e7b32a3bd0131ee515" author="default" date="2003-03-27 15:43:01"><file name="ajde/testsrc/org/aspectj/ajde/AjdeTests.java"><method name="suite" returnType="Test" parameters=""/></file><file name="ajde/testsrc/org/aspectj/ajde/NullIdeTaskListManager.java"><method name="addSourcelineTask" returnType="void" parameters="String ISourceLocation IMessage.Kind"/><method name="clearTasks" returnType="void" parameters=""/></file><file name="ajde/testsrc/org/aspectj/ajde/NullIdeManager.java"><method name="init" returnType="void" parameters="String"/></file></commit></fixedCommits></bug><bug id="16" opendate="2003-04-03 18:21:00" fixdate="2003-04-10 22:20:14"><buginformation><summary>inter-type declaration bug with abstract classes</summary><description>This error occurs when you do an inter-type declaration on an interface, use 
declare parents to make an abstract base class implement it, and then try to 
use the declared (method), it fails. If you make the base class concrete, then 
this doesn't fail.

The following code demonstrates the error. If you run java Driver you get:
java.lang.AbstractMethodError: Derived.getExecutions(Ljava/lang/String;)I
	at Driver.main(Driver.java:23)
Exception in thread "main" 

public class Driver {
    public static void main(String args[]) {
        Derived generator = new Derived();
        System.out.println(generator.getExecutions("processEvents"));
    }
    static aspect MonitorBase {
        declare parents: Base implements ExecutionMonitor.MonitoredItem;
    }    
}

class Derived extends Base {
    public String getName() {
        return null;
    }
}

abstract class Base {
    abstract public String getName();
}

aspect ExecutionMonitor {
    /** marker interface to indicate the execution monitor should track calls 
and executions on this class. */
    public interface MonitoredItem {
        int getExecutions(String methodName);
    }

    /** a Map of events to mutable integers */
    public int MonitoredItem.getExecutions(String methodName) {
        return 0;
    }
}</description><comments/></buginformation><fixedCommits><commit id="808bae83b3d5f37de4b39a2380db2782919a5f8a" author="default" date="2003-04-10 22:20:14"><file name="weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"><method name="isStatic" returnType="boolean" parameters=""/></file><file name="weaver/src/org/aspectj/weaver/bcel/LazyClassGen.java"><method name="getMethodGens" returnType="List" parameters=""/></file><file name="weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"><method name="alreadyDefined" returnType="boolean" parameters="LazyClassGen LazyMethodGen"/></file></commit></fixedCommits></bug><bug id="17" opendate="2003-04-16 08:42:00" fixdate="2003-04-22 17:55:13"><buginformation><summary>Internal compiler error</summary><description>Eclipse: 2.1.0, 200302211557
AspectJ: 1.1.1


I get the following internal error when using "thisJoinPoint.getStaticPart()" 
in around advice at a call joinpoit (source below). Using just "thisJoinPoint" 
is fine.

java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode
(MessageSend.java:40)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode
(MessageSend.java:44)
	at 
org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.analyseCode
(AbstractMethodDeclaration.java:106)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode
(TypeDeclaration.java:445)
	at 
org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode
(CompilationUnitDeclaration.java:76)
	at org.eclipse.jdt.internal.compiler.Compiler.process
(Compiler.java:539)
	at org.aspectj.ajdt.internal.compiler.AjCompiler.process
(AjCompiler.java:65)
	at org.eclipse.jdt.internal.compiler.Compiler.compile
(Compiler.java:340)
	at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile
(AbstractImageBuilder.java:232)
	at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile
(AbstractImageBuilder.java:171)
	at 
org.aspectj.ajdt.internal.core.builder.AjBuildManager$BatchBuilder.run
(AjBuildManager.java:655)
	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild
(AjBuildManager.java:139)
	at org.aspectj.ajde.internal.CompilerAdapter.compile
(CompilerAdapter.java:92)
	at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run
(AspectJBuildManager.java:213)
	Exceptions.java	AspectJ Bugs/src/compiler	

Source:

package compiler;

import java.io.*;

/**
 * @author websterm
 *
 * To change this generated comment go to 
 * Window&gt;Preferences&gt;Java&gt;Code Generation&gt;Code and Comments
 */
public class Test {

	public static void main(String[] args) throws Exception{
		FileInputStream in = new FileInputStream("test");
	}
}

/*
 * Created on 14-Apr-03
 *
 * To change this generated comment go to 
 * Window&gt;Preferences&gt;Java&gt;Code Generation&gt;Code and Comments
 */
package compiler;

import java.io.*;

import org.aspectj.lang.*;

/**
 * @author websterm
 *
 * To change this generated comment go to 
 * Window&gt;Preferences&gt;Java&gt;Code Generation&gt;Code and Comments
 */
public aspect Exceptions {
	
	pointcut exceptionMethods () :
		call(* java.io.*.*(..) throws IOException);
		
	Object around () throws IOException : exceptionMethods() &amp;&amp; !within
(Exceptions) {
		Object obj = proceed();
		System.out.println(thisJoinPoint.getStaticPart());
		return obj;	
	}
}</description><comments/></buginformation><fixedCommits><commit id="0a8dbdeed13fe79ddfd7a291e2b45b50b9a90579" author="default" date="2003-04-22 17:55:13"><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/ThisJoinPointVisitor.java"><method name="canTreatAsStatic" returnType="boolean" parameters="String"/></file></commit></fixedCommits></bug><bug id="18" opendate="2003-04-23 12:56:00" fixdate="2003-04-25 18:11:33"><buginformation><summary>BCException thrown by AspectJ 1.1rc1</summary><description>[iajc] expected state: resolved got: concrete
     [iajc] expected state: resolved got: concrete
     [iajc] org.aspectj.weaver.BCException: expected state: resolved got: 
concrete
     [iajc]     at org.aspectj.weaver.patterns.Pointcut.assertState
(Pointcut.java:236)
     [iajc]     at org.aspectj.weaver.patterns.Pointcut.concretize
(Pointcut.java:126)
     [iajc]     at org.aspectj.weaver.patterns.CflowPointcut.concretize1
(CflowPointcut.java:143)
     [iajc]     at org.aspectj.weaver.patterns.NotPointcut.concretize1
(NotPointcut.java:94)
     [iajc]     at org.aspectj.weaver.patterns.AndPointcut.concretize1
(AndPointcut.java:88)
     [iajc]     at org.aspectj.weaver.patterns.ReferencePointcut.concretize1
(ReferencePointcut.java:270)
     [iajc]     at org.aspectj.weaver.patterns.AndPointcut.concretize1
(AndPointcut.java:88)
     [iajc]     at org.aspectj.weaver.patterns.ReferencePointcut.concretize1
(ReferencePointcut.java:270)
     [iajc]     at org.aspectj.weaver.patterns.Pointcut.concretize
(Pointcut.java:127)
     [iajc]     at org.aspectj.weaver.patterns.Pointcut.concretize
(Pointcut.java:120)
     [iajc]     at org.aspectj.weaver.Advice.concretize(Advice.java:207)
     [iajc]     at org.aspectj.weaver.CrosscuttingMembers.addShadowMunger
(CrosscuttingMembers.java:78)
     [iajc]     at org.aspectj.weaver.CrosscuttingMembers.addShadowMungers
(CrosscuttingMembers.java:72)
     [iajc]     at org.aspectj.weaver.ResolvedTypeX.collectCrosscuttingMembers
(ResolvedTypeX.java:328)
     [iajc]     at org.aspectj.weaver.CrosscuttingMembersSet.addOrReplaceAspect
(CrosscuttingMembersSet.java:54)
     [iajc]     at org.aspectj.weaver.bcel.BcelWeaver.prepareForWeave
(BcelWeaver.java:164)
     [iajc]     at org.aspectj.weaver.bcel.BcelWeaver.weave
(BcelWeaver.java:214)
     [iajc]     at 
org.aspectj.ajdt.internal.core.builder.AjBuildManager.weaveAndGenerateClassFile
s(AjBuildManager.java:394)
     [iajc]     at 
org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild
(AjBuildManager.java:149)
     [iajc]     at org.aspectj.ajdt.ajc.AjdtCommand.runCommand
(AjdtCommand.java:55)
     [iajc]     at org.aspectj.tools.ajc.Main.run(Main.java:216)
     [iajc]     at org.aspectj.tools.ajc.Main.runMain(Main.java:155)
     [iajc]     at org.aspectj.tools.ant.taskdefs.AjcTask.execute
(AjcTask.java:646)
     [iajc]     at org.apache.tools.ant.UnknownElement.execute
(UnknownElement.java:193)
     [iajc]     at org.apache.tools.ant.Task.perform(Task.java:341)
     [iajc]     at org.apache.tools.ant.Target.execute(Target.java:309)
     [iajc]     at org.apache.tools.ant.Target.performTasks(Target.java:336)
     [iajc]     at org.apache.tools.ant.Project.executeTarget
(Project.java:1339)
     [iajc]     at org.apache.tools.ant.Project.executeTargets
(Project.java:1255)
     [iajc]     at org.apache.tools.ant.Main.runBuild(Main.java:609)
     [iajc]     at org.apache.tools.ant.Main.start(Main.java:196)
     [iajc]     at org.apache.tools.ant.Main.main(Main.java:235)</description><comments/></buginformation><fixedCommits><commit id="1e502f504f2ad333ad5627d8e9d106315c38ecc0" author="default" date="2003-04-25 18:11:33"><file name="weaver/src/org/aspectj/weaver/patterns/Pointcut.java"><method name="concretize" returnType="Pointcut" parameters="ResolvedTypeX IntMap"/><method name="concretize1" returnType="Pointcut" parameters=""/></file><file name="weaver/src/org/aspectj/weaver/patterns/WithinPointcut.java"><method name="concretize1" returnType="Pointcut" parameters="ResolvedTypeX IntMap"/></file><file name="weaver/src/org/aspectj/weaver/patterns/KindedPointcut.java"><method name="concretize1" returnType="Pointcut" parameters="ResolvedTypeX IntMap"/></file><file name="weaver/src/org/aspectj/weaver/patterns/WithincodePointcut.java"><method name="concretize1" returnType="Pointcut" parameters="ResolvedTypeX IntMap"/></file></commit></fixedCommits></bug><bug id="19" opendate="2003-03-13 14:38:00" fixdate="2003-04-27 23:29:27"><buginformation><summary>NPE compiling without aspectjrt.jar</summary><description>Compiling spacewar without specifying aspectjrt.jar on the classpath causes a 
NPE.  Expected an error message "aspectjrt.jar required".

Steps to reproduce
1) install latest
2) cd doc/examples
3) java -jar ../../lib/aspectjtools.jar -verbose @spacewar/debug.lst
RESULT:NPE in attached log</description><comments/></buginformation><fixedCommits><commit id="f236927770b4c1029e4d108c3991870609555dfb" author="default" date="2003-04-27 23:29:27"><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"><method name="initBcelWorld" returnType="void" parameters="IMessageHandler"/></file></commit></fixedCommits></bug><bug id="20" opendate="2003-01-30 15:48:00" fixdate="2003-04-27 23:31:06"><buginformation><summary>lame error message: "negation doesn't allow binding"</summary><description>AspectJ Compiler 1.1beta4

This program:

public aspect Foo {
  pointcut p(int i): call(void f(i));
}

produces these error messages:

negation doesn't allow binding
formal unbound in pointcut

2 errors

It should say something like "binding is only allowed in state-based pointcuts", and it should print the file and line number.

--Doug</description><comments/></buginformation><fixedCommits><commit id="7d144321837cac05cdbe2a30323d670dfcc9809a" author="default" date="2003-04-27 23:31:06"><file name="weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java"><method name="resolveBindings" returnType="TypePattern" parameters="IScope Bindings"/></file><file name="weaver/src/org/aspectj/weaver/patterns/TypePattern.java"><method name="matchesStatically" returnType="boolean" parameters="ResolvedTypeX"/></file><file name="weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"><method name="weave" returnType="boolean" parameters=""/></file></commit></fixedCommits></bug><bug id="21" opendate="2003-05-15 21:20:00" fixdate="2003-05-19 18:06:04"><buginformation><summary>Unexpected Xlint:unresolvableMember warning with withincode</summary><description>The following code produces an Xlint:unresolvableMember warning:

class A {
    A(Class type) {}

    A() {
        this(String.class);
    }
}

class B {

    public void test() {
    }

    public void test2() {
        test();
    }
}

aspect C {
    void around() :
        (call (void B.test()) &amp;&amp;
         withincode (void B.test2())) {
        proceed();
    }
}

The warning text is:

Warning.java:22 can not resolve this member:
void A.&lt;catch&gt;(java.lang.ClassNotFoundException) [Xlint:unresolvableMember]

Line 22 is the line in the aspect that says "withincode".  If I comment out 
the aspect, the warning goes away.  Also, if I comment out A's default 
constructor, it goes away.  The "String.class" seems to have something to do 
with the warning.  

I can reproduce this with 1.1rc1 and 1.1rc2.</description><comments/></buginformation><fixedCommits><commit id="2072ac11448e493e26ab7ff818ce26c6ef33c19c" author="default" date="2003-05-19 18:06:04"><file name="weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"><method name="getEnclosingCodeSignature" returnType="Member" parameters=""/><method name="getThisEnclosingJoinPointStaticPartBcelVar" returnType="BcelVar" parameters=""/></file></commit></fixedCommits></bug><bug id="22" opendate="2003-05-27 01:46:00" fixdate="2003-05-27 17:35:13"><buginformation><summary>ajc needs -d . option while correctly compiling classes from subpackage</summary><description>I am using 1.1rc1. This is a regression since rc1 and a deviation from javac.
I am guessing this may have to do something with change in the underlying
Eclipse compiler.

Create a class in a subpackage such as:
package subpackage;

public class Test {
    public static void main(String[] args) {
	System.out.println("Hello");
    }
}

Then compile using following command:
 &gt; ajc subpackage\Test.java 

You will see a directory "subpackage" created under the existing "subpackage"
directory. The test.class is then put in subpackage\subpackage directory.
This means running java command results in 
Exception in thread "main" java.lang.NoClassDefFoundError: subpackage/Test

Running either of the following command fixes the problem:
 &gt; ajc -d . subpackage\Test.java 

or 

 &gt; javac subpackage\Test.java 

No big deal, really. But it will be nice to have same behavior as javac.</description><comments/></buginformation><fixedCommits><commit id="c509c6f751a553cc85d0210a408681f4f3ae05cb" author="default" date="2003-05-27 17:35:13"><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"><method name="outputClassFiles" returnType="void" parameters="CompilationResult"/></file></commit></fixedCommits></bug><bug id="23" opendate="2003-06-29 23:42:00" fixdate="2003-07-02 23:12:18"><buginformation><summary>Compiler crash in ajc 1.1</summary><description>Here is the compiler output. Source code below.
---
C:\devel\test\entAJtutorial\test&gt;ajc Processing.java
C:\devel\test\entAJtutorial\test\Processing.java:17 this affected type is not 
ex
posed to the weaver: java.lang.Void (needed for privileged access) 
[Xlint:typeNo
tExposedToWeaver]
java.lang.NullPointerException
        at 
org.eclipse.jdt.internal.compiler.lookup.SyntheticAccessMethodBinding
.initializeConstructorAccessor(SyntheticAccessMethodBinding.java:215)
        at 
org.eclipse.jdt.internal.compiler.lookup.SyntheticAccessMethodBinding
.&lt;init&gt;(SyntheticAccessMethodBinding.java:136)
        at 
org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.addSynthet
icMethod(SourceTypeBinding.java:332)
        at 
org.eclipse.jdt.internal.compiler.ast.AllocationExpression.manageSynt
heticAccessIfNecessary(AllocationExpression.java:200)
        at 
org.eclipse.jdt.internal.compiler.ast.AllocationExpression.analyseCod
e(AllocationExpression.java:60)
        at org.eclipse.jdt.internal.compiler.ast.ReturnStatement.analyseCode
(Ret
urnStatement.java:37)
        at org.eclipse.jdt.internal.compiler.ast.Block.analyseCode
(Block.java:41
)
        at org.eclipse.jdt.internal.compiler.ast.IfStatement.analyseCode
(IfState
ment.java:84)
        at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode
(M
ethodDeclaration.java:70)
        at 
org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyse
Code(TypeDeclaration.java:639)
        at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode
(Typ
eDeclaration.java:196)
        at 
org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.anal
yseCode(CompilationUnitDeclaration.java:78)
        at org.eclipse.jdt.internal.compiler.Compiler.process
(Compiler.java:541)

        at org.aspectj.ajdt.internal.compiler.AjCompiler.process
(AjCompiler.java
:65)
        at org.eclipse.jdt.internal.compiler.Compiler.compile
(Compiler.java:338)

        at 
org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilat
ion(AjBuildManager.java:372)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild
(AjBuild
Manager.java:133)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild
(AjBu
ildManager.java:78)
        at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:106)
        at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:60)
        at org.aspectj.tools.ajc.Main.run(Main.java:217)
        at org.aspectj.tools.ajc.Main.runMain(Main.java:155)
        at org.aspectj.tools.ajc.Main.main(Main.java:72)
C:\devel\test\entAJtutorial\test\Processing.java:0 Internal compiler error
java.lang.NullPointerException
        at 
org.eclipse.jdt.internal.compiler.lookup.SyntheticAccessMethodBinding
.initializeConstructorAccessor(SyntheticAccessMethodBinding.java:215)
        at 
org.eclipse.jdt.internal.compiler.lookup.SyntheticAccessMethodBinding
.&lt;init&gt;(SyntheticAccessMethodBinding.java:136)
        at 
org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.addSynthet
icMethod(SourceTypeBinding.java:332)
        at 
org.eclipse.jdt.internal.compiler.ast.AllocationExpression.manageSynt
heticAccessIfNecessary(AllocationExpression.java:200)
        at 
org.eclipse.jdt.internal.compiler.ast.AllocationExpression.analyseCod
e(AllocationExpression.java:60)
        at org.eclipse.jdt.internal.compiler.ast.ReturnStatement.analyseCode
(Ret
urnStatement.java:37)
        at org.eclipse.jdt.internal.compiler.ast.Block.analyseCode
(Block.java:41
)
        at org.eclipse.jdt.internal.compiler.ast.IfStatement.analyseCode
(IfState
ment.java:84)
        at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode
(M
ethodDeclaration.java:70)
        at 
org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyse
Code(TypeDeclaration.java:639)
        at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode
(Typ
eDeclaration.java:196)
        at 
org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.anal
yseCode(CompilationUnitDeclaration.java:78)
        at org.eclipse.jdt.internal.compiler.Compiler.process
(Compiler.java:541)

        at org.aspectj.ajdt.internal.compiler.AjCompiler.process
(AjCompiler.java
:65)
        at org.eclipse.jdt.internal.compiler.Compiler.compile
(Compiler.java:338)

        at 
org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilat
ion(AjBuildManager.java:372)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild
(AjBuild
Manager.java:133)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild
(AjBu
ildManager.java:78)
        at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:106)
        at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:60)
        at org.aspectj.tools.ajc.Main.run(Main.java:217)
        at org.aspectj.tools.ajc.Main.runMain(Main.java:155)
        at org.aspectj.tools.ajc.Main.main(Main.java:72)


!! no source information available !!
ABORT
Exception thrown from AspectJ 1.1.0

This might be logged as a bug already -- find current bugs at
   http://bugs.eclipse.org/bugs/buglist.cgi?product=AspectJ&amp;component=Compiler 

Bugs for exceptions thrown have titles File:line from the top stack,
e.g., "SomeFile.java:243"

If you don't find the exception below in a bug, please add a new bug
at  http://bugs.eclipse.org/bugs/enter_bug.cgi?product=AspectJ 
To make the bug a priority, please include a test program
that can reproduce this exception.
null
java.lang.NullPointerException
        at 
org.eclipse.jdt.internal.compiler.lookup.SyntheticAccessMethodBinding
.initializeConstructorAccessor(SyntheticAccessMethodBinding.java:215)
        at 
org.eclipse.jdt.internal.compiler.lookup.SyntheticAccessMethodBinding
.&lt;init&gt;(SyntheticAccessMethodBinding.java:136)
        at 
org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.addSynthet
icMethod(SourceTypeBinding.java:332)
        at 
org.eclipse.jdt.internal.compiler.ast.AllocationExpression.manageSynt
heticAccessIfNecessary(AllocationExpression.java:200)
        at 
org.eclipse.jdt.internal.compiler.ast.AllocationExpression.analyseCod
e(AllocationExpression.java:60)
        at org.eclipse.jdt.internal.compiler.ast.ReturnStatement.analyseCode
(Ret
urnStatement.java:37)
        at org.eclipse.jdt.internal.compiler.ast.Block.analyseCode
(Block.java:41
)
        at org.eclipse.jdt.internal.compiler.ast.IfStatement.analyseCode
(IfState
ment.java:84)
        at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode
(M
ethodDeclaration.java:70)
        at 
org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyse
Code(TypeDeclaration.java:639)
        at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode
(Typ
eDeclaration.java:196)
        at 
org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.anal
yseCode(CompilationUnitDeclaration.java:78)
        at org.eclipse.jdt.internal.compiler.Compiler.process
(Compiler.java:541)

        at org.aspectj.ajdt.internal.compiler.AjCompiler.process
(AjCompiler.java
:65)
        at org.eclipse.jdt.internal.compiler.Compiler.compile
(Compiler.java:338)

        at 
org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilat
ion(AjBuildManager.java:372)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild
(AjBuild
Manager.java:133)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild
(AjBu
ildManager.java:78)
        at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:106)
        at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:60)
        at org.aspectj.tools.ajc.Main.run(Main.java:217)
        at org.aspectj.tools.ajc.Main.runMain(Main.java:155)
        at org.aspectj.tools.ajc.Main.main(Main.java:72)


1 fail|abort, 1 error, 1 warning

Processing.java source:
---
import org.aspectj.lang.*;
import org.aspectj.lang.reflect.*;
import java.lang.reflect.Method;

public aspect Processing {
    Object around() : 
            call(new(..))  {
        return proceed();
    }

    
    Object around() : 
             call(* *(..)) {
        MethodSignature sig = (MethodSignature)thisJoinPoint.getSignature();
        Class returnType = sig.getReturnType();
        if (returnType == java.lang.Void.TYPE) {
            return new java.lang.Void(); // this works if you make it null
        } 
    }
}</description><comments/></buginformation><fixedCommits><commit id="ba41fae6547688e8714d01be27bc81dbbe850f55" author="default" date="2003-07-02 23:12:18"><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/PrivilegedHandler.java"><method name="getPrivilegedAccessMethod" returnType="MethodBinding" parameters="MethodBinding AstNode"/></file><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AccessForInlineVisitor.java"><method name="endVisit" returnType="void" parameters="AllocationExpression BlockScope"/><method name="endVisit" returnType="void" parameters="MessageSend BlockScope"/><method name="endVisit" returnType="void" parameters=""/></file><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AdviceDeclaration.java"><method name="resolveStatements" returnType="void" parameters=""/></file></commit></fixedCommits></bug><bug id="24" opendate="2003-07-13 15:02:00" fixdate="2003-07-22 20:57:17"><buginformation><summary>ajc stack trace on declaring hashcode() method in aspect</summary><description>From an email sent to the user's list 6/26/2003:
------------------------------------------
ajc 1.1 NPE when an aspect declares hashcode() as follows:

     interface Identifiable {
         void setId(Id id);
         Id getId();
     }
 
     aspect IdentifiableAspect {
         private Id Identifiable.id = null;
         public Id Identifiable.getId() {
 		return this.id;
 	  }
         public void Identifiable.setId(Id id) {
             this.id = id;
         }
 
         public int Identifiable.hashCode() {
             return (this.getId() == null)
                 ? super.hashCode()
                 : this.getId().hashCode();
         }
     }

A workaround for callers the compiler controls is to replace the declaration
with around advice:

     int around(Identifiable i): target(i)
         &amp;&amp; call(public int hashCode())
     {
         return (i.getId() == null)
             ? proceed(i)
             : i.getId().hashCode();
     }</description><comments/></buginformation><fixedCommits><commit id="026b2728aef846823419ebffceb57fe8161e3d15" author="default" date="2003-07-22 20:57:17"><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/InterTypeDeclaration.java"><method name="resolve" returnType="void" parameters="ClassScope"/></file><file name="weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java"><method name="makeDispatcher" returnType="LazyMethodGen" parameters=""/><method name="mungeNewMethod" returnType="boolean" parameters="BcelClassWeaver"/></file></commit></fixedCommits></bug><bug id="25" opendate="2003-07-17 11:08:00" fixdate="2003-07-23 17:23:22"><buginformation><summary>AspectJ does not honour libraries defined via Project Properties</summary><description>AJDT 1.1.3, Eclipse 2.1

To build a JDK 1.4. program under Eclipse using JDK 1.3 the appropriate build 
library should be selected in the Project Properties "Java Build Path". 
However AspectJ continues to use the JDK associated with Eclipse so errors 
result from using 1.4 APIs. The same will occur running Eclipse under 1.4 and 
compiling programs for 1.5

Testcase:
1. Run Eclipse under JDK 1.3
2. Create a Java project which uses a 1.4 JDK
3. Write a Java classes that uses 1.4 APIs e.g.

public class TestStringBuffer {

	public  static void main(String[] args) {
		new StringBuffer("Test").indexOf("T");
  	}
}
4. Convert to AspectJ project</description><comments/></buginformation><fixedCommits><commit id="d5ea336dac0b484629f6453afcc7b271446732d4" author="default" date="2003-07-23 17:23:22"><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/AjdtCommand.java"><method name="genBuildConfig" returnType="AjBuildConfig" parameters="String[]"/></file><file name="ajde/src/org/aspectj/ajde/internal/CompilerAdapter.java"><method name="genBuildConfig" returnType="AjBuildConfig" parameters="String"/></file></commit></fixedCommits></bug><bug id="26" opendate="2003-07-25 10:47:00" fixdate="2003-07-25 15:07:57"><buginformation><summary>ajde apis are unnecessariy coupled to swing</summary><description>The AJDE APIs are coupled to javax.swing by org.aspectj.ajde.EditorManager.  
The EditorManager needs to be refactored, have swing specific parts moved to 
org.aspectj.ajde.ui.swing and org.aspectj.ajbrowser.</description><comments/></buginformation><fixedCommits><commit id="bbd832b4800bc0d7c54d65b2d9d690316e97c6a6" author="default" date="2003-07-25 15:07:57"><file name="ajde/src/org/aspectj/ajde/ui/StructureModelUtil.java"><method name="getLinesToAspectMap" returnType="Map" parameters="String"/></file><file name="ajbrowser/src/org/aspectj/tools/ajbrowser/TopFrame.java"><method name="jMenuItem1_actionPerformed" returnType="void" parameters="ActionEvent"/><method name="emacsTest_button_actionPerformed" returnType="void" parameters="ActionEvent"/><method name="save_button_actionPerformed" returnType="void" parameters="ActionEvent"/></file><file name="ajbrowser/src/org/aspectj/tools/ajbrowser/CompilerMessagesPanel.java"><method name="displayMessage" returnType="void" parameters="IMessage"/></file><file name="ajbrowser/src/org/aspectj/tools/ajbrowser/BrowserManager.java"><method name="getDefault" returnType="BrowserManager" parameters=""/><method name="openFile" returnType="void" parameters="String"/><method name="saveAll" returnType="void" parameters=""/><method name="BrowserManager" returnType="BrowserManager" parameters=""/><method name="init" returnType="void" parameters="String[] boolean"/></file><file name="ajde/src/org/aspectj/ajde/Ajde.java"><method name="Ajde" returnType="Ajde" parameters=""/><method name="getEditorManager" returnType="EditorManager" parameters=""/><method name="init" returnType="void" parameters=""/><method name="getStructureModelManager" returnType="StructureModelManager" parameters=""/><method name="compileFinished" returnType="void" parameters="String int boolean boolean"/></file></commit></fixedCommits></bug><bug id="27" opendate="2003-07-09 19:31:00" fixdate="2003-07-26 04:13:54"><buginformation><summary>allow use of an environment variable to set compiler arguments</summary><description>I'm trying to create a special jsp compilation servlet in Tomcat 4.x that uses 
the aspectj compiler. I can plug in the compiler adapter, but I don't have 
control of the ant code they use to invoke the compiler, so I'd like to use 
an environment variable to do this (apparently the only mechanism they do 
support).

I'm doing this so I can pass an aspectpath in to weave aspects into the 
compiled jsp servlet.</description><comments/></buginformation><fixedCommits><commit id="2502ee5106921a6947e3470d08e30a0734a4d805" author="default" date="2003-07-26 04:13:54"><file name="taskdefs/testsrc/org/aspectj/tools/ant/taskdefs/AjcTaskTest.java"><method name="getTask" returnType="AjcTask" parameters="String"/></file><file name="taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java"><method name="completeDestdir" returnType="void" parameters=""/><method name="setupAjc" returnType="String" parameters="AjcTask Javac File"/><method name="verifyOptions" returnType="void" parameters=""/><method name="File" returnType="File" parameters=""/></file></commit></fixedCommits></bug><bug id="28" opendate="2003-07-28 05:55:00" fixdate="2003-07-29 10:55:25"><buginformation><summary>asm treats "declare parents" as methods</summary><description>"declare parents" member declarations report their kind as "method" instead of 
what they are.</description><comments/></buginformation><fixedCommits><commit id="58e3cb226a2afa23134b75acecce617e5b16f781" author="default" date="2003-07-29 10:55:25"><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmBuilder.java"><method name="visit" returnType="boolean" parameters="MethodDeclaration ClassScope"/></file></commit></fixedCommits></bug><bug id="29" opendate="2003-07-04 05:26:00" fixdate="2003-07-30 09:10:45"><buginformation><summary>Compiler error when compiling a buggy class</summary><description>I use AspectJ 1.1 from within eclipse.
After some time of developing, I get following stack trace (Wrapped in the 
eclipse gui), when I try to compile a java file with a huge amount of syntax 
errors, missing variables, and other problems.

As soon as I have fixed these issues, I can comnpile normally as ever.

Unfortunatly I can not provide any more detailed information because:
this errors pops up randomly,
disappears when the bug is fixed, 
I have neither the time nor the permission to create a more accurate sample

java.lang.NullPointerException
    at java.lang.String.&lt;init&gt;(String.java:214)
    at org.aspectj.ajdt.internal.core.builder.AsmBuilder.visit
(AsmBuilder.java:231)
    at org.aspectj.ajdt.internal.core.builder.AsmBuilder.visit
(AsmBuilder.java:259)
    at 
org.eclipse.jdt.internal.compiler.ast.AnonymousLocalTypeDeclaration.traverse
(AnonymousLocalTypeDeclaration.java:138)
    at 
org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.traverse
(QualifiedAllocationExpression.java:342)
    at org.eclipse.jdt.internal.compiler.ast.MessageSend.traverse
(MessageSend.java:299)
    at org.eclipse.jdt.internal.compiler.ast.Block.traverse(Block.java:147)
    at org.eclipse.jdt.internal.compiler.ast.ForStatement.traverse
(ForStatement.java:347)
    at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.traverse
(MethodDeclaration.java:157)
    at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.traverse
(TypeDeclaration.java:946)
    at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.traverse
(CompilationUnitDeclaration.java:303)
    at org.aspectj.ajdt.internal.core.builder.AsmBuilder.internalBuild
(AsmBuilder.java:169)
    at org.aspectj.ajdt.internal.core.builder.AsmBuilder.build
(AsmBuilder.java:66)
    at 
org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.finishedCompilationUnit
(EclipseFactory.java:303)
    at org.aspectj.ajdt.internal.compiler.AjCompiler.process(AjCompiler.java:67)
    at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:338)
    at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation
(AjBuildManager.java:372)
    at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild
(AjBuildManager.java:133)
    at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild
(AjBuildManager.java:78)
    at org.aspectj.ajde.internal.CompilerAdapter.compile
(CompilerAdapter.java:117)
    at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run
(AspectJBuildManager.java:164)
    LoadTest.java   CrefoClient/src/com/dcbank/scoring/socketserver 
 
kind regards
   Arno Schmidmeier</description><comments/></buginformation><fixedCommits><commit id="78869703a8bf08bfa4e8f19b26dcf877949b0ad2" author="default" date="2003-07-30 09:10:45"><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmBuilder.java"><method name="makeLocation" returnType="ISourceLocation" parameters="AstNode"/><method name="build" returnType="void" parameters=""/><method name="visit" returnType="boolean" parameters="LocalTypeDeclaration BlockScope"/></file><file name="org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/core/builder/AjdtBuilderTests.java"><method name="suite" returnType="Test" parameters=""/></file></commit></fixedCommits></bug><bug id="30" opendate="2003-07-12 06:00:00" fixdate="2003-07-30 09:54:07"><buginformation><summary>Some strange error when compiling the observer example with JBuilder7 integrated AJDE</summary><description>When I compiled the observer/subject protocol example with JBuilder7 
integrated AJDE,there was a strange internal error

C:/JBuilder7/extras/aspectj-110/doc/examples/observer/Observer.java:0: 
Internal compiler error
java.lang.NullPointerException

	at 
org.aspectj.ajdt.internal.compiler.lookup.EclipseWorld.makeResolvedMember
(Unknown Source)

	at org.aspectj.ajdt.internal.core.builder.AsmBuilder.visit(Unknown 
Source)

	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.traverse
(Unknown Source)

	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.traverse
(Unknown Source)

	at 
org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.traverse
(Unknown Source)

	at org.aspectj.ajdt.internal.core.builder.AsmBuilder.internalBuild
(Unknown Source)

	at org.aspectj.ajdt.internal.core.builder.AsmBuilder.build(Unknown 
Source)

	at 
org.aspectj.ajdt.internal.compiler.lookup.EclipseWorld.finishedCompilationUnit
(Unknown Source)

	at org.aspectj.ajdt.internal.compiler.AjCompiler.process(Unknown 
Source)

	at org.eclipse.jdt.internal.compiler.Compiler.compile(Unknown Source)

	at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile
(Unknown Source)

	at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile
(Unknown Source)

	at 
org.aspectj.ajdt.internal.core.builder.AjBuildManager$BatchBuilder.run(Unknown 
Source)

	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild
(Unknown Source)

	at org.aspectj.ajde.internal.CompilerAdapter.compile(Unknown Source)

	at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run
(Unknown Source)

I firstly fix it by changing the interface Subject and Observer like this:
interface Observer {    void update();}
interface Subject { Object getData(); }
then it could compile successfully ,however,I immediately got another 
confusing.The compiler only made Display.java Observer.java Subject.java 
SubjectObserverProtocol.java and SubjectObserverProtocolImpl.java but ignoring 
the others.I don't know why,it seems to be a bug.

Meanwhile, I use ajc command-line  to compile this example ,it can get through 
without any exceptions.</description><comments/></buginformation><fixedCommits><commit id="f5d31bac784ae2c0cccb6a990d1fc54e86df2dd1" author="default" date="2003-07-30 09:54:07"><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmBuilder.java"><method name="visit" returnType="boolean" parameters="MethodDeclaration ClassScope"/><method name="visit" returnType="boolean" parameters="TypeDeclaration CompilationUnitScope"/><method name="findEnclosingClass" returnType="StructureNode" parameters="Stack"/></file></commit></fixedCommits></bug><bug id="31" opendate="2003-06-10 12:03:00" fixdate="2003-07-30 17:29:44"><buginformation><summary>".lst" file parsing errors should include sourceline information</summary><description>To check for this bug add an erroneous line to an ".lst" file and compile it 
with AJDE.  The error message returned is project-specific.  It should be 
specific to the ".lst" file in which the error originated (i.e. the message 
needs a SourceLocation).</description><comments/></buginformation><fixedCommits><commit id="a26cac9b4c36b9512003ac739d856c8082e5e17a" author="default" date="2003-07-30 17:29:44"><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java"><method name="showError" returnType="void" parameters="String"/><method name="showWarning" returnType="void" parameters="String"/><method name="genBuildConfig" returnType="AjBuildConfig" parameters="String[] IMessageHandler boolean"/><method name="genBuildConfig" returnType="AjBuildConfig" parameters="String[] IMessageHandler"/></file><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/AjdtCommand.java"><method name="genBuildConfig" returnType="AjBuildConfig" parameters="String[] CountingMessageHandler"/></file></commit></fixedCommits></bug><bug id="32" opendate="2003-07-16 15:06:00" fixdate="2003-08-07 08:10:01"><buginformation><summary>parsing of "../" paths in LST files is broken</summary><description>Relative paths (e.g. "../") are no longer parser properly in AJDE 1.1.0.</description><comments/></buginformation><fixedCommits><commit id="acdf688ccc4d8b376141b2c8e28bc5d7b7612e90" author="default" date="2003-08-07 08:10:01"><file name="ajde/src/org/aspectj/ajde/ui/swing/CompilerMessagesCellRenderer.java"><method name="getListCellRendererComponent" returnType="Component" parameters=""/></file><file name="org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/ajc/AjdtAjcTests.java"><method name="suite" returnType="Test" parameters=""/></file></commit></fixedCommits></bug><bug id="33" opendate="2003-07-20 12:16:00" fixdate="2003-08-07 10:51:36"><buginformation><summary>Declare warning/error output - more detail required.</summary><description>At present the declare warning and declare error functionality of the compiler 
provides no detailed information about what it is in the user code that has led 
to the generation of the compile-time warning or error. 

Consider the following test case...

public class A
{
  public static void main(String[] args)
  {
    A a = new A();
    a.doSomething();
    System.out.println("All done");
  }

  void doSomething()
  {
    System.out.println("Doing something");
  }
} // end of class A


public aspect MyAspect
{
  pointcut noDoing() :
    call(* *.doSomething(..));

  declare warning : noDoing() :
    "Don't do it!";
} 

When I compile these two files I get the following warning ...

c:\src\A.java:16 Don't do it!

..which is great if all I want to know is where the offending code is. But not 
nearly enough if I want to know what it is on the line that is contravening the 
policy (or policies) that I have specified in my aspect. In the above example it 
would be even more useful if the warning message was something like ...

c:\src\A.java:16 Don't do it! : calling method : void A.doSomething()

For large projects where there is an architectural imperative to reduce or 
completely remove coupling between certain components declare warning/error 
would be of far greater use if it could return more detailed info to say *why* 
not just *where* the desired enforcement rules have been broken.</description><comments/></buginformation><fixedCommits><commit id="684c9c1c3dd084b43645f537774bea0b4a9c1222" author="default" date="2003-08-07 10:51:36"><file name="bridge/src/org/aspectj/bridge/IMessage.java"><method name="toString" returnType="String" parameters=""/></file><file name="bridge/src/org/aspectj/bridge/Message.java"><method name="fail" returnType="Message" parameters="String Throwable"/></file><file name="weaver/src/org/aspectj/weaver/Checker.java"><method name="match" returnType="boolean" parameters="Shadow World"/></file></commit></fixedCommits></bug><bug id="34" opendate="2003-08-05 00:39:00" fixdate="2003-08-08 01:23:31"><buginformation><summary>Weaving failure when using injars</summary><description>Sample run that fails using injars:
C:\devel\test\libraryWeave&gt;ajc ajee\testing\ExecutionMonitor.aj

C:\devel\test\libraryWeave&gt;jar cf ajee.jar ajee\testing\*.class

C:\devel\test\libraryWeave&gt;ajc -injars ajee.jar model\BusObj.java 
model\MonitorB
usObj.java
C:\devel\test\libraryWeave\model\BusObj.java:3 Class must implement the 
inherite
d abstract method ExecutionMonitor.MonitoredItem.ajc$interMethodDispatch2
$ajee_t
esting_ExecutionMonitor$record(String, String)
public class BusObj {
             ^^^^^^

1 error

It works in a single pass compilation:
C:\devel\test\libraryWeave&gt;ajc ajee\testing\ExecutionMonitor.aj 
model\BusObj.jav
a model\MonitorBusObj.java

C:\devel\test\libraryWeave&gt;

Sample source code:
package ajee.testing;

public aspect ExecutionMonitor {
    public interface MonitoredItem {}
    private void MonitoredItem.record(String eventType, String eventName) {}
}         
---
package model;

public class BusObj {

}
---
package model;

import ajee.testing.ExecutionMonitor;

public aspect MonitorBusObj {
    declare parents: BusObj implements ExecutionMonitor.MonitoredItem;
}</description><comments/></buginformation><fixedCommits><commit id="3e5974557278e81a9891edd4269eca39a8d42f43" author="default" date="2003-08-08 01:23:31"><file name="weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"><method name="pack" returnType="MethodGen" parameters=""/></file><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java"><method name="weaveInterTypeDeclarations" returnType="void" parameters="SourceTypeBinding"/><method name="doDeclareParents" returnType="void" parameters="DeclareParents"/></file><file name="weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java"><method name="makeMethodGen" returnType="LazyMethodGen" parameters="LazyClassGen ResolvedMember"/></file></commit></fixedCommits></bug><bug id="35" opendate="2003-08-07 09:00:00" fixdate="2003-08-08 11:02:53"><buginformation><summary>revise asm and create interfaces</summary><description>The org.aspectj.asm API exposes implementation detail, does not have 
interfaces, and has needless generalization and indirection (Association&lt;-
 &gt;Relation&lt;-&gt;RelationNode and LinkNode&lt;-&gt;StructureNode).  The following is a  
first pass at an improved interface:

- IProgramElement
  * getName
  * getAccessibility : Accessiblity
  * getModifiers : Modifiers
  * getKind : Kind  
  * getFormalComment : String
  * isImplementor
  * isOverrider
  * isRunnable
  + getRelationships
  + getDeclaringType : IAspectJElement 
  + getPackage : IAspectJElement 
  + getType : IAspectJElement (can be null)
  + getParameters : List /*IAspectJElement*/ (can be null)
  + toString -&gt; name
  + toSignatureString -&gt; full signature

/** 
  * uni-directional 1..* relationships
  */
- IRelationship
  + getName
  + getKind
  + getSource
  + getTargets</description><comments/></buginformation><fixedCommits><commit id="f1deb9c11024ecebab2e0aa17a260821375c25bd" author="default" date="2003-08-08 11:02:53"><file name="ajde/src/org/aspectj/ajde/ui/AbstractIconRegistry.java"><method name="getStructureIcon" returnType="AbstractIcon" parameters="ProgramElementNode.Kind"/><method name="getRelationIcon" returnType="AbstractIcon" parameters="Relation"/><method name="getStructureIcon" returnType="AbstractIcon" parameters="ProgramElementNode.Kind ProgramElementNode.Accessibility"/></file><file name="ajde/src/org/aspectj/ajde/internal/LstBuildConfigManager.java"><method name="pruneEmptyDirs" returnType="boolean" parameters="BuildConfigNode"/></file><file name="ajbrowser/src/org/aspectj/tools/ajbrowser/TopFrame.java"><method name="init" returnType="void" parameters="MultiStructureViewPanel"/><method name="actionPerformed" returnType="void" parameters="ActionEvent"/></file><file name="ajbrowser/src/org/aspectj/tools/ajbrowser/BrowserManager.java"><method name="getDefault" returnType="BrowserManager" parameters=""/></file></commit></fixedCommits></bug><bug id="36" opendate="2003-06-27 14:32:00" fixdate="2003-08-21 16:02:53"><buginformation><summary>[Tasks] No summary shown in status line</summary><description>build I20030625

The old tasks view showed a summary of the number of tasks, errors, warnings 
and infos in the status line.  This is missing in the reworked view.</description><comments/></buginformation><fixedCommits><commit id="d90acdcedd63f04b906b0efc5e249e93245f5618" author="default" date="2003-08-21 16:02:53"><file name="weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"><method name="compare" returnType="int" parameters="Object Object"/><method name="unpackLocals" returnType="void" parameters="MethodGen"/><method name="packBody" returnType="void" parameters="MethodGen"/></file></commit></fixedCommits></bug><bug id="37" opendate="2003-08-09 11:19:00" fixdate="2003-08-28 21:44:55"><buginformation><summary>percflow aspects compiled from jars share one instance for all entry points</summary><description>When a percflow aspect is woven into source code from a jar using the aspectPath
compiler option, it produces only one instance of the aspect for each entrypoint
defined in the source code.</description><comments/></buginformation><fixedCommits><commit id="5a07dcee3a3f520e4b5cadc67000673e2d0ca0b7" author="default" date="2003-08-28 21:44:55"><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectDeclaration.java"><method name="lookupPerClauseKind" returnType="PerClause.Kind" parameters="ReferenceBinding"/></file></commit></fixedCommits></bug><bug id="38" opendate="2003-09-04 11:15:00" fixdate="2003-09-04 15:49:08"><buginformation><summary>throw derivative pointcuts not advised.</summary><description>Given the following point cut and advice:

public aspect ExceptionAspect
{
    pointcut exceptionThrower() : execution(public * ExceptionBugTest.*(..)
throws Exception+);

    declare warning : exceptionThrower() : "throws Exception+";
}

And the to be aspected code:

public class ExceptionBugTest
{

    class MyException extends Exception
    {
    }

    public void method1() throws Exception
    {
    }

    public void method2() throws MyException
    {
    }
}

listing file default.lst:
C:\temp\AJC Bug\ExceptionAspect.aj
C:\temp\AJC Bug\ExceptionBugTest.java


AJC does not advise ExceptionBugTest.method2().  The output from the compilation
is the following:
C:\temp\AJC Bug&gt;ajc -argfile default.lst -classpath %ASPECTJ_HOME%\lib\aspectjrt.jar
C:\eclipse\workspace\AJC Bug\ExceptionBugTest.java:11 throws Exception+

From the aspect-j mailing list, contributed by Jim Hugunin:
&amp;lt;detail&amp;gt;The bug was caused because the code for ThrowsPattern mistakenly
used the internal protected method TypePattern.matchesExactly instead of the
external public method TypePattern.matchesStatically.  Because the classes were
in the same package, Java's accessibility rules allowed this.  It would be nice
if there was an easy way to specifiy that a method could only be accessed from
subtypes.&amp;lt;/detail&amp;gt;</description><comments/></buginformation><fixedCommits><commit id="8660cc12bfbcd6f4957abd4dfc84735de6c048cf" author="default" date="2003-09-04 15:49:08"><file name="weaver/src/org/aspectj/weaver/patterns/ThrowsPattern.java"><method name="matchesAny" returnType="boolean" parameters=""/></file></commit></fixedCommits></bug><bug id="39" opendate="2003-09-08 22:47:00" fixdate="2003-09-10 00:35:18"><buginformation><summary>declare error fails on pointcuts composed from multiple classes</summary><description>This error occurs in both 1.1.0 and in the head of CVS as of 9/8/03. The 
compiler crash output from the CVS head version is at the end. It may be 
related to 42739, but they may be distinct problems.

Sample source:
/*
 * Created on Sep 8, 2003
 *
 * Copyright (c) 2003 New Aspects of Security. All Rights Reserved.
 */
aspect Library {
    public pointcut executionsThrowingChecked() : 
        execution(* *(..) throws (Exception+ &amp;&amp; !RuntimeException));
}

public aspect SampleExceptionHandling {
    public pointcut scope() : within(org.atrack.model..*);
    
    public pointcut executionsThrowingChecked() : 
        Library.executionsThrowingChecked() &amp;&amp; scope();

    declare error : executionsThrowingChecked(): 
        "no checked exceptions";
}

sample compile:
C:\eclipse\workspace\atrack&gt;ajc src\SampleExceptionHandling.java
java.lang.Exception: Stack trace
        at java.lang.Thread.dumpStack(Thread.java:1071)
        at org.aspectj.weaver.patterns.ReferencePointcut.concretize1
(ReferencePo
intcut.java:215)
        at org.aspectj.weaver.patterns.AndPointcut.concretize1
(AndPointcut.java:
88)
        at org.aspectj.weaver.patterns.ReferencePointcut.concretize1
(ReferencePo
intcut.java:272)
        at org.aspectj.weaver.patterns.AndPointcut.concretize1
(AndPointcut.java:
88)
        at org.aspectj.weaver.patterns.ReferencePointcut.concretize1
(ReferencePo
intcut.java:272)
        at org.aspectj.weaver.patterns.Pointcut.concretize(Pointcut.java:127)
        at org.aspectj.weaver.patterns.Pointcut.concretize(Pointcut.java:120)
        at org.aspectj.weaver.Checker.concretize(Checker.java:37)
        at org.aspectj.weaver.CrosscuttingMembers.addShadowMunger
(CrosscuttingMe
mbers.java:78)
        at org.aspectj.weaver.CrosscuttingMembers.addDeclare
(CrosscuttingMembers
.java:102)
        at org.aspectj.weaver.CrosscuttingMembers.addDeclares
(CrosscuttingMember
s.java:92)
        at org.aspectj.weaver.ResolvedTypeX.collectCrosscuttingMembers
(ResolvedT
ypeX.java:332)
        at org.aspectj.weaver.CrosscuttingMembersSet.addOrReplaceAspect
(Crosscut
tingMembersSet.java:50)
        at 
org.aspectj.ajdt.internal.compiler.ast.AspectDeclaration.buildInterTy
peAndPerClause(AspectDeclaration.java:754)
        at 
org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.buildIn
terTypeAndPerClause(AjLookupEnvironment.java:124)
        at 
org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.complet
eTypeBindings(AjLookupEnvironment.java:91)
        at org.eclipse.jdt.internal.compiler.Compiler.beginToCompile
(Compiler.ja
va:310)
        at org.eclipse.jdt.internal.compiler.Compiler.compile
(Compiler.java:324)

        at 
org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilat
ion(AjBuildManager.java:373)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild
(AjBuild
Manager.java:125)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild
(AjBu
ildManager.java:70)
        at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:99)
        at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:53)
        at org.aspectj.tools.ajc.Main.run(Main.java:217)
        at org.aspectj.tools.ajc.Main.runMain(Main.java:155)
        at org.aspectj.tools.ajc.Main.main(Main.java:72)
C:\eclipse\workspace\atrack\src\SampleExceptionHandling.java:15 circular 
pointcu
t declaration involving: executionsThrowingChecked()

1 error</description><comments/></buginformation><fixedCommits><commit id="d78d9ed48963cf302c26daab6af782d9b01ea3ac" author="default" date="2003-09-10 00:35:18"><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/PointcutDeclaration.java"><method name="makeResolvedPointcutDefinition" returnType="ResolvedPointcutDefinition" parameters=""/><method name="resolveStatements" returnType="void" parameters=""/></file><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectDeclaration.java"><method name="buildInterTypeAndPerClause" returnType="void" parameters="ClassScope"/></file><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java"><method name="completeTypeBindings" returnType="void" parameters=""/></file></commit></fixedCommits></bug><bug id="40" opendate="2003-09-12 04:26:00" fixdate="2003-09-12 16:49:58"><buginformation><summary>Language regression, or possible language improvement?</summary><description>The file AspectBug.java:

public aspect AspectBug extends AbstractCaching
perthis(execution(ContainerLoader+.new(..)))
{
	declare parents: ContainerDescriptor implements AbstractCaching.Key;

	protected pointcut loadExecutions( Key key ):
		ContainerLoader.containerLoads( *, key );
}

abstract aspect AbstractCaching  {
	interface Key {}
	protected abstract pointcut loadExecutions(Key key);
}

class Key {
}

class ContainerDescriptor {
}

class ActiveContainer {
}

class ContainerLoader {
	public ActiveContainer createContainer(ContainerDescriptor c) {
		return null;
	}

    public pointcut containerLoads(ContainerLoader loader,
								   
ContainerDescriptor containerDesc ):
        this(loader) &amp;&amp; args(containerDesc)
        &amp;&amp; execution(ActiveContainer ContainerLoader.createContainer
(ContainerDescriptor));
}

        First, here are the versions of AspectJ I'm using (this is a bash
        shell under cygwin on Windows XP):

~&gt; CLASSPATH='C:\aspectj1.0\lib\aspectjrt.jar' /cygdrive/c/aspectj1.0/bin/ajc -
version
ajc version 1.0.6 (built Jul 24, 2002 6:21 PM PST) running on java 1.4.1_02
~&gt; CLASSPATH='C:\aspectj1.1\lib\aspectjrt.jar' /cygdrive/c/aspectj1.1/bin/ajc -
version
AspectJ Compiler 1.1.0
~&gt; CLASSPATH='C:\aspectj1.1.1rc1
\lib\aspectjrt.jar' /cygdrive/c/aspectj1.1.1rc1/bin/ajc -version
AspectJ Compiler 1.1.1rc1
~&gt; CLASSPATH='C:\aspectj1.1.1
\lib\aspectjrt.jar' /cygdrive/c/aspectj1.1.1/bin/ajc -version
AspectJ Compiler 1.1.1

        For all four of these compilers, I give them the AspectBug.java file
	(which is attached):

~&gt; CLASSPATH='C:\aspectj1.0\lib\aspectjrt.jar' /cygdrive/c/aspectj1.0/bin/ajc 
AspectBug.java
~&gt; CLASSPATH='C:\aspectj1.1\lib\aspectjrt.jar' /cygdrive/c/aspectj1.1/bin/ajc 
AspectBug.java
~&gt; CLASSPATH='C:\aspectj1.1.1rc1
\lib\aspectjrt.jar' /cygdrive/c/aspectj1.1.1rc1/bin/ajc AspectBug.java
~&gt; CLASSPATH='C:\aspectj1.1.1
\lib\aspectjrt.jar' /cygdrive/c/aspectj1.1.1/bin/ajc AspectBug.java
C:\Documents and Settings\Macneil Shonle\AspectBug.java:7 incompatible type, 
expected ContainerDescriptor found BindingTypePattern(AbstractCaching$Key, 0)

1 error

        As you can see, only the final run (with the Sept 11 build of
	ajc) do we see the "incompatible type" error. If this is not a
	regression but a desirable result, how should the code be ported?</description><comments/></buginformation><fixedCommits><commit id="b5127388a3b5a2403e8d8944766bbe1895e09530" author="default" date="2003-09-12 16:49:58"><file name="weaver/src/org/aspectj/weaver/ResolvedTypeX.java"><method name="collectCrosscuttingMembers" returnType="CrosscuttingMembers" parameters=""/></file><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java"><method name="completeTypeBindings" returnType="void" parameters=""/></file><file name="weaver/src/org/aspectj/weaver/CrosscuttingMembersSet.java"><method name="getDeclareDominates" returnType="List" parameters=""/></file></commit></fixedCommits></bug><bug id="41" opendate="2003-09-16 23:21:00" fixdate="2003-09-18 18:38:14"><buginformation><summary>java.lang.VerifyError in generated code</summary><description>See the attached file VerifyBug.jar for the source files. You won't need 
anything else to compiler and reproduce this bug:

~/bug&gt; ls
AbstractCaching.java   TreeNode.java         VerifyBug.jar
ContainerCaching.java  TreeNodeFolding.java  WorkspaceGroup.java
ContainerLoader.java   TreePanel.java        WorkspaceNode.java
Makefile               TreeWorkspace.java
~/bug&gt; gmake   
/cygdrive/c/aspectj1.1.1/bin/ajc -classpath "C:\aspectj1.1.1
\lib\aspectjrt.jar" -version
AspectJ Compiler 1.1.1

/cygdrive/c/aspectj1.1.1/bin/ajc -classpath "C:\aspectj1.1.1\lib\aspectjrt.jar" 
*.java
java -classpath "C:\aspectj1.1.1\lib\aspectjrt.jar;." TreeNode
java.lang.VerifyError: (class: TreeNode, method: doShowAction signature: ()V) 
Unable to pop operand off an empty stack
Exception in thread "main" make: *** [all] Error 1</description><comments/></buginformation><fixedCommits><commit id="fc0d2af02cc6b6f8a4d9425e3c1cdd166957dde9" author="default" date="2003-09-18 18:38:14"><file name="weaver/src/org/aspectj/weaver/patterns/ReferencePointcut.java"><method name="concretize1" returnType="Pointcut" parameters="ResolvedTypeX IntMap"/></file></commit></fixedCommits></bug><bug id="42" opendate="2003-09-12 13:34:00" fixdate="2003-09-19 08:16:17"><buginformation><summary>Compiler crash in ajc head (post 1.1.1 rc1) on erroneous program</summary><description>This must be caused by the fix to concretization...

Input sources:
package base;

public abstract aspect ExceptionHandling {
    public abstract pointcut scope();
    declare soft: Exception: scope();
}

package model;

import base.ExceptionHandling;

public aspect ModelExceptionHandling extends ExceptionHandling {
    public pointcut scope() : within(*);

    protected RuntimeException convertCheckedException(Throwable t) {
        return new RuntimeException(t.getMessage(), t
}

Compiler output:
C:\eclipse\workspace\atrack&gt;ajc -d debug @narrow.lst
java.lang.NullPointerException
        at org.aspectj.weaver.patterns.ReferencePointcut.concretize1
(ReferencePo
intcut.java:243)
        at org.aspectj.weaver.patterns.Pointcut.concretize(Pointcut.java:127)
        at org.aspectj.weaver.patterns.Pointcut.concretize(Pointcut.java:110)
        at org.aspectj.weaver.CrosscuttingMembers.addDeclare
(CrosscuttingMembers
.java:111)
        at org.aspectj.weaver.CrosscuttingMembers.addDeclares
(CrosscuttingMember
s.java:92)
        at org.aspectj.weaver.ResolvedTypeX.collectCrosscuttingMembers
(ResolvedT
ypeX.java:332)
        at org.aspectj.weaver.CrosscuttingMembersSet.addOrReplaceAspect
(Crosscut
tingMembersSet.java:50)
        at 
org.aspectj.ajdt.internal.compiler.ast.AspectDeclaration.buildInterTy
peAndPerClause(AspectDeclaration.java:754)
        at 
org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.buildIn
terTypeAndPerClause(AjLookupEnvironment.java:124)
        at 
org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.complet
eTypeBindings(AjLookupEnvironment.java:91)
        at org.eclipse.jdt.internal.compiler.Compiler.beginToCompile
(Compiler.ja
va:310)
        at org.eclipse.jdt.internal.compiler.Compiler.compile
(Compiler.java:324)

        at 
org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilat
ion(AjBuildManager.java:373)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild
(AjBuild
Manager.java:125)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild
(AjBu
ildManager.java:70)
        at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:99)
        at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:53)
        at org.aspectj.tools.ajc.Main.run(Main.java:217)
        at org.aspectj.tools.ajc.Main.runMain(Main.java:155)
        at org.aspectj.tools.ajc.Main.main(Main.java:72)
C:\eclipse\workspace\atrack\src\org\atrack\model\error\impl\ModelExceptionHandl
i
ng.java:0 Internal compiler error
java.lang.NullPointerException
        at org.aspectj.weaver.patterns.ReferencePointcut.concretize1
(ReferencePo
intcut.java:243)
        at org.aspectj.weaver.patterns.Pointcut.concretize(Pointcut.java:127)
        at org.aspectj.weaver.patterns.Pointcut.concretize(Pointcut.java:110)
        at org.aspectj.weaver.CrosscuttingMembers.addDeclare
(CrosscuttingMembers
.java:111)
        at org.aspectj.weaver.CrosscuttingMembers.addDeclares
(CrosscuttingMember
s.java:92)
        at org.aspectj.weaver.ResolvedTypeX.collectCrosscuttingMembers
(ResolvedT
ypeX.java:332)
        at org.aspectj.weaver.CrosscuttingMembersSet.addOrReplaceAspect
(Crosscut
tingMembersSet.java:50)
        at 
org.aspectj.ajdt.internal.compiler.ast.AspectDeclaration.buildInterTy
peAndPerClause(AspectDeclaration.java:754)
        at 
org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.buildIn
terTypeAndPerClause(AjLookupEnvironment.java:124)
        at 
org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.complet
eTypeBindings(AjLookupEnvironment.java:91)
        at org.eclipse.jdt.internal.compiler.Compiler.beginToCompile
(Compiler.ja
va:310)
        at org.eclipse.jdt.internal.compiler.Compiler.compile
(Compiler.java:324)

        at 
org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilat
ion(AjBuildManager.java:373)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild
(AjBuild
Manager.java:125)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild
(AjBu
ildManager.java:70)
        at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:99)
        at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:53)
        at org.aspectj.tools.ajc.Main.run(Main.java:217)
        at org.aspectj.tools.ajc.Main.runMain(Main.java:155)
        at org.aspectj.tools.ajc.Main.main(Main.java:72)


!! no source information available !!
C:\eclipse\workspace\atrack\src\org\atrack\model\error\impl\ModelExceptionHandl
i
ng.java:23 Unmatched bracket
return new RuntimeException(t.getMessage(), t
                           ^
ABORT
Exception thrown from AspectJ DEVELOPMENT

This might be logged as a bug already -- find current bugs at
   http://bugs.eclipse.org/bugs/buglist.cgi?product=AspectJ&amp;component=Compiler 

Bugs for exceptions thrown have titles File:line from the top stack,
e.g., "SomeFile.java:243"

If you don't find the exception below in a bug, please add a new bug
at  http://bugs.eclipse.org/bugs/enter_bug.cgi?product=AspectJ 
To make the bug a priority, please include a test program
that can reproduce this exception.
null
java.lang.NullPointerException
        at org.aspectj.weaver.patterns.ReferencePointcut.concretize1
(ReferencePo
intcut.java:243)
        at org.aspectj.weaver.patterns.Pointcut.concretize(Pointcut.java:127)
        at org.aspectj.weaver.patterns.Pointcut.concretize(Pointcut.java:110)
        at org.aspectj.weaver.CrosscuttingMembers.addDeclare
(CrosscuttingMembers
.java:111)
        at org.aspectj.weaver.CrosscuttingMembers.addDeclares
(CrosscuttingMember
s.java:92)
        at org.aspectj.weaver.ResolvedTypeX.collectCrosscuttingMembers
(ResolvedT
ypeX.java:332)
        at org.aspectj.weaver.CrosscuttingMembersSet.addOrReplaceAspect
(Crosscut
tingMembersSet.java:50)
        at 
org.aspectj.ajdt.internal.compiler.ast.AspectDeclaration.buildInterTy
peAndPerClause(AspectDeclaration.java:754)
        at 
org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.buildIn
terTypeAndPerClause(AjLookupEnvironment.java:124)
        at 
org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.complet
eTypeBindings(AjLookupEnvironment.java:91)
        at org.eclipse.jdt.internal.compiler.Compiler.beginToCompile
(Compiler.ja
va:310)
        at org.eclipse.jdt.internal.compiler.Compiler.compile
(Compiler.java:324)

        at 
org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilat
ion(AjBuildManager.java:373)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild
(AjBuild
Manager.java:125)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild
(AjBu
ildManager.java:70)
        at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:99)
        at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:53)
        at org.aspectj.tools.ajc.Main.run(Main.java:217)
        at org.aspectj.tools.ajc.Main.runMain(Main.java:155)
        at org.aspectj.tools.ajc.Main.main(Main.java:72)


1 fail|abort, 2 errors

C:\eclipse\workspace\atrack&gt;cd \devel\test\excHandling\c1

C:\devel\test\excHandling\c1&gt;ajc base\ExceptionHandling.java 
model\ModelExceptio
nHandling.java
java.lang.NullPointerException
        at org.aspectj.weaver.patterns.ReferencePointcut.concretize1
(ReferencePo
intcut.java:243)
        at org.aspectj.weaver.patterns.Pointcut.concretize(Pointcut.java:127)
        at org.aspectj.weaver.patterns.Pointcut.concretize(Pointcut.java:110)
        at org.aspectj.weaver.CrosscuttingMembers.addDeclare
(CrosscuttingMembers
.java:111)
        at org.aspectj.weaver.CrosscuttingMembers.addDeclares
(CrosscuttingMember
s.java:92)
        at org.aspectj.weaver.ResolvedTypeX.collectCrosscuttingMembers
(ResolvedT
ypeX.java:332)
        at org.aspectj.weaver.CrosscuttingMembersSet.addOrReplaceAspect
(Crosscut
tingMembersSet.java:50)
        at 
org.aspectj.ajdt.internal.compiler.ast.AspectDeclaration.buildInterTy
peAndPerClause(AspectDeclaration.java:754)
        at 
org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.buildIn
terTypeAndPerClause(AjLookupEnvironment.java:124)
        at 
org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.complet
eTypeBindings(AjLookupEnvironment.java:91)
        at org.eclipse.jdt.internal.compiler.Compiler.beginToCompile
(Compiler.ja
va:310)
        at org.eclipse.jdt.internal.compiler.Compiler.compile
(Compiler.java:324)

        at 
org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilat
ion(AjBuildManager.java:373)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild
(AjBuild
Manager.java:125)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild
(AjBu
ildManager.java:70)
        at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:99)
        at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:53)
        at org.aspectj.tools.ajc.Main.run(Main.java:217)
        at org.aspectj.tools.ajc.Main.runMain(Main.java:155)
        at org.aspectj.tools.ajc.Main.main(Main.java:72)
C:\devel\test\excHandling\c1\model\ModelExceptionHandling.java:0 Internal 
compil
er error
java.lang.NullPointerException
        at org.aspectj.weaver.patterns.ReferencePointcut.concretize1
(ReferencePo
intcut.java:243)
        at org.aspectj.weaver.patterns.Pointcut.concretize(Pointcut.java:127)
        at org.aspectj.weaver.patterns.Pointcut.concretize(Pointcut.java:110)
        at org.aspectj.weaver.CrosscuttingMembers.addDeclare
(CrosscuttingMembers
.java:111)
        at org.aspectj.weaver.CrosscuttingMembers.addDeclares
(CrosscuttingMember
s.java:92)
        at org.aspectj.weaver.ResolvedTypeX.collectCrosscuttingMembers
(ResolvedT
ypeX.java:332)
        at org.aspectj.weaver.CrosscuttingMembersSet.addOrReplaceAspect
(Crosscut
tingMembersSet.java:50)
        at 
org.aspectj.ajdt.internal.compiler.ast.AspectDeclaration.buildInterTy
peAndPerClause(AspectDeclaration.java:754)
        at 
org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.buildIn
terTypeAndPerClause(AjLookupEnvironment.java:124)
        at 
org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.complet
eTypeBindings(AjLookupEnvironment.java:91)
        at org.eclipse.jdt.internal.compiler.Compiler.beginToCompile
(Compiler.ja
va:310)
        at org.eclipse.jdt.internal.compiler.Compiler.compile
(Compiler.java:324)

        at 
org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilat
ion(AjBuildManager.java:373)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild
(AjBuild
Manager.java:125)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild
(AjBu
ildManager.java:70)
        at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:99)
        at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:53)
        at org.aspectj.tools.ajc.Main.run(Main.java:217)
        at org.aspectj.tools.ajc.Main.runMain(Main.java:155)
        at org.aspectj.tools.ajc.Main.main(Main.java:72)


!! no source information available !!
C:\devel\test\excHandling\c1\model\ModelExceptionHandling.java:9 Unmatched 
brack
et
return new RuntimeException(t.getMessage(), t
                           ^
ABORT
Exception thrown from AspectJ DEVELOPMENT

This might be logged as a bug already -- find current bugs at
   http://bugs.eclipse.org/bugs/buglist.cgi?product=AspectJ&amp;component=Compiler 

Bugs for exceptions thrown have titles File:line from the top stack,
e.g., "SomeFile.java:243"

If you don't find the exception below in a bug, please add a new bug
at  http://bugs.eclipse.org/bugs/enter_bug.cgi?product=AspectJ 
To make the bug a priority, please include a test program
that can reproduce this exception.
null
java.lang.NullPointerException
        at org.aspectj.weaver.patterns.ReferencePointcut.concretize1
(ReferencePo
intcut.java:243)
        at org.aspectj.weaver.patterns.Pointcut.concretize(Pointcut.java:127)
        at org.aspectj.weaver.patterns.Pointcut.concretize(Pointcut.java:110)
        at org.aspectj.weaver.CrosscuttingMembers.addDeclare
(CrosscuttingMembers
.java:111)
        at org.aspectj.weaver.CrosscuttingMembers.addDeclares
(CrosscuttingMember
s.java:92)
        at org.aspectj.weaver.ResolvedTypeX.collectCrosscuttingMembers
(ResolvedT
ypeX.java:332)
        at org.aspectj.weaver.CrosscuttingMembersSet.addOrReplaceAspect
(Crosscut
tingMembersSet.java:50)
        at 
org.aspectj.ajdt.internal.compiler.ast.AspectDeclaration.buildInterTy
peAndPerClause(AspectDeclaration.java:754)
        at 
org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.buildIn
terTypeAndPerClause(AjLookupEnvironment.java:124)
        at 
org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.complet
eTypeBindings(AjLookupEnvironment.java:91)
        at org.eclipse.jdt.internal.compiler.Compiler.beginToCompile
(Compiler.ja
va:310)
        at org.eclipse.jdt.internal.compiler.Compiler.compile
(Compiler.java:324)

        at 
org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilat
ion(AjBuildManager.java:373)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild
(AjBuild
Manager.java:125)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild
(AjBu
ildManager.java:70)
        at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:99)
        at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:53)
        at org.aspectj.tools.ajc.Main.run(Main.java:217)
        at org.aspectj.tools.ajc.Main.runMain(Main.java:155)
        at org.aspectj.tools.ajc.Main.main(Main.java:72)


1 fail|abort, 2 errors</description><comments/></buginformation><fixedCommits><commit id="53570863fa77364052937376a0ff65ce2fa37842" author="default" date="2003-09-19 08:16:17"><file name="weaver/src/org/aspectj/weaver/patterns/ReferencePointcut.java"><method name="concretize1" returnType="Pointcut" parameters="ResolvedTypeX IntMap"/></file></commit></fixedCommits></bug><bug id="43" opendate="2003-09-25 18:30:00" fixdate="2003-09-26 05:24:49"><buginformation><summary>structure view crash when extending library aspects</summary><description>I have an library with an aspect that includes advice, which I compile into an 
outjar. In my client project I extend it, and make a concrete pointcut that 
results in the library aspect affecting parts of my system. 

There is a bug and an enhancement request here:

1) A bug: when you look at the structure view for affected classes, there is a 
problem if you try to navigate from calls to advice (in AJDT, it results in an 
NPE). Here is the stack trace in AJDT:
java.lang.NullPointerException
at org.aspectj.asm.internal.ProgramElement.toLinkLabelString
(ProgramElement.java:403)
at org.eclipse.ajdt.internal.core.AJDTStructureViewNode.getLabel
(AJDTStructureViewNode.java:171)
at org.eclipse.ajdt.internal.core.AJDTStructureViewNodeAdapter.getLabel
(AJDTStructureViewNodeAdapter.java:89)
at org.eclipse.ui.model.WorkbenchLabelProvider.getText
(WorkbenchLabelProvider.java:142)
at org.eclipse.jface.viewers.TreeViewer.doUpdateItem(TreeViewer.java:95)
at org.eclipse.jface.viewers.AbstractTreeViewer$UpdateItemSafeRunnable.run
(AbstractTreeViewer.java:87)
at org.eclipse.core.internal.runtime.InternalPlatform.run
(InternalPlatform.java:1006)
at org.eclipse.core.runtime.Platform.run(Platform.java:413)
at org.eclipse.jface.viewers.AbstractTreeViewer.doUpdateItem
(AbstractTreeViewer.java:406)
at org.eclipse.jface.viewers.StructuredViewer$UpdateItemSafeRunnable.run
(StructuredViewer.java:119)
at org.eclipse.core.internal.runtime.InternalPlatform.run
(InternalPlatform.java:1006)
at org.eclipse.core.runtime.Platform.run(Platform.java:413)
at org.eclipse.jface.viewers.StructuredViewer.updateItem
(StructuredViewer.java:1271)
at org.eclipse.jface.viewers.AbstractTreeViewer.createTreeItem
(AbstractTreeViewer.java:320)
at org.eclipse.jface.viewers.AbstractTreeViewer$1.run
(AbstractTreeViewer.java:303)
at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:69)
at org.eclipse.jface.viewers.AbstractTreeViewer.createChildren
(AbstractTreeViewer.java:289)
at org.eclipse.jface.viewers.AbstractTreeViewer.handleTreeExpand
(AbstractTreeViewer.java:697)
at org.eclipse.jface.viewers.AbstractTreeViewer$4.treeExpanded
(AbstractTreeViewer.java:709)
at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:175)
at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:81)
at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:840)
at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:865)
at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:849)
at org.eclipse.swt.widgets.Tree.wmNotifyChild(Tree.java:1909)
at org.eclipse.swt.widgets.Control.WM_NOTIFY(Control.java:3815)
at org.eclipse.swt.widgets.Composite.WM_NOTIFY(Composite.java:642)
at org.eclipse.swt.widgets.Control.windowProc(Control.java:2816)
at org.eclipse.swt.widgets.Display.windowProc(Display.java:2361)
at org.eclipse.swt.internal.win32.OS.CallWindowProcW(Native Method)
at org.eclipse.swt.internal.win32.OS.CallWindowProc(OS.java:1236)
at org.eclipse.swt.widgets.Tree.callWindowProc(Tree.java:156)
at org.eclipse.swt.widgets.Tree.WM_LBUTTONDOWN(Tree.java:1517)
at org.eclipse.swt.widgets.Control.windowProc(Control.java:2799)
at org.eclipse.swt.widgets.Display.windowProc(Display.java:2361)
at org.eclipse.swt.internal.win32.OS.DispatchMessageW(Native Method)
at org.eclipse.swt.internal.win32.OS.DispatchMessage(OS.java:1303)
at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1543)
at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:1402)
at org.eclipse.ui.internal.Workbench.run(Workbench.java:1385)
at org.eclipse.core.internal.boot.InternalBootLoader.run
(InternalBootLoader.java:858)
at org.eclipse.core.boot.BootLoader.run(BootLoader.java:461)
at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
at java.lang.reflect.Method.invoke(Unknown Source)
at org.eclipse.core.launcher.Main.basicRun(Main.java:291)
at org.eclipse.core.launcher.Main.run(Main.java:747)
at org.eclipse.core.launcher.Main.main(Main.java:583)
 

2) The enhancement request: the concrete aspect that applies the advice should 
also show what is affected in the project. Of course, it would also be nice to 
see how a given concrete library aspect in the aspect path affects your 
project too.</description><comments/></buginformation><fixedCommits><commit id="426d89b639c5f64504ff372b849495d75cdc7540" author="default" date="2003-09-26 05:24:49"><file name="asm/src/org/aspectj/asm/internal/ProgramElement.java"><method name="toLinkLabelString" returnType="String" parameters=""/><method name="toSignatureString" returnType="String" parameters=""/></file></commit></fixedCommits></bug><bug id="44" opendate="2003-10-03 01:17:00" fixdate="2003-10-16 15:15:45"><buginformation><summary>NPE on compile</summary><description>java.lang.NullPointerException
at org.aspectj.weaver.AsmRelationshipProvider.checkerMunger
(AsmRelationshipProvider.java:51)
at org.aspectj.weaver.Checker.match(Checker.java:58)
at org.aspectj.weaver.bcel.BcelClassWeaver.match(BcelClassWeaver.java:985)
at org.aspectj.weaver.bcel.BcelClassWeaver.match(BcelClassWeaver.java:791)
at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:291)
at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:77)
at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:417)
at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:390)
at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:316)
at 
org.aspectj.ajdt.internal.core.builder.AjBuildManager.weaveAndGenerateClassFile
s(AjBuildManager.java:256)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild
(AjBuildManager.java:156)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild
(AjBuildManager.java:70)
at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:103)
at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run
(AspectJBuildManager.java:165)</description><comments/></buginformation><fixedCommits><commit id="311725549a379f2bd3c0fcce2aaaae50b7a92ddb" author="default" date="2003-10-16 15:15:45"><file name="weaver/src/org/aspectj/weaver/AsmRelationshipProvider.java"><method name="checkerMunger" returnType="void" parameters="IHierarchy Shadow"/></file></commit></fixedCommits></bug><bug id="45" opendate="2003-09-26 19:36:00" fixdate="2003-10-22 15:24:59"><buginformation><summary>AJDT not very stable when confronted with java/aspect errors.</summary><description>AJDT is not very stable when an eclipse project contains errors like
missing classes, wrong package statements etc. etc. This may occurs when
refactoring a project (sometimes by changing the source outside eclipse).

Note I am using Eclipse 2.1.1, AJDT 1.1.4 + incremental compilation.

Generally a lot of exceptions will occur (mostly nullpointer). Here are some 
of them:

I:
java.lang.NullPointerException
	at org.aspectj.asm.internal.ProgramElement.toLinkLabelString
(ProgramElement.java:403)
	at org.eclipse.ajdt.internal.core.AJDTStructureViewNode.getLabel
(AJDTStructureViewNode.java:171)
	at org.eclipse.ajdt.internal.core.AJDTStructureViewNodeAdapter.getLabel
(AJDTStructureViewNodeAdapter.java:89)
	at org.eclipse.ui.model.WorkbenchLabelProvider.getText
(WorkbenchLabelProvider.java:142)

II:
java.lang.NullPointerException
	at org.eclipse.ajdt.internal.ui.editor.AspectJEditor$1.run
(AspectJEditor.java:242)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)

III:
java.lang.NullPointerException
	at org.aspectj.ajde.internal.CompilerAdapter.compile
(CompilerAdapter.java:79)
	at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run
(AspectJBuildManager.java:165)
!</description><comments/></buginformation><fixedCommits><commit id="3e4b59a6752567468a001c325c47396f5ab6782d" author="default" date="2003-10-22 15:24:59"><file name="ajde/src/org/aspectj/ajde/internal/CompilerAdapter.java"><method name="signalError" returnType="void" parameters="String"/><method name="compile" returnType="boolean" parameters="String BuildProgressMonitor boolean"/><method name="signalWarning" returnType="void" parameters="String"/><method name="compile" returnType="boolean" parameters="String BuildProgressMonitor"/><method name="genBuildConfig" returnType="AjBuildConfig" parameters="String"/></file></commit></fixedCommits></bug><bug id="46" opendate="2004-01-02 00:21:00" fixdate="2004-01-07 13:10:07"><buginformation><summary>No error on overloaded pointcuts unless binding variables</summary><description>The compiler might not be detecting overloaded pointcut names when parameters
are not bound, and/or might not be implementing the pointcut correctly.  Below
is the context from my reply to Ron Bodkin on aspectj-dev "Proper behavior of
overloaded pointcut definitions".  (I have not checked this code recently or
submitted a test case, nor have I evaluated whether my code below actually
replicates Ron's bug.)

---- context from the email
The programming guide says,

  It is an error for two pointcuts to be named with the same
  name in the same class or aspect declaration.

When I compile with overloaded pointcut names, I do get an error.

    pointcut pc(Runnable r) : target(r) &amp;&amp; call(void run());
    pointcut pc(SubRunnable r) : target(r) &amp;&amp; call(void run());

 $ aspectj-1.1.1 -classpath $ajrt11 OverloadedPointcut.java
 ...\OverloadedPointcut.java:14 duplicate pointcut name: pc
 ...\OverloadedPointcut.java:15 duplicate pointcut name: pc

...

When I use these pointcuts with bound parameters, I get an error.

    before(Runnable r) : pc(r) { log("pc(Runnable r)"); }
    before(SubRunnable r) : pc(r) { log("pc(SubRunnable r)"); }

When I use these pointcuts with type parameters, I get no errors.

    before() : pc(Runnable) { log("pc(Runnable)"); }
    before() : pc(SubRunnable) { log("pc(SubRunnable)"); }
    before() : pc(*) { log("pc(*)"); }

[...]

---- my code
public class OverloadedPointcut {
    public static void main(String[] args) {
        new C().run();
    }
}
class C { public void run() {} }

aspect A {
    declare parents: C implements Runnable;
    declare parents: C implements SubRunnable;
    interface SubRunnable extends Runnable {}

    pointcut pc(Runnable r) : target(r) &amp;&amp; call(void run());
    pointcut pc(SubRunnable r) : target(r) &amp;&amp; call(void run());
    before(Runnable r) : pc(r) { log("pc(Runnable r)"); }
    before(SubRunnable r) : pc(r) { log("pc(SubRunnable r)"); }
    before() : pc(Runnable) { log("pc(Runnable)"); }
    before() : pc(SubRunnable) { log("pc(SubRunnable)"); }
    before() : pc(*) { log("pc(*)"); }
    void log(String s) { System.out.println(s); }
} 

---- Ron's code
[...] the following program compiles with no warnings, produces no output when
run under AspectJ 1.1.1.  It appears to behave as if the more specific
definition is the only definition of the pointcut
[...]
Here is a simple program that illustrates the question and odd behavior:

package lib;

public class RunnablePointcuts {
    public pointcut runnableCalls(Runnable runnable, Object caller) :
        call(* run(..)) &amp;&amp; target(runnable) &amp;&amp; this(caller);

    //public pointcut specialRunnableCalls(SpecialRunnable runnable, Object
caller) :
    public pointcut runnableCalls(SpecialRunnable runnable, Object caller) :
        call(* run(..)) &amp;&amp; target(runnable) &amp;&amp; this(caller);
}
---
package lib;

public interface SpecialRunnable extends Runnable {
}
---
package client;

import lib.RunnablePointcuts;
import lib.SpecialRunnable;

public aspect Use {
    before(Object caller) : RunnablePointcuts.runnableCalls(*, caller) &amp;&amp;
target(MyRunnable) {
        System.out.println("my runnable called from "+caller);
    }
    public static void main(String args[]) {
	Use.aspectOf().doIt();
    }
    public void doIt() {
        new MyRunnable().run();
    }
}

// the advice will run if you make this implement SpecialRunnable
//class MyRunnable implements SpecialRunnable {
class MyRunnable implements Runnable {
    public void run() {}
}</description><comments/></buginformation><fixedCommits><commit id="c517e8507cbc0be482d3eb1be2694e3f6486a4e3" author="default" date="2004-01-07 13:10:07"><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectDeclaration.java"><method name="resolve" returnType="void" parameters=""/></file><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java"><method name="resolvePointcutDeclarations" returnType="void" parameters="ClassScope"/></file></commit></fixedCommits></bug><bug id="47" opendate="2003-08-26 05:38:00" fixdate="2004-01-07 17:00:52"><buginformation><summary>XLint warning for call PCD's using subtype of defining type</summary><description>Some would like an XLint compiler warning when the user in a call PCD specifies
a declaring type that is not the defining type, because that constrains the join
points to those whose bytecode signature contain the specified type as the
declaring type.  e.g., 

----
class A { void run() {} }
class B extends A {}
aspect C {
    before() : call(void B.run()) { } // warn here
}
public class Main {
    public static void main(String[] args) {
        // ok with -1.4; otherwise, becomes A.run in bytecode
        new B().run();        
        // never works - compile-time type of reference is A, not B
        ((A) new B()).run();
}
----
This warning is useful for two reasons.  First, the user probably intended that
any call to an instance of that object be picked out (regardless of the
compile-time type of the reference used to make the call), and thus should use

   target(B) &amp;&amp; call(void run())

(This suggestion could be in the XLint message.)

Second, older compilers (i.e., compilers not using -1.4) would incorrectly
specify the declaring type of the method call as the first type in the hierarchy
which defined the method, so even if the user meant to constrain the join point
by the compile-time reference type, the bytecode signature could be incorrect
and the pointcut fail to pick out the join point.

One problem with this XLint warning is that is also picks out valid declare
warning/error statements enforcing requirements at compile-time about the type
of the reference used to invoke a method (e.g., when using a static reference of
the wrong type).  So perhaps the default level should be ignore.

See also  bug 41888 .</description><comments/></buginformation><fixedCommits><commit id="97ab1e91dfba52187c14f0f7e5fdf6fafd9966c4" author="default" date="2004-01-07 17:00:52"><file name="bridge/src/org/aspectj/bridge/MessageUtil.java"><method name="renderMessage" returnType="String" parameters="IMessage boolean"/></file><file name="org.aspectj.ajdt.core/src/org/aspectj/tools/ajc/Main.java"><method name="render" returnType="String" parameters="IMessage"/></file><file name="bridge/src/org/aspectj/bridge/Message.java"><method name="fail" returnType="Message" parameters="String Throwable"/><method name="renderToString" returnType="String" parameters="IMessage"/><method name="toString" returnType="String" parameters=""/></file><file name="bridge/src/org/aspectj/bridge/SourceLocation.java"><method name="toString" returnType="String" parameters=""/></file></commit></fixedCommits></bug><bug id="48" opendate="2004-01-07 12:31:00" fixdate="2004-01-09 09:21:03"><buginformation><summary>exception logging: after() throwing advice can't convert Throwable obj to string and ajc aborts</summary><description>The problem is found by the example in Listing 5.15 from Laddad's AspectJ in
Action book. It looks like an exception object in after() throwing(Throwable ex)
advice has a problem being converted to string in a _logger.logp() call.

Environment
-----------
OS:
Solaris 8 kernel patch level 108528-27 plus j2se recommended patches

Java version:
java -version
java version "1.4.2"
Java(TM) 2 Runtime Environment, Standard Edition (build 1.4.2-b28)
Java HotSpot(TM) Client VM (build 1.4.2-b28, mixed mode)

The problem has also been reproduced with AspectJ 1.1.1 on Windows 2000
5.00.2195, SP 4.

Description
-----------
ajc aborts with the following output:

trouble in: 
public class TestException extends java.lang.Object:
  public static final org.aspectj.lang.JoinPoint$StaticPart ajc$tjp_0
  public static final org.aspectj.lang.JoinPoint$StaticPart ajc$tjp_1
  public void &lt;init&gt;():
                    ALOAD_0     // TestException this   (line 1)
                    INVOKESPECIAL java.lang.Object.&lt;init&gt; ()V
    constructor-execution(void TestException.&lt;init&gt;())
    |               RETURN
    constructor-execution(void TestException.&lt;init&gt;())
  end public void &lt;init&gt;()

  public static void main(String[]):
    method-execution(void TestException.main(java.lang.String[]))
    | method-call(void TestException.perform())
    | | catch java.lang.Throwable -&gt; E0
    | | |           INVOKESTATIC TestException.perform ()V   (line 4)
    | | catch java.lang.Throwable -&gt; E0
    | |             GOTO L0
    | |         E0: ASTORE_1
    | |             INVOKESTATIC ExceptionLoggerAspectV2.aspectOf
()LExceptionLoggerAspectV2;
    | |             ALOAD_1
    | |             GETSTATIC TestException.ajc$tjp_0
Lorg/aspectj/lang/JoinPoint$StaticPart;
    | |             INVOKEVIRTUAL
ExceptionLoggerAspectV2.ajc$after$ExceptionLoggerAspectV2$14a
(Ljava/lang/Throwable;Lorg/aspectj/lang/JoinPoint$StaticPart;)V
    | |             ALOAD_1
    | |             ATHROW
    | |         L0: NOP
    | |             ACONST_NULL
    | |             ASTORE_2
    | |             INVOKESTATIC ExceptionLoggerAspectV2.aspectOf
()LExceptionLoggerAspectV2;
    | |             ALOAD_2
    | |             CHECKCAST java.lang.Throwable
    | |             GETSTATIC TestException.ajc$tjp_0
Lorg/aspectj/lang/JoinPoint$StaticPart;
    | |             INVOKEVIRTUAL
ExceptionLoggerAspectV2.ajc$after$ExceptionLoggerAspectV2$14a
(Ljava/lang/Throwable;Lorg/aspectj/lang/JoinPoint$StaticPart;)V
    | |             NOP
    | method-call(void TestException.perform())
    |               RETURN   (line 5)
    method-execution(void TestException.main(java.lang.String[]))
  end public static void main(String[])

  public static void perform():
    method-execution(void TestException.perform())
    |               ACONST_NULL   (line 8)
    |               ASTORE_0
    |               ALOAD_0     // java.lang.Object nullObj   (line 9)
    | method-call(java.lang.String java.lang.Object.toString())
    | | catch java.lang.Throwable -&gt; E0
    | | |           INVOKEVIRTUAL java.lang.Object.toString ()Ljava/lang/String;
    | | catch java.lang.Throwable -&gt; E0
    | |             GOTO L0
    | |         E0: ASTORE_1
    | |             INVOKESTATIC ExceptionLoggerAspectV2.aspectOf
()LExceptionLoggerAspectV2;
    | |             ALOAD_1
    | |             GETSTATIC TestException.ajc$tjp_1
Lorg/aspectj/lang/JoinPoint$StaticPart;
    | |             INVOKEVIRTUAL
ExceptionLoggerAspectV2.ajc$after$ExceptionLoggerAspectV2$14a
(Ljava/lang/Throwable;Lorg/aspectj/lang/JoinPoint$StaticPart;)V
    | |             ALOAD_1
    | |             ATHROW
    | |         L0: NOP
    | method-call(java.lang.String java.lang.Object.toString())
    |               POP
    |               RETURN   (line 10)
    method-execution(void TestException.perform())
  end public static void perform()
end public class TestException
ABORT
Exception thrown from AspectJ 1.1.1

This might be logged as a bug already -- find current bugs at
   http://bugs.eclipse.org/bugs/buglist.cgi?product=AspectJ&amp;component=Compiler 

Bugs for exceptions thrown have titles File:line from the top stack, 
e.g., "SomeFile.java:243"

If you don't find the exception below in a bug, please add a new bug
at  http://bugs.eclipse.org/bugs/enter_bug.cgi?product=AspectJ 
To make the bug a priority, please include a test program
that can reproduce this exception.
can't convert from java.lang.String to java.lang.Throwable
can't convert from java.lang.String to java.lang.Throwable
org.aspectj.weaver.BCException: can't convert from java.lang.String to
java.lang.Throwable
        at org.aspectj.weaver.bcel.Utility.appendConversion(Utility.java:203)
        at org.aspectj.weaver.bcel.BcelVar.appendLoadAndConvert(BcelVar.java:57)
        at org.aspectj.weaver.bcel.BcelAdvice.getAdviceArgSetup(BcelAdvice.java:287)
        at
org.aspectj.weaver.bcel.BcelAdvice.getAdviceInstructions(BcelAdvice.java:244)
        at
org.aspectj.weaver.bcel.BcelShadow.weaveAfterReturning(BcelShadow.java:986)
        at org.aspectj.weaver.bcel.BcelShadow.weaveAfter(BcelShadow.java:941)
        at org.aspectj.weaver.bcel.BcelAdvice.implementOn(BcelAdvice.java:126)
        at org.aspectj.weaver.Shadow.implementMungers(Shadow.java:341)
        at org.aspectj.weaver.Shadow.implement(Shadow.java:313)
        at
org.aspectj.weaver.bcel.BcelClassWeaver.implement(BcelClassWeaver.java:1006)
        at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:299)
        at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:77)
        at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:417)
        at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:390)
        at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:327)
        at
org.aspectj.ajdt.internal.core.builder.AjBuildManager.weaveAndGenerateClassFiles(AjBuildManager.java:256)
        at
org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:156)
        at
org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:70)
        at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:99)
        at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:53)
        at org.aspectj.tools.ajc.Main.run(Main.java:217)
        at org.aspectj.tools.ajc.Main.runMain(Main.java:155)
        at org.aspectj.tools.ajc.Main.main(Main.java:72)


1 fail|abort

Sample code is two files, TextException.java and ExceptionLoggerAspectV2.java
(see below). To reproduce the problem, do

$ ajc *.java

File 1  - TestException.java
----------------------------
public class TestException 
{
    public static void main(String[] args) {
        perform();
    }

    public static void perform() {
        Object nullObj = null;
        nullObj.toString();
    }
}

File 2 - ExceptionLoggerAspectV2.java
-------------------------------------
import java.util.logging.*;
import org.aspectj.lang.*;

public aspect ExceptionLoggerAspectV2 
{
    Logger _logger = Logger.getLogger("exceptions");

    ExceptionLoggerAspectV2() {
        _logger.setLevel(Level.ALL);
    }

    pointcut exceptionLogMethods()
        : call(* *.*(..)) &amp;&amp; !within(ExceptionLoggerAspectV2);

    after() thowing(Throwable ex) : exceptionLogMethods() {
        if (_logger.isLoggable(Level.WARNING)) {
            Signature sig = thisJoinPointStaticPart.getSignature();
            _logger.logp(Level.WARNING,
                         sig.getDeclaringType().getName(),
                         sig.getName(),
                         "Exception logger aspect", ex);
        }
    }
}</description><comments/></buginformation><fixedCommits><commit id="7b081f2e0bece3414ac4f385cde75d7b54981099" author="default" date="2004-01-09 09:21:03"><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/parser/AjParser.java"><method name="consumeExtraParameterNoFormal" returnType="void" parameters=""/></file></commit></fixedCommits></bug><bug id="49" opendate="2004-01-10 17:46:00" fixdate="2004-01-12 11:37:20"><buginformation><summary>ConfigParser.java:132</summary><description>I have a directory structure such that 

D:\java\aop\benchmark\strategy\aspectj\ca\ubc\ca\spl\pattern\library

exists, and contains source files. The command I issued was

ajc ca\ubc\cs\spl\patterns\library\*.java examples\strategy\aspectj\*.java

The difference is the directory is actually called 'pattern', but I mistyped and
tried to compile in the directory 'patterns'. Here's the output after calling this:

build config error: can't find D:\java\aop\BENCHM~1\strategy\aspectj\ca\ubc\cs\s
pl\patterns\library
ABORT
Exception thrown from AspectJ 1.1.1

This might be logged as a bug already -- find current bugs at
   http://bugs.eclipse.org/bugs/buglist.cgi?product=AspectJ&amp;component=Compiler 

Bugs for exceptions thrown have titles File:line from the top stack,
e.g., "SomeFile.java:243"

If you don't find the exception below in a bug, please add a new bug
at  http://bugs.eclipse.org/bugs/enter_bug.cgi?product=AspectJ 
To make the bug a priority, please include a test program
that can reproduce this exception.
null
java.lang.NullPointerException
        at org.aspectj.util.ConfigParser.addFiles(ConfigParser.java:132)
        at org.aspectj.util.ConfigParser.addFileOrPattern(ConfigParser.java:110)

        at org.aspectj.util.ConfigParser.parseOneArg(ConfigParser.java:194)
        at org.aspectj.util.ConfigParser.parseArgs(ConfigParser.java:157)
        at org.aspectj.util.ConfigParser.parseCommandLine(ConfigParser.java:35)
        at org.aspectj.ajdt.ajc.BuildArgParser.genBuildConfig(BuildArgParser.jav
a:109)
        at org.aspectj.ajdt.ajc.BuildArgParser.genBuildConfig(BuildArgParser.jav
a:88)
        at org.aspectj.ajdt.ajc.AjdtCommand.genBuildConfig(AjdtCommand.java:131)

        at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:89)
        at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:53)
        at org.aspectj.tools.ajc.Main.run(Main.java:217)
        at org.aspectj.tools.ajc.Main.runMain(Main.java:155)
        at org.aspectj.tools.ajc.Main.main(Main.java:72)


1 fail|abort, 1 error</description><comments/></buginformation><fixedCommits><commit id="a4a12342a16145ee4ac835c77827d8e16f6078cb" author="default" date="2004-01-12 11:37:20"><file name="util/src/org/aspectj/util/ConfigParser.java"><method name="addFiles" returnType="void" parameters="File FileFilter"/></file></commit></fixedCommits></bug><bug id="50" opendate="2003-11-07 11:32:00" fixdate="2004-01-14 11:28:13"><buginformation><summary>compiler issues error on inner aspects when privilieged</summary><description>The compiler complains that "inner aspects must be static" whenever I try to 
qualify an inner (and static) aspect as privileged, no matter what the 
enclosing type is (aspect, interface or class).
I was using j2sdk1.4.0_02, AspectJ 1.1, eclipse 2.1 (with AJDT 1.1.3).
Test case:
------------------
BASE CLASS:
public class Capsule {
   private int hidden;
   public int visible;
   public Capsule(int priv, int pub) {
      hidden = priv;
      visible = pub;
   }
   public void doSomething() {
      System.out.println(""" + hidden + ", " + visible + """);
   }
   public static void main(String[] args) {
      Capsule capsule = new Capsule(1, 1);
      capsule.doSomething();
   }
}
------------------
ASPECT:
public aspect Outer {
   static //privileged &lt;== JUST TRY TO UNCOMMENT THIS!
   aspect Inner {
      pointcut call2doSomething(Capsule capsule):
         call(void Capsule.doSomething())
         &amp;&amp; target(capsule);
      before(Capsule capsule): call2doSomething(capsule) {
         capsule.visible++;
         //capsule.hidden++;
      }
   }
}
------------------
INTERFACE:
public interface Marker {
   static //privileged &lt;== JUST TRY TO UNCOMMENT THIS!
   aspect Inner {
      pointcut call2doSomething(Capsule capsule):
         call(void Capsule.doSomething())
         &amp;&amp; target(capsule);
      before(Capsule capsule): call2doSomething(capsule) {
         capsule.visible++;
         //capsule.hidden++;
      }
   }
}</description><comments/></buginformation><fixedCommits><commit id="7bbd1f419239dc9e8b46e7fd912b2bc007bbd76a" author="default" date="2004-01-14 11:28:13"><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/parser/AjParser.java"><method name="consumeAspectHeaderName" returnType="void" parameters="boolean"/></file></commit></fixedCommits></bug><bug id="51" opendate="2003-10-09 13:58:00" fixdate="2004-01-14 15:24:06"><buginformation><summary>Erroneous exception conversion</summary><description>The following code results in an incorrect exception NoClassDefFoundError 
being thrown (and without a stack trace). Here is the output when running 
after compiling with AspectJ from head (and AspectJ 1.1.1):
C:\devel\test\excHandling\interType&gt;java client.Main
Exception in thread "main" java.lang.NoClassDefFoundError
        at client.Main.main(Main.java:6)

AspectJ 1.0.6 doesn't exhibit this problem; it produces the following output:
C:\devel\test\excHandling\interType&gt;java client.Main
Exception in thread "main" java.lang.ExceptionInInitializerError
        at client.Main.main(Main.java;client/ExceptionHandling.java
[1k];library/
LogManager.java[2k]:1004)
Caused by: java.lang.RuntimeException: evil
        at client.ExceptionHandling.doGetLogger_library_LogManager
(ExceptionHand
ling.java;library/LogManager.java[1k]:1009)
        at client.ExceptionHandling.&lt;init&gt;
(ExceptionHandling.java;library/LogMan
ager.java[1k]:1006)
        at client.ExceptionHandling.&lt;clinit&gt;
(ExceptionHandling.java;library/LogM
anager.java[1k]:3)
        ... 1 more

This example is probably related to  bug #44586 .
If you change the after throwing advice in client/ExceptionHandling.java to 
remove the execution OR initialization part, you get similar the following 
output to the AspectJ 1.0.6 case; the exception isn't swallowed.

Here is our test code:
package client;

public aspect ExceptionHandling {
    after() throwing (Throwable t) : execution(* Main.*(..)) || initialization
(Main.new(..)) {
	System.err.println("exception thrown at "+thisJoinPointStaticPart);
	t.printStackTrace(System.err);
    }
}
---
package client;

import library.Loggable;

public aspect LogManager {
    declare parents: client..* implements Loggable;
}
---
package client;

public class Main {
    public static void main(String args[]) {
	new Main();
    }
}
---
package library;

import java.util.logging.Logger;

public aspect LogManager {
    private Logger Loggable.logger = doGetLogger();
    public Logger Loggable.getLogger() { return logger; }
    private Logger Loggable.doGetLogger() {
	throw new RuntimeException("evil");
	//return Logger.getLogger("main");
    }
}
---
package library;

public interface Loggable {}</description><comments/></buginformation><fixedCommits><commit id="5834de97836ebcc056415736c17c46e8b1dfaf5a" author="default" date="2004-01-14 15:24:06"><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectClinit.java"><method name="generatePostSyntheticCode" returnType="void" parameters=""/><method name="generateSyntheticCode" returnType="void" parameters=""/></file><file name="weaver/src/org/aspectj/weaver/AjcMemberMaker.java"><method name="noAspectBoundExceptionInit" returnType="Member" parameters=""/></file><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectDeclaration.java"><method name="generateCode" returnType="void" parameters="ClassFile"/><method name="generate" returnType="void" parameters="CodeStream"/><method name="canBeSeenBy" returnType="boolean" parameters=""/></file><file name="tests/new/ConstructorExecInitFails.java"><method name="main" returnType="void" parameters="String[]"/></file><file name="weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"><method name="match" returnType="void" parameters=""/><method name="matchSetInstruction" returnType="void" parameters=""/><method name="matchGetInstruction" returnType="void" parameters="LazyMethodGen InstructionHandle BcelShadow List"/></file></commit></fixedCommits></bug><bug id="52" opendate="2003-06-12 05:35:00" fixdate="2004-01-14 15:51:53"><buginformation><summary>Anomalous handling of inter-type declarations to abstract base classes in aspectj 1.1</summary><description>Version 1.1 of aspectj does not handle correctly inter-type declarations to
abstract base classes.

This appears when the following pattern is present in the code:

Suppose there is an interface InterfaceA, another interface InterfaceB and a
third interface InterfaceC extending InterfaceA and InterfaceB and containing
some method declarations of its own. 

Suppose also there is an aspect AConcretisingAspect that contains inter-type
declarations providing default implementations for all InterfaceC's methods
(both own and inherited).

Now suppose we have a class hierarchy emanating from an abstract class
BaseClass, and an aspect BaseClassAspect declaring that BaseClass implements
InterfaceC:

aspect BaseClassAspect {
     declare parents: BaseClass implements InterfaceC;
}

Unfortunately, during compilation iajc complains for each offspring of BaseClass
that it does not implement any of the abstract methods of InterfaceA and
InterfaceB (but not of InterfaceC's own!).

This does not happen when BaseClass is not abstract; and it does not occur in
version 1.0.6 of aspectj.</description><comments/></buginformation><fixedCommits><commit id="0071cb4d0f30fc95f335eb6df73ad09e92d662ed" author="default" date="2004-01-14 15:51:53"><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/problem/AjProblemReporter.java"><method name="abstractMethodMustBeImplemented" returnType="void" parameters=""/></file><file name="weaver/src/org/aspectj/weaver/ResolvedTypeX.java"><method name="getInterTypeMungersIncludingSupers" returnType="List" parameters=""/></file></commit></fixedCommits></bug><bug id="53" opendate="2003-12-03 00:43:00" fixdate="2004-01-15 05:21:33"><buginformation><summary>SoftException.printStackTrace(..) should print wrapped throwable too</summary><description>SoftExceptions should print not only their trace but also that of the wrapped
throwable.

We should be able to set a flag on class initialization whether we are running
under 1.4 and then implement it under 1.4 using initCause() and otherwise by
direct delegation.  I can do this fix if we're agreed.</description><comments/></buginformation><fixedCommits><commit id="ad2fb7a583f7451f3101f8101b090999d6a43341" author="default" date="2004-01-15 05:21:33"><file name="runtime/testsrc/RuntimeModuleTests.java"><method name="testNoAspectBoundException" returnType="void" parameters=""/><method name="testNothing" returnType="void" parameters=""/></file></commit></fixedCommits></bug><bug id="54" opendate="2003-04-08 14:04:00" fixdate="2004-01-15 11:43:14"><buginformation><summary>out of memory error when compiling</summary><description>Getting an out of memory error when compiling with Ajc 1.1 RC1. 
I know this is not very descriptive, but maybe you can point me into a 
direction of getting more output.

here some additional information though:
Code base is medium size (about 1500 classfiles)
I removed all my aspects and still receive the error.
Running it from the command line: ajc -classpath whateveritis -sourceroots 
whateveritis -d whateveritis</description><comments/></buginformation><fixedCommits><commit id="b3b1eecf938fdc9d0bd8f954bc05ec38763299fb" author="default" date="2004-01-15 11:43:14"><file name="org.aspectj.ajdt.core/src/org/aspectj/tools/ajc/Main.java"><method name="runMain" returnType="void" parameters="String[] boolean"/></file></commit></fixedCommits></bug><bug id="55" opendate="2004-01-19 06:01:00" fixdate="2004-01-22 10:55:43"><buginformation><summary>aspectjrt.jar manifest file name needs changing to upper case</summary><description>The name of the aspectjrt.jar's manifest file should be changed from 

META-INF/manifest.mf

to 

META-INF/MANIFEST.MF

According to the Jar file specification (see  http://java.sun.com/products/jdk/1 .
2/docs/guide/jar/manifest.html) the name of the manifest file needs to be all 
upper case. It's beyond trivial, I know, but it does cause an unnecessary 
warning in at least one popular IDE for J2EE development (IBM WebSphere Studio)
when the aspectjrt.jar is packaged in an EAR file.

If there was an option to assign this a "very, very trivial" severity level I 
would.</description><comments/></buginformation><fixedCommits><commit id="6f099df282f6d4994e09e457132677de7194c471" author="default" date="2004-01-22 10:55:43"><file name="build/src/org/aspectj/internal/tools/ant/taskdefs/AntBuilder.java"><method name="assemble" returnType="boolean" parameters="Module File List"/></file></commit></fixedCommits></bug><bug id="56" opendate="2003-12-04 10:54:00" fixdate="2004-01-23 10:03:14"><buginformation><summary>Complete relationship information in the structure model</summary><description>Complete the set of relationships surfaced by the structure model (e.g. 
including support for declare parents etc.) - Mik you had a document listing the 
things yet to be done here?</description><comments/></buginformation><fixedCommits><commit id="f24286d65906e4fca5e2872ca1fa8295c1ab6bc7" author="default" date="2004-01-23 10:03:14"><file name="weaver/src/org/aspectj/weaver/bcel/BcelWorld.java"><method name="getPathEntries" returnType="List" parameters="String"/></file><file name="weaver/src/org/aspectj/weaver/Shadow.java"><method name="implementMungers" returnType="void" parameters=""/></file><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"><method name="initBcelWorld" returnType="void" parameters="IMessageHandler"/></file><file name="weaver/src/org/aspectj/weaver/Checker.java"><method name="match" returnType="boolean" parameters="Shadow World"/></file></commit></fixedCommits></bug><bug id="57" opendate="2003-12-04 12:18:00" fixdate="2004-01-24 02:28:54"><buginformation><summary>Lazy instantiation of thisJoinPoint</summary><description>In cases where the body of advice refers to a non-statically evaluable portion 
of thisJoinPoint (so that it can't be optimized by the compiler to 
thisJoinPointStaticPart), the JoinPoint object is currently always created 
before entering the advice body - even if the JoinPoint object would never 
actually be accessed (because of a test within the advice for example). Since
a) thisJoinPoint is often used in tracing applications
b) tracing applications tend to be very pervasive,
c) they must have low overhead when tracing is disabled, and 
d) creation of thisJoinPoint objects is expensive (v. expensive compared to just 
testing a flag)
it would be nice if there was a way to create JoinPoint objects lazily on first 
actual reference within the advice body.</description><comments/></buginformation><fixedCommits><commit id="0c833438dadeeb26659cd901870d18d2c103658b" author="default" date="2004-01-24 02:28:54"><file name="org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/AjdtBatchTests.java"><method name="suite" returnType="Test" parameters=""/></file><file name="weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java"><method name="getAdviceArgSetup" returnType="InstructionList" parameters=""/><method name="specializeOn" returnType="void" parameters="Shadow"/></file><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java"><method name="parseOption" returnType="void" parameters="String LinkedList"/></file><file name="runtime/src/org/aspectj/runtime/reflect/Factory.java"><method name="makeJP" returnType="JoinPoint" parameters="JoinPoint.StaticPart"/></file><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"><method name="initBcelWorld" returnType="void" parameters="IMessageHandler"/></file><file name="org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/CommandTestCase.java"><method name="checkCompile" returnType="void" parameters="String int[]"/></file></commit></fixedCommits></bug><bug id="58" opendate="2004-01-25 11:47:00" fixdate="2004-01-28 01:12:17"><buginformation><summary>CatchClauseSignature has broken operation</summary><description>It looks like the getParameterName() operation on org.aspectj.lang.reflect.
CatchClauseSignature is not working. Instead of returning the name of the 
exception as declared in the matched handler, returns the string value 
"&lt;missing&gt;".

Here is a test case that shows the problem :-

------START OF TEST CASE CODE-----------

public class MyApp {

    public void doSomething() {
        // Get around "unreachable code error...
        if (true)
        {
            throw new BusinessException("Surprise!!");
        }
        System.out.println("Busy doing something.");
    }

    public static void main(String[] args) {
        try {
            MyApp m = new MyApp();
            m.doSomething();
        } catch (BusinessException be) {
            System.out.println("Exception caught : " + be.getMessage()); 
        }
    }
}

class BusinessException extends RuntimeException {
    BusinessException(String message) {
        super(message);
    }
}

aspect AppMonitor {
    pointcut problemHandling() : handler(Throwable+);

    before() : problemHandling() {
        CatchClauseSignature cSig =
            (CatchClauseSignature) thisJoinPointStaticPart.getSignature();

        System.out.println(
            "MONITOR::\tCaught a "
                + cSig.getParameterType().getName()
                + " called "
                + cSig.getParameterName());
    }
}

------END OF TEST CASE CODE-----------

The output from running the above was ...

MONITOR::	Caught a BusinessException called &lt;missing&gt;
Exception caught : Surprise !!!!

Operating system : Windows XP
AspectJ : 1.1.1 final and also on latest from CVS HEAD</description><comments/></buginformation><fixedCommits><commit id="19bac866e44563dad29b6bebefa31c4e354ee96c" author="default" date="2004-01-28 01:12:17"><file name="weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"><method name="makeExceptionHandler" returnType="BcelShadow" parameters=""/></file><file name="weaver/src/org/aspectj/weaver/Member.java"><method name="makeExceptionHandlerSignature" returnType="Member" parameters="TypeX TypeX"/></file></commit></fixedCommits></bug><bug id="59" opendate="2003-10-24 06:34:00" fixdate="2004-02-19 16:02:06"><buginformation><summary>Structure model is wrong when re-opened</summary><description>Some elements have the wrong kinds when a saved structure model is loaded.  
E.g. if I close then re-open the eclipse workbench classes are shown as 
interface in the outline view.  Also if I traverse the tree with the code 
below I get the wrong kinds assigned to classed, interfaces, aspects and 
import declarations.

List list = StructureModelUtil.getPackagesInModel();
for(Iterator i = list.iterator(); i.hasNext();){
    Object[] o = (Object[])i.next();
    IProgramElement node = (IProgramElement)o[0];
List files = StructureModelUtil.getFilesInPackage(node);
			for(Iterator i2 = files.iterator(); i2.hasNext();){
				IProgramElement file = (IProgramElement)i2.next
();
				System.out.println("file " + file.getKind
().toString() + ", " + file.getName());
				boolean added2 = false;
				
				List file_children = file.getChildren();
					// file children can be classes, 
aspects or other things
				for(Iterator i3 = file_children.iterator(); 
i3.hasNext();){
					IProgramElement file_child = 
(IProgramElement)i3.next();
					System.out.println("kind: " + 
file_child.getKind().toString() +", " + file_child.getName());</description><comments/></buginformation><fixedCommits><commit id="669cd7ce8634623c004cca5732c94a20fd7f57f7" author="default" date="2004-02-19 16:02:06"><file name="ajde/testsrc/org/aspectj/ajde/AjdeTests.java"><method name="suite" returnType="Test" parameters=""/></file><file name="asm/src/org/aspectj/asm/IProgramElement.java"><method name="readResolve" returnType="Object" parameters=""/></file></commit></fixedCommits></bug><bug id="60" opendate="2004-02-12 21:13:00" fixdate="2004-02-19 22:09:16"><buginformation><summary>Advice calling protected super method causing java.lang.VerifyError 'Bad access to protected data'</summary><description>A java.lang.VerifyError is thrown at runtime complaining about 'Bad access to  
protected data' when advice, on a sub-aspect, that calls a protected method, on  
the super-aspect, is woven into a class. 
However another call to the same method woven into the same class but due to  
advice declared in the super-aspect works fine. 
 
The aspects were woven into precompiled (by sun's 1.4 javac) classes. 
The verify error occurs under both sun's 1.4 and blackdowns 1.3 VMs, and presumably 
all VMs. 
 
Workaround: 
Making the protected method public fixes the verify error. 
 
A test case is available in CVS: 
tests/bugs/protectedvf/... 
tests/ajcTestFailing.xml</description><comments/></buginformation><fixedCommits><commit id="6ddae42579ceb781831e08f0fcf77a4ff4ffb5c0" author="default" date="2004-02-19 22:09:16"><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AccessForInlineVisitor.java"><method name="endVisit" returnType="void" parameters="FieldReference BlockScope"/><method name="endVisit" returnType="void" parameters="QualifiedNameReference BlockScope"/><method name="endVisit" returnType="void" parameters="MessageSend BlockScope"/><method name="getAccessibleMethod" returnType="MethodBinding" parameters="MethodBinding"/><method name="getAccessibleField" returnType="FieldBinding" parameters="FieldBinding"/><method name="endVisit" returnType="void" parameters="SingleNameReference BlockScope"/></file><file name="tests/bugs/protectedvf/main/Driver.java"><method name="doOtherStuff" returnType="void" parameters=""/><method name="doStuff" returnType="void" parameters=""/></file><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"><method name="makeResolvedMember" returnType="ResolvedMember" parameters="MethodBinding"/><method name="makeResolvedMember" returnType="ResolvedMember" parameters="FieldBinding"/></file></commit></fixedCommits></bug><bug id="61" opendate="2003-04-13 03:35:00" fixdate="2004-02-24 13:43:56"><buginformation><summary>Support -Xreweavable option</summary><description>Adding a RFE as Wes suggested...

Wes' reply:
There are some issues with the -Xnoweave option that we won't
have the time to carefully resolve for 1.1, even though, 
as you suggest, there may be times when it would be useful.

The workaround at present is to weave tracing into transactions 
when the transactions jar is compiled. e.g.,

-- do the build
  ajc @tracing.lst -outjar tracing.jar
  ajc @transactions.lst -aspectpath tracing.jar \
      -outjar transactions.jar
  ajc @app.lst -aspectpath "tracing.jar;transactions.jar" \
      -outjar app.jar
-- build the jar
  mkdir final
  cd final
  jar xf ../tracing.jar
  jar xf ../transactions.jar
  jar xf ../app.jar
  # fixup manifest, etc?
  jar cf ../final.jar *

What if you don't have the sources for the transactions.jar?
This is a case of getting binary transactions aspects from a 
vendor who won't provide source and wanting to weave your 
tracing into it.  I would hope that by the time that problem 
becomes prevalent, we will have a solution for it.

If you'd like to keep this on the radar, please submit this
discussion as an RFE for the compiler at

   http://dev.eclipse.org/bugs/enter_bug.cgi?product=AspectJ 

Thank you -
Wes

P.S. - Personally, I think this case

 &gt; &gt; ajc -injars app.jar;transaction.jar
&gt;       -aspectpath transaction.jar;tracing.jar 

doesn't make sense.  Things on the aspectpath are defined,
whereas things in injars will be woven into and redefined.
It's not clear from this command which variant the user 
expects when refering to a type in transactions.jar.

Ramnivas Laddad wrote:
 &gt; 
&gt; Hello,
&gt; 
&gt; I think I have a use case that cannot be implemented
&gt; (at least elegantly, anyway) without noweave/XnoWeave
&gt; option (and thus I request to make it a regular option
&gt; instead of experimental -X).
&gt; 
&gt; Basically, I want to have my tracing.jar (
&gt; contains tracing aspect) weave into transaction.jar
&gt; (contains abstract transaction mangement aspects,
&gt; concrete policy enforcement aspects, and supporting
&gt; classes). Assume app.jar contain business classes
&gt; and interfaces. Each of the jar is created using
&gt; -ourjar (but not -noweave or -XnoWeave).
&gt; 
&gt; To build the final system I issue the following
&gt; command:
&gt; &gt; ajc -injars app.jar;transaction.jar
&gt;       -aspectpath transaction.jar;tracing.jar
&gt; 
&gt; Now compiler gives me error due to multiply woven
&gt; classes and aspects in transaction.jar.
&gt; 
&gt; Everything works fine if I create the original jar
&gt; files using -noweave.
&gt; 
&gt; I could workaround by creating multiple jars, but
&gt; I hink -noweave is the right approach as
&gt; I really don't want to ship multiple jars that are
&gt; needed to implement a single concern and expect the
&gt; users to correctly specify jar files in -injars
&gt; and -aspectpath.
&gt; 
&gt; -Ramnivas</description><comments/></buginformation><fixedCommits><commit id="16a0abd70e5fe2538c32994de05f52b6bf939ef5" author="default" date="2004-02-24 13:43:56"><file name="ajde/testsrc/org/aspectj/ajde/AjdeTests.java"><method name="suite" returnType="Test" parameters=""/></file></commit></fixedCommits></bug><bug id="62" opendate="2004-02-07 12:26:00" fixdate="2004-02-25 11:14:32"><buginformation><summary>ClasscastException on concretization of if(false)</summary><description>I get the following exception when weaving the attached aspect on the dev build.

java.lang.ClassCastException
	at org.aspectj.weaver.patterns.IfPointcut.concretize1(IfPointcut.java:156)
	at org.aspectj.weaver.patterns.IfPointcut.concretize(IfPointcut.java:143)
	at org.aspectj.weaver.patterns.Pointcut.concretize(Pointcut.java:119)
	at org.aspectj.weaver.Checker.concretize(Checker.java:35)
	at org.aspectj.weaver.CrosscuttingMembers.
addShadowMunger(CrosscuttingMembers.java:78)
	at org.aspectj.weaver.CrosscuttingMembers.addDeclare(CrosscuttingMembers.
java:102)
	at org.aspectj.weaver.CrosscuttingMembers.addDeclares(CrosscuttingMembers.
java:92)
	at org.aspectj.weaver.CrosscuttingMembersSet.
addAdviceLikeDeclares(CrosscuttingMembersSet.java:65)
	at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.
addAdviceLikeDeclares(AjLookupEnvironment.java:147)
	at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.
completeTypeBindings(AjLookupEnvironment.java:122)
	at org.eclipse.jdt.internal.compiler.Compiler.beginToCompile(Compiler.java:
300)
	at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:314)
	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.
performCompilation(AjBuildManager.java:384)
	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.
doBuild(AjBuildManager.java:125)
	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.
batchBuild(AjBuildManager.java:70)
	at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:104)
	at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:53)
	at org.aspectj.tools.ajc.Main.run(Main.java:234)
	at org.aspectj.tools.ajc.Main.runMain(Main.java:170)
	at org.aspectj.tools.ajc.Main.main(Main.java:81)</description><comments/></buginformation><fixedCommits><commit id="fbc0aa305ea367e5fbeb99acf9907ae3a155f16a" author="default" date="2004-02-25 11:14:32"><file name="weaver/src/org/aspectj/weaver/patterns/ArgsPointcut.java"><method name="concretize1" returnType="Pointcut" parameters="ResolvedTypeX IntMap"/></file><file name="weaver/src/org/aspectj/weaver/patterns/IfPointcut.java"><method name="concretize1" returnType="Pointcut" parameters="ResolvedTypeX IntMap"/></file><file name="weaver/src/org/aspectj/weaver/patterns/CflowPointcut.java"><method name="concretize1" returnType="Pointcut" parameters="ResolvedTypeX IntMap"/></file><file name="weaver/src/org/aspectj/weaver/patterns/ThisOrTargetPointcut.java"><method name="concretize1" returnType="Pointcut" parameters="ResolvedTypeX IntMap"/></file></commit></fixedCommits></bug><bug id="63" opendate="2004-02-18 13:35:00" fixdate="2004-03-04 16:09:34"><buginformation><summary>inter-type declarations cause JRockit Crash</summary><description>BEA's JRockit JVM (version:
8.1sp2-1.4.1_05-Load10-viking-win32-sthqa29-20031105-1554) crashes on simple
inter-type declarations. (Obviously I have also submitted this bug to BEA, but
the AJ team may be able to shed some light on what is going on and where (if
anywhere) BEA's JVM is behaving wrong.)

The cannonical example lies below:

public class SimpleClass {
    public static void main(String[] args) {
        SimpleClass simple = new SimpleClass();
    }
}

public aspect SimpleAspect {
    public int SimpleClass.foo;
}

When running SimpleClass I get a JVM crash with the following thread stack trace.

Thread Stack Trace:
    at _exprPush+112 ()@0082FF70
    at COM.jrockit.vm.RNI.toNative(Native Method)@32520000
    at COM.jrockit.vm.RNI.clinitTrampoline(Native Method)@325200FA
    at com.vms.adbase.jvmcrashtest.SimpleClass.&lt;init&gt;(SimpleClass.java:4)@344B0055
    at com.vms.adbase.jvmcrashtest.SimpleClass.main(SimpleClass.java:6)@344B0034
    --- End of stack trace

Feel free to ask me for further details. JRockit can be downloaded at:
 http://commerce.bea.com/showallversions.jsp?family=WLJR . I reproduced this error
on Windows XP, but it also happend on RedHat.

Is it worth adding JRockit to AspectJ's compatibility test suite?</description><comments/></buginformation><fixedCommits><commit id="5d73494d7d222b92cdbb19f860f9215a07430681" author="default" date="2004-03-04 16:09:34"><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectClinit.java"><method name="generatePostSyntheticCode" returnType="void" parameters=""/></file><file name="weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"><method name="isInitFailureHandler" returnType="boolean" parameters="InstructionHandle"/></file></commit></fixedCommits></bug><bug id="64" opendate="2003-10-07 00:05:00" fixdate="2004-03-15 17:27:56"><buginformation><summary>retitle warning to "circular {advice} dependency at ..."</summary><description>When writing aspects with cycles in the advice precedence, get warning "circular
dependency at {join point}" -- should be "circular advice dependency..." or
"circular advice precedences at {join point} -- reorder the advice in the aspect".

FWIW, here's an example of circularity in advice precedence:
----
aspect A {
    pointcut crun() : execution (void run()) ;
    before() : crun() {}
    after() returning : crun() {}
    void around() : crun() { proceed(); }
}
----

See programming guide for more discussion of circularity in advice precedence.</description><comments/></buginformation><fixedCommits><commit id="01095341153b24fcf5ab5f537ecc77077819b1f1" author="default" date="2004-03-15 17:27:56"><file name="weaver/src/org/aspectj/weaver/patterns/DeclarePrecedence.java"><method name="resolve" returnType="void" parameters="IScope"/></file><file name="weaver/src/org/aspectj/weaver/Shadow.java"><method name="sortMungers" returnType="void" parameters=""/></file></commit></fixedCommits></bug><bug id="65" opendate="2004-03-16 10:08:00" fixdate="2004-03-16 15:07:19"><buginformation><summary>Incremental compilation does twice as much work as necessary</summary><description>When I added support for -outjar in the test harness, I was surprised to find 
duplicate entry exceptions coming from the output file writing to the outjar. I 
traced it through, and found that every source file passed to an incremental 
compile is in fact compiled twice!

The first time round we note the references, and of course each file has a 
reference to itself. Then we call "AjState.getFilesToCompile" looking to see if 
there are any further files to compile in another iteration. This method does 
not remember the set of files it just compiled, so since we have referenced each 
type we just compiled, and we have no reord of that fact, we compile them again. 
Second time around, the bytecodes are identical to the previous go, so 
recordClassFile doesn't note their dependents - and thus this time we terminate.</description><comments/></buginformation><fixedCommits><commit id="41c6f6d0a10e881ac705a108cdd59f31d160e1c7" author="default" date="2004-03-16 15:07:19"><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java"><method name="addAffectedSourceFiles" returnType="void" parameters="List"/><method name="prepareForNextBuild" returnType="boolean" parameters="AjBuildConfig"/><method name="getFilesToCompile" returnType="List" parameters="boolean"/></file></commit></fixedCommits></bug><bug id="66" opendate="2004-03-12 09:43:00" fixdate="2004-03-16 15:16:46"><buginformation><summary>Incremental support does not work with outjar</summary><description>Either fix the class file deleting etc. to work with jars, or always do a batch 
build when working with outjars.</description><comments/></buginformation><fixedCommits><commit id="1a4c02c986332c37aa1d1e86867b2434892eb11f" author="default" date="2004-03-16 15:16:46"><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java"><method name="prepareForNextBuild" returnType="boolean" parameters="AjBuildConfig"/></file></commit></fixedCommits></bug><bug id="67" opendate="2003-12-02 13:35:00" fixdate="2004-03-17 12:25:49"><buginformation><summary>ajc -outjar jarfile does not contain MANIFEST.MF</summary><description>I call ajc -sourceroots &lt;mydir&gt; -outjar &lt;my.jar&gt; and an output file is created 
with a .jar extension, but it is not a valid jar file because there is no 
MANIFEST.MF file. I see that the text for ajc says:

-outjar &lt;file&gt;      put output classes in zip file &lt;file&gt;

which might imply that it is supposed to be a zip file, but a parameter called -
outjar which creates a zip file doesn't really make sense. If -outjar is used, 
the resulting file should be a valid jar file, i.e. with a META-INF/MANIFEST.MF 
file inside.</description><comments/></buginformation><fixedCommits><commit id="34dbb0c41b3e324e3c7fc5a150c314fbecfd5e6e" author="default" date="2004-03-17 12:25:49"><file name="ajde/testsrc/org/aspectj/ajde/AjdeTests.java"><method name="suite" returnType="Test" parameters=""/></file><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"><method name="copyResourcesFromJarFile" returnType="void" parameters="File"/><method name="copyResourcesToDestination" returnType="void" parameters=""/><method name="openOutputStream" returnType="boolean" parameters="File"/><method name="writeResource" returnType="void" parameters="String byte[] File"/></file><file name="ajde/testsrc/org/aspectj/ajde/InpathTestcase.java"><method name="fetchFromJar" returnType="int" parameters="File String"/><method name="compareSourceToOutjar" returnType="void" parameters="String File"/><method name="compareJars" returnType="void" parameters=""/></file><file name="weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java"><method name="addLibraryJarFile" returnType="void" parameters="File"/><method name="addJarFile" returnType="List" parameters="File File boolean"/></file><file name="ajde/testsrc/org/aspectj/ajde/ResourceCopyTestCase.java"><method name="compareSourceToOutjar" returnType="void" parameters="String File"/></file></commit></fixedCommits></bug><bug id="68" opendate="2003-07-16 06:57:00" fixdate="2004-03-18 13:00:01"><buginformation><summary>build cancel during weaving</summary><description>The build can not be cancelled during the bytecode weaving stage.</description><comments/></buginformation><fixedCommits><commit id="183fc23883289ae42854ce9afcf2d3b0d29b7599" author="default" date="2004-03-18 13:00:01"><file name="ajde/testsrc/org/aspectj/ajde/AjdeTests.java"><method name="suite" returnType="Test" parameters=""/></file></commit></fixedCommits></bug><bug id="69" opendate="2004-03-17 14:09:00" fixdate="2004-03-18 14:36:58"><buginformation><summary>Incremental compilation does not delete weaver-generated class files</summary><description>During incremental compilation, AjState records classes generated from source 
files following the initial compile phase, but before weaving. (So that these 
can be passed to the weaver on a subsequent iteration if we need to reweave the 
world). During weaving of a given class file, the weaver may generate additional 
class files (for e.g. around closures) that get written to the output. If the 
orginal source file is deleted, these additional weaver generated classes are 
not deleted from the output since AjState does not know about them.</description><comments/></buginformation><fixedCommits><commit id="7d6b500be325633c3057abaf973b8c56464d6706" author="default" date="2004-03-18 14:36:58"><file name="weaver/src/org/aspectj/weaver/bcel/UnwovenClassFile.java"><method name="toString" returnType="String" parameters=""/><method name="deleteRealFile" returnType="void" parameters=""/></file></commit></fixedCommits></bug><bug id="70" opendate="2004-02-24 19:43:00" fixdate="2004-03-19 09:28:14"><buginformation><summary>declare precedence on a class should be a compile-time error</summary><description>The compiler silently accepts

----
public class DeclarePrecedence {
public static void main(String[] args) {
    System.out.println("hello");
}
}
aspect DP {
    declare precedence: DeclarePrecedence, DP;
    before() : staticinitialization(DeclarePrecedence) {
        System.out.println("ok"); 
    }
}
----

Since this is likely to be a mistake, an error would be nice.  However, that
would mean saying (!TargetClass &amp;&amp; TargetClass+) to pick out the aspect subtypes
of TargetClass.</description><comments/></buginformation><fixedCommits><commit id="0a017593dcbeab409c1634da87b3f500b848e903" author="default" date="2004-03-19 09:28:14"><file name="weaver/src/org/aspectj/weaver/patterns/DeclarePrecedence.java"><method name="resolve" returnType="void" parameters="IScope"/></file></commit></fixedCommits></bug><bug id="71" opendate="2003-02-10 10:35:00" fixdate="2004-04-02 12:03:40"><buginformation><summary>Weaving class loader</summary><description>Hi!

As discussed on the mailing list a few days ago I implemented a weaving class
loader to enable bytecode based weaving at class loading time. The class loader
is based on the URLClassLoader and can be used like any other URLClassLoader. In
addition to that you can add aspects to the weaving loader. These aspects got
woven into each class that is loaded. The test cases for the class loader aren't
implemented yet, I am still thinking about how to implement them. I will
contribute them later, okay?

-Martin</description><comments/></buginformation><fixedCommits><commit id="33d8ee9eededcd1219a6cbd1d063af005d40a3f7" author="default" date="2004-04-02 12:03:40"><file name="org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/BcweaverJarMaker.java"><method name="main" returnType="void" parameters="String[]"/></file></commit></fixedCommits></bug><bug id="72" opendate="2004-03-19 04:32:00" fixdate="2004-04-02 12:45:13"><buginformation><summary>error Type mismatch: cannot convert from java.lang.String to java.lang.String</summary><description>When compiling a binary concrete aspect library (for later LTW) consisting of
more than one aspect that performs an ITD on a target class not exposed to the 
weaver I get the following error:

error Type mismatch: cannot convert from java.lang.String to java.lang.String

The error does not oocur if a complete build &amp; weave is performed. Testcase 
attached.</description><comments/></buginformation><fixedCommits><commit id="0521e79aea0550b1357a7ccc6a5050f8ce27ce9b" author="default" date="2004-04-02 12:45:13"><file name="org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/BcweaverJarMaker.java"><method name="makeTestJars" returnType="void" parameters=""/><method name="makeURLWeavingClassLoaderJars" returnType="void" parameters=""/></file><file name="weaver/testsrc/org/aspectj/weaver/WeavingURLClassLoaderTest.java"><method name="testWeavingAspects" returnType="void" parameters=""/><method name="testWeavingITD" returnType="void" parameters=""/></file></commit></fixedCommits></bug><bug id="73" opendate="2004-04-05 04:58:00" fixdate="2004-04-07 09:07:43"><buginformation><summary>exception printing</summary><description>Exceptions thrown from the compiler used to be printed once, with the submit-bug
header.  Now they are printed twice, without and with the header.  True of CVS
version.</description><comments/></buginformation><fixedCommits><commit id="e7ac54fae25b797a0d3609350a27330bea302fb9" author="default" date="2004-04-07 09:07:43"><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/AjCompilerAdapter.java"><method name="afterCompiling" returnType="void" parameters=""/></file></commit></fixedCommits></bug><bug id="74" opendate="2004-04-05 05:42:00" fixdate="2004-04-08 10:46:58"><buginformation><summary>Java 1.5 fails to run classes produced by ajc</summary><description>Java 1.5 beta reports a ClassFormatError when running programs (e.g., spacewar)
compiled by ajc 1.1.1 and the latest CVS head.  Sun's Java 1.5 beta
binary-compatibility docs say that some obfuscators violated the .class format
specification, so those .class files will fail when run under 1.5.  (The docs
also say they are still incomplete.)  

Although 1.5 is still beta, we would want to submit a bug to Sun if our
implementation techniques are valid, so we don't have to change those
techniques.  For 1.2, we should at document if we don't fix, since many people
are using 1.5.</description><comments/></buginformation><fixedCommits><commit id="b0d32cafba6241023d1efdc343a2744a5e25a00d" author="default" date="2004-04-08 10:46:58"><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectDeclaration.java"><method name="generateMethod" returnType="void" parameters="ClassFile MethodBinding"/></file></commit></fixedCommits></bug><bug id="75" opendate="2004-04-22 05:11:00" fixdate="2004-04-23 16:24:27"><buginformation><summary>Null pointer exception while weaving java.awt.Label</summary><description>I tried to add an Aspect to java.awt.Label. I compile the aspect via:
ajc -inpath /usr/local/j2sdk_nb/j2sdk1.4.2/jre/lib/rt.jar Timestamp.java

Here is the aspect Timestamp.java:

aspect Timestamp {

    private int java.awt.Label._ts_read = 0;
    private int java.awt.Label._ts_write = 0;

    pointcut writeOp():
    call (void java.awt.Label.setText (String));

    pointcut readOp():
    call (String java.awt.Label.getText());
	
    after (java.awt.Label b) returning: readOp() &amp;&amp; target (b)
    {
	b._ts_read++;
    }
    
    after (java.awt.Label b) returning: writeOp() &amp;&amp; target (b)
    {
	b._ts_write++;
	System.out.println (b._ts_write);
    }

    public static void main (String[] args)
    {
	java.awt.Label b1 = new java.awt.Label();
	b1.setText ("abc");
    }
}

Here is the error message I get from ajc:

null
java.lang.NullPointerException
        at
org.aspectj.ajdt.internal.core.builder.EclipseAdapterUtils.makeLocationContext(EclipseAdapterUtils.java:50)
        at
org.aspectj.ajdt.internal.core.builder.EclipseAdapterUtils.makeSourceLocation(EclipseAdapterUtils.java:120)
        at
org.aspectj.ajdt.internal.core.builder.EclipseAdapterUtils.makeMessage(EclipseAdapterUtils.java:129)
        at
org.aspectj.ajdt.internal.core.builder.AjBuildManager$4.acceptResult(AjBuildManager.java:663)
        at
org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.acceptResult(AjCompilerAdapter.java:178)
        at
org.aspectj.ajdt.internal.compiler.WeaverAdapter.finishedWith(WeaverAdapter.java:203)
        at
org.aspectj.ajdt.internal.compiler.WeaverAdapter.weaveCompleted(WeaverAdapter.java:167)
        at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:570)
        at
org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave(AjCompilerAdapter.java:239)
        at
org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling(AjCompilerAdapter.java:114)
        at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:376)
        at
org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:600)
        at
org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:160)
        at
org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:94)
        at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:102)
        at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:53)
        at org.aspectj.tools.ajc.Main.run(Main.java:280)
        at org.aspectj.tools.ajc.Main.runMain(Main.java:217)
        at org.aspectj.tools.ajc.Main.main(Main.java:79)


1 fail|abort</description><comments/></buginformation><fixedCommits><commit id="a97f3b6758f778e9a19843ef984085b34be8e7d0" author="default" date="2004-04-23 16:24:27"><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/EclipseAdapterUtils.java"><method name="makeLocationContext" returnType="String" parameters="ICompilationUnit"/></file></commit></fixedCommits></bug><bug id="76" opendate="2004-03-09 22:52:00" fixdate="2004-04-27 18:55:41"><buginformation><summary>Restore build cancelling to Swing-based IDEs</summary><description>Core compiler implementation changes have resulted in an incompatability with 
AJDE's build cancelling mechanism.  Once the core canceling behavior 
stabilizes this needs to be restored.</description><comments/></buginformation><fixedCommits><commit id="a17b51bec37c42f0bf29df5bc454aff948bc6105" author="default" date="2004-04-27 18:55:41"><file name="ajbrowser/src/org/aspectj/tools/ajbrowser/BasicEditor.java"><method name="showSourceLine" returnType="void" parameters="ISourceLocation boolean"/></file></commit></fixedCommits></bug><bug id="77" opendate="2004-04-22 06:03:00" fixdate="2004-05-05 10:18:34"><buginformation><summary>Race condition in test suite for incremental</summary><description>On faster machines (my linux desktop, andy's home pc) several of the tests in
ajcTests.xml are failing (suite attached). This appears to be due to a race 
condition between checking directory contents and waiting for the compilation to 
complete. I have an environment in which I can test candidate fixes if you can 
give me a pointer for what to tweak...</description><comments/></buginformation><fixedCommits><commit id="bd1603312535dea0f2c6109a8b074631a3218929" author="default" date="2004-05-05 10:18:34"><file name="testing/src/org/aspectj/testing/harness/bridge/DirChanges.java"><method name="start" returnType="boolean" parameters="IMessageHandler File"/><method name="end" returnType="boolean" parameters="IMessageHandler File"/></file></commit></fixedCommits></bug><bug id="78" opendate="2004-05-14 05:34:00" fixdate="2004-05-14 12:51:52"><buginformation><summary>Load Time Weaving aborts on any kind of warning (declare/xlint)</summary><description>The message handler in the weaving adapter for load time weaving says:

public boolean handleMessage(IMessage message) throws AbortException {
  if (!isIgnoring(message.getKind())) {
    if (verbose) System.err.println(message.getMessage());
    throw new AbortException(message);
  }
  return true;
}

This means for warnings it goes bang.  So, even a declare warning that is 
meant to tell the user something informational during a LTW will cause the 
code to blow up.  The fix is straightforward and simply to log warning 
messages and only fail for error messages.  I am waiting for a testcase from 
Matthew before checking in the fix.</description><comments/></buginformation><fixedCommits><commit id="9ebfc84930fde3f56a0166a5abb671029d457ea4" author="default" date="2004-05-14 12:51:52"><file name="weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java"><method name="isIgnoring" returnType="boolean" parameters="Kind"/><method name="handleMessage" returnType="boolean" parameters="IMessage"/></file><file name="org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/BcweaverJarMaker.java"><method name="makeURLWeavingClassLoaderJars" returnType="void" parameters=""/></file></commit></fixedCommits></bug><bug id="79" opendate="2004-05-07 12:00:00" fixdate="2004-05-28 15:19:14"><buginformation><summary>AJDoc launch script on Windows can lose arguments</summary><description>Using AspectJ 1.2rc1 on Windows XP

This report highlights a problem that I've seen using ajdoc.bat on Windows but
the issue applies equally to the ajc.bat and ajbrowser.bat files as well.

The %ASPECTJ_HOME%\bin\ajdoc.bat file that users run to launch the ajdoc tool
imposes a limit of only 9 command line arguments that may be passed to the
class org.aspectj.tools.ajdoc.Main. In scenarios where there the -sourcepath,
-classpath, -d etc options are used it is easy for these to "eat up" the list
of arguments that are passed into the JVM. A long list of packages entered
at the end of the ajdoc.bat command can be truncated or possibly even ignored
(in which case an error message will be output telling the user that no
classes or packages have been specified).

In order to prevent a limit being put on the number of arguments passed to
the launched JVM, the invocation line needs to end with %* rather than the
%1 %2 %3 %4 %5 %6 %7 %8 %9 list it currently uses.

The proposed fix also *seems* (could somebody else confirm this ?) to sort
out another problem regarding the ajdoc.bat file which is this : long semi-
colon delimited paths supplied as the arguments for the -sourcepath and 
-classpath options seem to get split apart and passed into the JVM as separate 
arguments unless the entire path list is supplied inside quotes. This should
not be necessary. It seems that the batch file processor interprets the
semi-colons in a path list as delimiters between arguments. Consequently
each element in the path list is treated as a separate argument instead
of being part of one big string representing the sourcepath or classpath.</description><comments/></buginformation><fixedCommits><commit id="39c3a3bb4a0c939c1dfbc33b0ba560614b43d8a2" author="default" date="2004-05-28 15:19:14"><file name="build/src/$installer$/org/aspectj/Main.java"><method name="onWindowsPro" returnType="boolean" parameters=""/></file></commit></fixedCommits></bug><bug id="80" opendate="2004-06-24 12:04:00" fixdate="2004-06-24 22:11:53"><buginformation><summary>ajdoc does not support .aj files</summary><description>In addition to accepting .java source files ajdoc needs to accept .aj files.</description><comments/></buginformation><fixedCommits><commit id="3707411c2b5fdd0294c2ab5305c32766644241f1" author="default" date="2004-06-24 22:11:53"><file name="ajdoc/testsrc/org/aspectj/tools/ajdoc/CoverageTestCase.java"><method name="testCoverage" returnType="void" parameters=""/></file><file name="ajdoc/src/org/aspectj/tools/ajdoc/Main.java"><method name="accept" returnType="boolean" parameters="File String"/><method name="findFile" returnType="File" parameters="String"/><method name="parseArgs" returnType="void" parameters="List File"/><method name="main" returnType="void" parameters="String[]"/><method name="removeDeclIDsFromFile" returnType="void" parameters="String boolean"/></file><file name="ajdoc/src/org/aspectj/tools/ajdoc/StubFileGenerator.java"><method name="processFile" returnType="void" parameters="SymbolManager File File"/></file></commit></fixedCommits></bug><bug id="81" opendate="2004-06-30 10:22:00" fixdate="2004-07-05 18:19:15"><buginformation><summary>ajdoc fails when using default package</summary><description>When trying to document classes that are in the default package, the following 
error occurs:

 &gt; Calling ajc...
&gt; Building signature files...
&gt; Calling javadoc... 
Loading source file C:\eclipse_RC3\eclipse\ajdocworkingdir\A.java...
C:\eclipse_RC3\eclipse\ajdocworkingdir\A.java:1: &lt;identifier&gt; expected
package ;
        ^
1 error
 &gt; Decorating html files...
&gt; Decorating C:\doc\classX.html... 
An internal error occured in ajdoc
Please copy the following text into an email message and send it,
along with any additional information you can add to:            
                                                                 
        aspectj-dev@eclipse.org                            
                                                                 

java.io.FileNotFoundException: C:\doc\classX.html (The system cannot find the 
file specified)
java.io.FileNotFoundException: C:\doc\classX.html (The system cannot find the 
file specified)
	at java.io.FileInputStream.open(Native Method)
	at java.io.FileInputStream.&lt;init&gt;(FileInputStream.java:106)
	at java.io.FileReader.&lt;init&gt;(FileReader.java:55)
	at org.aspectj.tools.ajdoc.HtmlDecorator.decorateHTMLFile
(HtmlDecorator.java:142)
	at org.aspectj.tools.ajdoc.HtmlDecorator.decorateHTMLFromDecl
(HtmlDecorator.java:115)
	at org.aspectj.tools.ajdoc.HtmlDecorator.decorateHTMLFromDecls
(HtmlDecorator.java:54)
	at org.aspectj.tools.ajdoc.HtmlDecorator.decorateHTMLFromInputFiles
(HtmlDecorator.java:43)
	at org.aspectj.tools.ajdoc.Main.main(Main.java:210)</description><comments/></buginformation><fixedCommits><commit id="2cc4826419d8c08e3879e600b82354fac2596241" author="default" date="2004-07-05 18:19:15"><file name="ajdoc/testsrc/org/aspectj/tools/ajdoc/CoverageTestCase.java"><method name="testCoverage" returnType="void" parameters=""/></file><file name="ajdoc/src/org/aspectj/tools/ajdoc/StubFileGenerator.java"><method name="processFile" returnType="void" parameters="SymbolManager File"/></file></commit></fixedCommits></bug><bug id="82" opendate="2004-07-14 07:16:00" fixdate="2004-07-14 20:36:00"><buginformation><summary>problem with ajdoc -public</summary><description>Using the spacewar example, the following works fine:
    ajdoc -private -d doc spacewar coordination
but the following breaks:
    ajdoc -public -d doc spacewar coordination

The end of the failing output is below. Display.html and
Display.DisplayAspect.html were not generated as the types are not public, so
presumably the decorator shouldn't be looking for them in this case.

 &gt; Decorating html files...
&gt; Decorating C:\aspectj1.2\doc\examples\doc\spacewar\Debug.html...
&gt; Decorating C:\aspectj1.2\doc\examples\doc\spacewar\Display.DisplayAspect.html. 
..
An internal error occured in ajdoc
Please copy the following text into an email message and send it,
along with any additional information you can add to:

        aspectj-dev@eclipse.org 


java.io.FileNotFoundException: C:\aspectj1.2\doc\examples\doc\spacewar\Display.D
isplayAspect.html (The system cannot find the file specified)
java.io.FileNotFoundException: C:\aspectj1.2\doc\examples\doc\spacewar\Display.D
isplayAspect.html (The system cannot find the file specified)
        at java.io.FileInputStream.open(Native Method)
        at java.io.FileInputStream.&lt;init&gt;(FileInputStream.java:106)
        at java.io.FileReader.&lt;init&gt;(FileReader.java:55)
        at org.aspectj.tools.ajdoc.HtmlDecorator.decorateHTMLFile(HtmlDecorator.
java:142)
        at org.aspectj.tools.ajdoc.HtmlDecorator.decorateHTMLFromDecl(HtmlDecora
tor.java:115)
        at org.aspectj.tools.ajdoc.HtmlDecorator.decorateHTMLFromDecls(HtmlDecor
ator.java:54)
        at org.aspectj.tools.ajdoc.HtmlDecorator.decorateHTMLFromInputFiles(Html
Decorator.java:43)
        at org.aspectj.tools.ajdoc.Main.main(Main.java:210)</description><comments/></buginformation><fixedCommits><commit id="8dc08453232f9b4c1572ad0feb60979fb07336fe" author="default" date="2004-07-14 20:36:00"><file name="ajdoc/src/org/aspectj/tools/ajdoc/HtmlDecorator.java"><method name="decorateHTMLFile" returnType="void" parameters="File"/><method name="constructNestedTypeName" returnType="String" parameters="IProgramElement"/></file><file name="ajdoc/testsrc/org/aspectj/tools/ajdoc/CoverageTestCase.java"><method name="testCoverage" returnType="void" parameters=""/></file><file name="ajdoc/testsrc/org/aspectj/tools/ajdoc/SpacewarTestCase.java"><method name="setUp" returnType="void" parameters=""/><method name="testSimpleExample" returnType="void" parameters=""/></file></commit></fixedCommits></bug><bug id="83" opendate="2004-07-22 10:11:00" fixdate="2004-07-26 13:28:20"><buginformation><summary>compiler aborts with "conflicting dominates orders" with circular declare precedences</summary><description>The following program causes ajc 1.2 to abort:

public class Conflict { public static void main(String[] args) { } }

aspect Conflict1 {
  declare precedence: Conflict1, Conflict2;

   before(): execution(* *(..)) { }
}

aspect Conflict2 {
  declare precedence: Conflict2, Conflict1;


  after(): execution(* *(..)) { }
}</description><comments/></buginformation><fixedCommits><commit id="75852d7b1915cddfd4ba3dea272324617abdaa60" author="default" date="2004-07-26 13:28:20"><file name="weaver/src/org/aspectj/weaver/World.java"><method name="compareByDominates" returnType="int" parameters="ResolvedTypeX ResolvedTypeX"/></file></commit></fixedCommits></bug><bug id="84" opendate="2004-03-07 22:07:00" fixdate="2004-07-27 10:34:41"><buginformation><summary>"can't bind type" message has $ for . in type name for declare soft</summary><description>cosmetic mistake in error message...

expected: can't bind type name 'unknown.Error'
  actual: can't bind type name 'unknown$Error'

(not sure why it would ever be munged with $)

public class Test {
	public static void main(String[] args) {
		test();
	}
	static void test() {
		throw new Error("hello");
	}
	static aspect A {
		declare soft : unknown.Error : call(void test()); // CE
	}
}</description><comments/></buginformation><fixedCommits><commit id="936459c28229321deb0b09d076193be32cd9754e" author="default" date="2004-07-27 10:34:41"><file name="weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java"><method name="resolveBindings" returnType="TypePattern" parameters="IScope Bindings"/></file></commit></fixedCommits></bug><bug id="85" opendate="2004-07-07 09:10:00" fixdate="2004-07-27 14:17:32"><buginformation><summary>Hiding of Instance Methods by static methods</summary><description>Using Introduction it is possible to hide instance methods by static methods.
Example:

class Super {
  public void m(){};
}
class Sub {}

aspect A {
  public static void Sub.m(){}
}

Acccording to the Java Language Specification this is not allowed. Is this
behaviour desired ??

It is also possible to override static methods by instance methods, wich causes
a compile time error in java.</description><comments/></buginformation><fixedCommits><commit id="b18436307ecfed63c8995fd35013ffa07e5116e7" author="default" date="2004-07-27 14:17:32"><file name="weaver/src/org/aspectj/weaver/ResolvedTypeX.java"><method name="compareToExistingMembers" returnType="boolean" parameters="ConcreteTypeMunger"/><method name="checkLegalOverride" returnType="boolean" parameters="ResolvedMember ResolvedMember"/></file></commit></fixedCommits></bug><bug id="86" opendate="2004-04-15 12:19:00" fixdate="2004-07-27 15:44:24"><buginformation><summary>-X should output available -X options</summary><description>ajc should emit the available -X options on -help or -X request (the latter like
java) to get more traffic and feedback on the experimental options.</description><comments/></buginformation><fixedCommits><commit id="6ea830044009af2991178f1833b6386143f2cc1b" author="default" date="2004-07-27 15:44:24"><file name="org.aspectj.ajdt.core/src/org/aspectj/tools/ajc/Main.java"><method name="run" returnType="void" parameters="String[] IMessageHolder"/></file><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/AjdtCommand.java"><method name="runCommand" returnType="boolean" parameters="String[] IMessageHandler"/></file><file name="org.aspectj.ajdt.core/testsrc/EajcModuleTests.java"><method name="suite" returnType="Test" parameters=""/></file><file name="org.aspectj.ajdt.core/testsrc/org/aspectj/tools/ajc/MainTest.java"><method name="testMainbare" returnType="void" parameters=""/></file></commit></fixedCommits></bug><bug id="87" opendate="2004-05-27 09:58:00" fixdate="2004-07-28 14:43:40"><buginformation><summary>java.lang.NullPointerException in WeaverMessageHandler class</summary><description>I've got an java.lang.NullPointerException while running the aspectJ 1.2
compiler. That's the stack trace:
     [iajc] If you don't find the exception below in a bug, please add a new bug
     [iajc] at  http://bugs.eclipse.org/bugs/enter_bug.cgi?product=AspectJ 
     [iajc] To make the bug a priority, please include a test program
     [iajc] that can reproduce this exception.
     [iajc] null
     [iajc] java.lang.NullPointerException
     [iajc]     at
org.aspectj.ajdt.internal.compiler.WeaverMessageHandler.buildSeeAlsoProblems(WeaverMessageHandler.java:172)
     [iajc]     at
org.aspectj.ajdt.internal.compiler.WeaverMessageHandler.handleMessage(WeaverMessageHandler.java:100)
     [iajc]     at
org.aspectj.weaver.ResolvedTypeX.checkInterTypeMungers(ResolvedTypeX.java:989)
     [iajc]     at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:716)
     [iajc]     at
org.aspectj.weaver.bcel.BcelWeaver.weaveWithoutDump(BcelWeaver.java:689)
     [iajc]     at
org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify(BcelWeaver.java:615)
     [iajc]     at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:563)
     [iajc]     at
org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave(AjCompilerAdapter.java:239)
     [iajc]     at
org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling(AjCompilerAdapter.java:114)
     [iajc]     at
org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:376)
     [iajc]     at
org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:601)
     [iajc]     at
org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:160)
     [iajc]     at
org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:94)
     [iajc]     at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:102)
     [iajc]     at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:53)
     [iajc]     at org.aspectj.tools.ajc.Main.run(Main.java:280)
     [iajc]     at org.aspectj.tools.ajc.Main.runMain(Main.java:217)
     [iajc]     at
org.aspectj.tools.ant.taskdefs.AjcTask.executeInSameVM(AjcTask.java:1157)
     [iajc]     at org.aspectj.tools.ant.taskdefs.AjcTask.execute(AjcTask.java:954)
     [iajc]     at org.apache.tools.ant.Task.perform(Task.java:341)
     [iajc]     at
org.apache.tools.ant.taskdefs.Sequential.execute(Sequential.java:117)
     [iajc]     at org.apache.tools.ant.Task.perform(Task.java:341)
     [iajc]     at net.sf.antcontrib.logic.IfTask.execute(Unknown Source)
     [iajc]     at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
     [iajc]     at
sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
     [iajc]     at
sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
     [iajc]     at java.lang.reflect.Method.invoke(Method.java:324)
     [iajc]     at org.apache.tools.ant.TaskAdapter.execute(TaskAdapter.java:147)
     [iajc]     at
org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:193)
     [iajc]     at org.apache.tools.ant.Task.perform(Task.java:341)
     [iajc]     at org.apache.tools.ant.Target.execute(Target.java:309)
     [iajc]     at org.apache.tools.ant.Target.performTasks(Target.java:336)
     [iajc]     at org.apache.tools.ant.Project.executeTarget(Project.java:1339)
     [iajc]     at org.apache.tools.ant.Project.executeTargets(Project.java:1255)
     [iajc]     at org.apache.tools.ant.Main.runBuild(Main.java:609)
     [iajc]     at org.apache.tools.ant.Main.start(Main.java:196)
     [iajc]     at org.apache.tools.ant.Main.main(Main.java:235)

       [if] Error in class net.sf.antcontrib.logic.IfTask


Sorry, i have no simple test case for that problem...</description><comments/></buginformation><fixedCommits><commit id="573741c8081c6b6b45921cafaae39f37eede2302" author="default" date="2004-07-28 14:43:40"><file name="weaver/src/org/aspectj/weaver/ResolvedTypeX.java"><method name="checkInterTypeMungers" returnType="void" parameters=""/></file><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/WeaverMessageHandler.java"><method name="buildSeeAlsoProblems" returnType="IProblem[]" parameters="List"/></file></commit></fixedCommits></bug><bug id="88" opendate="2003-12-17 06:29:00" fixdate="2004-07-28 15:13:09"><buginformation><summary>Special case if(false) to not require a dynamic test</summary><description>FastMatch, the efficient pattern matching for pointcuts on the constant pool, is
currrently only implemented for the within pointcut. I am planning to provide
further oimplementations for other pointcuts by release 1.2.</description><comments/></buginformation><fixedCommits><commit id="10c6de6fbc8a0b9eb07801f4ac19bea8304a9cb3" author="default" date="2004-07-28 15:13:09"><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/IfPseudoToken.java"><method name="maybeGetParsedPointcut" returnType="Pointcut" parameters=""/></file><file name="weaver/src/org/aspectj/weaver/patterns/Pointcut.java"><method name="read" returnType="Pointcut" parameters="DataInputStream ISourceContext"/></file></commit></fixedCommits></bug><bug id="89" opendate="2004-05-09 12:50:00" fixdate="2004-07-29 12:39:42"><buginformation><summary>Front-end bug, shouldn't allow patterns of the form foo.., should be foo..*</summary><description>See following code:

public class Test2 {
  public static void main(String args[])
    { System.out.println("Hi");
    }
}

aspect Aspect2 {
  // shouldn't one have to say,  java..* instead of java.. in the following??
  // Note that the first advice (incorrect one) passes the front-end, but does
  // not match,  whereas the second one does match.   I believe the front-end
  // should reject the first one.
  before () : call( * java..(..)) &amp;&amp; within(Test2)
    { System.out.println(
        "Incorrect One: Before a call of method in a java package ");
    }

  before () : call( * java..*(..)) &amp;&amp; within(Test2)
    { System.out.println(
        "Correct One: Before a call of method in a java package ");
    }
}</description><comments/></buginformation><fixedCommits><commit id="45bce91f642a86ca3db7238d9e4cfb81d85e4f5b" author="default" date="2004-07-29 12:39:42"><file name="weaver/src/org/aspectj/weaver/patterns/PatternParser.java"><method name="parseDottedNamePattern" returnType="List" parameters=""/></file></commit></fixedCommits></bug><bug id="90" opendate="2003-01-28 16:20:00" fixdate="2004-07-29 15:04:00"><buginformation><summary>spurious "circular dependency" error</summary><description>AspectJ Compiler 1.1beta4
This program:

aspect Foo { 
  pointcut p1(): execution(void f()) &amp;&amp; cflow(execution(void f1()));
  pointcut p2(): execution(void f()) &amp;&amp; cflow(execution(void f2()));

  before(): p1() { }
  after():  p1() { }
  before(): p2() { }
  after():  p2() { }
}

class A {
  void f1() { f(); }
  void f2() { f(); }
  void f() { }
}

results in these errors:

circular dependency at method-execution(void A.f())
circular dependency at method-execution(void A.f())
circular dependency at method-execution(void A.f())
circular dependency at method-execution(void A.f())

4 errors

If I comment out any one of the four pieces of advice, all the errors go away.
Also, assuming that there is a valid reason for printing this error sometimes, how come there's no line number?

--Doug</description><comments/></buginformation><fixedCommits><commit id="4feb835a5339c3f63d73fbd6db2fe307e1f08ed1" author="default" date="2004-07-29 15:04:00"><file name="weaver/src/org/aspectj/weaver/NewConstructorTypeMunger.java"><method name="check" returnType="void" parameters="World"/></file><file name="weaver/src/org/aspectj/weaver/Lint.java"><method name="loadDefaultProperties" returnType="void" parameters=""/><method name="setFromProperties" returnType="void" parameters="Properties"/><method name="setFromProperties" returnType="void" parameters="File"/></file><file name="weaver/src/org/aspectj/weaver/Shadow.java"><method name="checkCanThrow" returnType="boolean" parameters="ShadowMunger"/><method name="sortMungers" returnType="void" parameters=""/></file><file name="weaver/src/org/aspectj/weaver/Advice.java"><method name="match" returnType="boolean" parameters="Shadow World"/></file><file name="weaver/src/org/aspectj/weaver/ResolvedTypeX.java"><method name="getExposedPointcuts" returnType="List" parameters=""/><method name="checkLegalOverride" returnType="boolean" parameters="ResolvedMember ResolvedMember"/><method name="addPointcutsResolvingConflicts" returnType="void" parameters="List List"/><method name="compareToExistingMembers" returnType="boolean" parameters="ConcreteTypeMunger"/><method name="interTypeConflictError" returnType="interTypeConflictError" parameters=""/></file><file name="weaver/src/org/aspectj/weaver/WeaverStateInfo.java"><method name="getTypeMungers" returnType="List" parameters="ResolvedTypeX"/></file><file name="weaver/src/org/aspectj/weaver/World.java"><method name="resolve" returnType="ResolvedTypeX" parameters="TypeX boolean"/></file></commit></fixedCommits></bug><bug id="91" opendate="2004-07-23 21:07:00" fixdate="2004-08-02 10:14:39"><buginformation><summary>AspectJ Error: ConncurrentModificationException thrown: null</summary><description>In AspectJ 1.1.11 for Eclipse, build ID 1.2.0 (and also in the previous 1.1.10)
on Eclipse version 3.0.0, build ID 200406351208: If I enable incremental
compilation and make a change to a file (typing a space and deleting it, or
editing a comment), I get a "ConncurrentModificationException thrown: null" error.</description><comments/></buginformation><fixedCommits><commit id="9aed31d18e3848c72c6963dc3a6ee4661a79add9" author="default" date="2004-08-02 10:14:39"><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java"><method name="warnOnAddedInterface" returnType="void" parameters="ResolvedTypeX ResolvedTypeX"/><method name="createBinaryTypeFrom" returnType="BinaryTypeBinding" parameters=""/></file></commit></fixedCommits></bug><bug id="92" opendate="2004-06-18 04:54:00" fixdate="2004-08-02 13:43:43"><buginformation><summary>Nullpointer-exception in pointcuts using withincode() clause</summary><description>Hi,
I am getting null-pointer-exceptions whenever I try to specify a pointcut with 
a "withincode(Signature)" clause. E.g.:

public aspect DetectSystemOutErrorUsage 
{
pointcut allSystemOutAndSystemErrAccesses(): 
	(get(* System.out) || get(* System.err))
	;

declare warning: 
	allSystemOutAndSystemErrAccesses() 
	&amp;&amp; !adviceexecution()
	&amp;&amp; !within(com.tivoli.act..Test*)
	&amp;&amp; !within(com.tivoli.act.log..*)
	&amp;&amp; !execution(* com.tivoli.act..*.main(..))
	&amp;&amp; !execution(* com.tivoli.act..*.usage())
	// &amp;&amp; !withincode(* com.tivoli.act..*.main(..))
	// &amp;&amp; !withincode(* com.tivoli.act..*.usage())
	: "Warning: use of System.out or System.err - consider logging 
instead!";
}

In the above example excluding main() and usage() methods from the pointcut 
using an execution(...)-clause (shows) works but using a withincode()-clause 
(as commented) always yields an NPE:

trouble in:
null
java.lang.NullPointerException
        at org.aspectj.weaver.patterns.SignaturePattern.matches
(SignaturePattern.java:87)
        at org.aspectj.weaver.patterns.WithincodePointcut.match
(WithincodePointcut.java:42)
        at org.aspectj.weaver.patterns.NotPointcut.match(NotPointcut.java:45)
        at org.aspectj.weaver.patterns.AndPointcut.match(AndPointcut.java:42)
        at org.aspectj.weaver.patterns.AndPointcut.match(AndPointcut.java:42)
        at org.aspectj.weaver.patterns.AndPointcut.match(AndPointcut.java:42)
        at org.aspectj.weaver.patterns.AndPointcut.match(AndPointcut.java:42)
        at org.aspectj.weaver.patterns.AndPointcut.match(AndPointcut.java:42)
        at org.aspectj.weaver.patterns.AndPointcut.match(AndPointcut.java:42)
        at org.aspectj.weaver.patterns.AndPointcut.match(AndPointcut.java:42)
        at org.aspectj.weaver.ShadowMunger.match(ShadowMunger.java:62)
        at org.aspectj.weaver.Checker.match(Checker.java:48)
        at org.aspectj.weaver.bcel.BcelClassWeaver.match
(BcelClassWeaver.java:1121)
        at org.aspectj.weaver.bcel.BcelClassWeaver.matchInit
(BcelClassWeaver.java:895)
        at org.aspectj.weaver.bcel.BcelClassWeaver.match
(BcelClassWeaver.java:793)
        at org.aspectj.weaver.bcel.BcelClassWeaver.weave
(BcelClassWeaver.java:343)
        at org.aspectj.weaver.bcel.BcelClassWeaver.weave
(BcelClassWeaver.java:80)
        at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:724)
        at org.aspectj.weaver.bcel.BcelWeaver.weaveWithoutDump
(BcelWeaver.java:689)
        at org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify
(BcelWeaver.java:615)
        at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:563)
        at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave
(AjCompilerAdapter.java:239)
        at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling
(AjCompilerAdapter.java:114)
        at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:376)
        at 
org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation
(AjBuildManager.java:601)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild
(AjBuildManager.java:160)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild
(AjBuildManager.java:94)
        at org.aspectj.ajde.internal.CompilerAdapter.compile
(CompilerAdapter.java:108)
        at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run
(AspectJBuildManager.java:165)
!SESSION Jun 18, 2004 10:49:48.666 ---------------------------------------------
eclipse.buildId=I200406110010
java.version=1.4.2_03
java.vendor=Sun Microsystems Inc.
BootLoader constants: OS=win32, ARCH=x86, WS=win32, NL=de_CH

!ENTRY org.eclipse.ajdt.ui 4 0 Jun 18, 2004 10:49:48.666
!MESSAGE NullPointerException thrown: null
!STACK 0
java.lang.NullPointerException
        at org.aspectj.weaver.patterns.SignaturePattern.matches
(SignaturePattern.java:87)
        at org.aspectj.weaver.patterns.WithincodePointcut.match
(WithincodePointcut.java:42)
        at org.aspectj.weaver.patterns.NotPointcut.match(NotPointcut.java:45)
        at org.aspectj.weaver.patterns.AndPointcut.match(AndPointcut.java:42)
        at org.aspectj.weaver.patterns.AndPointcut.match(AndPointcut.java:42)
        at org.aspectj.weaver.patterns.AndPointcut.match(AndPointcut.java:42)
        at org.aspectj.weaver.patterns.AndPointcut.match(AndPointcut.java:42)
        at org.aspectj.weaver.patterns.AndPointcut.match(AndPointcut.java:42)
        at org.aspectj.weaver.patterns.AndPointcut.match(AndPointcut.java:42)
        at org.aspectj.weaver.patterns.AndPointcut.match(AndPointcut.java:42)
        at org.aspectj.weaver.ShadowMunger.match(ShadowMunger.java:62)
        at org.aspectj.weaver.Checker.match(Checker.java:48)
        at org.aspectj.weaver.bcel.BcelClassWeaver.match
(BcelClassWeaver.java:1121)
        at org.aspectj.weaver.bcel.BcelClassWeaver.matchInit
(BcelClassWeaver.java:895)
        at org.aspectj.weaver.bcel.BcelClassWeaver.match
(BcelClassWeaver.java:793)
        at org.aspectj.weaver.bcel.BcelClassWeaver.weave
(BcelClassWeaver.java:343)
        at org.aspectj.weaver.bcel.BcelClassWeaver.weave
(BcelClassWeaver.java:80)
        at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:724)
        at org.aspectj.weaver.bcel.BcelWeaver.weaveWithoutDump
(BcelWeaver.java:689)
        at org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify
(BcelWeaver.java:615)
        at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:563)
        at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave
(AjCompilerAdapter.java:239)
        at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling
(AjCompilerAdapter.java:114)
        at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:376)
        at 
org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation
(AjBuildManager.java:601)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild
(AjBuildManager.java:160)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild
(AjBuildManager.java:94)
        at org.aspectj.ajde.internal.CompilerAdapter.compile
(CompilerAdapter.java:108)
        at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run
(AspectJBuildManager.java:165)


Michael</description><comments/></buginformation><fixedCommits><commit id="7f19ab47a3df5327c6246420354089d1db1c765f" author="default" date="2004-08-02 13:43:43"><file name="weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"><method name="getEnclosingCodeSignature" returnType="Member" parameters=""/></file></commit></fixedCommits></bug><bug id="93" opendate="2004-04-06 17:22:00" fixdate="2004-08-02 15:47:02"><buginformation><summary>duplicate manifests cause resource-copying to gack</summary><description>(Ah, the joy of build infrastructure...)

Mostly self-explanatory trace, from a build Monday Apr 5, 2004 at 08:46:01 GMT:

duplicate entry: META-INF/MANIFEST.MF
duplicate entry: META-INF/MANIFEST.MF
java.util.zip.ZipException: duplicate entry: META-INF/MANIFEST.MF
	at java.util.zip.ZipOutputStream.putNextEntry(ZipOutputStream.java:163)
	at java.util.jar.JarOutputStream.putNextEntry(JarOutputStream.java:90)
	at
org.aspectj.ajdt.internal.core.builder.AjBuildManager.writeResource(AjBuildManager.java:344)
	at
org.aspectj.ajdt.internal.core.builder.AjBuildManager.copyResourcesFromJarFile(AjBuildManager.java:288)
	at
org.aspectj.ajdt.internal.core.builder.AjBuildManager.copyResourcesToDestination(AjBuildManager.java:253)
	at
org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:195)
	at
org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:94)
	at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:102)
	at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:53)
	at org.aspectj.tools.ajc.Main.run(Main.java:280)
	at org.aspectj.tools.ajc.Main.runMain(Main.java:217)
	at org.aspectj.tools.ajc.Main.main(Main.java:79)</description><comments/></buginformation><fixedCommits><commit id="2b8fa314f21eddf8551715fdd571da2b611411d0" author="default" date="2004-08-02 15:47:02"><file name="ajde/testsrc/org/aspectj/ajde/AjdeTests.java"><method name="suite" returnType="Test" parameters=""/></file><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"><method name="copyResourcesFromJarFile" returnType="void" parameters="File"/><method name="acceptResource" returnType="boolean" parameters="String"/></file><file name="org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/BcweaverJarMaker.java"><method name="main" returnType="void" parameters="String[]"/></file><file name="weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java"><method name="addManifest" returnType="void" parameters="Manifest"/><method name="addJarFile" returnType="List" parameters="File File boolean"/></file></commit></fixedCommits></bug><bug id="94" opendate="2004-04-26 16:49:00" fixdate="2004-08-03 14:53:38"><buginformation><summary>NPE, Incorrect XLint:unmatchedSuperTypeInCall warning</summary><description>(This is an incomplete bug report -- sorry no time not to further isolate.)

Running AJDT 1.1.6, I get dozens of these warnings:

----------
Warning does not match because declaring type is java.lang.Object, if match
desired use target(st.ata.mc.exim.DatastoreReader)
[Xlint:unmatchedSuperTypeInCall] Blah.aj project/src/package/dir line 22
----------

for something like this code:

----------
import pack.Interface;
...
pointcut dsrCall() : call(* Interface.*(..)); // WARNING HERE
...
----------

Each warning points to the pointcut (not the join point shadow).

NPE running from the command-line with the latest tree (will attach).</description><comments/></buginformation><fixedCommits><commit id="ef7885fd1269261aec9cb1265f0e15472fdb03bb" author="default" date="2004-08-03 14:53:38"><file name="weaver/src/org/aspectj/weaver/patterns/KindedPointcut.java"><method name="warnOnConfusingSig" returnType="void" parameters="Shadow"/></file></commit></fixedCommits></bug><bug id="95" opendate="2003-09-04 18:40:00" fixdate="2004-08-05 17:31:56"><buginformation><summary>.lst file entries not resolved relative to list file: {boot}classpath, extdirs,</summary><description>My -classpath entry in a config/.lst file was resolved relative to the working
directory rather than to the config/.lst file.  BuildArgParser.java looks like
this would also be true for bootclasspath and extdirs, but not for injars,
aspectpath, or sourceroots.</description><comments/></buginformation><fixedCommits><commit id="648c0f4d15d9ab6bac9deef010a1b66824cd8da1" author="default" date="2004-08-05 17:31:56"><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java"><method name="parseOption" returnType="void" parameters="String LinkedList"/></file><file name="util/src/org/aspectj/util/ConfigParser.java"><method name="makeFile" returnType="File" parameters="String"/><method name="parseConfigFileHelper" returnType="void" parameters="File"/></file><file name="org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/ajc/BuildArgParserTestCase.java"><method name="testDefaultClasspathAndTargetCombo" returnType="void" parameters=""/><method name="testExtDirs" returnType="void" parameters=""/></file></commit></fixedCommits></bug><bug id="96" opendate="2003-10-04 20:23:00" fixdate="2004-08-06 15:04:45"><buginformation><summary>Need better error message for "can't find type"</summary><description>I have experienced situations where IAJC outputs a message like this at the 
end of compilation.

    [iajc] can't find type org.xxx.SomeTest

In my case this was one time highly confusing since I did not expect the class 
in question to be referred anywhere in the project (I have to date still not 
located the reference). 

For such cases, it would be extremely nice if the error message would display 
WHY it need the class (i.e. the name of the refering class(es) or aspect(es) 
possibly with a reasonable cutoff as there is seldom need to list all 
referals). So I would like a message like this:

    [iajc] can't find type org.xxx.SomeTest referred by 
org.yyy.SomeClass,org.yy.SomeOtherClass ...</description><comments/></buginformation><fixedCommits><commit id="061395c8c7fe681ab40ab53a7d1bfeb8e17c1028" author="default" date="2004-08-06 15:04:45"><file name="weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"><method name="getThisJoinPointStaticPartBcelVar" returnType="BcelVar" parameters=""/><method name="createThisJoinPoint" returnType="InstructionList" parameters=""/><method name="addPreInitializationReturnCode" returnType="void" parameters=""/></file><file name="weaver/src/org/aspectj/weaver/patterns/DeclareParents.java"><method name="maybeGetNewParent" returnType="ResolvedTypeX" parameters="ResolvedTypeX"/></file><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseSourceType.java"><method name="getSuperclass" returnType="ResolvedTypeX" parameters=""/></file><file name="weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java"><method name="collectCheckedExceptions" returnType="Collection" parameters="TypeX[]"/></file><file name="weaver/src/org/aspectj/weaver/patterns/DeclareSoft.java"><method name="resolve" returnType="void" parameters="IScope"/></file><file name="weaver/src/org/aspectj/weaver/ResolvedTypeX.java"><method name="addInterTypeMunger" returnType="void" parameters="ConcreteTypeMunger"/><method name="isExposedToWeaver" returnType="boolean" parameters=""/></file><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectDeclaration.java"><method name="canBeSeenBy" returnType="boolean" parameters=""/></file></commit></fixedCommits></bug><bug id="97" opendate="2004-08-04 10:21:00" fixdate="2004-08-09 10:26:53"><buginformation><summary>Cannot advise private method call in around advice</summary><description>Pointcuts should match call joint points in advice. However AspectJ does not 
match calls to _private_ methods in around advice. The same applies to get/set 
pointcuts for _private fields. This is probably because in the testcase below 
a call to "privateMethod()" in the body of the around advice is a call to an 
accessor method:

        
ajc$inlineAccessMethod$bug_nnnn_JoinPointInAroundAdvice$bug_nnnn_JoinPointInAro
undAdvice$privateMethod("around");

public aspect JoinPointInAroundAdvice {

	private static Set privateCalls = new HashSet();
	private static Set publicCalls = new HashSet();
	
	pointcut internalCall () :
		call(* JoinPointInAroundAdvice.privateMethod(..));
	
	before () : internalCall () {
		privateCalls.add(thisJoinPoint);
	}

	pointcut externalCall () :
		call(* JoinPointInAroundAdvice.publicMethod(..));
	
	before () : externalCall () {
		publicCalls.add(thisJoinPoint);
	}
	
	pointcut execTest () :
		execution(* JoinPointInAroundAdvice.test());
	
	before () : execTest () {
		privateMethod("before");
		publicMethod("before");
	}
	
	void around () : execTest () {
		privateMethod("around");
		publicMethod("around");
		proceed();
	}
	
//	void around () : execTest () {
//		Runnable runnable = new Runnable () {
//			public void run () {
//				privateMethod("around closure");
//				publicMethod;
//				proceed();
//			}
//		};
//		runnable.run();
//	}
	
	after () : execTest () {
		privateMethod("after");
		publicMethod("after");
	}
	
	private static void privateMethod (String from) {
		System.out.println("? privateMethod() " + from);
	}
	
	public static void publicMethod (String from) {
		System.out.println("? publicMethod() " + from);
	}
	
	public static void test () {
		System.out.println("? test()");
		privateMethod("test");
		publicMethod("test");
	}
	
	public static void main (String[] args) {
		test();
		
		if (privateCalls.size() != publicCalls.size()) {
			throw new RuntimeException("Missing join point");
		}
		else {
			System.out.println("Success.");
		}
	}
}</description><comments/></buginformation><fixedCommits><commit id="851da68a07bcbfac4414fadc1b9f3bc02fa810a5" author="default" date="2004-08-09 10:26:53"><file name="weaver/src/org/aspectj/weaver/bcel/LazyClassGen.java"><method name="getTjpField" returnType="Field" parameters="BcelShadow"/></file><file name="tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java"><method name="test001" returnType="void" parameters=""/></file><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectDeclaration.java"><method name="generateMethod" returnType="void" parameters="ClassFile MethodBinding BodyGenerator"/><method name="generate" returnType="void" parameters="CodeStream"/><method name="generateInlineAccessors" returnType="void" parameters="ClassFile InlineAccessFieldBinding ResolvedMember"/><method name="generateInlineAccessMethod" returnType="void" parameters="ClassFile MethodBinding ResolvedMember"/></file></commit></fixedCommits></bug><bug id="98" opendate="2004-06-17 04:06:00" fixdate="2004-08-09 12:48:11"><buginformation><summary>value in the args[] array of thisjoinpoint can be changed by one advice decl and updated values seen in another advice decl</summary><description>In ajc a use of thisJoinPoint corresponds to an object of type JoinPoint, where
a JoinPoint object has four components, which can be retrieved using
accessor methods.

  this                   getThis()
  target                 getTarget()
  args                   getArgs()
  staticJoinPoint        getStaticPart()

In the case of args, the object returned is an Object array.  This means
that an advice decl can overwrite the args,  and then another advice which
shares the same JoinPoint will see the changed args.   Here is a
small example.  In this aspect the
before advice changes arg[0] to always be "Laurie" and then the after
advice will always say that "Laurie won a million pounds".

Is this the behaviour that is intended?   I would have thought that the
interface to args[] should be such that the values can only be read.  Otherwise
very strange interactions between advice decls could occur.

---------------------------------------------------------------------

public class Main {

  public static Main v = new Main();

  void lottery ( String arg )
    { System.out.println("The arg in lottery is " + arg);
    }

  public static void main (String args[])
    { v.lottery("Oege");
      v.lottery("Ganesh");
    }

}

---------------------------------------------------------------------

public aspect Aspect {

  // This pair of advice decls demonstrates that an advice can change to
  //   the args of a join point.

  before () : call(* lottery(java.lang.String)) &amp;&amp; !within(Aspect)
    { System.out.println("BEFORE " + thisJoinPoint +
                         " at " + thisJoinPointStaticPart.getSourceLocation());
      Object args[] = thisJoinPoint.getArgs();
      System.out.println("arg[0] is " + args[0]);
      args[0] = "Laurie";
      System.out.println("... now it is " + thisJoinPoint.getArgs()[0]);
    }


  after ()  : call(* lottery(java.lang.String)) &amp;&amp; !within(Aspect)
    { System.out.println("AFTER " + thisJoinPoint +
                         " at " + thisJoinPointStaticPart.getSourceLocation());
      if (thisJoinPoint.getArgs()[0].equals("Laurie"))
        System.out.println("Laurie wins 1 million pounds!");
    }

}</description><comments/></buginformation><fixedCommits><commit id="f6436e3fc84f7e140acb3a250a29fe38f9c20c35" author="default" date="2004-08-09 12:48:11"><file name="runtime/testsrc/RuntimeModuleTests.java"><method name="suite" returnType="TestSuite" parameters=""/></file><file name="runtime/src/org/aspectj/runtime/reflect/JoinPointImpl.java"><method name="getArgs" returnType="Object[]" parameters=""/></file></commit></fixedCommits></bug><bug id="99" opendate="2004-03-06 22:43:00" fixdate="2004-08-10 13:22:08"><buginformation><summary>proceed used as method name in around advice</summary><description>Using a method named proceed(..) in around advice confuses the compiler (in at
least the 2-3 ways shown below).  

True of the current tree (untested in 1.1.1).  Workaround for now is to rename
the method.  

---- first problem: NPE in compiler
java.lang.NullPointerException
	at
org.aspectj.ajdt.internal.compiler.ast.MakeDeclsPublicVisitor.endVisit(MakeDeclsPublicVisitor.java:44)

public class Proceeding {
    public static void main(String[] args) { }
    static aspect A {
        interface IProceed {
            void proceed(Runnable next);
        }
        IProceed decorator;
        void around() : execution(void main(String[])) {
            decorator.proceed(new Runnable() {
                public void run() {
                    proceed();
                }
            });
        }
    }
}

---- second problem: incorrect error wrt number of arguments

public class Proceeding {
    public static void main(String[] args) {
    }
    static aspect A {
        void around() : execution(void main(String[])) {
            Proceeding.proceed(null); // BUG: treated as proceed(Object);
        }
    }
    static void proceed(Object o) {}
}

---- third hypothetical: we should document how ambiguity is resolved

public class Proceeding {
    public static void main(String[] args) {
    }
    static aspect A {
        void around() : execution(void main(String[])) {
            proceed(); // special form or Proceeding.proceed()?
        }
    }
    void proceed() {}
}</description><comments/></buginformation><fixedCommits><commit id="05dabd1821fffd9f353d1e965a56658b962c82d7" author="default" date="2004-08-10 13:22:08"><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/Proceed.java"><method name="findEnclosingAround" returnType="AdviceDeclaration" parameters="Scope"/></file></commit></fixedCommits></bug><bug id="100" opendate="2004-06-02 10:29:00" fixdate="2004-08-10 16:22:01"><buginformation><summary>ajc crashes when compiling the following program (binding this() and target())</summary><description>class Test
{  
	public static void main(String args[])
	{		
		new Test().method();
	}
	public void method()
	{
		new Test2().method2();
	}
}
class Test2 {
	public void method2() {}
}
aspect Plain {
	before(Test x):  call(void *.* (..)) &amp;&amp; (this(x) || target(x))
	{
	}
}</description><comments/></buginformation><fixedCommits><commit id="b75cd93e0de66996397e9f18809973abec91fe46" author="default" date="2004-08-10 16:22:01"><file name="weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java"><method name="getAdviceArgSetup" returnType="InstructionList" parameters=""/></file><file name="weaver/src/org/aspectj/weaver/patterns/ArgsPointcut.java"><method name="findResidueNoEllipsis" returnType="Test" parameters="Shadow ExposedState"/></file><file name="weaver/src/org/aspectj/weaver/patterns/ThisOrTargetPointcut.java"><method name="findResidue" returnType="Test" parameters="Shadow ExposedState"/></file><file name="weaver/src/org/aspectj/weaver/patterns/ExposedState.java"><method name="set" returnType="void" parameters="int Var"/><method name="toString" returnType="String" parameters=""/></file></commit></fixedCommits></bug><bug id="101" opendate="2004-06-30 07:51:00" fixdate="2004-08-11 12:24:27"><buginformation><summary>intertype initialisers should match field set pointcuts</summary><description>/* initialisers of intertype fields should match field set pointcuts.

   In the example below, the output should be

set field set(int C.n)
set field set(int C.m)
get field get(int C.n)
set field set(int C.n)

   but the first field set (of C.n) is not picked up.
*/



aspect Aspect {

    private int C.n = 13;

    before() : get(* C.*) {
	System.out.println("get field "+thisJoinPointStaticPart);
    }

    before() : set(* C.*)  {
	System.out.println("set field "+thisJoinPointStaticPart);
    }

    public void C.foo() {
	n++;
    }

}

class C {
    int m = 20;
}

public class ITFieldsAdvice {

    public static void main(String[] args) {
	C c = new C();
	c.foo();
    }

}</description><comments/></buginformation><fixedCommits><commit id="64183c38266114bce7aa60ff743b4b9eda5cbe2d" author="default" date="2004-08-11 12:24:27"><file name="tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java"><method name="test026_bindingThisAndTargetToTheSameFormal" returnType="void" parameters=""/></file></commit></fixedCommits></bug><bug id="102" opendate="2004-03-11 03:00:00" fixdate="2004-08-11 13:18:24"><buginformation><summary>Compile time declarations (warning and error) do not accept string concatenation (with +)</summary><description>The following code does not compile because the message uses string 
concatenation (the + operator). 


public class WarningSample {

  public void method() {}
  public void anotherMethod() {
    this.method();
  }

}

aspect WarningAspect {

  pointcut illegalCall(): call(* WarningSample.method())
                &amp;&amp; within(WarningSample);

  // the same thing happens with declare error
  declare warning: illegalCall() : "Hey, don't " +
      "do that, that is not nice. You should do something else";

}</description><comments/></buginformation><fixedCommits><commit id="d43a39103f476d95cade6b87b604ee4578de25b3" author="default" date="2004-08-11 13:18:24"><file name="tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java"><method name="test030_privateITDinitialisersBeingMatched" returnType="void" parameters=""/><method name="test026_bindingThisAndTargetToTheSameFormal" returnType="void" parameters=""/></file><file name="weaver/src/org/aspectj/weaver/patterns/PatternParser.java"><method name="parseErrorOrWarning" returnType="Declare" parameters="boolean"/></file></commit></fixedCommits></bug><bug id="103" opendate="2004-05-11 13:35:00" fixdate="2004-08-11 16:51:24"><buginformation><summary>scope for intertype methods</summary><description>/* According to the documentation, the scope rules for
   intertype method declarations are interpreted
   from the originating aspect. The only exceptions
   (I thought) are the use of "this" and "super" which refer to
   the target type.

   According to that interpretation, the program below is type correct, but
   ajc generates two error messages, shown in comments
   at the relevant lines. Note that it's ok to access private static
   fields of the aspect, but not to use private classes of the aspect.

   If this is a feature and not a bug, what are the
   precise scope rules for intertype method declarations?
*/

aspect Aspect { 

    private static int y = 5;

    private class A { int x = 3; }

    private static void B.happy() {
	System.out.println(y);          // happy accessing private field y
    }

    private static void B.foo(A z) { 
	System.out.println(z.x); 	// ERROR: The type Aspect.A is not visible
    }

    public void B.bar() {
	B.foo(new A());                 // ERROR: The type A is not visible
    }

}

class B {
}

public class IT { 


    public static void main(String[] args) { 
	new B().bar();
    } 
 
}</description><comments/></buginformation><fixedCommits><commit id="8c5d743c848479b07f3d35479292002aa01b4f70" author="default" date="2004-08-11 16:51:24"><file name="tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java"><method name="test027_itdsOnInnerClassesAsStatic" returnType="void" parameters=""/><method name="test030_privateITDinitialisersBeingMatched" returnType="void" parameters=""/></file></commit></fixedCommits></bug><bug id="104" opendate="2004-08-12 12:24:00" fixdate="2004-08-13 14:49:39"><buginformation><summary>Bad injar aspect name on Linux</summary><description>If you checkout the "JarUsingProject" project from "org.eclipse.ajdt.test/manual
testing" in the AJDT 1.1.12 tree, and look at the advised-by entries in the
outline view and the context menu of the gutter annotation, on Windows you get
"injar aspect: AbstractAspect.aj", but on Linux you get "injar aspect:
C:\eclipse30AJDTPluginTest\eclipse\workspace\JarGeneratingProject\src\p1\AbstractAspect.aj".
The Windows-style path indicates the location of the original class files in the
JAR file, which was clearly built on Windows.</description><comments/></buginformation><fixedCommits><commit id="2dfc73855a1d7ab7652476729e6575f9116e12b8" author="default" date="2004-08-13 14:49:39"><file name="asm/src/org/aspectj/asm/internal/AspectJElementHierarchy.java"><method name="createFileStructureNode" returnType="IProgramElement" parameters="String"/></file></commit></fixedCommits></bug><bug id="105" opendate="2004-07-16 11:41:00" fixdate="2004-08-17 09:37:46"><buginformation><summary>outline view shows anonymous inner classes in different way than jdt outline</summary><description>See screenshots.</description><comments/></buginformation><fixedCommits><commit id="a2469c733c9f65514c3949cb1cc7254495011894" author="default" date="2004-08-17 09:37:46"><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmHierarchyBuilder.java"><method name="visit" returnType="boolean" parameters="TypeDeclaration BlockScope"/></file></commit></fixedCommits></bug><bug id="106" opendate="2004-05-18 10:23:00" fixdate="2004-08-17 14:04:29"><buginformation><summary>proper handling of ExceptionInIntializer inside &lt;clinit&gt; in presence of after throwing advice</summary><description>When a &lt;clinit&gt; of a class contains after throwing advice that may catch
ExceptionInInitializer errors due to an embedded advice aspectOf() that
fails,  the ExceptionInIntializer error does not get properly reported.

For the example below:

public class Main {
  static int x = 13;
  int y;

  public Main() {
     y= 14;
  }

  public static void main(String args[])
    { Main m = new Main();
      m.y = 3;
      System.out.println("hi");
    }
}


aspect Aspect {

  before () :  within(*)
    { System.out.println("BEFORE " + thisJoinPointStaticPart.getKind() +
                         " at " + thisJoinPointStaticPart.getSourceLocation());
    }

  after ()  : within(*)
    { System.out.println("AFTER " + thisJoinPointStaticPart.getKind() +
                         " at " + thisJoinPointStaticPart.getSourceLocation());
    }
}


....  

when compiled with ajc, and then run,  the following exception is given,

Exception in thread "main" java.lang.NoClassDefFoundError
        at Main.&lt;clinit&gt;(Main.java:1)

when really one wants the following:

Exception in thread "main" java.lang.ExceptionInInitializerError
        at Main. ...
Caused by: org.aspectj.lang.NoAspectBoundException: Aspect
        at Aspect.aspectOf ..
        

-------------

Here is a fix ... I give the decompiled &lt;clinit&gt; for Main.java and indicate with
comments,
  look for ***LJH ****,  what can be woven to fix it.   Basically, the catch
block for after throwing,  when in &lt;clinit&gt;,  should first check if the
caught exception if a ExceptionInInitializerError, and if so just throw it.

----------- static
    {
        org.aspectj.runtime.reflect.Factory r1;
        java.lang.Throwable r2, r31;
        int $i0;

        r1 = new Factory("Main.java", Class.forName("Main"));
        ajc$tjp_0 = r1.makeSJP("field-set", r1.makeFieldSig("8-x-Main-int-"), 2);
        ajc$tjp_1 = r1.makeSJP("staticinitialization",
r1.makeInitializerSig("8--Main-"), 2);
        ajc$tjp_10 = r1.makeSJP("preinitialization",
r1.makeConstructorSig("1--Main----"), 5);
        ajc$tjp_2 = r1.makeSJP("field-set", r1.makeFieldSig("0-y-Main-int-"), 6);
        ajc$tjp_3 = r1.makeSJP("constructor-execution",
r1.makeConstructorSig("1--Main----"), 6);
        ajc$tjp_4 = r1.makeSJP("constructor-call",
r1.makeConstructorSig("1--Main----"), 10);
        ajc$tjp_5 = r1.makeSJP("field-set", r1.makeFieldSig("0-y-Main-int-"), 11);
        ajc$tjp_6 = r1.makeSJP("field-get",
r1.makeFieldSig("19-out-java.lang.System-java.io.PrintStream-"), 12);
        ajc$tjp_7 = r1.makeSJP("method-call",
r1.makeMethodSig("1-println-java.io.PrintStream-java.lang.String:-arg0:--void-"),
12);
        ajc$tjp_8 = r1.makeSJP("method-execution",
r1.makeMethodSig("9-main-Main-[Ljava.lang.String;:-args:--void-"), 10);
        ajc$tjp_9 = r1.makeSJP("initialization",
r1.makeConstructorSig("1--Main----"), 6);

 try
        {
            Aspect.aspectOf().ajc$before$Aspect$1$36f01b1c(ajc$tjp_1);
            $i0 = 13;

            try
            {
                Aspect.aspectOf().ajc$before$Aspect$1$36f01b1c(ajc$tjp_0);
                x = $i0;
            }
            catch (Throwable $r30)
            {
                /*** LJH insert here *****/
                if ($r30 instanceof ExceptionInIntializerError) //***
                  throw($r30); //***
                /***********/
                r31 = $r30;
                Aspect.aspectOf().ajc$after$Aspect$2$36f01b1c(ajc$tjp_0);
                throw r31;
            }

            Aspect.aspectOf().ajc$after$Aspect$2$36f01b1c(ajc$tjp_0);
        }
        catch (Throwable $r36)
        {
           /*** LJH insert here *****/
           if ($r36 instanceof ExceptionInIntializerError) //***
           throw($r36); //***
           /***********/
            r2 = $r36;
            Aspect.aspectOf().ajc$after$Aspect$2$36f01b1c(ajc$tjp_1);
            throw r2;
        }

        Aspect.aspectOf().ajc$after$Aspect$2$36f01b1c(ajc$tjp_1);
    }</description><comments/></buginformation><fixedCommits><commit id="84e4e53608871ab3ad0381d19abd8fa2e1bc4533" author="default" date="2004-08-17 14:04:29"><file name="weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"><method name="weaveAfterThrowing" returnType="void" parameters="BcelAdvice TypeX"/></file></commit></fixedCommits></bug><bug id="107" opendate="2004-07-29 09:58:00" fixdate="2004-08-18 10:33:07"><buginformation><summary>Missing Javadoc comments that aren't missing</summary><description>Reported in the AJDT newsgroup:

Go to Preferences &gt; Java &gt; Compiler &gt; Javadoc and set "Missing javadoc comments"
to "Warning".

You then get warnings against things you wouldn't expect, such as after advice.

/**
 * A comment
 */
public aspect World {
	pointcut greeting() : execution(* Hello.sayHello(..));
	
	/**
	 * A comment
	 */
	after() returning : greeting() {
		System.out.println("world");
	}
}

This gives two warnings, one for the aspect itself, and one for the after
returning advice. The warnings occur both with and without the existence of
Javadoc comments!</description><comments/></buginformation><fixedCommits><commit id="5b902242b00ffaf3105335f231e45291e7d09320" author="default" date="2004-08-18 10:33:07"><file name="org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/AjdtBatchTests.java"><method name="suite" returnType="Test" parameters=""/></file></commit></fixedCommits></bug><bug id="108" opendate="2004-01-07 17:27:00" fixdate="2004-08-19 16:38:16"><buginformation><summary>Weaver results in rt error if affected base class not exposed</summary><description>I was weaving a 3rd party library and wrote an aspect that should affect both a 
base class and a derived class, but inadvertently wove only the derived class.  
This resulted in the following error. I would like the weaver to catch this 
kind of error at weave (link) time, rather than creating code that results in a 
rt error... I get this error in 1.1.1 final and in a fairly recent version from 
CVS HEAD:

java.lang.AbstractMethodError
	at ajee.logging.LogManager.ajc$interMethodDispatch1
$ajee_logging_LogManager$ajee_logging_Loggable$getLogger(LogManager.java)
	at 
ajee.tracing.ExecutionTracer.ajc$before$ajee_tracing_ExecutionTracer$926
(ExecutionTracer.java:62)
	at library.Derived.&lt;init&gt;(Derived.java:46)

This line is a call to super();

I've attached a small example that reproduces another error that I think is 
related:
C:\devel\test\ctors\twoPass&gt;build

C:\devel\test\ctors\twoPass&gt;call ajc -outjar fullBase.jar sample\Base.java sampl
e\Derived.java
Exception in thread "main" java.lang.ExceptionInInitializerError
        at sample.Derived.&lt;init&gt;(Derived.java:6)
        at sample.Derived.main(Derived.java:13)
Caused by: org.aspectj.lang.NoAspectBoundException
        at sample.Trace.aspectOf(Trace.aj)
        at sample.Trace.&lt;init&gt;(Trace.aj:5)
        at sample.Trace.ajc$postClinit(Trace.aj)
        at sample.Trace.&lt;clinit&gt;(Trace.aj:5)
        ... 2 more</description><comments/></buginformation><fixedCommits><commit id="dbe1024f852c600d2752e5f39eb31ca4f5d72de9" author="default" date="2004-08-19 16:38:16"><file name="org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/AjdtBatchTests.java"><method name="suite" returnType="Test" parameters=""/></file><file name="weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java"><method name="mungeNewMethod" returnType="boolean" parameters="BcelClassWeaver"/></file></commit></fixedCommits></bug><bug id="109" opendate="2004-08-18 06:00:00" fixdate="2004-08-23 13:40:31"><buginformation><summary>Support for simple dump file</summary><description>When the compiler terminates abnormally (exception) or behaves unexpectedly 
(warning/error/abort) a simple dump of the compiler state should be produced 
to aid problem diagnosis. The content and conditions under which the dump is 
produced should be configurable by the user but the facility should be enabled 
by default for exceptions. Consequently its inclusion should have negligible 
impact on compiler performance and footprint. The file should be attached to 
bug reports to give a complete and objective description of the user鈥檚 
environment and support problem resolution where a testcase cannot be provided.

One approach is to write a uniquely name file (using date &amp; time) in the 
current directory e.g 鈥渁jcore.20040818.105200.txt鈥 which should be human 
readable (it can be zipped if large) to allow the user to potentially diagnose 
their own problems or remove potentially sensitive data before submission. It 
should contain basic information such as AspectJ version, system properties 
and command line as well as failure information such as _full_ exception stack 
trace, compiler messages and internal compiler state.</description><comments/></buginformation><fixedCommits><commit id="f5035234ee878003515413fee5e7e6bfa7a2228d" author="default" date="2004-08-23 13:40:31"><file name="org.aspectj.ajdt.core/src/org/aspectj/tools/ajc/Main.java"><method name="run" returnType="void" parameters="String[] IMessageHolder"/></file><file name="org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/AjdtBatchTests.java"><method name="suite" returnType="Test" parameters=""/></file><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java"><method name="populateBuildConfig" returnType="AjBuildConfig" parameters="AjBuildConfig String[] boolean File"/></file><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"><method name="performCompilation" returnType="void" parameters="List"/></file><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/AjdtCommand.java"><method name="doCommand" returnType="boolean" parameters="IMessageHandler boolean"/></file></commit></fixedCommits></bug><bug id="110" opendate="2004-08-24 14:42:00" fixdate="2004-08-24 21:10:56"><buginformation><summary>declare warning warns at wrong points</summary><description>I have a "declare warning" declaration that warns on usage of any method that
returns an array of any POJO type, this should point to the methods that in
reality return an array, but i see warnings at points other than these array
returning methods, and also those that have void in their signature. In the
attached files i get a warning at statements like:

 &gt;        PrinterWorld p = new PrinterWorld();[in main()method]
&gt;        System.out.println("Hello World!"); 
&gt;    	 return new Integer(3); 

and these being the first/only lines in their respective methods.</description><comments/></buginformation><fixedCommits><commit id="82eae551311afbd3a942d54e55b1c569c5f975b8" author="default" date="2004-08-24 21:10:56"><file name="weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java"><method name="resolveBindings" returnType="TypePattern" parameters="IScope Bindings"/><method name="matchesExactlyByName" returnType="boolean" parameters="String"/></file></commit></fixedCommits></bug><bug id="111" opendate="2004-08-18 03:27:00" fixdate="2004-08-27 10:03:54"><buginformation><summary>AJC possible bug with static nested classes</summary><description>AJC fails to find nested static classes during binary-weaving analysis if the 
classes have been previously compiled with J2SE5.0 javac compiler with 
options: -source 1.5/ - target 1.5
Note, that the nested static classes are not necessarily subject to bytecode 
weaving - AJC merely fails to detect them in the JARS for its analysis.

This issue disappears when the .java sources are pre-compiled with -
source/target 1.4, regardless if the javac compiler comes from the J2SE1.4 or 
J2SE5.0 distribution.

This issue is distinct form  Bug #71548 , since no 5.0 source code processing is 
required from AJC ever.

Thanks,
Hristo</description><comments/></buginformation><fixedCommits><commit id="b5e6307a63b0513cb058e8d6e56ff87287bdfa15" author="default" date="2004-08-27 10:03:54"><file name="weaver/src/org/aspectj/weaver/TypeX.java"><method name="nameToSignature" returnType="String" parameters="String"/></file></commit></fixedCommits></bug><bug id="112" opendate="2004-08-26 11:46:00" fixdate="2004-08-27 11:18:01"><buginformation><summary>Bogus error message: The abstract method ajc$pointcut$$tracingScope$a2 in type Tracing can only be defined by an abstract class</summary><description>When attempting to compile the following aspect the resulting error message 
should say something like "The abstract method pointcut tracingScope in type 
Tracing can only be defined by an abstract aspect"

public aspect Tracing {
	public abstract pointcut tracingScope();

}</description><comments/></buginformation><fixedCommits><commit id="5e0876580b0e95dd06ca4342e233f9a5dceb33a5" author="default" date="2004-08-27 11:18:01"><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/PointcutDeclaration.java"><method name="postParse" returnType="void" parameters="TypeDeclaration"/></file></commit></fixedCommits></bug><bug id="113" opendate="2004-01-08 17:37:00" fixdate="2004-09-01 10:30:07"><buginformation><summary>performance improvements for runtime library</summary><description>I am heavily using the runtime signature information from
thisJoinPoint.getSignature() and the toString() method of it. This causes heavy
String operations each time the toString method is called. Would it be possible
to cache the resulting string for example in MethodSignatureImpl and similar
classes for other signatures?</description><comments/></buginformation><fixedCommits><commit id="438e61c998298b48830d5be76668df45629a1eb0" author="default" date="2004-09-01 10:30:07"><file name="runtime/src/org/aspectj/runtime/reflect/SignatureImpl.java"><method name="makeClass" returnType="Class" parameters="String"/><method name="SignatureImpl" returnType="SignatureImpl" parameters="int String Class"/></file><file name="runtime/src/org/aspectj/runtime/reflect/InitializerSignatureImpl.java"><method name="toString" returnType="String" parameters="StringMaker"/></file><file name="runtime/src/org/aspectj/runtime/reflect/FieldSignatureImpl.java"><method name="toString" returnType="String" parameters="StringMaker"/></file><file name="runtime/src/org/aspectj/runtime/reflect/SourceLocationImpl.java"><method name="SourceLocationImpl" returnType="SourceLocationImpl" parameters="Class String int int"/><method name="getColumn" returnType="int" parameters=""/><method name="toString" returnType="String" parameters=""/></file><file name="runtime/src/org/aspectj/runtime/reflect/Factory.java"><method name="makeSourceLoc" returnType="SourceLocation" parameters="int int"/></file><file name="runtime/src/org/aspectj/runtime/reflect/ConstructorSignatureImpl.java"><method name="toString" returnType="String" parameters="StringMaker"/></file><file name="runtime/testsrc/RuntimeModuleTests.java"><method name="suite" returnType="TestSuite" parameters=""/></file><file name="runtime/src/org/aspectj/runtime/reflect/AdviceSignatureImpl.java"><method name="toString" returnType="String" parameters="StringMaker"/></file><file name="runtime/src/org/aspectj/runtime/reflect/MethodSignatureImpl.java"><method name="toString" returnType="String" parameters="StringMaker"/></file><file name="runtime/src/org/aspectj/runtime/reflect/CatchClauseSignatureImpl.java"><method name="toString" returnType="String" parameters="StringMaker"/></file></commit></fixedCommits></bug><bug id="114" opendate="2003-11-07 14:40:00" fixdate="2004-09-01 15:26:43"><buginformation><summary>Aspectj generate code does not de-compile cleanly.</summary><description>Under certain condition you can not cleanly decompile code generated by the 
aspectj compiler/byte code weaver.

package com.regular;

public class ExceptionCatcher
{
	public ExceptionCatcher()
	{
		super();
	}
	
	public void catchException()
	{
		try
		{
			ExceptionThrower throwUp = new ExceptionThrower();
			throwUp.throwException();
		}
		catch(Exception e)
		{
			System.out.println("Inside my catch block");
		}
	}
	
	public static void main(String[] args)
	{
		ExceptionCatcher catcher = new ExceptionCatcher();
		catcher.catchException();	
	}
}

package com.aop;

import org.aspectj.lang.JoinPoint;

public aspect ExceptionHandler
{
	pointcut classList() : 
		within(com.regular..*);
	
	before(Throwable e) : 
		classList() 
		&amp;&amp; handler(*)
		&amp;&amp; args(e)
	{
		System.out.println("Starting before block");
		log(thisJoinPointStaticPart, e);
		System.out.println("End of before block");
	}
		
	private void log(JoinPoint.StaticPart jp, Throwable e)
	{
		System.out.println("Class Name: " + jp.getSignature
().getDeclaringType());
		System.out.println("Error Message" + e.getMessage() );
	}
}

Runing JAD:

jad ExceptionCatcher.class
Parsing ExceptionCatcher.class... Generating ExceptionCatcher.jad
Couldn't fully decompile method catchException
Couldn't resolve all exception handlers in method catchException

Now the JAD Output:

// Decompiled by Jad v1.5.7. Copyright 1997-99 Pavel Kouznetsov.
// Jad home page:  http://www.geocities.com/SiliconValley/Bridge/8617/jad.html 
// Decompiler options: packimports(3) 
// Source File Name:   ExceptionCatcher.java

package com.regular;

import com.aop.ExceptionHandler;
import com.capitalone.risk.aop.ITestInterface;
import com.capitalone.risk.aop.ITestInterfaceAspect;
import java.io.PrintStream;
import org.aspectj.runtime.reflect.Factory;

// Referenced classes of package com.regular:
//            ExceptionThrower

public class ExceptionCatcher
    implements com.aop.IntroductionPointCut.IPhilipsTarget
{

    public ExceptionCatcher()
    {
    }

    public void catchException()
    {
        if(this instanceof ITestInterface)
            ITestInterfaceAspect.aspectOf
().ajc$before$com_capitalone_risk_aop_ITestInterfaceAspect$113((ITestInterface)
this);
        ExceptionThrower throwUp = new ExceptionThrower();
        throwUp.throwException();
        break MISSING_BLOCK_LABEL_77;
        Exception exception;
        exception;
        ExceptionHandler.aspectOf().ajc$before$com_aop_ExceptionHandler$1f8
(exception, ajc$tjp_0);
        Exception e = exception;
        System.out.println("Inside my catch block");
        break MISSING_BLOCK_LABEL_77;
        Throwable throwable;
        throwable;
        if(this instanceof ITestInterface)
            ITestInterfaceAspect.aspectOf
().ajc$after$com_capitalone_risk_aop_ITestInterfaceAspect$172((ITestInterface)
this);
        throw throwable;
        if(this instanceof ITestInterface)
            ITestInterfaceAspect.aspectOf
().ajc$after$com_capitalone_risk_aop_ITestInterfaceAspect$172((ITestInterface)
this);
        return;
    }

    public static void main(String args[])
    {
        ExceptionCatcher catcher = new ExceptionCatcher();
        catcher.catchException();
    }

    public static final org.aspectj.lang.JoinPoint.StaticPart ajc$tjp_0;

    static 
    {
        Factory factory = new Factory("ExceptionCatcher.java", Class.forName
("com.regular.ExceptionCatcher"));
        ajc$tjp_0 = factory.makeSJP("exception-handler", 
factory.makeCatchClauseSig("0--com.regular.ExceptionCatcher-
java.lang.Exception-&lt;missing&gt;-"), 33);
    }
}

The aspect class:

jad ExceptionHandler.class
Parsing ExceptionHandler.class... Generating ExceptionHandler.jad
Couldn't fully decompile method aspectOf

// Decompiled by Jad v1.5.7. Copyright 1997-99 Pavel Kouznetsov.
// Jad home page:  http://www.geocities.com/SiliconValley/Bridge/8617/jad.html 
// Decompiler options: packimports(3) 
// Source File Name:   ExceptionHandler.java

package com.aop;

import java.io.PrintStream;
import org.aspectj.lang.NoAspectBoundException;
import org.aspectj.lang.Signature;

public class ExceptionHandler
{

    public ExceptionHandler()
    {
    }

    public void ajc$before$com_aop_ExceptionHandler$1f8(Throwable e, 
org.aspectj.lang.JoinPoint.StaticPart thisJoinPointStaticPart)
    {
        System.out.println("Starting before block");
        log(thisJoinPointStaticPart, e);
        System.out.println("End of before block");
    }

    private void log(org.aspectj.lang.JoinPoint.StaticPart jp, Throwable e)
    {
        System.out.println("Class Name: " + jp.getSignature().getDeclaringType
());
        System.out.println("Error Message" + e.getMessage());
    }

    public static ExceptionHandler aspectOf()
    {
        ajc$perSingletonInstance;
        JVM INSTR dup ;
        JVM INSTR ifnull 8;
           goto _L1 _L2
_L1:
        return;
_L2:
        throw new NoAspectBoundException();
    }

    public static boolean hasAspect()
    {
        return ajc$perSingletonInstance != null;
    }

    private static void ajc$postClinit()
    {
        ajc$perSingletonInstance = new ExceptionHandler();
    }

    public static final ExceptionHandler ajc$perSingletonInstance;

    static 
    {
        ajc$postClinit();
    }
}

Enjoy!

Ron</description><comments/></buginformation><fixedCommits><commit id="4921f0c8f03353385d709bc79a7dd301c2caa5df" author="default" date="2004-09-01 15:26:43"><file name="weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"><method name="prepareForMungers" returnType="void" parameters=""/></file></commit></fixedCommits></bug><bug id="115" opendate="2004-08-24 14:21:00" fixdate="2004-09-03 13:45:46"><buginformation><summary>around advice throws java.lang.VerifyError at runtime</summary><description>I have an aspect that captures around() a pcd and returns an Object[], though
the actual methods being instrumented might return any valid POJO array, i
understand that AspectJ will take care of casting at assignment.

I expected the following code to work properly, but at runtime i get a
java.lang.VerifyError as shown below:

F:\wd\Hello&gt;ajbrowser HelloWorld.lst
java.lang.VerifyError: (class: de/rohith/PrinterWorld, method: returnArrayWithCl
oning signature: ()[Ljava/lang/Integer;) Incompatible argument to function
        at de.rohith.HelloWorld.main(HelloWorld.java:18)
Exception in thread "main"

I suspect the compiler fails to notice the return types of the methods being
caught at compile time.

I have tested this code with both ajbrowser as well as AJDT, both result in the
same error output.

-----------HelloWorldAspect.java---------------
package de.rohith;

import java.lang.Object;

public aspect HelloWorldAspect {
    
	private int callDepth = -1;

    public HelloWorldAspect() {
    }
    
    pointcut hello(): !within(HelloWorldAspect);
    
    pointcut method(): execution(public (*[]) de..*(..));
    
    pointcut cloning(): call(* java.lang.Object.clone());

    declare warning: method() &amp;&amp; hello(): "*[] returning method called" ;
    
    Object[] around(): cflow(method()) &amp;&amp; cloning() &amp;&amp; hello() {
    	print("", thisEnclosingJoinPointStaticPart);
    	Object[] ret = proceed(); 
    	return (Object[])ret.clone();
    }

    private void print(String prefix, Object message) {
        for (int i = 0, spaces = callDepth * 2; i &lt; spaces; i++) {
            System.out.print(" ");
        }
        System.out.println(prefix + message);
    }

}


-----------PrinterWorld.java------------
package de.rohith;
public class PrinterWorld {
	private Integer[] intArray = new Integer[2];
	public PrinterWorld() {
		
	}
    public void print() {
        System.out.println("Hello World!"); 
    }
    
    public Integer returnInt() {
    	return new Integer(3);
    }
    
    public Integer[] returnArrayWithCloning() {
    	for (int i = 0; i &lt; intArray.length; i++) {
			intArray[i] = new Integer(i++);
		}
    	return (Integer[])intArray.clone();
    }
    
    public Integer[] returnArrayWithoutCloning() {
    	return intArray;
    }
}

-----------HelloWorld.java------------
package de.rohith;

public class HelloWorld {

    public static void main(String[] args) {
        PrinterWorld p = new PrinterWorld();
        p.print(); 
        Integer i = p.returnInt();
        Integer[] intArray = p.returnArrayWithCloning();
        Integer[] array2 = p.returnArrayWithoutCloning();
    }
}</description><comments/></buginformation><fixedCommits><commit id="27d204cf9f57a0cc06f4d7c5800c93eb55edc02a" author="default" date="2004-09-03 13:45:46"><file name="weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"><method name="createMethodGen" returnType="LazyMethodGen" parameters="String"/><method name="initializeTargetVar" returnType="void" parameters=""/></file><file name="weaver/src/org/aspectj/weaver/ResolvedTypeX.java"><method name="isExposedToWeaver" returnType="boolean" parameters=""/></file></commit></fixedCommits></bug><bug id="116" opendate="2004-08-26 06:56:00" fixdate="2004-09-06 15:13:46"><buginformation><summary>Bootclasspath specification for compiling is not possible</summary><description>I have following bug running  eclipse 3.0 and ajdt 1.1.12

I have following class:
 
import java.io.FileNotFoundException;
import java.io.FileOutputStream;

import org.w3c.dom.DOMConfiguration;
import org.w3c.dom.DOMError;
import org.w3c.dom.DOMErrorHandler;
import org.w3c.dom.Document;
import org.w3c.dom.DocumentFragment;
import org.w3c.dom.NodeList;
import org.w3c.dom.ls.DOMImplementationLS;
import org.w3c.dom.ls.LSInput;
import org.w3c.dom.ls.LSOutput;
import org.w3c.dom.ls.LSParser;

import com.dcbank.common.DOMImplementationLSSingleton;

public class DOMHelper {

   public static final String CLASS_ID = "%full_filespec:
DOMHelper.java~1:java:1 %";
   
   public static void save(Document document, String filename)
   throws ClassNotFoundException, InstantiationException,  
IllegalAccessException, FileNotFoundException {
   
      document.normalizeDocument();
   }

}

which compiles very fine with JDK 1.4.2_02 on Windows XP, 
as soon as the  dom2-xml-apis.jar and dom3-xercesImpl.jar are added at the
beginning of the jre container, or are included in
the jar-library list before the system jar. 

As soon as I convert this project to an AspectJ project, the code does not
compile anymore. The aspectJ compiler does not find the  normalizeDocument,
which is included in the one of the two additional jars.
method any more.

kind regards
Arno Schmidmeier</description><comments/></buginformation><fixedCommits><commit id="d1551bda9b14c6c2035e0c8df6f09bf4634041de" author="default" date="2004-09-06 15:13:46"><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java"><method name="populateBuildConfig" returnType="AjBuildConfig" parameters="AjBuildConfig"/><method name="getClasspath" returnType="List" parameters="AjcConfigParser"/></file><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.java"><method name="getFullClasspath" returnType="List" parameters=""/><method name="isIncrementalFileMode" returnType="boolean" parameters=""/><method name="getOptions" returnType="AjCompilerOptions" parameters=""/></file><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"><method name="initBcelWorld" returnType="void" parameters="IMessageHandler"/><method name="makeClasspathString" returnType="String" parameters=""/><method name="checkRtJar" returnType="String" parameters="AjBuildConfig"/></file><file name="ajde/src/org/aspectj/ajde/internal/CompilerAdapter.java"><method name="configureProjectOptions" returnType="void" parameters="AjBuildConfig"/><method name="configureProjectOptions" returnType="void" parameters="AjBuildConfig ProjectPropertiesAdapter"/><method name="configureNonStandardOptions" returnType="boolean" parameters=""/></file><file name="org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/ajc/BuildArgParserTestCase.java"><method name="testPathResolutionFromConfigArgs" returnType="void" parameters=""/><method name="testBootclasspath" returnType="void" parameters=""/></file></commit></fixedCommits></bug><bug id="117" opendate="2004-09-08 05:46:00" fixdate="2004-09-08 10:14:44"><buginformation><summary>AspectJ does not correctly support -cp</summary><description>Discovered by Andy Brodie.

-cp is a shorthand for -classpath supported by the JDT compiler.  AspectJ does
not correctly support -cp option.  Look at this example:

C:\aspectj1.2&gt;ajc -inpath injar.jar -outjar outjar.jar -cp lib\aspectjrt.jar
[error] can't find type org.aspectj.lang.JoinPoint


1 error

C:\aspectj1.2&gt;ajc -inpath injar.jar -outjar outjar.jar -classpath lib\aspectjrt.jar

This is due to the arg parser in AspectJ only recognizing -classpath.  It
doesn't fail when it encounters -cp, it just ignores it and passes it down to
JDT for processing.  The fix is to recognize -cp too.</description><comments/></buginformation><fixedCommits><commit id="8e4d8980e45ba054e7d8e3e5e7ac3aca940d0758" author="default" date="2004-09-08 10:14:44"><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java"><method name="parseOption" returnType="void" parameters="String LinkedList"/></file></commit></fixedCommits></bug><bug id="118" opendate="2004-08-18 06:39:00" fixdate="2004-09-08 12:04:49"><buginformation><summary>declare soft can cause programs with invalid exception behaviour to be generated</summary><description>Compiling the program below results in the constructor for the class SCE2
throwing Exception, which it is not declared to throw either in the source code
or in the generated bytecode. If the 'declare soft' statement is removed, then
the super() call in the SCE2 constructor is correctly reported as throwing an
undeclared exception; it seems that the 'declare soft' statement turns off the
exception checking of the super() call despite there being no join point which
covers this call that would actually soften the exception.

I'm using 'DEVELOPMENT built on Monday Aug 16, 2004 at 13:50:47 GMT'.

public class SuperConsExc {
    public SuperConsExc() throws Exception {
	throw new Exception();
    }

    public static void main(String[] args) {
	new SCE2();
    }
}

class SCE2 extends SuperConsExc {
    public SCE2() {
	super();
    }
}

aspect SCEAspect {
    declare soft: Exception: within(SCE2);
}</description><comments/></buginformation><fixedCommits><commit id="eca1429e79b3dc55c1f93ffbadb3e50eb9808d9c" author="default" date="2004-09-08 12:04:49"><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/problem/AjProblemReporter.java"><method name="unhandledException" returnType="void" parameters=""/></file></commit></fixedCommits></bug><bug id="119" opendate="2004-09-19 05:51:00" fixdate="2004-10-14 08:12:09"><buginformation><summary>Applet which uses cflow pointcut gets AccessControlException</summary><description>When I used cflow pointcut for my applet, I couldn't launch the Applet.

java.lang.ExceptionInInitializerError
        at SandAspect.ajc$preClinit(SandAspect.aj)
        at SandAspect.&lt;clinit&gt;(SandAspect.aj)
        at SandApplet.init(SandApplet.java)
        at sun.applet.AppletPanel.run(AppletPanel.java:353)
        at java.lang.Thread.run(Thread.java:534)
Caused by: java.security.AccessControlException: access denied (java.util.Proper
tyPermission aspectj.runtime.cflowstack.usethreadlocal read)
        at java.security.AccessControlContext.checkPermission(AccessControlConte
xt.java:269)
        at java.security.AccessController.checkPermission(AccessController.java:
401)
        at java.lang.SecurityManager.checkPermission(SecurityManager.java:524)
        at java.lang.SecurityManager.checkPropertyAccess(SecurityManager.java:12
76)
        at java.lang.System.getProperty(System.java:612)
        at org.aspectj.runtime.internal.CFlowStack.selectFactoryForVMVersion(CFl
owStack.java:124)
        at org.aspectj.runtime.internal.CFlowStack.&lt;clinit&gt;(CFlowStack.java:59)
        ... 5 more

It because CFlowStack uses System.getProperty method with no try..catch block. 
Applet doesn't have permission to read system property:
"aspectj.runtime.cflowstack.usethreadlocal".

workaround:
modify CFlowStack.java(1.5) line 123,124 like this
-----
private static String getSystemPropertyWithNoSecurityException(
  String aPropertyName, String aDefaultValue){
  try{
    return System.getProperty(aPropertyName, aDefaultValue);
  } catch(java.lang.SecurityException e){
    return aDefaultValue;
  }
}

private static void selectFactoryForVMVersion() {
  String override = getSystemPropertyWithNoSecurityException(
    "aspectj.runtime.cflowstack.usethreadlocal"
    , "unspecified"
  );
-----
I think defining getSystemPropertyWithNoSecurityException(or more
simple name :-)) method in some utility class and using it where you call
System.getProperty are better way.</description><comments/></buginformation><fixedCommits><commit id="6e155a6b9b78ec64f2fd4dc08152698277f1e7b7" author="default" date="2004-10-14 08:12:09"><file name="runtime/src/org/aspectj/runtime/internal/CFlowStack.java"><method name="selectFactoryForVMVersion" returnType="void" parameters=""/></file><file name="runtime/src/org/aspectj/runtime/internal/CFlowCounter.java"><method name="selectFactoryForVMVersion" returnType="void" parameters=""/></file></commit></fixedCommits></bug><bug id="120" opendate="2004-10-04 10:12:00" fixdate="2004-10-14 12:51:18"><buginformation><summary>ajc changes classfile timestamps even if compilation fails (regression)</summary><description>It appears that ajc 1.2 updates a classfile timestamps even if the compilation 
fails. This breaks the integration with the Ant build system. E.g. using the 
ant "javac" task with the Ajc11CompilerAdapter interface, the compilation may 
fail on the first attempt and succeed on the second attempt, - because ajc has 
touched the timestamp and Ant hence decides that nothing needs to be recompiled.

This did not happen in ajc 1.1.

To reproduce:
1. In the examples/observer folder, run a build:
 ajc -sourceroots . 
2. Edit the "Demo.java" class and insert the line "DONT COMPILE"
3. Run the compilation again. The compiler displays the correct error message 
but the Demo.class file has been updated with the compile-time timestamp.</description><comments/></buginformation><fixedCommits><commit id="0a77939b3286d5ac033797234741436c57ad202f" author="default" date="2004-10-14 12:51:18"><file name="org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/AjdtBatchTests.java"><method name="suite" returnType="Test" parameters=""/></file><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/AjCompilerAdapter.java"><method name="afterCompiling" returnType="void" parameters=""/></file><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AspectJBuilder.java"><method name="getAdapter" returnType="ICompilerAdapter" parameters="Compiler"/></file><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java"><method name="parseOption" returnType="void" parameters="String LinkedList"/></file><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"><method name="proceedOnError" returnType="boolean" parameters=""/><method name="getAdapter" returnType="ICompilerAdapter" parameters=""/></file></commit></fixedCommits></bug><bug id="121" opendate="2004-10-12 12:17:00" fixdate="2004-10-19 10:37:31"><buginformation><summary>Anonymous classes unaware of introductions into abstract classes (error can't find type $Local$)</summary><description>The example below generates a compiler error, on both Linux and Windows. The
error occurs for ajdt (eclipse) as well.

The compiler error:

$ ajc -version
 &gt; AspectJ Compiler 1.2 built on Friday May 21, 2004 at
&gt; 15:06:22 GMT
&gt; $ ajc ConcreteClassA.java
&gt; error can't find type $Local$
&gt; 
&gt; /home/marin/tests/ConcreteClassA.java:18 error Class
&gt; must implement the inherited abstract method
&gt; InterfaceA.a2()
&gt; InterfaceA a = new AbstractClassA() {
&gt;                    ^^^^^^^^^^^^^
&gt; 
&gt; 2 errors
&gt; --------
&gt;  


The example (in ConcreteClassA.java):


interface InterfaceA {

 public void a1();
 
 public void a2();
 
}

abstract class AbstractClassA implements InterfaceA {

 public void a1() {
  System.out.println("AbstractClassA.a()");
 }
 
}


public class ConcreteClassA extends AbstractClassA {

 public void someMethod() {
  InterfaceA a = new AbstractClassA() {
  };
 }
 
}

aspect IntroAspectA {

 public void AbstractClassA.a2() {
  System.out.println("AbstractClassA.a2() from IntroAspectA");
 }
}

------------
If you comment out the body of someMethod() (the anonymous class), the code
compiles without errors.</description><comments/></buginformation><fixedCommits><commit id="6beb43faeecff249a33e7d7e2489c6a92a4700fd" author="default" date="2004-10-19 10:37:31"><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/problem/AjProblemReporter.java"><method name="abstractMethodMustBeImplemented" returnType="void" parameters=""/></file></commit></fixedCommits></bug><bug id="122" opendate="2004-10-22 07:04:00" fixdate="2004-10-22 10:53:11"><buginformation><summary>Add versions to woven class files - enabling better backwards compatibility.</summary><description>We don't currently include a version in the class files that come out of the
weaver.  This can cause problems.  For example, if we add a new attribute to a
class file in a future version of AspectJ, then that attribute will cause older
versions of AspectJ to blow up if they encounter it.  If we include a version in
the class file we can rev the version number when we add attributes (or change
the class file form in another way), and by checking that version number in the
weaver we can better determine whether we should fail if we encounter a new
attribute (or other change), or if it is safe to continue processing.

I will add a new WeaverVersion attribute that includes 2 shorts.  Major and Minor.

Encountering a major version in a class file that is greater than the version a
particular weaver is designed to understand will cause compilation to fail.

Encountering a minor version in a class file that is greater than the minor
version a particular weaver is designed to understand will not cause compilation
to fail - we will assume it is safe to continue.</description><comments/></buginformation><fixedCommits><commit id="6aa75169a769a19b3f7f26acc03a5ad81f092bb0" author="default" date="2004-10-22 10:53:11"><file name="weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"><method name="printAspectAttributes" returnType="void" parameters="PrintStream"/></file><file name="weaver/src/org/aspectj/weaver/bcel/BcelObjectType.java"><method name="unpackAspectAttributes" returnType="void" parameters=""/></file><file name="weaver/src/org/aspectj/weaver/bcel/LazyClassGen.java"><method name="writeBack" returnType="void" parameters="BcelWorld"/></file><file name="weaver/src/org/aspectj/weaver/bcel/BcelAttributes.java"><method name="readAjAttributes" returnType="List" parameters="Attribute[] ISourceContext"/></file><file name="weaver/src/org/aspectj/weaver/AjAttribute.java"><method name="read" returnType="AjAttribute" parameters="String byte[] ISourceContext"/></file><file name="weaver/src/org/aspectj/weaver/bcel/BcelField.java"><method name="unpackAttributes" returnType="void" parameters="World"/></file><file name="weaver/src/org/aspectj/weaver/bcel/BcelMethod.java"><method name="unpackAjAttributes" returnType="void" parameters="World"/></file></commit></fixedCommits></bug><bug id="123" opendate="2004-11-04 01:48:00" fixdate="2004-11-04 15:44:51"><buginformation><summary>NullPointerException in StructureSearchManager</summary><description>Calling Ajde.getDefault().getStructureSearchManager().findMatches(...)
for an AspectJ project that has not been built results in a NullPointerException
in StructureSearchManager.findMatchesHelper(...) (line 58)

Simple patch is attached.</description><comments/></buginformation><fixedCommits><commit id="aab9c2c57db1c014e03720676d7e3cac14a761aa" author="default" date="2004-11-04 15:44:51"><file name="ajde/src/org/aspectj/ajde/ui/StructureSearchManager.java"><method name="findMatchesHelper" returnType="List" parameters=""/></file></commit></fixedCommits></bug><bug id="124" opendate="2004-10-27 20:09:00" fixdate="2004-11-05 11:00:41"><buginformation><summary>Load time weaver default verbose setting</summary><description>The default setting for the load time weaver is (as of 1.2.1rc1) to produce
weaving messages rather than ignore them.  I think the default should be changed
to ignore them.  

Also, I cannot override the default setting with -Daj.weaver.versose="False". 
This is the implied syntax from docs/examples/build.xml.  If this has changed
then build.xml should be updated.  Otherwise, the weaver should be fixed to use it!</description><comments/></buginformation><fixedCommits><commit id="edd6539e53d96e60f257952e582783c7d8aac25c" author="default" date="2004-11-05 11:00:41"><file name="weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java"><method name="getFullClassPath" returnType="List" parameters="ClassLoader"/><method name="isIgnoring" returnType="boolean" parameters="Kind"/><method name="addAspectLibrary" returnType="void" parameters="File"/><method name="handleMessage" returnType="boolean" parameters="IMessage"/><method name="addURL" returnType="void" parameters="URL"/><method name="shouldWeave" returnType="boolean" parameters="String"/><method name="init" returnType="void" parameters="List List"/><method name="weaveClass" returnType="byte[]" parameters="String byte[]"/><method name="registerAspectLibraries" returnType="void" parameters="List"/></file></commit></fixedCommits></bug><bug id="125" opendate="2004-12-06 05:20:00" fixdate="2004-12-06 10:38:07"><buginformation><summary>Order of types passed to compiler determines weaving behavior</summary><description>Currently, the order in which you specify types when passing them to the
compiler can affect how they are woven:

For example, if we have class A and class B extends A - Also, an aspect that
'declare parents: A+ implements Serializable' then depending on whether we see A
first, we may or may not make B serializable.

The fix is that when we weave a type, we first weave its supertype then its
superinterfaces (if they were also passed to the compiler).

The problematic construct is declare parents - so we only process the types in a
special order if there are declare parents around.  Also, because we can't
currently do decp when binary weaving, the order processing logic is only being
put into the source weaving pipeline.</description><comments/></buginformation><fixedCommits><commit id="9052d5d86cfcdeb9a64ed903beea53d077f0de08" author="default" date="2004-12-06 10:38:07"><file name="tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"><method name="test" returnType="void" parameters=""/></file><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java"><method name="completeTypeBindings" returnType="void" parameters=""/></file></commit></fixedCommits></bug><bug id="126" opendate="2004-12-14 06:01:00" fixdate="2004-12-20 14:44:07"><buginformation><summary>In some cases the structure model doesn't contain the "matches declare" relationship</summary><description>With a project containing one class and one aspect:

public class HelloClass {

	public static void main(String[] args) {
		new HelloClass().sayHello();
	}
	
	public void sayHello() {
		System.out.println("Hello");
	}
	
}


public aspect A1 {

	pointcut test() : get(* System.out);
	
	declare warning : test() &amp;&amp; !within(A1)
		 : "test warning";
	
	pointcut anotherTest() : 
		execution(void HelloClass.sayHello(..));
	
	after() returning : anotherTest() {
		System.out.println("returning....");
	}
		
}

The following is returned from the structure model:

asmRelMap entry: HelloClass.sayHello(), relationship: advised by, target: 
A1.afterReturning(): anotherTest..
asmRelMap entry: A1.afterReturning(): anotherTest.., relationship: uses 
pointcut, target: A1.anotherTest()
asmRelMap entry: A1.afterReturning(): anotherTest.., relationship: advises, 
target: HelloClass.sayHello()
asmRelMap entry: HelloClass.sayHello(), relationship: advised by, target: 
A1.afterReturning(): anotherTest..
asmRelMap entry: A1.anotherTest(), relationship: pointcut used by, target: 
A1.afterReturning(): anotherTest..
asmRelMap entry: A1.declare warning: "test warning", relationship: matched by, 
target: HelloClass.sayHello()

In other words, the model is saying that there are two entries the same:

asmRelMap entry: HelloClass.sayHello(), relationship: advised by, target: 
A1.afterReturning(): anotherTest..

whereas one of these should be the "matches declare" relationship relating to 
the declare warning.

Changing the aspect to be:


public aspect A1 {

	pointcut test() : get(* System.out);
	
	declare warning : test() &amp;&amp; !within(A1)
		 : "test warning";
	
	pointcut anotherTest() : 
		execution(void HelloClass.sayHello(..));
	
	after() returning : anotherTest() {
		System.out.println("returning....");
	}
	
	after() returning : test() {
		System.out.println("returning again!");
	}
	
}

means that the IRelationshipMap does now contain the "matches declare" 
relationship.

This is all with AspectJ 5 M1.</description><comments/></buginformation><fixedCommits><commit id="427c0d3dfdcc6a74c7e0bc6fcf1f55206ee04a8e" author="default" date="2004-12-20 14:44:07"><file name="weaver/src/org/aspectj/weaver/AsmRelationshipProvider.java"><method name="checkerMunger" returnType="void" parameters="IHierarchy Shadow Checker"/></file></commit></fixedCommits></bug><bug id="127" opendate="2005-01-01 15:07:00" fixdate="2005-01-04 13:15:57"><buginformation><summary>WeaveMessage should provide more information</summary><description>It would be wonderful if the WeaveMessage object would provide two additional
things:

- the affected class name
- the aspect name

I could use this to determine which aspect is woven into which class during
load-time weaving (need this for dependency management).</description><comments/></buginformation><fixedCommits><commit id="98976598593e8a1f89e9628e8fc11c7822b8e3d4" author="default" date="2005-01-04 13:15:57"><file name="weaver/src/org/aspectj/weaver/bcel/BcelWorld.java"><method name="makeBcelObjectType" returnType="BcelObjectType" parameters="ResolvedTypeX.Name JavaClass boolean"/></file><file name="weaver/src/org/aspectj/weaver/Shadow.java"><method name="reportWeavingMessage" returnType="void" parameters="ShadowMunger"/></file><file name="weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java"><method name="munge" returnType="boolean" parameters="BcelClassWeaver"/></file></commit></fixedCommits></bug><bug id="128" opendate="2004-12-23 10:54:00" fixdate="2005-01-05 15:15:28"><buginformation><summary>Annotation matching using within() PCD doesn't appear to be working.</summary><description>From discussion on aspectj list:

Hi,

Well, having just done some testing, I think this even simpler case shows 
within() is not behaving correctly for annotations:

@Entity
public class myClass1 {...}

public class myClass2 {...}

public aspect myAspect {
  before():call(* *(..)) &amp;&amp; within(@Entity *) {
  }
}

The pointcut matches all the method calls in myClass1 and myClass2 
(effectively it is parsing but then ignoring the annotation specified
in the within()).

So, what you want to do is valid but AspectJ is misbehaving - you get a 
stack overflow because the perthis() clause is also matching on your aspect 
type when obviously that doesnt have the annotation and shouldnt be matched.



Andy.
---
Andy Clement
AspectJ Development



Rifflard Micka毛l &lt; Mickael.Rifflard@atosorigin.com &gt; 
Sent by:  aspectj-users-admin@eclipse.org 
22/12/2004 16:56
Please respond to
 aspectj-users@eclipse.org 
	
To
&lt; aspectj-users@eclipse.org &gt;
cc

Subject
[aspectj-users] Aspect instance on JDK 1.5 annotation
	

	


Hi all, 
I'm currently trying to get an aspect instance for an object instance with
specific JDK 1.5 annotation. 
Exemple : 
        Create an aspect instance for all object like that : 
        @Entity 
        public class myClass { ... } 
I try 
        public aspect myAspect perthis(within(@Entity *)) {...} 
but this aspect execution lead to a java.lang.StackOverflowError exception. 
Is it possible ? 
Thanks. 
        Micka毛l 
        
_______________________________________________ aspectj-users mailing list
 aspectj-users@eclipse.org   http://dev.eclipse.org/mailman/listinfo/aspectj-users</description><comments/></buginformation><fixedCommits><commit id="8a8930fd9808b03e3c117086d7ba0eaa654a2438" author="default" date="2005-01-05 15:15:28"><file name="weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java"><method name="matchesExactly" returnType="boolean" parameters="ResolvedTypeX"/></file><file name="weaver/src/org/aspectj/weaver/patterns/HandlerPointcut.java"><method name="matchInternal" returnType="FuzzyBoolean" parameters="Shadow"/></file><file name="tests/src/org/aspectj/systemtest/ajc150/AnnotationRuntimeTests.java"><method name="test007_Within_Code" returnType="void" parameters=""/></file><file name="weaver/src/org/aspectj/weaver/patterns/ExactAnnotationTypePattern.java"><method name="resolve" returnType="void" parameters="World"/></file><file name="weaver/src/org/aspectj/weaver/patterns/ExactTypePattern.java"><method name="matchesInstanceof" returnType="FuzzyBoolean" parameters="ResolvedTypeX"/><method name="matchesExactly" returnType="boolean" parameters="ResolvedTypeX"/></file><file name="weaver/src/org/aspectj/weaver/patterns/WithinPointcut.java"><method name="fastMatch" returnType="FuzzyBoolean" parameters="FastMatchInfo"/><method name="matchInternal" returnType="FuzzyBoolean" parameters="Shadow"/><method name="isWithinType" returnType="FuzzyBoolean" parameters="ResolvedTypeX"/></file></commit></fixedCommits></bug><bug id="129" opendate="2005-01-04 09:40:00" fixdate="2005-01-07 14:14:45"><buginformation><summary>AspectJ 5 M2 should implement backwards compatibility for binary aspect form</summary><description>Hi Adrian,

thanks for the detailed explanation of the compatibility questions. That 
explains the problem I observed.

 &gt; * An AspectJ program should always be run with the aspectjrt.jar runtime 
&gt; library that accompanies the distribution containing the compiler/weaver 
&gt; used to build it.  

Interesting point. Which one? The one that is used to compile it or the 
one that is used to weave it?

 &gt; However, instead of some IOException, what you should see is a nice 
&gt; message saying that the aspect was produced by a more recent version of 
&gt; AspectJ and cannot be read. Likewise, if you load a pre-aspectj 5 aspect 
&gt; into the AspectJ 5 weaver right now, you'll also see an IOException 
&gt; (odds-on). In M2 we'll detect that and use the back-level loaders to read 
&gt; it in. 

Okay. Is there a bug to track this? I really would like to update the 
weaver of my weaving runtime but only if it allows to load/weave 
asepects that are compiled with any of the AJDT versions that are out 
right now (AJDT 1.1.x and AJDT 1.2.0Mx).</description><comments/></buginformation><fixedCommits><commit id="797b6a6afb75b14dc530bc0831566e110da3ae91" author="default" date="2005-01-07 14:14:45"><file name="weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"><method name="printAspectAttributes" returnType="void" parameters="PrintStream"/></file><file name="weaver/src/org/aspectj/weaver/bcel/BcelObjectType.java"><method name="unpackAspectAttributes" returnType="void" parameters=""/></file><file name="weaver/src/org/aspectj/weaver/bcel/BcelAttributes.java"><method name="readAjAttributes" returnType="List" parameters="Attribute[] ISourceContext IMessageHandler"/></file><file name="weaver/src/org/aspectj/weaver/patterns/AndAnnotationTypePattern.java"><method name="read" returnType="AnnotationTypePattern" parameters="DataInputStream ISourceContext"/></file><file name="tests/src/org/aspectj/systemtest/ajc150/AllTestsJava5_binaryWeaving.java"><method name="suite" returnType="Test" parameters=""/></file><file name="weaver/src/org/aspectj/weaver/AjAttribute.java"><method name="read" returnType="WeaverVersionInfo" parameters="DataInputStream"/><method name="read" returnType="EffectiveSignatureAttribute" parameters="DataInputStream ISourceContext"/><method name="read" returnType="PrivilegedAttribute" parameters="DataInputStream ISourceContext"/><method name="read" returnType="AdviceAttribute" parameters="DataInputStream ISourceContext"/><method name="read" returnType="MethodDeclarationLineNumberAttribute" parameters="DataInputStream"/><method name="read" returnType="SourceContextAttribute" parameters="DataInputStream"/><method name="read" returnType="AjAttribute" parameters="String byte[] ISourceContext IMessageHandler"/></file><file name="weaver/src/org/aspectj/weaver/WeaverStateInfo.java"><method name="read" returnType="WeaverStateInfo" parameters="DataInputStream ISourceContext"/></file><file name="weaver/src/org/aspectj/weaver/AdviceKind.java"><method name="read" returnType="AdviceKind" parameters="DataInputStream"/></file><file name="weaver/src/org/aspectj/weaver/bcel/BcelField.java"><method name="unpackAttributes" returnType="void" parameters="World"/></file><file name="weaver/src/org/aspectj/weaver/ResolvedPointcutDefinition.java"><method name="read" returnType="ResolvedPointcutDefinition" parameters="DataInputStream ISourceContext"/></file><file name="weaver/src/org/aspectj/weaver/bcel/BcelMethod.java"><method name="unpackAjAttributes" returnType="void" parameters="World"/></file></commit></fixedCommits></bug><bug id="130" opendate="2004-11-06 13:47:00" fixdate="2005-01-11 11:22:15"><buginformation><summary>Injecting exception into while loop with break statement causes catch block to be ignored</summary><description>In order to test exception scenarios in an existing framework, I have
created an aspect to inject an exception.  The exception is injected into
some code running within a try/catch/finally block.  After the exception is
thrown, I am expecting control to pass to the catch block.  However, what
is happening is that the catch block code is not executed, control passes
through the finally block and the (undeclared) exception is thrown to the
calling method.

Here is a distilled test case:

public class MainClass {

       protected Integer counter;
       private int j;

       public static void main(String[] args) {

               MainClass mh = new MainClass();
               try {
                       mh.doSomething();
               } catch (Exception e) {
                       System.out.println("Exception thrown by
doSomething!!!!!");
                       e.printStackTrace();
               }
       }

       public void doSomething() {
               int i = 0;
               while (i++ &lt; 1) {
                       counter=null;

                       try {
                               counter = getCounter();
                               if (counter == null) {
                                       break;
                               }

                               commit();
                       } catch (Throwable e) {
                               System.out.println("Caught exception " +
e);
                       } finally {
                               System.out.println("In finally block");
                       }
               }
       }

       protected Integer getCounter() {
               return new Integer(j++);
       }

       protected void commit() throws SQLException {
               System.out.println("Main.commit");
       }
}

The following aspect injects the exception:

public aspect SimpleExceptionThrowingAspect {

   pointcut commitOperation() : call (* MainClass+.commit(..));

   before() throws SQLException : commitOperation() {
        throw new SQLException("Dummy SQL Exception", "55102");
   }
}

Expected output is:
       Caught exception java.sql.SQLException: Dummy SQL Exception
       In finally block

Actual output is:
       In finally block
       Exception thrown by doSomething!!!!!
       java.sql.SQLException: Dummy SQL Exception        at
nz.govt.moh.test.SimpleExceptionThrowingAspect.ajc$before$nz_govt_moh_test_SimpleExceptionThrowingAspect$1$292c82f1(SimpleExceptionThrowingAspect.aj:10)

       at nz.govt.moh.test.MainClass.doSomething(MainClass.java:32)
       at nz.govt.moh.test.MainClass.main(MainClass.java:14)


Removing the "break;" statement from MainClass.java causes the expected
output to be produced.</description><comments/></buginformation><fixedCommits><commit id="603b063ecd2943e20f099712d9b754b19a380fee" author="default" date="2005-01-11 11:22:15"><file name="weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"><method name="remap" returnType="InstructionHandle" parameters="InstructionHandle Map"/><method name="insertHandler" returnType="void" parameters="ExceptionRange LinkedList"/></file><file name="tests/src/org/aspectj/systemtest/AllTests.java"><method name="suite" returnType="Test" parameters=""/></file></commit></fixedCommits></bug><bug id="131" opendate="2005-01-05 04:49:00" fixdate="2005-01-13 04:22:51"><buginformation><summary>fails to doc spacewar using AJDT 1.2.0M2</summary><description>Using AJDT 1.2.0M2 {with Java 5 JRE on XP SP2}, install Spacewar example and
generate to Spacewar/docs.  
Result: output has no cross-references (and displays special AJDT tags), and
stderr lists this exception:

java.lang.StringIndexOutOfBoundsException: String index out of range: -1
	at java.lang.AbstractStringBuilder.insert(AbstractStringBuilder.java:980)
	at java.lang.StringBuffer.insert(StringBuffer.java:447)
	at
org.aspectj.tools.ajdoc.HtmlDecorator.insertDeclarationsDetails(HtmlDecorator.java:350)
	at
org.aspectj.tools.ajdoc.HtmlDecorator.addAspectDocumentation(HtmlDecorator.java:234)
	at org.aspectj.tools.ajdoc.HtmlDecorator.decorateHTMLFile(HtmlDecorator.java:188)
	at
org.aspectj.tools.ajdoc.HtmlDecorator.decorateHTMLFromDecl(HtmlDecorator.java:116)
	at
org.aspectj.tools.ajdoc.HtmlDecorator.decorateHTMLFromDecls(HtmlDecorator.java:54)
	at
org.aspectj.tools.ajdoc.HtmlDecorator.decorateHTMLFromInputFiles(HtmlDecorator.java:43)
	at org.aspectj.tools.ajdoc.Main.main(Main.java:210)</description><comments/></buginformation><fixedCommits><commit id="f70b383d6292995c1e0521e7312e827022fe8fc9" author="default" date="2005-01-13 04:22:51"><file name="ajdoc/src/org/aspectj/tools/ajdoc/HtmlDecorator.java"><method name="findSummaryIndex" returnType="int" parameters="StringBuffer int"/><method name="findDetailsIndex" returnType="int" parameters="StringBuffer int"/></file><file name="ajdoc/testsrc/org/aspectj/tools/ajdoc/CoverageTestCase.java"><method name="testCoverage" returnType="void" parameters=""/><method name="testCoveragePublicMode" returnType="void" parameters=""/></file><file name="ajdoc/testdata/coverage/foo/ModelCoverage.java"><method name="doIt" returnType="void" parameters=""/></file></commit></fixedCommits></bug><bug id="132" opendate="2005-01-06 12:25:00" fixdate="2005-01-13 15:53:01"><buginformation><summary>Visibility selector ignored for pointcuts</summary><description>Using ajdoc under AJDT 1.1.12 or AspectJ 1.2.1 at the commandline has the 
following aspect has problems.

public abstract aspect Aspect {

	private pointcut privatePointcut ();
	protected pointcut protectedPointcut ();
	public pointcut publicPointcut ();
	
	private void privateMethod () {
		
	}
	
	public void protectedMethod () {
		
	}
	
	public void publicMethod () {
		
	}
}

1. Asking for "protected" gives all pointcuts (public, protected _and_ private)
2. The Aspect entry is wrong: "public abstract class Aspect"
3. The "Methods inherited ..." section has a leading comma: ", clone, equals, 
finalize, ..."</description><comments/></buginformation><fixedCommits><commit id="b460597575b05920885bd2f5f226b0140b687d6e" author="default" date="2005-01-13 15:53:01"><file name="ajdoc/src/org/aspectj/tools/ajdoc/HtmlDecorator.java"><method name="insertDeclarationsDetails" returnType="void" parameters="StringBuffer"/><method name="decorateHTMLFromInputFiles" returnType="void" parameters="Hashtable"/><method name="decorateHTMLFromDecl" returnType="void" parameters="Declaration"/><method name="insertDeclarationsSummary" returnType="void" parameters="StringBuffer"/><method name="addAspectDocumentation" returnType="void" parameters="IProgramElement StringBuffer int"/></file><file name="ajdoc/src/org/aspectj/tools/ajdoc/StubFileGenerator.java"><method name="processMembers" returnType="void" parameters=""/></file></commit></fixedCommits></bug><bug id="133" opendate="2005-01-24 14:59:00" fixdate="2005-01-25 20:18:42"><buginformation><summary>pertypewithin() handing of inner classes</summary><description>It seems that pertypewithin() aspect association does not handle nested classes
correctly. Here is a test class that exhibits the problem:

package test;

public class Test {
    public static void main(String[] args) {
        new NestedTest().run();
    }
	
    static class NestedTest implements Runnable {
        public void run() {
            System.out.println("Running...");
        }
    }
}
 
aspect PertypewithinTest pertypewithin(Test) {
    before() : execution(* *.*(..)) {
        System.out.println(thisJoinPointStaticPart);
    }	
}

 &gt; ajc -version 
AspectJ Compiler DEVELOPMENT built on Monday Jan 24, 2005 at 17:07:00 GMT

 &gt; ajc test\Test.java 

 &gt; java test.Test 
execution(void test.Test.main(String[]))
execution(void test.Test.bar())
Exception in thread "main" java.lang.NoSuchMethodError: test.Test$1.ajc$test_Per
typewithinTest$localAspectOf()Ltest/PertypewithinTest;
        at test.Test$1.run(Test.java)
        at test.Test.bar(Test.java:9)
        at test.Test.main(Test.java:13)

The same problem is seen for anonymous inner classes, as well:
package test;

public class Test {
    public void bar() {
        new Runnable() {
            public void run() {
                System.out.println("Running...");
            }
        }.run();
    }
        
    public static void main(String[] args) {
        new Test().bar();
    }
}
 
aspect PertypewithinTest pertypewithin(Test) {
    before() : execution(* *.*(..)) {
        System.out.println(thisJoinPoint);
    }    
}

 &gt; ajc test\Test.java
&gt; java test.Test 
execution(void test.Test.main(String[]))
execution(void test.Test.bar())
Exception in thread "main" java.lang.NoSuchMethodError: test.Test$1.ajc$test_Per
typewithinTest$localAspectOf()Ltest/PertypewithinTest;
        at test.Test$1.run(Test.java)
        at test.Test.bar(Test.java:9)
        at test.Test.main(Test.java:13)</description><comments/></buginformation><fixedCommits><commit id="1b01255892ef222c14fea25b5db77208f1f6bb13" author="default" date="2005-01-25 20:18:42"><file name="weaver/src/org/aspectj/weaver/patterns/PerTypeWithin.java"><method name="concretize" returnType="PerClause" parameters="ResolvedTypeX"/></file><file name="weaver/src/org/aspectj/weaver/PerTypeWithinTargetTypeMunger.java"><method name="matches" returnType="boolean" parameters="ResolvedTypeX ResolvedTypeX"/><method name="getTestPointcut" returnType="Pointcut" parameters=""/></file></commit></fixedCommits></bug><bug id="134" opendate="2005-01-25 11:20:00" fixdate="2005-01-26 14:01:30"><buginformation><summary>@AJ</summary><description>Andy wants a patch format + a bugzilla for @AJ work due to some funny license issue.
Here it is as drafted</description><comments/></buginformation><fixedCommits><commit id="7b4c7d7befe53b132713ba8a5b32729344fbd62e" author="default" date="2005-01-26 14:01:30"><file name="bcel-builder/src/org/aspectj/apache/bcel/generic/MethodGen.java"><method name="getArgumentNames" returnType="String[]" parameters=""/></file></commit></fixedCommits></bug><bug id="135" opendate="2005-01-24 17:13:00" fixdate="2005-01-27 17:21:17"><buginformation><summary>BCException "bad type name" thrown when compiling</summary><description>I just downloaded AJDT version 1.2.0.20050124144759 and I am running Eclipse
3.1M4.  I tried to use aspectJ on an existing Java 5 project.  There are no
aspects in it yet, just straight Java 5.  The project runs just fine as a
standard Java project. 

When add the AspectJ nature and I try to compile the project, no class files are
generated and I get this error generated on a type that is parameterized:

Internal compiler error
org.aspectj.weaver.BCException: Bad type name: 

	at org.aspectj.weaver.TypeX.nameToSignature(TypeX.java:634)

	at org.aspectj.weaver.TypeX.forName(TypeX.java:87)

	at
org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.fromBinding(EclipseFactory.java:155)

	at
org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.fromBindings(EclipseFactory.java:163)

	at
org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.makeResolvedMember(EclipseFactory.java:229)

	at
org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.makeResolvedMember(EclipseFactory.java:224)

	at
org.aspectj.ajdt.internal.core.builder.AsmHierarchyBuilder.visit(AsmHierarchyBuilder.java:675)

	at
org.aspectj.org.eclipse.jdt.internal.compiler.ast.ConstructorDeclaration.traverse(ConstructorDeclaration.java:447)

	at
org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.traverse(TypeDeclaration.java:1133)

	at
org.aspectj.org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.traverse(CompilationUnitDeclaration.java:314)

	at
org.aspectj.ajdt.internal.core.builder.AsmHierarchyBuilder.internalBuild(AsmHierarchyBuilder.java:171)

	at
org.aspectj.ajdt.internal.core.builder.AsmHierarchyBuilder.buildStructureForCompilationUnit(AsmHierarchyBuilder.java:111)

	at
org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.finishedCompilationUnit(EclipseFactory.java:354)

	at
org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterProcessing(AjCompilerAdapter.java:138)

	at
org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:373)

	at
org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:682)

	at
org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:168)

	at
org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:102)

	at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:122)

	at
org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:165)


The source code of the file that generates this error is:

package mj.compiler.ast;

import java.util.Vector;

import mj.compiler.Driver;
import mj.compiler.Visitor;

public class Sequence&lt;T extends AST&gt; extends AST {
	
	private Vector&lt;T&gt; elements = new Vector&lt;T&gt;();
	
	public Sequence() {
		super(0, 0);
    }
	
	public Sequence(T element) {
		super(element);
		elements.add(element);
    }
    
	public int length()       { return elements.size(); }
	public T elementAt(int i) { return elements.elementAt(i); }

    public Sequence add(T element) {
    	elements.add(element);
		return this;
    }
    
    public Sequence add(int pos, T element) {
    	elements.add(pos, element);
    	return this;
    }
    
    public Sequence addAll(Sequence&lt;T&gt; others) {		
		if(  others == null ) return this;
		elements.addAll(others.elements);
		return this;
    }
    
    public void visitChildren(Visitor v) {
    	for( AST element : elements ) {
    		element.visit(v);
        }
    }
    
    public void replaceChild(AST old, AST gnu) {
    	T NEW = (T)gnu;
    	for(int i = 0; i &lt; elements.size(); i++ ) {
    		if( elements.get(i) == old ) {
    			elements.set(i, NEW);
    			return;
    		}
    	}
    	throw new Driver.CompileError("Can't find child in replaceChild.");
    }

	/*** START GENERATED VISITOR PROTOCOL ***///TODO
    public void visit(mj.compiler.Visitor v) {
        v.visitSequence(this);
    }
	/*** END GENERATED VISITOR PROTOCOL ***/
}


Hope this helps something.

ps- I am able to create and run a very simple AspectJ project with an aspect,
advice, and some Java 5 syntax.</description><comments/></buginformation><fixedCommits><commit id="5765d534a5437b624646ff20ca487346fa76a267" author="default" date="2005-01-27 17:21:17"><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmHierarchyBuilder.java"><method name="visit" returnType="boolean" parameters="ConstructorDeclaration"/><method name="genBytecodeInfo" returnType="void" parameters="MethodDeclaration"/></file><file name="ajde/testsrc/org/aspectj/ajde/AjdeTests.java"><method name="suite" returnType="Test" parameters=""/></file></commit></fixedCommits></bug><bug id="136" opendate="2005-02-27 16:24:00" fixdate="2005-03-09 14:13:14"><buginformation><summary>annotations and "circularity in declare precedence"</summary><description>The following example

    declare precedence : (@PremiumPartner *), *;

results in the error message

    circularity in declare precedence, ''*'' occurs more than once   

It is the same example (apart form the name) as in the developers notebook.
(see also  http://dev.eclipse.org/mhonarc/lists/aspectj-dev/msg01326.html )</description><comments/></buginformation><fixedCommits><commit id="f90186cb8eac1b4abae4c9b8fd74828b98f534ab" author="default" date="2005-03-09 14:13:14"><file name="weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java"><method name="resolveBindings" returnType="TypePattern" parameters="IScope Bindings"/><method name="isStar" returnType="boolean" parameters=""/><method name="matchesExactlyByName" returnType="boolean" parameters="String"/></file></commit></fixedCommits></bug><bug id="137" opendate="2005-03-08 10:11:00" fixdate="2005-03-10 13:34:55"><buginformation><summary>NPE when unresolved type of a bound var in a pointcut expression (EclipseFactory.java:224)</summary><description>see attached mini-project to reproduce</description><comments/></buginformation><fixedCommits><commit id="85aa1520881e7271e658b9377dfd020fde28868c" author="default" date="2005-03-10 13:34:55"><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmHierarchyBuilder.java"><method name="getPointcutDeclaration" returnType="ResolvedMember" parameters="ReferencePointcut"/></file></commit></fixedCommits></bug><bug id="138" opendate="2005-03-21 12:05:00" fixdate="2005-03-22 13:14:44"><buginformation><summary>an array type as the last parameter in a signature does not match on the varargs declared method</summary><description>I get this warning in my code, though I actually do not specify an array type.

The signature I want to match is the following constructor signature:

public Touple(Object formulaHandle, Object... propositions) {...}

Touple implements IRelation

The pointcut I use is the following:

pointcut p(): call(Touple.new(..));

This should actually match the signature, shouldn't it?
AspectJ however complains with this warning:

an array type as the last parameter in a signature does not match on the varargs 
declared method: void ltlrv.Touple.&lt;init&gt;(java.lang.Object, java.lang.Object[]) 
[Xlint:cantMatchArrayTypeOnVarargs]

Also, even if I *had* stated an array type, it should match even then IMHO, 
since arrays and varargs are actually the same in the Java implementation.</description><comments/></buginformation><fixedCommits><commit id="b5f4d09e4f4e45943c6c8b3dc8dca0c05b90f27c" author="default" date="2005-03-22 13:14:44"><file name="weaver/src/org/aspectj/weaver/patterns/SignaturePattern.java"><method name="isNotMatchBecauseOfVarargsIssue" returnType="boolean" parameters="TypePatternList int"/></file></commit></fixedCommits></bug><bug id="139" opendate="2004-10-12 03:43:00" fixdate="2005-03-23 13:45:09"><buginformation><summary>Some Pointcut PatternNodes are missing getters to traverse syntax tree</summary><description>In order to find out which other pointcuts are referenced by a pointcut definition  
i need to access the private members of the CflowPointcut, IfPointcut and
NotPointcut PatternNodes found in the weaver module.

Unlike the OrPointcut and AndPointcut classes, they are missing the appropriate
getter methods.</description><comments/></buginformation><fixedCommits><commit id="b0f270ee1090daf7b5aec3b534b98d28955f77bd" author="default" date="2005-03-23 13:45:09"><file name="weaver/src/org/aspectj/weaver/patterns/IfPointcut.java"><method name="alwaysTrue" returnType="boolean" parameters=""/></file><file name="weaver/src/org/aspectj/weaver/patterns/CflowPointcut.java"><method name="couldMatchKinds" returnType="Set" parameters=""/></file></commit></fixedCommits></bug><bug id="140" opendate="2005-02-01 05:03:00" fixdate="2005-03-23 16:47:55"><buginformation><summary>Allow aspectPath to contain directories</summary><description>The -aspectpath option to the compiler only allows jar/zip files, not
directories. But inpath and classpath allow directories.

This capability would improve the handling of aspects spanning multiple projects
in Eclipse. AJDT can currently only support jar/zip files on the aspect path,
which requires one of the projects to create an outjar instead of writing to the
bin directory as usual.

The iajc ant task could then also be enhanced to support aspectpath directories.</description><comments/></buginformation><fixedCommits><commit id="68f63508828d1c1ea7076d051cc77713625f6a03" author="default" date="2005-03-23 16:47:55"><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java"><method name="pathChange" returnType="boolean" parameters="AjBuildConfig AjBuildConfig"/><method name="changed" returnType="boolean" parameters="List List"/></file><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java"><method name="parseOption" returnType="void" parameters="String LinkedList"/></file><file name="weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java"><method name="addLibraryJarFile" returnType="void" parameters="File"/></file></commit></fixedCommits></bug><bug id="141" opendate="2005-02-03 10:14:00" fixdate="2005-03-23 20:26:21"><buginformation><summary>BCException: Bad type name: TypeX.nameToSignature(TypeX.java:635)</summary><description>To reproduce:
  cd doc\examples\introduction
  ajc -1.5 @files.lst

Output from ajcore is below. This looks similar to  bug 83565 , but we aren't
building the structure model here.


---- AspectJ Properties ---
AspectJ Compiler DEVELOPMENT built on Tuesday Feb 1, 2005 at 18:05:49 GMT
---- Dump Properties ---
Dump file: ajcore.20050203.150321.210.txt
Dump reason: org.aspectj.weaver.BCException
Dump on exception: true
Dump at exit condition: abort
---- Exception Information ---
org.aspectj.weaver.BCException: Bad type name: 
	at org.aspectj.weaver.TypeX.nameToSignature(TypeX.java:635)
	at org.aspectj.weaver.TypeX.forName(TypeX.java:88)
	at
org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.fromBinding(EclipseFactory.java:155)
	at
org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.fromBindings(EclipseFactory.java:163)
	at
org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.makeResolvedMember(EclipseFactory.java:229)
	at
org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.makeResolvedMember(EclipseFactory.java:224)
	at
org.aspectj.ajdt.internal.compiler.problem.AjProblemReporter.abstractMethodMustBeImplemented(AjProblemReporter.java:203)
	at
org.aspectj.org.eclipse.jdt.internal.compiler.lookup.MethodVerifier.checkAbstractMethod(MethodVerifier.java:96)
	at
org.aspectj.org.eclipse.jdt.internal.compiler.lookup.MethodVerifier.checkMethods(MethodVerifier.java:261)
	at
org.aspectj.org.eclipse.jdt.internal.compiler.lookup.MethodVerifier.verify(MethodVerifier.java:575)
	at
org.aspectj.org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.verifyMethods(SourceTypeBinding.java:1376)
	at
org.aspectj.org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope.verifyMethods(CompilationUnitScope.java:672)
	at
org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:543)
	at
org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:365)
	at
org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:682)
	at
org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:168)
	at
org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:102)
	at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:109)
	at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:60)
	at org.aspectj.tools.ajc.Main.run(Main.java:291)
	at org.aspectj.tools.ajc.Main.runMain(Main.java:227)
	at org.aspectj.tools.ajc.Main.main(Main.java:80)
---- System Properties ---
java.runtime.name=Java(TM) 2 Runtime Environment, Standard Edition
sun.boot.library.path=e:\sun150\jre\bin
java.vm.version=1.5.0_01-b08
java.vm.vendor=Sun Microsystems Inc.
java.vendor.url= http://java.sun.com/ 
path.separator=;
java.vm.name=Java HotSpot(TM) Client VM
file.encoding.pkg=sun.io
user.country=GB
sun.os.patch.level=Service Pack 1
java.vm.specification.name=Java Virtual Machine Specification
user.dir=C:\aspectj1.5\doc\examples\introduction
java.runtime.version=1.5.0_01-b08
java.awt.graphicsenv=sun.awt.Win32GraphicsEnvironment
java.endorsed.dirs=e:\sun150\jre\lib\endorsed
os.arch=x86
java.io.tmpdir=C:\DOCUME~1\mchapman\LOCALS~1\Temp\
line.separator=

java.vm.specification.vendor=Sun Microsystems Inc.
user.variant=
os.name=Windows XP
sun.jnu.encoding=Cp1252
java.library.path=e:\sun150\bin;.;C:\WINDOWS\System32;C:\WINDOWS;e:\sun150\jre\bin;c:\aspectj1.5\bin;C:\PROGRAM
FILES\THINKPAD\UTILITIES;C:\WINDOWS\system32;C:\WINDOWS;C:\WINDOWS\System32\Wbem;C:\Program
Files\IBM\Infoprint Select;C:\Program Files\ATI Technologies\ATI Control
Panel;C:\Program Files\PC-Doctor for Windows\services;C:\Program
Files\ObjREXX;C:\Program
Files\ObjREXX\OODIALOG;;c:\cygwin\bin;c:\utilities;e:\ant\bin;c:\aspectj1.2\bin
java.specification.name=Java Platform API Specification
java.class.version=49.0
sun.management.compiler=HotSpot Client Compiler
os.version=5.1
user.home=C:\Documents and Settings\mchapman
user.timezone=Europe/London
java.awt.printerjob=sun.awt.windows.WPrinterJob
file.encoding=Cp1252
java.specification.version=1.5
java.class.path=c:\aspectj1.5\lib\aspectjtools.jar;e:\sun150\lib\tools.jar;c:\aspectj1.5\lib\aspectjrt.jar
user.name=mchapman
java.vm.specification.version=1.0
java.home=e:\sun150\jre
sun.arch.data.model=32
user.language=en
java.specification.vendor=Sun Microsystems Inc.
awt.toolkit=sun.awt.windows.WToolkit
java.vm.info=mixed mode
java.version=1.5.0_01
java.ext.dirs=e:\sun150\jre\lib\ext
sun.boot.class.path=e:\sun150\jre\lib\rt.jar;e:\sun150\jre\lib\i18n.jar;e:\sun150\jre\lib\sunrsasign.jar;e:\sun150\jre\lib\jsse.jar;e:\sun150\jre\lib\jce.jar;e:\sun150\jre\lib\charsets.jar;e:\sun150\jre\classes
java.vendor=Sun Microsystems Inc.
file.separator=\
java.vendor.url.bug= http://java.sun.com/cgi-bin/bugreport.cgi 
sun.io.unicode.encoding=UnicodeLittle
sun.cpu.endian=little
sun.desktop=windows
sun.cpu.isalist=pentium_pro+mmx pentium_pro pentium+mmx pentium i486 i386 i86
---- Command Line ---
-1.5
@files.lst
---- Full Classpath ---
e:\sun150\jre\lib\rt.jar(37600990 bytes)
e:\sun150\jre\lib\i18n.jar(missing)
e:\sun150\jre\lib\sunrsasign.jar(missing)
e:\sun150\jre\lib\jsse.jar(549229 bytes)
e:\sun150\jre\lib\jce.jar(81615 bytes)
e:\sun150\jre\lib\charsets.jar(8628006 bytes)
e:\sun150\jre\classes(missing)
e:\sun150\jre\lib\ext\dnsns.jar(8176 bytes)
e:\sun150\jre\lib\ext\localedata.jar(802502 bytes)
e:\sun150\jre\lib\ext\sunjce_provider.jar(153036 bytes)
e:\sun150\jre\lib\ext\sunpkcs11.jar(173235 bytes)
e:\sun150\lib\tools.jar(6812965 bytes)
c:\aspectj1.5\lib\aspectjrt.jar(42013 bytes)
e:\sun150\jre\lib\ext\dnsns.jar(8176 bytes)
e:\sun150\jre\lib\ext\localedata.jar(802502 bytes)
e:\sun150\jre\lib\ext\sunjce_provider.jar(153036 bytes)
e:\sun150\jre\lib\ext\sunpkcs11.jar(173235 bytes)
e:\sun150\lib\tools.jar(6812965 bytes)
c:\aspectj1.5\lib\aspectjrt.jar(42013 bytes)
---- Compiler Messages ---
error at (no source information available)
C:\aspectj1.5\doc\examples\introduction\Point.java:0::0 Internal compiler error
org.aspectj.weaver.BCException: Bad type name: 
	at org.aspectj.weaver.TypeX.nameToSignature(TypeX.java:635)
	at org.aspectj.weaver.TypeX.forName(TypeX.java:88)
	at
org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.fromBinding(EclipseFactory.java:155)
	at
org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.fromBindings(EclipseFactory.java:163)
	at
org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.makeResolvedMember(EclipseFactory.java:229)
	at
org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.makeResolvedMember(EclipseFactory.java:224)
	at
org.aspectj.ajdt.internal.compiler.problem.AjProblemReporter.abstractMethodMustBeImplemented(AjProblemReporter.java:203)
	at
org.aspectj.org.eclipse.jdt.internal.compiler.lookup.MethodVerifier.checkAbstractMethod(MethodVerifier.java:96)
	at
org.aspectj.org.eclipse.jdt.internal.compiler.lookup.MethodVerifier.checkMethods(MethodVerifier.java:261)
	at
org.aspectj.org.eclipse.jdt.internal.compiler.lookup.MethodVerifier.verify(MethodVerifier.java:575)
	at
org.aspectj.org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.verifyMethods(SourceTypeBinding.java:1376)
	at
org.aspectj.org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope.verifyMethods(CompilationUnitScope.java:672)
	at
org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:543)
	at
org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:365)
	at
org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:682)
	at
org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:168)
	at
org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:102)
	at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:109)
	at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:60)
	at org.aspectj.tools.ajc.Main.run(Main.java:291)
	at org.aspectj.tools.ajc.Main.runMain(Main.java:227)
	at org.aspectj.tools.ajc.Main.main(Main.java:80)

abort ABORT -- (BCException) Bad type name: 
Bad type name: 
org.aspectj.weaver.BCException: Bad type name: 
	at org.aspectj.weaver.TypeX.nameToSignature(TypeX.java:635)
	at org.aspectj.weaver.TypeX.forName(TypeX.java:88)
	at
org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.fromBinding(EclipseFactory.java:155)
	at
org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.fromBindings(EclipseFactory.java:163)
	at
org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.makeResolvedMember(EclipseFactory.java:229)
	at
org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.makeResolvedMember(EclipseFactory.java:224)
	at
org.aspectj.ajdt.internal.compiler.problem.AjProblemReporter.abstractMethodMustBeImplemented(AjProblemReporter.java:203)
	at
org.aspectj.org.eclipse.jdt.internal.compiler.lookup.MethodVerifier.checkAbstractMethod(MethodVerifier.java:96)
	at
org.aspectj.org.eclipse.jdt.internal.compiler.lookup.MethodVerifier.checkMethods(MethodVerifier.java:261)
	at
org.aspectj.org.eclipse.jdt.internal.compiler.lookup.MethodVerifier.verify(MethodVerifier.java:575)
	at
org.aspectj.org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.verifyMethods(SourceTypeBinding.java:1376)
	at
org.aspectj.org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope.verifyMethods(CompilationUnitScope.java:672)
	at
org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:543)
	at
org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:365)
	at
org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:682)
	at
org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:168)
	at
org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:102)
	at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:109)
	at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:60)
	at org.aspectj.tools.ajc.Main.run(Main.java:291)
	at org.aspectj.tools.ajc.Main.runMain(Main.java:227)
	at org.aspectj.tools.ajc.Main.main(Main.java:80)

---- org.aspectj.weaver.bcel.BcelWorld ----
Shadow mungers:
Empty
Type mungers:
(EclipseTypeMunger ResolvedTypeMunger(Method, java.lang.Object
introduction.Point.clone()))
(BcelTypeMunger ResolvedTypeMunger(PrivilegedAccess, void java.lang.Cloneable.()))
(EclipseTypeMunger ResolvedTypeMunger(Method, int introduction.Point.hashCode()))
(EclipseTypeMunger ResolvedTypeMunger(Method, boolean
introduction.Point.equals(java.lang.Object)))
(EclipseTypeMunger ResolvedTypeMunger(Method, int
introduction.Point.compareTo(java.lang.Object)))
(BcelTypeMunger ResolvedTypeMunger(PrivilegedAccess, void java.lang.Comparable.()))</description><comments/></buginformation><fixedCommits><commit id="fb01cad1cc839b23cba31cd4dd5f44f68bad4411" author="default" date="2005-03-23 20:26:21"><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"><method name="fromBinding" returnType="TypeX" parameters="TypeBinding"/></file></commit></fixedCommits></bug><bug id="142" opendate="2005-03-23 09:47:00" fixdate="2005-03-23 21:31:49"><buginformation><summary>Declare annotation on ITDs</summary><description>I'll use this bug to capture info on the implementation...</description><comments/></buginformation><fixedCommits><commit id="0d14ccfa4ce92c9adc2f849a4ee4f22c5b3a5ef7" author="default" date="2005-03-23 21:31:49"><file name="weaver/src/org/aspectj/weaver/ResolvedMember.java"><method name="resolve" returnType="ResolvedMember" parameters="World"/><method name="hasAnnotation" returnType="boolean" parameters="TypeX"/><method name="getAnnotationTypes" returnType="ResolvedTypeX[]" parameters=""/></file><file name="tests/src/org/aspectj/systemtest/ajc150/Annotations.java"><method name="testAnnotatedITDs" returnType="void" parameters=""/></file><file name="tests/src/org/aspectj/systemtest/ajc150/AnnotationBinding.java"><method name="testCallsAndExecutionsOfStaticMethods" returnType="void" parameters=""/></file></commit></fixedCommits></bug><bug id="143" opendate="2005-02-15 12:31:00" fixdate="2005-04-05 14:50:06"><buginformation><summary>Improvements to incremental compilation</summary><description>This bug is to track compiler improvements to incremental compilation.

There are multiple scenarios to think about but the first focus is changing one
source file for a class/interface that is affected by an Aspect - it should
compile/weave almost instantly.  Recently response times have been reported of
 &gt;3seconds (and worse...) and this is not reasonable. 

I've put the following improvements in today:
- Caching classpath calculations rather than performing them repeatedly.
- Improved logic to detect weaver completion.
- Removed unnecessary serialization of the structure model.

These are available in dev builds right now:  	ajdt_1.2.0.20050215161840

I'd be interested in user feedback on whether they see noticeable improvements
in their particular projects.

more improvements to follow shortly.</description><comments/></buginformation><fixedCommits><commit id="e460b1e3dae5d05b3457ff96746292516b963c32" author="default" date="2005-04-05 14:50:06"><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java"><method name="changed" returnType="boolean" parameters="List List boolean"/><method name="accept" returnType="boolean" parameters="File"/><method name="prepareForNextBuild" returnType="boolean" parameters="AjBuildConfig"/><method name="pathChange" returnType="boolean" parameters="AjBuildConfig AjBuildConfig"/></file><file name="tests/src/org/aspectj/systemtest/incremental/IncrementalTests.java"><method name="test008" returnType="void" parameters=""/></file></commit></fixedCommits></bug><bug id="144" opendate="2005-01-04 14:13:00" fixdate="2005-04-14 16:44:01"><buginformation><summary>enable ASM interoperability with JavaCore via uniform element handles</summary><description>Proposal pasted from the following email discussion:
 http://dev.eclipse.org/mhonarc/lists/ajdt-dev/msg00379.html 

We finally seem to be both have more support for working directly with the
Java Model, and more need to do so.  Here's an idea for a light-weight
update to our architecture that will give us transparent access for working
with the relationship map using either the IJavaElements or
IProgramElements.

The idea is that we change the handle identifiers, used for storing entries
in the map, to be the same those used by the JavaModel, i.e.
IJavaElement.getHandleIdentifier().  That will allow us to ask for
relationships for IJavaElements, and get back a list of handles that an
adapter can turn into IJavaElements.  

Currently our identifiers are a source location including path, line, and
column number.  The Java model uses the handles that look like the
following, "=Project-l/src&lt;pkg1{Foo.java[Foo~m1", which uniquely identify
members, are stable across builds and Eclipse invocations, but don't go
below the member signature.  So our adapter will have to extend these by
appending either line/column or offset information to reach at "code"
elements (e.g. calls, handlers).  That's doable, and these handles should
just get ignored by JavaCore as desired.  But I'm wondering what they should
correspond to in our extended Java Model, perhaps a subtype of
SourceRefElement called ICodeElement?  We should get JDT Core to add
something like that anyway, but they'll probably want to call it
IUnknownElement or IGenericRefElement to provide other projects with the
same sort of extensibility.  Another challenge will be generating the
project part of the handle because our compiler doesn't know about
workspaces.  I hope that info can be extracted from the full path and source
path information.  Then for other IDEs we can simply use the same relative
path convention.</description><comments/></buginformation><fixedCommits><commit id="df7fff4c8c073a3bbcfe749134d577299402d5fb" author="default" date="2005-04-14 16:44:01"><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmHierarchyBuilder.java"><method name="addUsesPointcutRelationsForNode" returnType="void" parameters="IProgramElement"/></file><file name="asm/src/org/aspectj/asm/AsmManager.java"><method name="AsmManager" returnType="AsmManager" parameters=""/></file><file name="asm/src/org/aspectj/asm/internal/AspectJElementHierarchy.java"><method name="findElementForHandle" returnType="IProgramElement" parameters="String"/><method name="getElement" returnType="IProgramElement" parameters="String"/></file><file name="docs/sandbox/api-clients/org/aspectj/samples/AsmRelationshipMapExtensionTest.java"><method name="addDeclareParentsRelationship" returnType="void" parameters="ISourceLocation"/></file><file name="weaver/src/org/aspectj/weaver/AsmRelationshipProvider.java"><method name="checkerMunger" returnType="void" parameters="IHierarchy Shadow Checker"/><method name="addRelationship" returnType="void" parameters=""/><method name="addDeclareParentsRelationship" returnType="void" parameters="ISourceLocation ResolvedTypeX List"/><method name="addDeclareAnnotationRelationship" returnType="void" parameters="ISourceLocation ISourceLocation"/><method name="addDeclareAnnotationRelationship" returnType="void" parameters="ISourceLocation"/></file><file name="asm/src/org/aspectj/asm/internal/ProgramElement.java"><method name="createHandleIdentifier" returnType="String" parameters="File int int int"/><method name="genHandleIdentifier" returnType="String" parameters="ISourceLocation"/><method name="getHandleIdentifier" returnType="String" parameters=""/></file></commit></fixedCommits></bug><bug id="145" opendate="2005-04-19 05:38:00" fixdate="2005-04-20 12:57:49"><buginformation><summary>NullPointerException when declare @type is spelt with capital letter</summary><description>I have the following code in an AspectJ project:

declare @Type: MainClass : @MyAnnotation;

I believe the correct syntax should be:

declare @type: MainClass : @MyAnnotation;

However when I saved my aspect with the first version I got the following 
NullPointerException:

java.lang.NullPointerException
	at 
org.aspectj.ajdt.internal.compiler.ast.DeclareAnnotationDeclaration.postParse
(DeclareAnnotationDeclaration.java:83)
	at 
org.aspectj.org.eclipse.jdt.internal.compiler.lookup.ClassScope.postParse
(ClassScope.java:175)
	at 
org.aspectj.org.eclipse.jdt.internal.compiler.lookup.ClassScope.buildFieldsAndM
ethods(ClassScope.java:154)
	at 
org.aspectj.org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope.build
FieldsAndMethods(CompilationUnitScope.java:63)
	at 
org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.completeTypeBindi
ngs(AjLookupEnvironment.java:104)
	at 
org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.beginToCompile
(Compiler.java:331)
	at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile
(Compiler.java:348)
	at 
org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation
(AjBuildManager.java:683)
	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild
(AjBuildManager.java:191)
	at 
org.aspectj.ajdt.internal.core.builder.AjBuildManager.incrementalBuild
(AjBuildManager.java:109)
	at org.aspectj.ajde.internal.CompilerAdapter.compile
(CompilerAdapter.java:117)
	at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run
(AspectJBuildManager.java:165)</description><comments/></buginformation><fixedCommits><commit id="78abc76610cfb5fd2a2282086adfb017537ce49c" author="default" date="2005-04-20 12:57:49"><file name="weaver/src/org/aspectj/weaver/patterns/PatternParser.java"><method name="parseDeclareAnnotation" returnType="Declare" parameters=""/></file></commit></fixedCommits></bug><bug id="146" opendate="2005-04-20 07:19:00" fixdate="2005-04-20 14:32:40"><buginformation><summary>@args causes a VerifyError: Unable to pop operand off an empty stack</summary><description>I'm getting a VerifyError exception when I try to use @args
in following code:

------------------ Test3.java -------------------------
import java.lang.annotation.*;

@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@interface Ann {}

@Ann
class AClass{}

public class Test3 {
        void abc(AClass y) {}

        public static void main(String[] args) {
                new Test3().abc(new AClass());
        }
}


aspect Annotations {
        before(Ann ann) : call(* Test3.*(..)) &amp;&amp; @args(ann) {
                System.out.println("Before: " + thisJoinPoint);
        }
}
----

On JRockIt5 jre and AspectJ 1.5.0M2 I get following result:
-----------
java.lang.VerifyError: (class: Test3, method: main signature:
([Ljava/lang/String;)V) Unable to pop operand off an empty stack
-----------

I'm getting similar error with sun jre and with older versions
of AspectJ5 (20050324155000 and from 10th feb).</description><comments/></buginformation><fixedCommits><commit id="3f942a4c58210535e91c50a037a8d743a0c70e19" author="default" date="2005-04-20 14:32:40"><file name="weaver/src/org/aspectj/weaver/patterns/ArgsAnnotationPointcut.java"><method name="findResidueInternal" returnType="Test" parameters="Shadow ExposedState"/></file></commit></fixedCommits></bug><bug id="147" opendate="2005-04-19 11:32:00" fixdate="2005-04-21 17:00:18"><buginformation><summary>Request for a new type of relationship in the structure model</summary><description>Declare soft relationships are currently 'advises' and 'advised by' 
relationships.  Would it be possible to add 'softens' and 'softened by' 
(or 'softens exception at' and 'exception softened by') relationships to the 
structure model?</description><comments/></buginformation><fixedCommits><commit id="7a613809e63e1a3320a7598e8d7381e70c717adc" author="default" date="2005-04-21 17:00:18"><file name="asm/src/org/aspectj/asm/IRelationship.java"><method name="Kind" returnType="Kind" parameters=""/></file><file name="weaver/src/org/aspectj/weaver/AsmRelationshipProvider.java"><method name="adviceMunger" returnType="void" parameters="IHierarchy Shadow ShadowMunger"/></file></commit></fixedCommits></bug><bug id="148" opendate="2005-04-25 15:26:00" fixdate="2005-04-26 16:14:06"><buginformation><summary>Null Pointer Exception thrown by ajc compiler</summary><description>Hi,

I wrote my first aspect using aspect J as follows to enable logging:

package com.apple.ist.espresso.aspects;


import com.apple.ist.espresso.util.EspressoLogger;

public class EspressoTrace {

        private static EspressoLogger logger = null;


        public static void initLogger(EspressoLogger l) {
                logger = l;
        }

        public static void TraceEntry(String message) {
                logger.debug("Entering : " + message);
        }

        public static void TraceExit(String message) {
                logger.debug("Exiting : " + message);
        }
}


My aspect is in the file EspressoTraceAspect.java as follows:

package com.apple.ist.espresso.aspects;

aspect EspressoTraceAspect {

        pointcut traceCall() : execution(public * com.apple.ist.espresso..*.*(..));

        before() : traceCall {
                Trace.traceEntry("" + thisJointPointStaticPart.getSignature());
        }

        after() : traceCall {
                Trace.traceExit("" + thisJointPointStaticPart.getSignature());
        

        public static void main(String[] args) {
                Trace.initStream(EspressoLogger.getLogger(TraceAspect.class));
        }
}


When i compiled it using the following target: (init target that sets the required variables are done as 
shown in the example build.xml file and are NOT shown here)

      &lt;target name="Ajx" depends="init"&gt;
                &lt;iajc destdir="${build.dir}/classes" fork="true" forkclasspath="${aspectjtools.jar}" 
argfiles="${list}"&gt;
                    &lt;src path="${src.dir}"/&gt;
                    &lt;src path="${sharedsrc.dir}"/&gt;
                    &lt;src path="${gensrc.dir}"/&gt;
                        &lt;classpath&gt;
                                &lt;path refid="classpath"/&gt;
                                &lt;path refid="aspectj.lib"/&gt;
                        &lt;/classpath&gt;
                &lt;/iajc&gt;

        &lt;/target&gt;

i'm getting the following exception.

[error] Internal compiler error
     [iajc] java.lang.NullPointerException
     [iajc]     at org.aspectj.weaver.bcel.UnwovenClassFile.deleteRealFile(UnwovenClassFile.java:170)
     [iajc]     at org.aspectj.ajdt.internal.core.builder.AjState.deleteClassFile(AjState.java:413)
     [iajc]     at org.aspectj.ajdt.internal.core.builder.AjState.noteResult(AjState.java:450)
     [iajc]     at org.aspectj.ajdt.internal.core.builder.AjBuildManager$3.acceptResult(AjBuildManager.java:
704)
     [iajc]     at 
org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterProcessing(AjCompilerAdapter.java:144)
     [iajc]     at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:373)
     [iajc]     at 
org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:683)
     [iajc]     at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:168)
     [iajc]     at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:102)
     [iajc]     at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:109)
     [iajc]     at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:60)
     [iajc]     at org.aspectj.tools.ajc.Main.run(Main.java:291)
     [iajc]     at org.aspectj.tools.ajc.Main.runMain(Main.java:227)
     [iajc]     at org.aspectj.tools.ajc.Main.main(Main.java:80)

     [iajc] (no source information available)
     [iajc] /Users/manjulajayaraman/projects/JADE/jadecvs/NewEspresso/ServerDevelopment/Phase1/
src/com/apple/ist/espresso/aspects/EspressoTrace.java:6 [error] The type EspressoTrace is already 
defined
     [iajc] public class EspressoTrace {
     [iajc]              ^^^^^^^^^^^^
     [iajc] ABORT
     [iajc] 
     [iajc] Exception thrown from AspectJ 1.5.0M2

     [iajc] This might be logged as a bug already -- find current bugs at
     [iajc]    http://bugs.eclipse.org/bugs/buglist.cgi?product=AspectJ&amp;component=Compiler 

     [iajc] Bugs for exceptions thrown have titles File:line from the top stack, 
     [iajc] e.g., "SomeFile.java:243"

     [iajc] If you don't find the exception below in a bug, please add a new bug
     [iajc] at  http://bugs.eclipse.org/bugs/enter_bug.cgi?product=AspectJ 
     [iajc] To make the bug a priority, please include a test program
     [iajc] that can reproduce this exception.
     [iajc] null
     [iajc] java.lang.NullPointerException
     [iajc]     at org.aspectj.weaver.bcel.UnwovenClassFile.deleteRealFile(UnwovenClassFile.java:170)
     [iajc]     at org.aspectj.ajdt.internal.core.builder.AjState.deleteClassFile(AjState.java:413)
     [iajc]     at org.aspectj.ajdt.internal.core.builder.AjState.noteResult(AjState.java:450)
     [iajc]     at org.aspectj.ajdt.internal.core.builder.AjBuildManager$3.acceptResult(AjBuildManager.java:
704)
     [iajc]     at 
org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterProcessing(AjCompilerAdapter.java:144)
     [iajc]     at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:373)
     [iajc]     at 
org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:683)
     [iajc]     at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:168)
     [iajc]     at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:102)
     [iajc]     at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:109)
     [iajc]     at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:60)
     [iajc]     at org.aspectj.tools.ajc.Main.run(Main.java:291)
     [iajc]     at org.aspectj.tools.ajc.Main.runMain(Main.java:227)
     [iajc]     at org.aspectj.tools.ajc.Main.main(Main.java:80)


     [iajc] 1 fail|abort, 2 errors

BUILD FAILED



Could someone please let me know  what's the problem and how do i proceed now?

Thanks,
Manjula</description><comments/></buginformation><fixedCommits><commit id="02f75ba1e5b0eb9806d5642f891940be06691747" author="default" date="2005-04-26 16:14:06"><file name="weaver/src/org/aspectj/weaver/bcel/UnwovenClassFile.java"><method name="accept" returnType="boolean" parameters="File String"/></file></commit></fixedCommits></bug><bug id="149" opendate="2005-04-27 09:55:00" fixdate="2005-05-04 09:22:43"><buginformation><summary>showWeaveInfo for declare annotations</summary><description>declaring annotations (declare @type, @constructor, @method and @field)
currently doesn't show a message when the -showWeaveInfo option is set in ajc.

Appropriate messages should be displayed.</description><comments/></buginformation><fixedCommits><commit id="abc9a58ac59f0ee427039e26cb44952cbef5e24b" author="default" date="2005-05-04 09:22:43"><file name="weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"><method name="weaveDeclareAtMethodCtor" returnType="boolean" parameters="LazyClassGen"/></file><file name="weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java"><method name="applyDeclareAtType" returnType="boolean" parameters="DeclareAnnotation ResolvedTypeX boolean"/></file><file name="ajde/testsrc/org/aspectj/ajde/ShowWeaveMessagesTestCase.java"><method name="testWeaveMessagesDeclareSoft" returnType="void" parameters=""/></file></commit></fixedCommits></bug><bug id="150" opendate="2005-04-13 09:29:00" fixdate="2005-05-06 10:21:26"><buginformation><summary>NPE at EclipseFactory.java:143 when using generic methods in aspects</summary><description>When I compile any of these two aspects with ajc -1.5, an exception is thrown by
the compiler:


import java.util.*;

public aspect TestBug1 {
    static &lt;T&gt; void addToEnv(Map&lt;String,T&gt; env, String key, T value) {
	env.put(key, value);
    }
}


import java.util.*;

public aspect TestBug2 {
    static &lt;T&gt; T lookupEnv(Map&lt;String,T&gt; env, String key) {
	return env.get(key);
    }
}


If the methods are placed into classes instead of aspects, all works fine.

The exception thrown is the following:

java.lang.NullPointerException
        at
org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.getName(EclipseFactory.java:143)
        at
org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.fromBinding(EclipseFactory.java:166)
        at
org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.fromBindings(EclipseFactory.java:176)
        at
org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.makeResolvedMember(EclipseFactory.java:254)
        at
org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.makeResolvedMember(EclipseFactory.java:249)
        at
org.aspectj.ajdt.internal.compiler.lookup.EclipseSourceType.fillDeclaredMembers(EclipseSourceType.java:115)
        at
org.aspectj.ajdt.internal.compiler.lookup.EclipseSourceType.getDeclaredPointcuts(EclipseSourceType.java:146)
        at
org.aspectj.ajdt.internal.compiler.ast.AspectDeclaration.buildInterTypeAndPerClause(AspectDeclaration.java:977)
        at
org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.buildInterTypeAndPerClause(AjLookupEnvironment.java:303)
        at
org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.completeTypeBindings(AjLookupEnvironment.java:119)
        at
org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.beginToCompile(Compiler.java:331)
        at
org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:348)
        at
org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:683)
        at
org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:168)
        at
org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:102)
        at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:109)
        at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:60)
        at org.aspectj.tools.ajc.Main.run(Main.java:291)
        at org.aspectj.tools.ajc.Main.runMain(Main.java:227)
        at org.aspectj.tools.ajc.Main.main(Main.java:80)</description><comments/></buginformation><fixedCommits><commit id="7389d9fc0252b90a9b0bf2cb1861a0f3802ad320" author="default" date="2005-05-06 10:21:26"><file name="weaver/src/org/aspectj/weaver/TypeX.java"><method name="forParameterizedTypeNames" returnType="TypeX" parameters="String"/></file><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"><method name="getName" returnType="String" parameters="TypeBinding"/><method name="fromBinding" returnType="TypeX" parameters="TypeBinding"/></file></commit></fixedCommits></bug><bug id="151" opendate="2005-04-11 17:15:00" fixdate="2005-05-06 15:18:54"><buginformation><summary>Generics problem with Set - does not compile with AspectJ 5</summary><description>I tried different things to remove compiler warnings about generics which you
get when you switch to JDK 5 and use collections. At last I fall back to JDK
1.4. The following code compiles with AspectJ 5 and JDK compliance level 1.4:

public aspect SubjectAspect {
    
    private Set Subject.observers = new HashSet();

    public void Subject.addObserver(SubjectObserver observer) {
        observers.add(observer);
    }
    ...
}

After switching to compliance level 5.0 I get an error message
"The method add(E) in the type Set&lt;E&gt; is not applicable for the arguments
(SubjectObserver)".
I don't know if it is a similar problem like #87550 but I means for older
projects which use collections that they can't switch to JDK 1.5</description><comments/></buginformation><fixedCommits><commit id="952dda914064ff58a39fc682d18cdbf3ad171475" author="default" date="2005-05-06 15:18:54"><file name="weaver/src/org/aspectj/weaver/TypeX.java"><method name="forParameterizedTypeNames" returnType="TypeX" parameters="String String[]"/><method name="getBaseName" returnType="String" parameters=""/></file><file name="weaver/src/org/aspectj/weaver/World.java"><method name="resolve" returnType="ResolvedTypeX" parameters="TypeX boolean"/></file><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"><method name="makeTypeBinding1" returnType="TypeBinding" parameters="TypeX"/><method name="fromBinding" returnType="TypeX" parameters="TypeBinding"/></file></commit></fixedCommits></bug><bug id="152" opendate="2005-04-30 08:49:00" fixdate="2005-05-09 11:08:28"><buginformation><summary>unresolved joinpoint in cflow causes ClassCastException on BcelWeaver:933</summary><description>I'm getting ClassCastException while compiling following code:

---- Test.java ----
class AClass {
//      void method() {}
}

aspect AnAspect {
        pointcut annt() : cflow( execution(* *(..)) );

        before() : annt() {
                System.out.println("before annt");
        }
}
----

Here's output of the compiler:
--- out ---
java.lang.ClassCastException: org.aspectj.weaver.ResolvedMember
        at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:933)
        at
org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave(AjCompilerAdapter.java:244)
        at
org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling(AjCompilerAdapter.java:119)
        at
org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:385)
  [cut]
------

The problem is caused by cflow on unresolved (not existing) jointpoint.
When you uncomment the method() in AnClass, the problem disappears.


I found this bug when I was introducing an aspect (which has
pointcuts based on annotations) to fresh object-oriented system
without annotated classes. When I started to annotate the classes
problem disappeared. Following code illustates (simplified) situation:

--- Test2.java ---
import java.lang.annotation.*;

@Target(ElementType.METHOD)
@interface Ann {}

class AClass {
        // @Ann
        void method() {}
}

aspect AnAspect {
        pointcut annt() : cflow( execution(@Ann * *(..)) );

        before() : annt() {
                System.out.println("before annt");
        }
}
----


I'm attaching those sources and ajcore files.

Best regards, Michal</description><comments/></buginformation><fixedCommits><commit id="f6034581d8540124494806a7c6b3ad37ead2b6c3" author="default" date="2005-05-09 11:08:28"><file name="tests/src/org/aspectj/systemtest/ajc150/AllTestsAspectJ150.java"><method name="suite" returnType="Test" parameters=""/></file><file name="weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java"><method name="weave" returnType="Collection" parameters="IClassFileProvider"/></file></commit></fixedCommits></bug><bug id="153" opendate="2005-01-13 10:49:00" fixdate="2005-05-12 06:53:15"><buginformation><summary>[ajdoc] update ajdoc to support Java 5 language features</summary><description>Java 5 langauge features such as enums and annotations need to be supported by 
ajdoc.</description><comments/></buginformation><fixedCommits><commit id="7b7c7b2fb25e09660f066e556a5008545d655f6f" author="default" date="2005-05-12 06:53:15"><file name="ajdoc/src/org/aspectj/tools/ajdoc/Declaration.java"><method name="isType" returnType="boolean" parameters=""/></file><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmHierarchyBuilder.java"><method name="genSourceSignature" returnType="String" parameters="FieldDeclaration"/></file><file name="ajdoc/src/org/aspectj/tools/ajdoc/StubFileGenerator.java"><method name="processMembers" returnType="void" parameters=""/></file></commit></fixedCommits></bug><bug id="154" opendate="2005-02-03 05:47:00" fixdate="2005-05-12 13:00:07"><buginformation><summary>Finish implementation of *runtime* retention checking</summary><description>See FIXME in BindingAnnotationTypePattern.resolveBinding() and
EclipseSourceType.getAnnotationTypes()</description><comments/></buginformation><fixedCommits><commit id="f9eebd48f6070a8254b38630d6d76da8c0aee80e" author="default" date="2005-05-12 13:00:07"><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseSourceType.java"><method name="isAnnotationWithRuntimeRetention" returnType="boolean" parameters=""/></file><file name="weaver/src/org/aspectj/weaver/patterns/BindingAnnotationTypePattern.java"><method name="resolveBinding" returnType="void" parameters="World"/></file></commit></fixedCommits></bug><bug id="155" opendate="2005-05-09 04:45:00" fixdate="2005-05-16 10:55:24"><buginformation><summary>Exploding compile time with if() statements in pointcut</summary><description>Compile time explodes when adding if(...) statements to pointcuts.
This is the same with ajc 1.2.1 and 1.5M2 although 1.5M2 is a little bit faster,
but compile time still explodes.

Example:
    pointcut pc2() :
        (execution(* Test.a(..)) &amp;&amp; if(sl.isEnabled()) )
        || (execution(* Test.a(..)) &amp;&amp; if(sl.isEnabled()) )

compiled in about 1 second.

Up to 7 such conditions , eg.
    pointcut Pc7() :
        (execution(* Test.a(..)) &amp;&amp; if (sl.isEnabled()))
        || (execution(* Test.b(..)) &amp;&amp; if (sl.isEnabled()))
        || (execution(* Test.c(..)) &amp;&amp; if (sl.isEnabled()))
        || (execution(* Test.d(..)) &amp;&amp; if (sl.isEnabled()))
        || (execution(* Test.e(..)) &amp;&amp; if (sl.isEnabled()))
        || (execution(* Test.f(..)) &amp;&amp; if (sl.isEnabled()))
        || (execution(* Test.g(..)) &amp;&amp; if (sl.isEnabled()));

are also compiled quite quickly (~ 3 seconds with both ajc 1.2.1 and 1.5M2).

Now, adding another condition (8 lines) causes 6 seconds compile time. Adding
yet another condition line (= 9 ex. lines) causes ~ 1 min compile time!
(10 such lines even more than 8 minutes)

Sample source code below
------------------------

// ########## Aspect.aj ###############

public aspect Aspect {
    private static final SimpleLogger sl
        = new SimpleLogger();

    pointcut PC() :
        (execution(* Test.a(..)) &amp;&amp; if (sl.isEnabled()))
        || (execution(* Test.b(..)) &amp;&amp; if (sl.isEnabled()))
        || (execution(* Test.c(..)) &amp;&amp; if (sl.isEnabled()))
        || (execution(* Test.d(..)) &amp;&amp; if (sl.isEnabled()))
        || (execution(* Test.e(..)) &amp;&amp; if (sl.isEnabled()))
        || (execution(* Test.f(..)) &amp;&amp; if (sl.isEnabled()))
        || (execution(* Test.g(..)) &amp;&amp; if (sl.isEnabled()))
        || (execution(* Test.h(..)) &amp;&amp; if (sl.isEnabled()))
        || (execution(* Test.i(..)) &amp;&amp; if (sl.isEnabled()))
        || (execution(* Test.j(..)) &amp;&amp; if (sl.isEnabled()))
        ;

    before() : PC() {
        sl.log("Before");
    }

    after() : PC() {
        sl.log("After");
    }
}

// ########## Test.java ###############</description><comments/></buginformation><fixedCommits><commit id="88d477dab59d9f5f175e89534885e4ac6bc0567c" author="default" date="2005-05-16 10:55:24"><file name="tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"><method name="testInternalCompilerError_pr86832" returnType="void" parameters=""/></file><file name="weaver/src/org/aspectj/weaver/patterns/IfPointcut.java"><method name="toString" returnType="String" parameters=""/><method name="findResidueInternal" returnType="Test" parameters="Shadow ExposedState"/></file></commit></fixedCommits></bug><bug id="156" opendate="2005-05-23 17:22:00" fixdate="2005-05-30 10:00:21"><buginformation><summary>Patch to support loading aop.xml properly</summary><description>AspectJ 5 load-time weaving in CVS HEAD isn't loading aop.xml files properly 
from a jar file without specifying the global -D flag. The following patch 
fixes the problem for me so I can load aop.xml files from jars on the 
classpath without a global flag:

ClassLoaderWeavingAdaptor.java:109:
-             Enumeration xmls = loader.getResources("/META-INF/aop.xml");
+            Enumeration xmls = loader.getResources("META-INF/aop.xml");


I.e., getResources doesn't work with a leading separator, at least not on the 
Sun VM or JRockIt on Windows. Writing a unit test for this would require 
significant changes to the loadtime module, so I wrote a standalone test of 
the API:

public class TestApi extends TestCase {
    public void testLoadResource() throws Exception {
        URL urlList[] = { new URL
("file:testsrc/org/aspectj/weaver/loadtime/test/sample.jar") };
        ClassLoader loader = new URLClassLoader(urlList);	
          
        Enumeration xmls = loader.getResources("META-INF/aop.xml");
        //this version fails:
        //Enumeration xmls = loader.getResources("/META-INF/aop.xml");

        assertTrue(xmls.hasMoreElements());
    }
}</description><comments/></buginformation><fixedCommits><commit id="f14646f57a93e7ec865416048c4491d9943064e5" author="default" date="2005-05-30 10:00:21"><file name="loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"><method name="registerDefinitions" returnType="void" parameters="BcelWeaver ClassLoader"/></file></commit></fixedCommits></bug><bug id="157" opendate="2004-12-23 07:27:00" fixdate="2005-06-01 16:12:58"><buginformation><summary>EclipseAdapterUtils.java:83</summary><description>java.lang.ArrayIndexOutOfBoundsException: 3

Unfortunately I can't provide much more information, please see the attached 
compiler dump.</description><comments/></buginformation><fixedCommits><commit id="a675b659cdc4da45383551e75c9472556c095f94" author="default" date="2005-06-01 16:12:58"><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/EclipseAdapterUtils.java"><method name="makeLocationContext" returnType="String" parameters="ICompilationUnit"/></file></commit></fixedCommits></bug><bug id="158" opendate="2005-05-09 13:37:00" fixdate="2005-06-07 12:17:30"><buginformation><summary>NPE in reflect implementation</summary><description>Proposed fix (I'd like input on how to best add test cases for this so I can 
submit a tested patch); I believe this will work because if you uncomment the 
work-around line, it works):

Change line 63 from:
				method = declaringType.getDeclaredMethod
(getName(),getParameterTypes());

to

				method = getDeclaringType().getDeclaredMethod
(getName(),getParameterTypes());

Test source:

package reflect;

import org.aspectj.lang.*;
import org.aspectj.lang.reflect.*;
import java.lang.reflect.*;

aspect Test {
    before() : call(* *(..)) &amp;&amp; !within(Test) {
       MethodSignature sig = (MethodSignature)thisJoinPoint.getSignature();
       //sig.getDeclaringType(); // uncomment to work-around
       Method method = sig.getMethod();
   }
}

public class MinimalErr {
    public static void main(String args[]) {
	try {
	    Inner.foo();
	} catch (Throwable t) {
	    t.printStackTrace();
	}
    }
    public static class Inner {
	public static void foo() {}
    }
}</description><comments/></buginformation><fixedCommits><commit id="3824b1c24717b79d48bd5f965bd2d34569dc2195" author="default" date="2005-06-07 12:17:30"><file name="tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"><method name="testIfEvaluationExplosiion_PR94086" returnType="void" parameters=""/></file><file name="runtime/src/org/aspectj/runtime/reflect/AdviceSignatureImpl.java"><method name="getAdvice" returnType="Method" parameters=""/></file><file name="runtime/src/org/aspectj/runtime/reflect/MethodSignatureImpl.java"><method name="getMethod" returnType="Method" parameters=""/></file></commit></fixedCommits></bug><bug id="159" opendate="2005-06-07 05:55:00" fixdate="2005-06-07 13:12:51"><buginformation><summary>parser cannot parse varargs correctly</summary><description>the following cannot be parsed:

call(* *(int, Integer...))

see in modules/weaver/.../PointcutVisitorTest (uncomment the testTemp())
See "FIXME AV for Adrian" comments in PatternParser. Half fix but then fails for
other tests.

Adrian can you have a look at it ?
Thanks</description><comments/></buginformation><fixedCommits><commit id="743566fb8882ea922e0ff56ac83d1e6fdd9cd637" author="default" date="2005-06-07 13:12:51"><file name="weaver/testsrc/org/aspectj/weaver/patterns/VisitorTestCase.java"><method name="testMock" returnType="void" parameters=""/></file><file name="weaver/src/org/aspectj/weaver/patterns/PatternParser.java"><method name="parseSingleTypePattern" returnType="TypePattern" parameters=""/><method name="parseDottedNamePattern" returnType="List" parameters=""/></file><file name="weaver/src/org/aspectj/weaver/patterns/BasicTokenSource.java"><method name="makeTokenSource" returnType="ITokenSource" parameters="String ISourceContext"/></file></commit></fixedCommits></bug><bug id="160" opendate="2005-06-09 11:20:00" fixdate="2005-06-14 14:53:37"><buginformation><summary>[generics][itds] ITD on generic inner class crashes ajc</summary><description>inter-type declaration on a generic inner class crashes the compiler:

class Outer {
  class Inner {}
  class Generic_Inner&lt;T&gt; {}
}

class Generic_Outer&lt;T&gt; {
}

aspect Injector {
  int Outer.outer; // works
  int Outer.Inner.inner; // works
  int Generic_Outer.outer; // works
  int Outer.Generic_Inner.inner; // crashes
}


/home/user/sgelin3/dev/java/ajc/new_bug/Bug.java [error] Internal compiler error
java.lang.RuntimeException: can't handle: class Generic_Inner#RAW
        extends NULL TYPENULL SUPERINTERFACES
        enclosing type : OuterNULL FIELDSNULL METHODS


        at
org.aspectj.ajdt.internal.compiler.lookup.InterTypeScope.makeSourceTypeBinding(InterTypeScope.java:35)
        at
org.aspectj.ajdt.internal.compiler.lookup.InterTypeScope.&lt;init&gt;(InterTypeScope.java:28)
        at
org.aspectj.ajdt.internal.compiler.ast.InterTypeDeclaration.resolve(InterTypeDeclaration.java:101)
        at
org.aspectj.ajdt.internal.compiler.ast.InterTypeFieldDeclaration.resolve(InterTypeFieldDeclaration.java:141)
        at
org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1076)
        at
org.aspectj.ajdt.internal.compiler.ast.AspectDeclaration.resolve(AspectDeclaration.java:110)
        at
org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1125)
...</description><comments/></buginformation><fixedCommits><commit id="588023e3beb9f861405f4f9a580122993d2dbb47" author="default" date="2005-06-14 14:53:37"><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/InterTypeScope.java"><method name="makeSourceTypeBinding" returnType="SourceTypeBinding" parameters="ReferenceBinding"/></file></commit></fixedCommits></bug><bug id="161" opendate="2005-06-15 12:24:00" fixdate="2005-06-16 08:30:14"><buginformation><summary>[generics][itds] inner class with generic enclosing class</summary><description>ajc crashes with a NullPointerException when an intertype declaration tries to
modify an inner class, if the enclosing (outer) class is generic:

class Outer {
  class Inner {}
}

class Generic_Outer&lt;T&gt; {
  class Inner {}
}

aspect Injector {
  int Outer.outer; // works
  int Outer.Inner.inner; // works
  int Generic_Outer.outer; // works
  int Generic_Outer.Inner.inner; // crashes
}


/home/user/sgelin3/dev/java/ajc/new_bug/Bug.java [error] Internal compiler error
java.lang.NullPointerException
        at
org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.fromBinding(EclipseFactory.java:202)
        at
org.aspectj.ajdt.internal.compiler.ast.InterTypeFieldDeclaration.build(InterTypeFieldDeclaration.java:173)
        at
org.aspectj.ajdt.internal.compiler.ast.AspectDeclaration.buildInterTypeAndPerClause(AspectDeclaration.java:1020)
        at
org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.buildInterTypeAndPerClause(AjLookupEnvironment.java:306)
        at
org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.completeTypeBindings(AjLookupEnvironment.java:122)
        at
org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.beginToCompile(Compiler.java:302)
        at
org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:316)
...</description><comments/></buginformation><fixedCommits><commit id="7d5002ad52c86eefdf58535310fb41f042206d11" author="default" date="2005-06-16 08:30:14"><file name="weaver/src/org/aspectj/weaver/TypeX.java"><method name="getBaseName" returnType="String" parameters=""/><method name="forParameterizedTypeNames" returnType="TypeX" parameters="String String[]"/><method name="forRawTypeNames" returnType="TypeX" parameters="String"/></file><file name="tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"><method name="testItdGenerics_pr98320" returnType="void" parameters=""/><method name="testItdGenerics_pr99228" returnType="void" parameters=""/></file><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"><method name="fromBinding" returnType="TypeX" parameters="TypeBinding"/></file></commit></fixedCommits></bug><bug id="162" opendate="2005-01-28 10:29:00" fixdate="2005-07-11 15:05:44"><buginformation><summary>@AJ and formal binding impl</summary><description>Some notes on formal binding impl for @AJ

In code style, the advice signature is always looking the same
(..bindings.., org.aspectj.lang.Part thisJoinPointStaticPart, JoinPoint
thisJoinPoint, org.aspectj.lang.Part thisEnclosingJoinPointStaticPart)

In @ style, it is user defined.

The current impl is handling the formal binding in a way that only
args/this/target can be bound.
I had to add some conditionals to handles cases like that:
void myAdvice(JoinPoint jp, Object target) {..}
where target() binding is at index 1, while the index 0 is not an unbound but
actually "virtually" bound to the joinpoint.

Pointcut are thus having a virtuallyBoundedNames String[] that is the list of
arguments for which we don't want any complain if it not bound.
This one is populated during  @ extraction, and Pointcut.concretize() make sure
the info is not lost when composition occurs (with PerClause f.e.)

The only issue is that currently, binding JP/SJP/ESJP themselves is not possible
f.e. "... &amp;&amp; args(jp)" myAdvice(JoinPoint jp, JoinPoint currentJp)
Is that a big issue ?
May be impact adviceexecution() and could impact some use cases around mock testing.</description><comments/></buginformation><fixedCommits><commit id="639b4fd0a436e19726dc9f2a47dc66a726794b3d" author="default" date="2005-07-11 15:05:44"><file name="weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java"><method name="getAdviceArgSetup" returnType="InstructionList" parameters=""/></file><file name="tests/java5/ataspectj/ataspectj/SingletonAspectBindingsTest.java"><method name="before" returnType="void" parameters="String JoinPoint.StaticPart"/></file><file name="tests/src/org/aspectj/systemtest/ajc150/ataspectj/AtAjSyntaxTests.java"><method name="testSingletonAspectBindings" returnType="void" parameters=""/></file></commit></fixedCommits></bug><bug id="163" opendate="2005-07-10 01:40:00" fixdate="2005-07-18 08:27:44"><buginformation><summary>NPE on syntax error</summary><description>This example program generates an NPE on CVS HEAD and M2. I will attach the 
ajcore file.

public abstract aspect WorkerExample {

    after() returning (RequestContext newContext) : call(RequestContext+.new
(..)) {        
        System.out.println("constructing "+newContext+" 
at "+thisJoinPoint.toLongString()+" 
from "+thisEnclosingJoinPointStaticPart+":");
    }

    public abstract class RequestContext {
        public final Object execute() {
            return doExecute();
        }
        
        /** template method */
        public abstract Object doExecute();
    }

    public static void main(String args[]) {
        new Runnable() {
            public void run() {}
        }.run();
    };
}

aspect ConcreteAlpha extends WorkerExample {

    Object around(final Object runnable) : execution(void Runnable.run()) &amp;&amp; 
this(runnable) {
        System.out.println("monitoring operation: "+runnable+" 
at "+thisJoinPoint+", for "+thisJoinPoint.getThis());
        RequestContext requestContext = new RequestContext() {
            public Object doExecute() {
                return proceed(runnable);
            }
            
        };
        return requestContext.execute();
    }
    
}

aspect ConcreteBeta extends WorkerExample {
    
    Object around() : call(void awqeyuwqer()) {
        RequestContext requestContext = new ConnectionRequestContext() {
            public Object doExecute() {                
                return proceed();
            }
            
        };
        return requestContext.execute();
    }

    
}</description><comments/></buginformation><fixedCommits><commit id="bba9c50768a1db72fc8606a80762333d4b12d140" author="default" date="2005-07-18 08:27:44"><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/MakeDeclsPublicVisitor.java"><method name="endVisit" returnType="void" parameters="MethodDeclaration ClassScope"/><method name="endVisit" returnType="void" parameters=""/><method name="endVisit" returnType="void" parameters="FieldDeclaration MethodScope"/><method name="endVisit" returnType="void" parameters="ConstructorDeclaration ClassScope"/></file></commit></fixedCommits></bug><bug id="164" opendate="2005-07-18 09:25:00" fixdate="2005-07-22 14:57:40"><buginformation><summary>static method call from subclass signature is wrong</summary><description>a very bad bug... or ?

in the snip below, getMethod() says null and the factory is actually thinking
that test() is a static method of AspectJBugMain instead of Assert...

wondering why we don't catch that in the test suite or what could happen
recently around that. Or is it something I am confused about ? (i doubt a
jp.getSignature().getMethod is supposed to return null in some cases though..)

@Aspect
public class Sam {

    @Pointcut("call(* *.*(..))")
            public void methodCalls() {
    }

    @Around("methodCalls() &amp;&amp; !within(alex.sam.Sam) &amp;&amp; within(alex..*)")
            public Object aroundMethodCalls(ProceedingJoinPoint jp) throws
Throwable {
        String typeName = jp.getSignature().getDeclaringTypeName();
        System.out.println("declType " + typeName);
        System.out.println("method " +
((MethodSignature)jp.getSignature()).getMethod());

        return jp.proceed();
    }

}

class Assert {
    public static void test() {
        System.out.println("RUN Assert.test");
    }
}

class AspectJBugMain extends Assert {
    public static void main(String[] args) {
        test();
    }
//    public static void test() {
//        System.out.println("RUN AspectJBugMain.test");
//    }
}</description><comments/></buginformation><fixedCommits><commit id="619a6adf4771e9b7a10776893583e8c5a96c0de3" author="default" date="2005-07-22 14:57:40"><file name="weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"><method name="makeMethodCall" returnType="BcelShadow" parameters=""/><method name="makeConstructorCall" returnType="BcelShadow" parameters=""/></file><file name="weaver/src/org/aspectj/weaver/bcel/BcelWorld.java"><method name="makeMethodSignature" returnType="Member" parameters="LazyClassGen InvokeInstruction"/></file><file name="weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"><method name="matchInvokeInstruction" returnType="void" parameters="LazyMethodGen"/></file></commit></fixedCommits></bug><bug id="165" opendate="2005-08-09 08:46:00" fixdate="2005-08-10 11:49:34"><buginformation><summary>org.aspectj.weaver.patterns.WildTypePattern.maybeGetCleanName(WildTypePattern.java:500)</summary><description>I want to declare a pointcut to capture invocation of methods on annotated
interfaces being subtypes of a given interface.

here is the full ajcore report:
 http://veleno.pastebin.com/332842 

i will attach a test case.</description><comments/></buginformation><fixedCommits><commit id="5735e966959da60fcacebb23e8b5463c4138020c" author="default" date="2005-08-10 11:49:34"><file name="weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java"><method name="extractName" returnType="NamePattern" parameters=""/></file><file name="weaver/src/org/aspectj/weaver/patterns/PatternParser.java"><method name="parseFieldSignaturePattern" returnType="SignaturePattern" parameters=""/></file></commit></fixedCommits></bug><bug id="166" opendate="2005-02-21 17:25:00" fixdate="2005-08-19 16:51:30"><buginformation><summary>expect error when overriding final pointcuts</summary><description>I get no compiler error when I "override"/redefine a final pointcut:

------------
public class Main {
    static void walk() {}
    static void run() {}
    public static void main(String[] args) {
        walk();
        run();
    }
}
abstract aspect AA {
    public final pointcut publicPointcut() : call(void walk());
    before() : publicPointcut() { System.out.print("here: " + thisJoinPoint); }
}
aspect AA1 extends AA {
    // expecting error here b/c pointcut is final
    public pointcut publicPointcut() : call(void run());
}
------------
When run, it picks out run() rather than walk().</description><comments/></buginformation><fixedCommits><commit id="86ce1f7ce2a4be24e55a0eafc96de86142ce1278" author="default" date="2005-08-19 16:51:30"><file name="weaver/src/org/aspectj/weaver/ResolvedType.java"><method name="checkLegalOverride" returnType="boolean" parameters="ResolvedMember ResolvedMember"/><method name="isDuplicateMemberWithinTargetType" returnType="boolean" parameters="ResolvedMember"/></file></commit></fixedCommits></bug><bug id="167" opendate="2004-11-25 16:31:00" fixdate="2005-08-19 19:51:32"><buginformation><summary>BCException: illegal change to pointcut declaration: calls(&lt;nothing&gt;)</summary><description>~&gt; which ajc
/cygdrive/c/aspectj1.2.1/bin/ajc
~&gt; ajc -version
AspectJ Compiler 1.2.1 built on Friday Nov 5, 2004 at 12:30:41 GMT
~&gt; cat AspectTest.java
aspect AspectTest {
        pointcut calls(String str): call(*.new(String)) &amp;&amp; args(str);
        declare warning: calls(str) : "not statically determinable, trying anyway";
}
~&gt; ajc AspectTest.java
C:\Documents and Settings\Macneil Shonle\AspectTest.java [error] Internal
compiler error
org.aspectj.weaver.BCException: illegal change to pointcut declaration:
calls(&lt;nothing&gt;)
        at
org.aspectj.weaver.patterns.ReferencePointcut.concretize1(ReferencePointcut.java:268)
        at org.aspectj.weaver.patterns.Pointcut.concretize(Pointcut.java:167)
        at org.aspectj.weaver.patterns.Pointcut.concretize(Pointcut.java:154)
        at org.aspectj.weaver.Checker.concretize(Checker.java:35)
        at
org.aspectj.weaver.CrosscuttingMembers.addShadowMunger(CrosscuttingMembers.java:78)
        at
org.aspectj.weaver.CrosscuttingMembers.addDeclare(CrosscuttingMembers.java:102)
        at
org.aspectj.weaver.CrosscuttingMembers.addDeclares(CrosscuttingMembers.java:92)
        at
org.aspectj.weaver.CrosscuttingMembersSet.addAdviceLikeDeclares(CrosscuttingMembersSet.java:68)
        at
org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.addAdviceLikeDeclares(AjLookupEnvironment.java:163)
        at
org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.completeTypeBindings(AjLookupEnvironment.java:138)
        at
org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.beginToCompile(Compiler.java:331)
        at
org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:348)
        at
org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:680)
        at
org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:168)
        at
org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:102)
        at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:109)
        at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:60)
        at org.aspectj.tools.ajc.Main.run(Main.java:291)
        at org.aspectj.tools.ajc.Main.runMain(Main.java:227)
        at org.aspectj.tools.ajc.Main.main(Main.java:80)

(no source information available)
C:\Documents and Settings\Macneil Shonle\AspectTest.java:3 [error] bad parameter
to pointcut reference
declare warning: calls(str) : "not statically determinable, trying anyway";
                 ^^^^^^^^
C:\Documents and Settings\Macneil Shonle\AspectTest.java:3 [warning] no match
for this type name: str [Xlint:invalidAbsoluteTypeName]
declare warning: calls(str) : "not statically determinable, trying anyway";
                       ^
ABORT
        
Exception thrown from AspectJ 1.2.1

This might be logged as a bug already -- find current bugs at
   http://bugs.eclipse.org/bugs/buglist.cgi?product=AspectJ&amp;component=Compiler 

Bugs for exceptions thrown have titles File:line from the top stack, 
e.g., "SomeFile.java:243"

If you don't find the exception below in a bug, please add a new bug
at  http://bugs.eclipse.org/bugs/enter_bug.cgi?product=AspectJ 
To make the bug a priority, please include a test program
that can reproduce this exception.
illegal change to pointcut declaration: calls(&lt;nothing&gt;)
illegal change to pointcut declaration: calls(&lt;nothing&gt;)
org.aspectj.weaver.BCException: illegal change to pointcut declaration:
calls(&lt;nothing&gt;)
        at
org.aspectj.weaver.patterns.ReferencePointcut.concretize1(ReferencePointcut.java:268)
        at org.aspectj.weaver.patterns.Pointcut.concretize(Pointcut.java:167)
        at org.aspectj.weaver.patterns.Pointcut.concretize(Pointcut.java:154)
        at org.aspectj.weaver.Checker.concretize(Checker.java:35)
        at
org.aspectj.weaver.CrosscuttingMembers.addShadowMunger(CrosscuttingMembers.java:78)
        at
org.aspectj.weaver.CrosscuttingMembers.addDeclare(CrosscuttingMembers.java:102)
        at
org.aspectj.weaver.CrosscuttingMembers.addDeclares(CrosscuttingMembers.java:92)
        at
org.aspectj.weaver.CrosscuttingMembersSet.addAdviceLikeDeclares(CrosscuttingMembersSet.java:68)
        at
org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.addAdviceLikeDeclares(AjLookupEnvironment.java:163)
        at
org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.completeTypeBindings(AjLookupEnvironment.java:138)
        at
org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.beginToCompile(Compiler.java:331)
        at
org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:348)
        at
org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:680)
        at
org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:168)
        at
org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:102)
        at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:109)
        at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:60)
        at org.aspectj.tools.ajc.Main.run(Main.java:291)
        at org.aspectj.tools.ajc.Main.runMain(Main.java:227)
        at org.aspectj.tools.ajc.Main.main(Main.java:80)

Dumping to ajcore.20041125.132911.022.txt

1 fail|abort, 2 errors, 1 warning
Signal 127</description><comments/></buginformation><fixedCommits><commit id="93fdce17441da20b66f6db665db9d9272adda09c" author="default" date="2005-08-19 19:51:32"><file name="weaver/src/org/aspectj/weaver/patterns/ReferencePointcut.java"><method name="concretize1" returnType="Pointcut" parameters="ResolvedType IntMap"/></file></commit></fixedCommits></bug><bug id="168" opendate="2005-01-17 12:07:00" fixdate="2005-08-24 17:50:18"><buginformation><summary>Compiler error due to a wrong exception check in try blocks</summary><description>Compiler error on correct code when an aspect performs a method introdiction.
The method introduction contains an invocation to a method from the class and
such an invocation is inside an appropriate try block.
The ajc compiler performs a wrong check on the exception types.
To understand better, please see the attached example</description><comments/></buginformation><fixedCommits><commit id="cc6e6812fa6908d315e2f07195bca3914438cb1a" author="default" date="2005-08-24 17:50:18"><file name="weaver/src/org/aspectj/weaver/AjcMemberMaker.java"><method name="|" returnType="Modifier.PUBLIC" parameters=""/><method name="privilegedAccessMethodForMethod" returnType="ResolvedMember" parameters="UnresolvedType ResolvedMember"/></file></commit></fixedCommits></bug><bug id="169" opendate="2005-07-21 15:16:00" fixdate="2005-08-25 11:35:49"><buginformation><summary>VerifyError after weaving around trivial switch statement</summary><description>After compiling the attached source file and class file with

ajc -inpath . -outjar t.jar Tracer.aj

(on any of 1.2.1, 1.5.0M2 or the June 2005 snapshot) and then attempting to run
it with

gij -classpath ./t.jar:$CLASSPATH Test

the following error is obtained:

Exception in thread "main" java.lang.VerifyError: verification failed at PC 1 in
Test:newTest_aroundBody2((I)LTest;): branch out of range
   at java.lang.VMClassLoader.resolveClass(java.lang.Class)
(/usr/lib/libgcj.so.6.0.0)
   at java.lang.Class.initializeClass() (/usr/lib/libgcj.so.6.0.0)
   at java.lang.Class.forName(java.lang.String, boolean, java.lang.ClassLoader)
(/usr/lib/libgcj.so.6.0.0)
   at gnu.java.lang.MainThread.run() (/usr/lib/libgcj.so.6.0.0)

An excerpt from the output of

javap -private -classpath t.jar -c Test

shows that the generated switch is indeed bogus:

private static final Test newTest_aroundBody2(int);
  Code:
   0:   iload_0
   1:   tableswitch{ //0 to 0
                0: -1157627302;
                default: 16 }
   20:  invokespecial   #3; //Method "&lt;init&gt;":()V
   23:  areturn</description><comments/></buginformation><fixedCommits><commit id="bf767a9d6e6501df9e973e381546b1c66f41a757" author="default" date="2005-08-25 11:35:49"><file name="bcel-builder/src/org/aspectj/apache/bcel/generic/TABLESWITCH.java"><method name="dump" returnType="void" parameters="DataOutputStream"/></file></commit></fixedCommits></bug><bug id="170" opendate="2005-08-23 06:56:00" fixdate="2005-08-26 09:09:35"><buginformation><summary>ClassCastException popup</summary><description>Whenever I change any file and save(auto-compile) I get this in a popup.

ClassCastException thrown: 
org.aspectj.ajdt.internal.compiler.lookup.EclipseSourceType cannot be cast to 
org.aspectj.weaver.bcel.BcelObjectType

This started happening when I wrote these aspects.

Before this started happening the IDE showed this line as an error.

b.support.firePropertyChange( property,
			( oldval == null ) ? oldval : new String(oldval),
	                      new String(newval));


----------------------------------------------------------------
/**
 * 
 */
package com.blueprint.util.mixin.test;

import java.beans.PropertyChangeListener;
import java.beans.PropertyChangeSupport;
import java.lang.reflect.Field;
import com.blueprint.util.mixin.test.*;
import org.aspectj.lang.Signature;

public aspect PropertySupportAspect {
	
		PropertyChangeSupport PropertySupport.support = new 
PropertyChangeSupport(this);

		public interface PropertySupport{
			  public void addPropertyChangeListener( 
PropertyChangeListener listener );
			  public void addPropertyChangeListener( String 
propertyName,
				                                     
PropertyChangeListener listener );
			  public void removePropertyChangeListener( String 
propertyName,
				                                        
PropertyChangeListener listener );
			  public void removePropertyChangeListener( 
PropertyChangeListener listener );
			  public void hasListeners( String propertyName );
		}
		
		public void PropertySupport.addPropertyChangeListener
(PropertyChangeListener listener){
		    support.addPropertyChangeListener(listener);
		}
		
		public void PropertySupport.addPropertyChangeListener( String 
propertyName,
		                                                       
PropertyChangeListener listener){

			support.addPropertyChangeListener(propertyName, 
listener);
	    }
	    
		public void PropertySupport.removePropertyChangeListener( 
String propertyName,
			                                                      
PropertyChangeListener listener) {
			support.removePropertyChangeListener(propertyName, 
listener);
	    }
		
		public void PropertySupport.removePropertyChangeListener
(PropertyChangeListener listener) {
		    support.removePropertyChangeListener(listener);
		}
		
		public void PropertySupport.hasListeners(String propertyName) {
		    support.hasListeners(propertyName);
		}

		pointcut callSetter( Bean b ) 
	    : call( public void com.blueprint.util.test.Bean.setName( 
String ) ) &amp;&amp; target( b );
		
		void around( Bean b ) : callSetter( b )  {
		    String propertyName = getField( 
thisJoinPointStaticPart.getSignature() ).
		    							
									getName
();
			System.out.println( "The property is [" + propertyName 
+ "]" );
			String oldValue = b.getName();
		    proceed( b );
		    firePropertyChange( b, propertyName, oldValue, b.getName
());
		}

	    private Field getField( Signature signature ){
	    	Field field = null;
			System.out.println( "Getting the field name of [" 
+signature.getName() + "]" );
	    	
	    	try{
	    		String methodName = signature.getName();
	    		field = signature.getDeclaringType().
							
	getDeclaredField( methodName.
									
			   substring( 3,
									
		                  methodName.length() ).
									
		                  			toLowerCase());
	    		field.setAccessible(true);
	    	}catch( NoSuchFieldException nsfe ){
	    		nsfe.printStackTrace();
	    	}
			return field;
		}

		void firePropertyChange( Bean b,
					 String property,
					 String oldval,
					 String newval) {
		System.out.println( "The property is [" + property + "]");
		System.out.println( "The old value is [" + oldval + "]");
		System.out.println( "The new value is [" + newval + "]");
		b.support.firePropertyChange( property,
					( oldval == null ) ? oldval : new 
String(oldval),
			            new String(newval));
		}
		
}
----------------------------------------------------------------
import java.io.Serializable;

public class Bean implements Serializable{
	
	private String name;

	public String getName() {
		return name;
	}
	public void setName( String name ) {
		this.name = name;
	}
}
----------------------------------------------------------------
public aspect BeanSupport {
     declare parents: Bean implements PropertySupportAspect.PropertySupport;
}
----------------------------------------------------------------</description><comments/></buginformation><fixedCommits><commit id="100d9e056735e85610fe9072527a0369dc867ec5" author="default" date="2005-08-26 09:09:35"><file name="weaver/src/org/aspectj/weaver/bcel/BcelWorld.java"><method name="makePerClauseAspect" returnType="ConcreteTypeMunger" parameters="ResolvedType"/><method name="getBcelObjectType" returnType="BcelObjectType" parameters="ResolvedType"/></file><file name="weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java"><method name="weave" returnType="Collection" parameters="IClassFileProvider"/><method name="weaveAndNotify" returnType="void" parameters="UnwovenClassFile"/></file></commit></fixedCommits></bug><bug id="171" opendate="2005-08-25 16:22:00" fixdate="2005-08-26 11:43:32"><buginformation><summary>Execution not matching override in doubly derived method</summary><description>The following sample code fails because the compiler isn't matching the
execution of doPost in MockServlet4. The declare warning for "servlet request"
doesn't match  in that case, nor does advice on the join point actually run at
runtime (though this simplified code only shows the problem with declare
warning). This was working until fairly recently (certainly in M2, even in AJDT
from August 11).

public abstract class MockServlet extends HttpServlet {
    
    protected void doPost() {
    }

    private static aspect FindMatches {
        declare warning: execution(* HttpServlet.do*(..)): "servlet request";
        declare warning: execution(* HttpServlet+.do*(..)): "servlet request2";    	
    }
}

class HttpServlet {
    protected void doPost() {
    }    
}

public class MockDelayingServlet extends MockServlet {
    private static final long serialVersionUID = 1; 
}

public class MockServlet4 extends MockDelayingServlet 
{
    protected void doPost()
    {
    } 
}

compiler output (should have 6 warnings, including two for MockServlet4):

C:\devel\workspace\test\src\MockServlet.java:16 [warning] servlet request
protected void doPost() {
^^^^^^^^^^^^^^^^^^^^^^^^^
        method-execution(void MockServlet.doPost())
        see also: C:\devel\workspace\test\src\MockServlet.java:20::0
C:\devel\workspace\test\src\MockServlet.java:16 [warning] servlet request2
protected void doPost() {
^^^^^^^^^^^^^^^^^^^^^^^^^
        method-execution(void MockServlet.doPost())
        see also: C:\devel\workspace\test\src\MockServlet.java:21::0
C:\devel\workspace\test\src\MockServlet.java:26 [warning] servlet request
protected void doPost() {
^^^^^^^^^^^^^^^^^^^^^^^^^
        method-execution(void HttpServlet.doPost())
        see also: C:\devel\workspace\test\src\MockServlet.java:20::0
C:\devel\workspace\test\src\MockServlet.java:26 [warning] servlet request2
protected void doPost() {
^^^^^^^^^^^^^^^^^^^^^^^^^
        method-execution(void HttpServlet.doPost())
        see also: C:\devel\workspace\test\src\MockServlet.java:21::0
C:\devel\workspace\test\src\MockServlet4.java:9 [warning] servlet request2
protected void doPost()
^^^^^^^^^^^^^^^^^^^^^^^
        method-execution(void MockServlet4.doPost())
        see also: C:\devel\workspace\test\src\MockServlet.java:21::0

5 warnings</description><comments/></buginformation><fixedCommits><commit id="27e68f3b3ae82408e8e046a40ab69d9e4996ff5a" author="default" date="2005-08-26 11:43:32"><file name="weaver/src/org/aspectj/weaver/ResolvedMemberImpl.java"><method name="accumulateMembersMatching" returnType="void" parameters=""/></file></commit></fixedCommits></bug><bug id="172" opendate="2005-08-31 02:35:00" fixdate="2005-08-31 11:42:29"><buginformation><summary>IllegalStateException: Undeclared type variable when hiding</summary><description>ISE thrown compiling  http://sourceforge.net/projects/collections  4.0beta3 source.
javac issues two warnings, but Eclipse 3.1 (JDT) issues *many* for type
parameter hiding types (perhaps  bug 103783 ).  I haven't isolated a test case or
tried it on earlier releases - sorry.</description><comments/></buginformation><fixedCommits><commit id="2c9ea11c6d7354d3e44aa59531964a15b4486519" author="default" date="2005-08-31 11:42:29"><file name="weaver/testsrc/org/aspectj/weaver/bcel/BcelGenericSignatureToTypeXTestCase.java"><method name="testColonColon" returnType="void" parameters=""/><method name="testEnumFromHell" returnType="void" parameters=""/></file><file name="weaver/src/org/aspectj/weaver/bcel/BcelObjectType.java"><method name="unpackGenericSignature" returnType="void" parameters=""/><method name="setJavaClass" returnType="void" parameters="JavaClass"/><method name="getFormalTypeParametersFromOuterClass" returnType="Signature.FormalTypeParameter[]" parameters=""/></file><file name="weaver/src/org/aspectj/weaver/bcel/BcelGenericSignatureToTypeXConverter.java"><method name="resolve" returnType="ResolvedType" parameters="World"/><method name="fieldTypeSignature2TypeX" returnType="ResolvedType" parameters=""/><method name="classTypeSignature2TypeX" returnType="ResolvedType" parameters=""/><method name="typeArgument2TypeX" returnType="ResolvedType" parameters=""/><method name="typeVariableSignature2TypeX" returnType="ResolvedType" parameters=""/><method name="typeSignature2TypeX" returnType="ResolvedType" parameters=""/><method name="formalTypeParameter2TypeVariable" returnType="TypeVariable" parameters=""/></file><file name="weaver/src/org/aspectj/weaver/bcel/BcelField.java"><method name="unpackGenericSignature" returnType="void" parameters=""/></file><file name="weaver/src/org/aspectj/weaver/bcel/BcelMethod.java"><method name="unpackGenericSignature" returnType="void" parameters=""/></file></commit></fixedCommits></bug><bug id="173" opendate="2005-08-24 10:53:00" fixdate="2005-08-31 14:24:14"><buginformation><summary>illegal argument to proceed crashes the parser</summary><description>in a context where proceed requires zero arguments, calling it with an extra
argument crashes the compiler, but only if that argument is a field access:

class Foo {
  Foo field;
  void test() {}
}

public aspect Bug {
  void around() : call(void Foo.test()) {
    Foo foo = new Foo().field;
    proceed(foo); // caught at compile time
    proceed(new Foo().field); // crashes
  }
}


/home/user/sgelin3/dev/java/ajc/new_bug/Bug.java [error] Internal compiler error
java.lang.NullPointerException
        at
org.aspectj.ajdt.internal.compiler.ast.AccessForInlineVisitor.getAccessibleField(AccessForInlineVisitor.java:145)
        at
org.aspectj.ajdt.internal.compiler.ast.AccessForInlineVisitor.endVisit(AccessForInlineVisitor.java:108)
        at
org.aspectj.org.eclipse.jdt.internal.compiler.ast.FieldReference.traverse(FieldReference.java:609)
        at
org.aspectj.org.eclipse.jdt.internal.compiler.ast.MessageSend.traverse(MessageSend.java:467)
        at
org.aspectj.org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.traverse(MethodDeclaration.java:212)</description><comments/></buginformation><fixedCommits><commit id="6c8747b590e9e9092ae256f2c7af0db169a6e2e4" author="default" date="2005-08-31 14:24:14"><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AccessForInlineVisitor.java"><method name="getAccessibleField" returnType="FieldBinding" parameters="FieldBinding TypeBinding"/></file></commit></fixedCommits></bug><bug id="174" opendate="2004-07-30 10:36:00" fixdate="2005-08-31 15:44:22"><buginformation><summary>pointcut call(MethodPattern) matches non-visible methods in parent class</summary><description>aspectjtools.jar / ajc v1.2

We believe that the call(methodpattern) pointcut has matching behaviour that is
inconsistent with what we expect from Java in relation to invocations of methods
on subclasses and superclasses.

Background: 
Our goal is to use an aspect to declare ajc compiler warnings on any invocation
to a target method, where the space of targets is defined as any visible method
of any class in a specified package P or its subpackages.

As well as straight invocations from types in packages oustide P and its
subpackages, we wish to match method invocations on P where the methods invoked
are inherited from P -- that is , they are obtained in a type that directly
extends a type in P or its subpackages.  

The fragment of the aspect we are using is:
public aspect Aspect1
{
  pointcut methodCalls() : 
    !within(Aspect1) &amp;&amp;
    call(* P..*.*(..)) ;         // 'P' is the target package space
  declare warning : methodCalls() : "invoking";
  //...
}

Consider these cases:

Case 1 method inheritance: 
Superclass A in package P declares and implements a public method M.  A direct
subclass B (in a package outside P) directly extends A and inherits this method.
 Now, any calls inside B to M or this.M() are matched by the call() join point
above which seeks to match calls to P..*.*() This is as we would expect since
the implementation in package space P is actually being called.

Case 2 method overriding: 
Superclass A in package P declares and implements a public method M.  Direct
subclass B (in a package outside P) overrides A.M with its own implementation
M'. M' does not invoke M.  Now, calls inside B to M' or this.M'() are still
matched by the call() join point above which seeks to match calls to P..*.*()
even though M' does not invoke or depend on M.  We do not expect this result
since we do not think M is actually called.

Case 3 redeclaration of non-visible method with the same name:  
Superclass A in package P declares and implements a private method M.  Direct
subclass B (in a package outside P) introduces its own method M having the same
signature as A.M.  Now, calls in B to M or this.M() are still matched by the
call() join point above which seeks to match calls to P..*.*() even though A.M
is not visible to B and is never called by it. We do not expect this result
since we do not think A.M is ever called.

The only way we can explain this apparent behaviour is by reasoning that the
compiler is treating the subclass B "as a type of" its parent A and somehow
concluding that method calls on B can be equated with calls to methods of
identical signature on A.  However this seems at odds with the rules for Java
visibility and with our expectations for when the call(...) joinpoint should match.

We have experimented with execution(...) join points to perform this matching
but that has turned up a different set of problems which we are still analyzing.

Please can you shed any light on what the call joinpoint is doing here?

regards, Dave</description><comments/></buginformation><fixedCommits><commit id="7e0c3cdc37b974ef2bba01e19fa90cb9c752f288" author="default" date="2005-08-31 15:44:22"><file name="weaver/src/org/aspectj/weaver/ResolvedMemberImpl.java"><method name="accumulateMembersMatching" returnType="void" parameters=""/></file></commit></fixedCommits></bug><bug id="175" opendate="2004-04-20 03:42:00" fixdate="2005-09-01 08:30:41"><buginformation><summary>"adviceexecution() &amp;&amp; args()" pcd does not pick up around advice execution because args() does not match the AroundClosure parameter.</summary><description>In the following sample, the advice defined in "other_aspect" does not pick up 
the execution of around advice defined in "some_aspect". It matches only 
against the before advice defined in "some_aspect".

The implicit AroundClosure parameter of an around advice seems to come in the 
way of args() matching. 

------------------------------------------------------ 
aspect some_aspect {
   pointcut call_m(int a, int b) : 
              call(int test.m(..)) &amp;&amp; args(a, b);
 
   before(int x, int y) : call_m(x, y) { ...  }
   int around(int x, int y) : call_m(x, y) { ... }
}
 
aspect other_aspect {
   before(int x, int y) : 
       adviceexecution() &amp;&amp; within(some_aspect) &amp;&amp; 
                                       args(x, y){ 
         ...
       }
}
--------------------------------------------------------

AspectJ doc has to state this explicitly.</description><comments/></buginformation><fixedCommits><commit id="a66e0a2aa8a6cb057f4b0d740ad961fb1ede5e85" author="default" date="2005-09-01 08:30:41"><file name="weaver/src/org/aspectj/weaver/patterns/ArgsPointcut.java"><method name="matchInternal" returnType="FuzzyBoolean" parameters="Shadow"/><method name="findResidueNoEllipsis" returnType="Test" parameters="Shadow ExposedState TypePattern[]"/><method name="findResidueInternal" returnType="Test" parameters="Shadow ExposedState"/></file></commit></fixedCommits></bug><bug id="176" opendate="2004-04-19 10:52:00" fixdate="2005-09-01 14:17:29"><buginformation><summary>Reduce footprint of JoinPoint.StaticPart objects</summary><description>Tests show that each object consumes 180+ bytes. For a large project (1000+ 
classes) where an aspect is used to implement a pervasive cross-cutting 
concern e.g. exception logging this can lead to &gt;1MB of additional heap space. 
Two possible approaches could be:
1. Break literal String used by Factory.makeXXXSig() methods into component 
parts e.g. package, class, method. ... names. These could then be shared 
automatically by the JVM as interned Strings.
2. Lazy instantiation of handler static JPs in the catch block.

Any enhancements could be enabled by a compiler option similar to -XlazyTjp.</description><comments/></buginformation><fixedCommits><commit id="a5e645fa9a16aba627560d058be824438ddfc890" author="default" date="2005-09-01 14:17:29"><file name="runtime/src/org/aspectj/runtime/reflect/SignatureImpl.java"><method name="Hashtable" returnType="Hashtable" parameters=""/><method name="extractType" returnType="Class" parameters="int"/><method name="makeClass" returnType="Class" parameters="String"/></file></commit></fixedCommits></bug><bug id="177" opendate="2005-07-01 06:48:00" fixdate="2005-09-01 18:40:31"><buginformation><summary>provide more detail in -showWeaveInfo messages</summary><description>When advice is executed, the object you have to work with is the joinpoint. This
can then be queried to get various information out of it. It would be nice, if
as part of the weaving you could get hold of the same information. 

This is particularly useful in the case of writing a coverage tool. In order to
measure where you've been, you have to know all the places you could possibly
go. The introduction of the -showWeaveInfo option means that we can record these
places, however, this would be greatly enhanced by providing similar information
as to that which is collected as the program is running.

The information which would be good is the same as that obtained from

JoinPoint.StaticPart.getSignature().toLongString().</description><comments/></buginformation><fixedCommits><commit id="c6bc7a2b2ee30b7647d3cb17fc323ebf96768fef" author="default" date="2005-09-01 18:40:31"><file name="weaver/src/org/aspectj/weaver/Shadow.java"><method name="reportWeavingMessage" returnType="void" parameters="ShadowMunger"/></file><file name="tests/java5/ataspectj/ataspectj/ltwlog/MainVerboseAndShow.java"><method name="main" returnType="void" parameters="String"/></file></commit></fixedCommits></bug><bug id="178" opendate="2005-06-03 10:57:00" fixdate="2005-09-01 19:47:37"><buginformation><summary>no "matches declare" entry in structure model for single declare warning statement</summary><description>A project containing one class and one aspect:

-----------------------------------------------------

package pack;

public class C {

	public static void main(String[] args) {
		new C().sayHello();
	}
	
	public void sayHello() {
		System.out.println("HELLO");
	}
}

----------------------------------------------------

package pack;

public aspect A {
		
	declare warning : 
		execution(* C.sayHello(..)) :
			"blah blah";	
		
}

-----------------------------------------------------

has the "matched by" entry for A.aj, but doesn't have the "matches declare"
entry for C.java.

This means that in AJDT, C.sayHello isn't added to our map and consequently we
don't get any relationships showing in the Cross Reference view for A.aj.</description><comments/></buginformation><fixedCommits><commit id="619f8bc764e127d4f43ece87ae0e858f7329ec9e" author="default" date="2005-09-01 19:47:37"><file name="weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"><method name="getSourceLocation" returnType="ISourceLocation" parameters=""/></file></commit></fixedCommits></bug><bug id="179" opendate="2005-08-25 17:47:00" fixdate="2005-09-02 09:35:02"><buginformation><summary>NPE when opening resources from CVS resources history</summary><description>NPE when opening resources (double-click) from CVS resources history view.

java.lang.NullPointerException
	at
org.eclipse.mylar.java.ui.editor.MylarJavaElementDescriptor.drawCompositeImage(MylarJavaElementDescriptor.java:40)
	at
org.eclipse.jface.resource.CompositeImageDescriptor.getImageData(CompositeImageDescriptor.java:205)
	at
org.eclipse.jface.resource.ImageDescriptor.createImage(ImageDescriptor.java:279)
	at
org.eclipse.jface.resource.ImageDescriptor.createImage(ImageDescriptor.java:233)
	at
org.eclipse.jface.resource.ImageDescriptor.createImage(ImageDescriptor.java:211)
	at
org.eclipse.mylar.ui.MylarImages.getImage(MylarImages.java:108)
	at org.eclipse.mylar.java.ui.editor.MylarCompilationUnitEditor.updatedTitleImage(MylarCompilationUnitEditor.java:55)
	at
org.eclipse.jdt.internal.ui.javaeditor.JavaEditorErrorTickUpdater$1.run(JavaEditorErrorTickUpdater.java:86)
	at
org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:152)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:28)
	at
org.eclipse.swt.widgets.Display.syncExec(Display.java:3413)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaEditorErrorTickUpdater.postImageChange(JavaEditorErrorTickUpdater.java:84)
	at
org.eclipse.jdt.internal.ui.javaeditor.JavaEditorErrorTickUpdater.updateEditorImage(JavaEditorErrorTickUpdater.java:77)
	at
org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor.doSetInput(CompilationUnitEditor.java:1548)
	at
org.eclipse.ui.texteditor.AbstractTextEditor$16.run(AbstractTextEditor.java:2360)
	at
org.eclipse.jface.operation.ModalContext.runInCurrentThread(ModalContext.java:346)
	at
org.eclipse.jface.operation.ModalContext.run(ModalContext.java:291)
	at org.eclipse.jface.window.ApplicationWindow$1.run(ApplicationWindow.java:624)
	at
org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:69)
	at org.eclipse.jface.window.ApplicationWindow.run(ApplicationWindow.java:621)
	at
org.eclipse.ui.internal.WorkbenchWindow.run(WorkbenchWindow.java:2135)
	at
org.eclipse.ui.texteditor.AbstractTextEditor.internalInit(AbstractTextEditor.java:2378)
	at
org.eclipse.ui.texteditor.AbstractTextEditor.init(AbstractTextEditor.java:2405)
	at
org.eclipse.ui.internal.EditorManager.createSite(EditorManager.java:773)
	at
org.eclipse.ui.internal.EditorReference.createPartHelper(EditorReference.java:572)
	at
org.eclipse.ui.internal.EditorReference.createPart(EditorReference.java:365)
	at
org.eclipse.ui.internal.WorkbenchPartReference.getPart(WorkbenchPartReference.java:552)
	at
org.eclipse.ui.internal.EditorReference.getEditor(EditorReference.java:214)
	at
org.eclipse.ui.internal.WorkbenchPage.busyOpenEditorBatched(WorkbenchPage.java:2325)
	at
org.eclipse.ui.internal.WorkbenchPage.busyOpenEditor(WorkbenchPage.java:2258)
	at
org.eclipse.ui.internal.WorkbenchPage.access$9(WorkbenchPage.java:2250)
	at
org.eclipse.ui.internal.WorkbenchPage$9.run(WorkbenchPage.java:2236)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:69)
	at
org.eclipse.ui.internal.WorkbenchPage.openEditor(WorkbenchPage.java:2231)
	at
org.eclipse.ui.internal.WorkbenchPage.openEditor(WorkbenchPage.java:2204)
	at
org.eclipse.team.internal.ccvs.ui.actions.OpenLogEntryAction$1.run(OpenLogEntryAction.java:85)
	at
org.eclipse.team.internal.ccvs.ui.repo.RepositoryManager.run(RepositoryManager.java:651)
	at
org.eclipse.team.internal.ccvs.ui.actions.CVSAction$2.run(CVSAction.java:347)
	at
org.eclipse.team.internal.ccvs.ui.actions.CVSAction$3.run(CVSAction.java:356)
	at
org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:69)
	at org.eclipse.team.internal.ccvs.ui.actions.CVSAction.run(CVSAction.java:353)
	at
org.eclipse.team.internal.ccvs.ui.actions.OpenLogEntryAction.execute(OpenLogEntryAction.java:64)
	at
org.eclipse.team.internal.ccvs.ui.actions.CVSAction.run(CVSAction.java:117)
	at
org.eclipse.team.internal.ccvs.ui.HistoryView$6.handleEvent(HistoryView.java:199)
	at
org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:66)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:843)
	at
org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:3080)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:2713)
	at
org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:1699)
	at org.eclipse.ui.internal.Workbench.runUI(Workbench.java:1663)
	at
org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:367)
	at
org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:143)
	at org.eclipse.ui.internal.ide.IDEApplication.run(IDEApplication.java:103)
	at
org.eclipse.core.internal.runtime.PlatformActivator$1.run(PlatformActivator.java:226)
	at
org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:376)
	at
org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:163)
	at
sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at
sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at
java.lang.reflect.Method.invoke(Method.java:585)
	at org.eclipse.core.launcher.Main.invokeFramework(Main.java:334)
	at
org.eclipse.core.launcher.Main.basicRun(Main.java:278)
	at org.eclipse.core.launcher.Main.run(Main.java:973)
	at
org.eclipse.core.launcher.Main.main(Main.java:948)</description><comments/></buginformation><fixedCommits><commit id="ad753aa80558748ab918988809ba6f58b8c26419" author="default" date="2005-09-02 09:35:02"><file name="bcel-builder/src/org/aspectj/apache/bcel/classfile/GenericSignatureParser.java"><method name="eatIdentifier" returnType="String" parameters=""/></file></commit></fixedCommits></bug><bug id="180" opendate="2005-06-09 08:36:00" fixdate="2005-09-02 10:40:19"><buginformation><summary>xlint advice not applied appears twice with cflows</summary><description>////////////// in the following code
aspect A{
  before(): call(* *(..)) &amp;&amp; cflow(execution(* *(..))) {}
}
////////////////////////////////////

two "advice not appied" xlint messages are produced, one for the before advice
and one for the cflow within the before advice.</description><comments/></buginformation><fixedCommits><commit id="047173e8683e4ab9004ae2151a8abad886d1b84b" author="default" date="2005-09-02 10:40:19"><file name="weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java"><method name="weave" returnType="Collection" parameters="IClassFileProvider"/></file></commit></fixedCommits></bug><bug id="181" opendate="2005-06-29 17:07:00" fixdate="2005-09-02 14:38:11"><buginformation><summary>[itds] abstract synchronized: compile error expected</summary><description>when using intertype declaration, the compiler doesn't check for illegal
modifier combinations such as "abstract synchronized".

another manifestation of this problem is when using intertype declaration to add
a synchronized method to an interface. the problem is more severe in this case
because conceptually, this method is not abstract at all.


interface Interface {}
abstract class Parent {}
class Child extends Parent implements Interface {}

aspect Bug {
  // illegal modifier combination not caught by ajc
  public abstract synchronized void Parent._abstract();

  public synchronized void Child._abstract() {}


  // the following has the same effect, but is easier to miss
  public /* implicit abstract */ synchronized void Interface._interface() {}


  // use Child to make java complain: "illegal modifiers: 0x421"
  // (this corresponds to "public abstract synchronized")
  public static void main(String[] args) {
    new Child();
  }
}</description><comments/></buginformation><fixedCommits><commit id="b17ff4ed2d55ec24f1f1a6f3fe70ffd91ac18e62" author="default" date="2005-09-02 14:38:11"><file name="weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java"><method name="mungeNewMethod" returnType="boolean" parameters="BcelClassWeaver"/></file></commit></fixedCommits></bug><bug id="182" opendate="2005-06-09 06:25:00" fixdate="2005-09-02 17:12:43"><buginformation><summary>Repetitive method name/signature in class file</summary><description>This is what the VM sais:

java.lang.ClassFormatError: Repetitive method name/signature in class file com/
netvisor/metadata_view/ComponentFactory
        at java.lang.ClassLoader.defineClass1(Native Method)
        at java.lang.ClassLoader.defineClass(ClassLoader.java:620)
        at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:
124)
        at java.net.URLClassLoader.defineClass(URLClassLoader.java:260)
        at java.net.URLClassLoader.access$100(URLClassLoader.java:56)
        at java.net.URLClassLoader$1.run(URLClassLoader.java:195)
        at java.security.AccessController.doPrivileged(Native Method)
        at java.net.URLClassLoader.findClass(URLClassLoader.java:188)
        at java.lang.ClassLoader.loadClass(ClassLoader.java:306)
        at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:268)
        at java.lang.ClassLoader.loadClass(ClassLoader.java:251)
        at java.lang.ClassLoader.loadClassInternal(ClassLoader.java:319)


And this is why: I've got an interface (ComponentFactory) and an aspect that 
adds various ITD methods trough that interface. I've added some methods to both 
the interface and the aspect, some other methods are only added trough the 
aspect. (The situation is a bit more complex, I've got a base interface/aspect 
with these two methods and the subaspects implement the problematic two methods
.)

And those methods that are both in the interface and the aspect are the ones 
that get duplicated in the interface class file.

This is working fine in the old CVS branch (1.2.*).

Hope it helps, good luck!</description><comments/></buginformation><fixedCommits><commit id="df46c6f728502a74b2d042a0a955eab1326ba76a" author="default" date="2005-09-02 17:12:43"><file name="weaver/src/org/aspectj/weaver/bcel/LazyClassGen.java"><method name="getLazyMethodGen" returnType="LazyMethodGen" parameters="String String"/><method name="getLazyMethodGen" returnType="LazyMethodGen" parameters="Member"/></file><file name="weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java"><method name="mungeNewMethod" returnType="boolean" parameters="BcelClassWeaver"/></file></commit></fixedCommits></bug><bug id="183" opendate="2005-09-06 03:18:00" fixdate="2005-09-06 13:08:19"><buginformation><summary>AspectJ 1.5.0 Development Compiler Chokes on Advice with Cflow</summary><description>The following is a valid AspectJ program, that should compile and run without 
infinite recursion. It does so with AspectJ 1.2.1. AspectJ 1.5.0 Development 
(but not M3a) chokes on it.

Sample Code:
aspect BadAdvice {
    after(Object controller) returning (Object foo): 
      cflow(adviceexecution() &amp;&amp; args(controller, ..) &amp;&amp; this(BadAdvice)) &amp;&amp; 
call(Bar+.new(..)) {
    }    
    Object around(Object controller) : call(* whoKnows()) &amp;&amp; target(controller) 
{
        return new Bar();
    }
    public static void main(String args[]) {
        (new Bar()).whoKnows();
    }
}

class Bar {
    void whoKnows() {}
}

Now look at the horrid output:
C:\devel\scratch\recurse&gt;ajc BadAdvice.aj
trouble in:
public class BadAdvice extends java.lang.Object:
  private static Throwable ajc$initFailureCause
  public static final BadAdvice ajc$perSingletonInstance
  public static final org.aspectj.runtime.internal.CFlowStack ajc$cflowStack$0
  static void &lt;clinit&gt;():
                    INVOKESTATIC BadAdvice.ajc$preClinit ()V
    staticinitialization(void BadAdvice.&lt;clinit&gt;())
    | catch java.lang.Throwable -&gt; E0
    | |             INVOKESTATIC BadAdvice.ajc$postClinit ()V   (line 1)
    | catch java.lang.Throwable -&gt; E0
    |               GOTO L0
    |           E0: ASTORE_0
    |               ALOAD_0
    |               PUTSTATIC BadAdvice.ajc$initFailureCause Ljava/lang/Throwabl
e;
    |           L0: RETURN
    staticinitialization(void BadAdvice.&lt;clinit&gt;())
  end static void &lt;clinit&gt;()

  void &lt;init&gt;():
                    ALOAD_0     // BadAdvice this   (line 1)
                    INVOKESPECIAL java.lang.Object.&lt;init&gt; ()V
    constructor-execution(void BadAdvice.&lt;init&gt;())
    |               RETURN
    constructor-execution(void BadAdvice.&lt;init&gt;())
  end void &lt;init&gt;()

  public void ajc$afterReturning$BadAdvice$1$97dc015a(Object, Object)    AdviceA
ttribute(afterReturning, (cflow((execution(* *) &amp;&amp; (args(BindingTypePattern(java
.lang.Object, 0), ..) &amp;&amp; this(BadAdvice)))) &amp;&amp; call(Bar+.new(..))), 1, 24)
:
                    ALOAD_1
                    ASTORE_3
                    ALOAD_2
                    ASTORE 4
    advice-execution(void BadAdvice.ajc$afterReturning$BadAdvice$1$97dc015a(java
.lang.Object, java.lang.Object))
    |               BIPUSH 1
    |               ANEWARRAY java.lang.Object
    |               ASTORE 6
    |               ALOAD 6
    |               BIPUSH 0
    |               ALOAD_3
    |               AASTORE
    |               GETSTATIC BadAdvice.ajc$cflowStack$0 Lorg/aspectj/runtime/in
ternal/CFlowStack;
    |               ALOAD 6
    |               INVOKEVIRTUAL org.aspectj.runtime.internal.CFlowStack.push (
[Ljava/lang/Object;)V
    | catch java.lang.Throwable -&gt; E0
    | |             GOTO L0   (line 4)
    | catch java.lang.Throwable -&gt; E0
    |           E0: ASTORE 7
    |               GETSTATIC BadAdvice.ajc$cflowStack$0 Lorg/aspectj/runtime/in
ternal/CFlowStack;
    |               INVOKEVIRTUAL org.aspectj.runtime.internal.CFlowStack.pop ()
V
    |               ALOAD 7
    |               ATHROW
    |           L0: GETSTATIC BadAdvice.ajc$cflowStack$0 Lorg/aspectj/runtime/in
ternal/CFlowStack;
    |               INVOKEVIRTUAL org.aspectj.runtime.internal.CFlowStack.pop ()
V
    |               RETURN
    advice-execution(void BadAdvice.ajc$afterReturning$BadAdvice$1$97dc015a(java
.lang.Object, java.lang.Object))
  end public void ajc$afterReturning$BadAdvice$1$97dc015a(Object, Object)

  public Object ajc$around$BadAdvice$2$ef382b2d(Object, org.aspectj.runtime.inte
rnal.AroundClosure)    AdviceAttribute(around, (call(* whoKnows()) &amp;&amp; target(Bin
dingTypePattern(java.lang.Object, 0))), 1, 196)
:
    advice-execution(java.lang.Object BadAdvice.ajc$around$BadAdvice$2$ef382b2d(
java.lang.Object, org.aspectj.runtime.internal.AroundClosure))
    | constructor-call(void Bar.&lt;init&gt;())
    | |             NEW Bar
    | |             DUP
    | |             INVOKESPECIAL Bar.&lt;init&gt; ()V   (line 6)
    | |             DUP
    | |             ASTORE_3
    | |             GETSTATIC BadAdvice.ajc$cflowStack$0 Lorg/aspectj/runtime/in
ternal/CFlowStack;
    | |             INVOKEVIRTUAL org.aspectj.runtime.internal.CFlowStack.isVali
d ()Z
    | |             IFEQ L0
    | |             INVOKESTATIC BadAdvice.aspectOf ()LBadAdvice;
    | |             GETSTATIC BadAdvice.ajc$cflowStack$0 Lorg/aspectj/runtime/in
ternal/CFlowStack;
    | |             BIPUSH 0
    | |             INVOKEVIRTUAL org.aspectj.runtime.internal.CFlowStack.get (I
)Ljava/lang/Object;
    | |             ALOAD_3
    | |             INVOKEVIRTUAL BadAdvice.ajc$afterReturning$BadAdvice$1$97dc0
15a (Ljava/lang/Object;Ljava/lang/Object;)V
    | |         L0: NOP
    | constructor-call(void Bar.&lt;init&gt;())
    |               ARETURN
    advice-execution(java.lang.Object BadAdvice.ajc$around$BadAdvice$2$ef382b2d(
java.lang.Object, org.aspectj.runtime.internal.AroundClosure))
  end public Object ajc$around$BadAdvice$2$ef382b2d(Object, org.aspectj.runtime.
internal.AroundClosure)

  static Object ajc$around$BadAdvice$2$ef382b2dproceed(Object, org.aspectj.runti
me.internal.AroundClosure) throws java.lang.Throwable    org.aspectj.weaver.AjAt
tribute$AjSynthetic@3feb61
:
                    ALOAD_1
                    ICONST_1
                    ANEWARRAY java.lang.Object
                    DUP
                    ICONST_0
                    ALOAD_0     // BadAdvice this
                    AASTORE
                    INVOKEVIRTUAL org.aspectj.runtime.internal.AroundClosure.run
 ([Ljava/lang/Object;)Ljava/lang/Object;
                    CHECKCAST java.lang.Object
                    ARETURN
  end static Object ajc$around$BadAdvice$2$ef382b2dproceed(Object, org.aspectj.r
untime.internal.AroundClosure) throws java.lang.Throwable

  public static BadAdvice aspectOf()    org.aspectj.weaver.AjAttribute$AjSynthet
ic@3ff616
:
                    GETSTATIC BadAdvice.ajc$perSingletonInstance LBadAdvice;
                    IFNONNULL L0
                    NEW org.aspectj.lang.NoAspectBoundException
                    DUP
                    LDC "BadAdvice"
                    GETSTATIC BadAdvice.ajc$initFailureCause Ljava/lang/Throwabl
e;
                    INVOKESPECIAL org.aspectj.lang.NoAspectBoundException.&lt;init&gt;
 (Ljava/lang/String;Ljava/lang/Throwable;)V
                    ATHROW
                L0: GETSTATIC BadAdvice.ajc$perSingletonInstance LBadAdvice;
                    ARETURN
  end public static BadAdvice aspectOf()

  public static boolean hasAspect()    org.aspectj.weaver.AjAttribute$AjSyntheti
c@400021
:
                    GETSTATIC BadAdvice.ajc$perSingletonInstance LBadAdvice;
                    IFNULL L0
                    ICONST_1
                    IRETURN
                L0: ICONST_0
                    IRETURN
  end public static boolean hasAspect()

  private static void ajc$postClinit()    org.aspectj.weaver.AjAttribute$AjSynth
etic@400662
:
                    NEW BadAdvice
                    DUP
                    INVOKESPECIAL BadAdvice.&lt;init&gt; ()V
                    PUTSTATIC BadAdvice.ajc$perSingletonInstance LBadAdvice;
                    RETURN
  end private static void ajc$postClinit()

  static void ajc$preClinit():
                    NEW org.aspectj.runtime.internal.CFlowStack
                    DUP
                    INVOKESPECIAL org.aspectj.runtime.internal.CFlowStack.&lt;init&gt;
 ()V
                    PUTSTATIC BadAdvice.ajc$cflowStack$0 Lorg/aspectj/runtime/in
ternal/CFlowStack;
                    RETURN
  end static void ajc$preClinit()
end public class BadAdvice
java.lang.NullPointerException
        at org.aspectj.weaver.bcel.BcelVar.appendConvertableArrayStore(BcelVar.j
ava:96)
        at org.aspectj.weaver.bcel.BcelShadow.weaveCflowEntry(BcelShadow.java:18
36)
        at org.aspectj.weaver.bcel.BcelAdvice.implementOn(BcelAdvice.java:200)
        at org.aspectj.weaver.Shadow.implementMungers(Shadow.java:511)
        at org.aspectj.weaver.Shadow.implement(Shadow.java:388)
        at org.aspectj.weaver.bcel.BcelClassWeaver.implement(BcelClassWeaver.jav
a:1757)
        at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:39
3)
        at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:96
)
        at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1415)
        at org.aspectj.weaver.bcel.BcelWeaver.weaveWithoutDump(BcelWeaver.java:1
380)
        at org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify(BcelWeaver.java:115
7)
        at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:989)
        at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave(AjCompiler
Adapter.java:286)
        at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling(A
jCompilerAdapter.java:165)
        at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$afterReturning
$org_aspectj_ajdt_internal_compiler_CompilerAdapter$2$f9cc9ca0(CompilerAdapter.a
j:70)
        at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compil
er.java:367)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilat
ion(AjBuildManager.java:728)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuild
Manager.java:206)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBu
ildManager.java:140)
        at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:112)
        at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:60)
        at org.aspectj.tools.ajc.Main.run(Main.java:324)
        at org.aspectj.tools.ajc.Main.runMain(Main.java:238)
        at org.aspectj.tools.ajc.Main.main(Main.java:82)
ABORT

Exception thrown from AspectJ DEVELOPMENT

This might be logged as a bug already -- find current bugs at
   http://bugs.eclipse.org/bugs/buglist.cgi?product=AspectJ&amp;component=Compiler 

Bugs for exceptions thrown have titles File:line from the top stack,
e.g., "SomeFile.java:243"

If you don't find the exception below in a bug, please add a new bug
at  http://bugs.eclipse.org/bugs/enter_bug.cgi?product=AspectJ 
To make the bug a priority, please include a test program
that can reproduce this exception.
null
java.lang.NullPointerException
        at org.aspectj.weaver.bcel.BcelVar.appendConvertableArrayStore(BcelVar.j
ava:96)
        at org.aspectj.weaver.bcel.BcelShadow.weaveCflowEntry(BcelShadow.java:18
36)
        at org.aspectj.weaver.bcel.BcelAdvice.implementOn(BcelAdvice.java:200)
        at org.aspectj.weaver.Shadow.implementMungers(Shadow.java:511)
        at org.aspectj.weaver.Shadow.implement(Shadow.java:388)
        at org.aspectj.weaver.bcel.BcelClassWeaver.implement(BcelClassWeaver.jav
a:1757)
        at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:39
3)
        at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:96
)
        at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1415)
        at org.aspectj.weaver.bcel.BcelWeaver.weaveWithoutDump(BcelWeaver.java:1
380)
        at org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify(BcelWeaver.java:115
7)
        at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:989)
        at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave(AjCompiler
Adapter.java:286)
        at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling(A
jCompilerAdapter.java:165)
        at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$afterReturning
$org_aspectj_ajdt_internal_compiler_CompilerAdapter$2$f9cc9ca0(CompilerAdapter.a
j:70)
        at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compil
er.java:367)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilat
ion(AjBuildManager.java:728)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuild
Manager.java:206)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBu
ildManager.java:140)
        at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:112)
        at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:60)
        at org.aspectj.tools.ajc.Main.run(Main.java:324)
        at org.aspectj.tools.ajc.Main.runMain(Main.java:238)
        at org.aspectj.tools.ajc.Main.main(Main.java:82)


1 fail|abort

Note: there isn't ever a call to construct a Bar in the first advice, so it 
shouldn't actually be self-advising at runtime, and even though the advice does 
itself match the cflow expression, it should just push an entry on the cflow 
stack.

By the way, this would be a great place to have a name for advice, so I could 
exclude this one advice from advising itself.</description><comments/></buginformation><fixedCommits><commit id="71771abbb2d2bac4cd832323c08d9dcad81db2a0" author="default" date="2005-09-06 13:08:19"><file name="weaver/src/org/aspectj/weaver/patterns/ArgsPointcut.java"><method name="findResidueInternal" returnType="Test" parameters="Shadow ExposedState"/></file></commit></fixedCommits></bug><bug id="184" opendate="2005-09-06 19:02:00" fixdate="2005-09-08 16:57:15"><buginformation><summary>Getting Exception during compilation : java.lang.RuntimeException: Internal Compiler Error: Unexpected null source location passed as 'see also' location.</summary><description>Am attaching a small test case to reproduce the error 
(Not sure how to attach it - hopefully should be feasible to do so after I log
the bug).</description><comments/></buginformation><fixedCommits><commit id="2d21db05869efd4715e8a4a10810c18a89093bfb" author="default" date="2005-09-08 16:57:15"><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseSourceType.java"><method name="eclipseWorld" returnType="EclipseFactory" parameters=""/><method name="fillDeclaredMembers" returnType="void" parameters=""/></file><file name="weaver/src/org/aspectj/weaver/ResolvedType.java"><method name="checkLegalOverride" returnType="boolean" parameters="ResolvedMember ResolvedMember"/></file><file name="weaver/src/org/aspectj/weaver/ResolvedMemberImpl.java"><method name="parameterizedWith" returnType="ResolvedMemberImpl" parameters="UnresolvedType[]"/></file><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java"><method name="completeTypeBindings" returnType="void" parameters=""/><method name="anonymousTypeBindingCreated" returnType="void" parameters="LocalTypeBinding"/></file><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"><method name="addSourceTypeBinding" returnType="void" parameters="SourceTypeBinding"/></file></commit></fixedCommits></bug><bug id="185" opendate="2005-09-07 21:09:00" fixdate="2005-09-08 19:19:11"><buginformation><summary>NullPointerException when building configuration</summary><description>The exception below seems to be happening with any .lst file:

Message: NullPointerException thrown: null
Stack trace: java.lang.NullPointerException
	at
org.aspectj.ajde.internal.CompilerAdapter.configureBuildOptions(CompilerAdapter.java:296)
	at
org.aspectj.ajde.internal.CompilerAdapter.genBuildConfig(CompilerAdapter.java:170)
	at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:95)
	at
org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)</description><comments/></buginformation><fixedCommits><commit id="51874377b6350b80287730e6b8e0cc8a76c284c4" author="default" date="2005-09-08 19:19:11"><file name="ajde/src/org/aspectj/ajde/internal/CompilerAdapter.java"><method name="configureBuildOptions" returnType="boolean" parameters="AjBuildConfig"/></file></commit></fixedCommits></bug><bug id="186" opendate="2005-09-09 05:44:00" fixdate="2005-09-09 10:48:58"><buginformation><summary>VerifyError with inner classes</summary><description>This bug apparently occurs only when compiling with the -1.5 option (Adrian
Colyer managed to reproduce it).

Considering the code below, when I set a 'set' pointcut on the fields of inner
class Node, I get an error from the class verifier:

	Exception in thread "main" java.lang.VerifyError: (class: test/List$Node,
method: &lt;init&gt; signature: (Ltest/List;I)V) Expecting to find object/array on stack

When the Node class is moved out of the List class, it works fine. The
decompiled code for the inner class is included below for reference.

//////////////////////////////////////////////////////////////////////
// List.java
package test;

public class List {

	class Node {
		int value;
		Node next;

		Node(int v)
		{
			value = v;
		}
	}

	private Node head;

	public List()
	{
		head = null;
	}

	public void add(int v)
	{
		Node n = new Node(v);
		n.next = head;
		head = n;
	}

	public void print()
	{
		Node n = head;
		while (n != null) {
			System.out.print(" " + n.value);
			n = n.next;
		}
		System.out.println();
	}

	public static void main(String[] args) {
		List l = new List();
		for (int i = 0; i &lt; 10; i++)
			l.add(i);
		l.print();
	}

}

//////////////////////////////////////////////////////////////////////
// ListAspect.aj
package test;

public aspect ListAspect {

	pointcut setField(Object t) : target(t) &amp;&amp; set(* List.Node+.*);

	before(Object t) : setField(t) {
		System.out.println("WRITE");
		// Do something with t...
	}

}

//////////////////////////////////////////////////////////////////////
//  List@Node.jad 
package test;


// Referenced classes of package test:
//            List, ListAspect

class List$Node
{

    int value;
    List$Node next;
    final List this$0;

    List$Node(int v)
    {
    //*   0    0:aload_0         
        List list1 = List.this;
    //    1    1:aload_1         
    //    2    2:astore_3        
        List$Node list$node = this;
    //    3    3:astore          4
        ListAspect.aspectOf().ajc$before$test_ListAspect$1$3f3247a5(list$node);
    //    4    5:invokestatic    #37  &lt;Method test.ListAspect
test.ListAspect.aspectOf()&gt;
    //    5    8:aload           4
    //    6   10:invokevirtual   #41  &lt;Method void
test.ListAspect.ajc$before$test_ListAspect$1$3f3247a5(java.lang.Object)&gt;
        list$node.this$0 = list1;
    //    7   13:aload           4
    //    8   15:aload_3         
    //    9   16:putfield        #16  &lt;Field test.List test.List$Node.this$0&gt;
        super();
    //   10   19:aload_0         
    //   11   20:invokespecial   #19  &lt;Method void Object()&gt;
    //*  12   23:aload_0         
        int i = v;
    //   13   24:iload_2         
    //   14   25:istore          5
        List$Node list$node1 = this;
    //   15   27:astore          6
        ListAspect.aspectOf().ajc$before$test_ListAspect$1$3f3247a5(list$node1);
    //   16   29:invokestatic    #37  &lt;Method test.ListAspect
test.ListAspect.aspectOf()&gt;
    //   17   32:aload           6
    //   18   34:invokevirtual   #41  &lt;Method void
test.ListAspect.ajc$before$test_ListAspect$1$3f3247a5(java.lang.Object)&gt;
        list$node1.value = i;
    //   19   37:aload           6
    //   20   39:iload           5
    //   21   41:putfield        #21  &lt;Field int test.List$Node.value&gt;
    //   22   44:return          
    }
}</description><comments/></buginformation><fixedCommits><commit id="a9ca915dc39c87267a7a763d51e87a819e9799c7" author="default" date="2005-09-09 10:48:58"><file name="weaver/src/org/aspectj/weaver/bcel/BcelField.java"><method name="unpackAttributes" returnType="void" parameters="World"/></file></commit></fixedCommits></bug><bug id="187" opendate="2005-09-06 08:13:00" fixdate="2005-09-09 14:19:19"><buginformation><summary>AJDT Error: Can't find type</summary><description>In Eclipse 3.1, using the latest AspectJ build (1.5.0_M3a compiler and 1.3.0
plugin) I get an error "can't find type test.T" , using the following code:

===============
package test;

public class CantFindType {
    public &lt;T&gt; T[] method(T[] array) {
        return null;
    }
}
================

The error occurs, if the return type, or the parameter is an array of a generic
type.

The code compiles fine, but Eclipse shows the error, but doesn't show the folder
or the location for the error.</description><comments/></buginformation><fixedCommits><commit id="2942ca0f23ee0489efce58272768529e6b907a63" author="default" date="2005-09-09 14:19:19"><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"><method name="fromBinding" returnType="UnresolvedType" parameters="TypeBinding"/></file></commit></fixedCommits></bug><bug id="188" opendate="2005-07-13 19:09:00" fixdate="2005-09-12 13:37:56"><buginformation><summary>Compiler failure on @annotation</summary><description>I'm using the ajc embedded in the latest dev build of AJDT (build 
20050713163417)

This small example illustrates the problem:
public abstract aspect AbstractRequestMonitor {

    public pointcut requestExecution(RequestContext requestContext) :
        execution(* RequestContext.execute(..)) &amp;&amp; this(requestContext);

    public abstract class RequestContext {
        public abstract Object execute();
    }
    
    after(RequestContext requestContext) throwing (Throwable t) : 
requestExecution(requestContext) {
    }
    
}

import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;

@Retention(RetentionPolicy.RUNTIME)
public @interface AroundAdvice {

}

public aspect ErrorHandling {

    declare soft: Exception: !@annotation(AroundAdvice) &amp;&amp; !withincode(* *
(..));
    
    Object around() : adviceexecution() &amp;&amp; !@annotation(AroundAdvice) {
        try {
            return proceed();
        } catch (Exception e) {
            return null;
        }
    }

}

Here's the stack trace I get:

org.aspectj.weaver.BCException: bad
	at org.aspectj.weaver.bcel.BcelRenderer.visit(BcelRenderer.java:228)
	at org.aspectj.weaver.ast.Literal.accept(Literal.java:29)
	at org.aspectj.weaver.bcel.BcelRenderer.recur(BcelRenderer.java:151)
	at org.aspectj.weaver.bcel.BcelRenderer.renderTest
(BcelRenderer.java:117)
	at org.aspectj.weaver.bcel.BcelAdvice.getTestInstructions
(BcelAdvice.java:445)
	at org.aspectj.weaver.bcel.BcelShadow.weaveAroundClosure
(BcelShadow.java:2585)
	at org.aspectj.weaver.bcel.BcelAdvice.implementOn(BcelAdvice.java:182)
	at org.aspectj.weaver.Shadow.implementMungers(Shadow.java:480)
	at org.aspectj.weaver.Shadow.implement(Shadow.java:358)
	at org.aspectj.weaver.bcel.BcelClassWeaver.implement
(BcelClassWeaver.java:1703)
	at org.aspectj.weaver.bcel.BcelClassWeaver.weave
(BcelClassWeaver.java:389)
	at org.aspectj.weaver.bcel.BcelClassWeaver.weave
(BcelClassWeaver.java:94)
	at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1362)
	at org.aspectj.weaver.bcel.BcelWeaver.weaveWithoutDump
(BcelWeaver.java:1327)
	at org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify
(BcelWeaver.java:1106)
	at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:981)
	at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave
(AjCompilerAdapter.java:286)
	at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling
(AjCompilerAdapter.java:165)
	at 
org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$afterReturning$org_aspec
tj_ajdt_internal_compiler_CompilerAdapter$2$f9cc9ca0(CompilerAdapter.aj:70)
	at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile
(Compiler.java:368)
	at 
org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation
(AjBuildManager.java:727)
	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild
(AjBuildManager.java:206)
	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild
(AjBuildManager.java:140)
	at org.aspectj.ajde.internal.CompilerAdapter.compile
(CompilerAdapter.java:121)
	at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run
(AspectJBuildManager.java:191)</description><comments/></buginformation><fixedCommits><commit id="2ae4f531c7f7c3c38c983c73492ef63b224784e3" author="default" date="2005-09-12 13:37:56"><file name="weaver/src/org/aspectj/weaver/patterns/AnnotationPointcut.java"><method name="findResidueInternal" returnType="Test" parameters="Shadow ExposedState"/></file></commit></fixedCommits></bug><bug id="189" opendate="2005-08-26 10:39:00" fixdate="2005-09-21 14:59:55"><buginformation><summary>Complete implemenation of runtime pointcut parsing and matching</summary><description>The weaver API for runtime pointcut parsing and matching needs extending for all
of the new pointcuts we have added in AJ5. Recommended approach is to implement
JavaLangReflectObjectType as a new ReferenceTypeDelegate, and a
JavaLangReflectWorld in place of BcelWorld.</description><comments/></buginformation><fixedCommits><commit id="a39f595c0cdcddf8eac0b99e1918d0578f2dc501" author="default" date="2005-09-21 14:59:55"><file name="tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"><method name="testUnableToBuildShadows_pr109728" returnType="void" parameters=""/></file><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/PointcutDeclaration.java"><method name="addAtAspectJAnnotations" returnType="void" parameters=""/></file><file name="aspectj5rt/java5-src/org/aspectj/internal/lang/reflect/AjTypeImpl.java"><method name="asPointcut" returnType="Pointcut" parameters="Method"/></file><file name="aspectj5rt/java5-src/org/aspectj/lang/annotation/Pointcut.java"><method name="value" returnType="String" parameters=""/></file></commit></fixedCommits></bug><bug id="190" opendate="2005-07-24 20:01:00" fixdate="2005-09-21 16:28:36"><buginformation><summary>NullPointerException when running ajc on gij</summary><description>When running ajc 1.2.1 on the GNU Interpreter for Java 4.0.1, I received this error:

java.lang.NullPointerException
   at
org.aspectj.apache.bcel.generic.InstructionComparator$1.equals(org.aspectj.apache.bcel.generic.Instruction,
org.aspectj.apache.bcel.g
eneric.Instruction) (/tmp/cache/local/aspectj1.2/lib/aspectjweaver.jar.so)
   at org.aspectj.apache.bcel.generic.Instruction.equals(java.lang.Object)
(/tmp/cache/local/aspectj1.2/lib/aspectjweaver.jar.so)
   at java.util.AbstractMap.equals(java.lang.Object, java.lang.Object)
(/usr/lib/libgcj.so.6.0.0)
   at java.util.HashMap.put(java.lang.Object, java.lang.Object)
(/usr/lib/libgcj.so.6.0.0)
   at java.util.HashSet.add(java.lang.Object) (/usr/lib/libgcj.so.6.0.0)
   at
org.aspectj.apache.bcel.generic.InstructionHandle.addTargeter(org.aspectj.apache.bcel.generic.InstructionTargeter)
(/tmp/cache/local/
aspectj1.2/lib/aspectjweaver.jar.so)
   at
org.aspectj.apache.bcel.generic.BranchInstruction.notifyTarget(org.aspectj.apache.bcel.generic.InstructionHandle,
org.aspectj.apache.
bcel.generic.InstructionHandle,
org.aspectj.apache.bcel.generic.InstructionTargeter)
(/tmp/cache/local/aspectj1.2/lib/aspectjweaver.jar.so)
   at
org.aspectj.apache.bcel.generic.BranchInstruction.setTarget(org.aspectj.apache.bcel.generic.InstructionHandle)
(/tmp/cache/local/aspe
ctj1.2/lib/aspectjweaver.jar.so)
   at org.aspectj.apache.bcel.generic.BranchInstruction.BranchInstruction(short,
org.aspectj.apache.bcel.generic.InstructionHandle) (/tmp/c
ache/local/aspectj1.2/lib/aspectjweaver.jar.so)
   at org.aspectj.apache.bcel.generic.Select.Select(short, int[],
org.aspectj.apache.bcel.generic.InstructionHandle[], org.aspectj.apache.b
cel.generic.InstructionHandle)
(/tmp/cache/local/aspectj1.2/lib/aspectjweaver.jar.so)
   at org.aspectj.apache.bcel.generic.LOOKUPSWITCH.LOOKUPSWITCH(int[],
org.aspectj.apache.bcel.generic.InstructionHandle[], org.aspectj.apa
che.bcel.generic.InstructionHandle)
(/tmp/cache/local/aspectj1.2/lib/aspectjweaver.jar.so)
   at org.aspectj.apache.bcel.generic.SWITCH.SWITCH(int[],
org.aspectj.apache.bcel.generic.InstructionHandle[], org.aspectj.apache.bcel.gen
eric.InstructionHandle, int) (/tmp/cache/local/aspectj1.2/lib/aspectjweaver.jar.so)
   at org.aspectj.apache.bcel.generic.SWITCH.SWITCH(int[],
org.aspectj.apache.bcel.generic.InstructionHandle[], org.aspectj.apache.bcel.gen
eric.InstructionHandle) (/tmp/cache/local/aspectj1.2/lib/aspectjweaver.jar.so)
   at
org.aspectj.weaver.bcel.Utility.copyInstruction(org.aspectj.apache.bcel.generic.Instruction)
(/tmp/cache/local/aspectj1.2/lib/aspectj
weaver.jar.so)
   at
org.aspectj.weaver.bcel.LazyMethodGen.packBody(org.aspectj.apache.bcel.generic.MethodGen)
(/tmp/cache/local/aspectj1.2/lib/aspectjwea
ver.jar.so)
   at org.aspectj.weaver.bcel.LazyMethodGen.pack()
(/tmp/cache/local/aspectj1.2/lib/aspectjweaver.jar.so)
   at org.aspectj.weaver.bcel.LazyMethodGen.getMethod()
(/tmp/cache/local/aspectj1.2/lib/aspectjweaver.jar.so)
   at
org.aspectj.weaver.bcel.LazyClassGen.writeBack(org.aspectj.weaver.bcel.BcelWorld)
(/tmp/cache/local/aspectj1.2/lib/aspectjweaver.jar.
so)
   at
org.aspectj.weaver.bcel.LazyClassGen.getJavaClass(org.aspectj.weaver.bcel.BcelWorld)
(/tmp/cache/local/aspectj1.2/lib/aspectjweaver.j
ar.so)
   at
org.aspectj.weaver.bcel.BcelWeaver.getClassFilesFor(org.aspectj.weaver.bcel.LazyClassGen)
(/tmp/cache/local/aspectj1.2/lib/aspectjwea
ver.jar.so)
   at
org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify(org.aspectj.weaver.bcel.UnwovenClassFile,
org.aspectj.weaver.bcel.BcelObjectType, o
rg.aspectj.weaver.IWeaveRequestor)
(/tmp/cache/local/aspectj1.2/lib/aspectjweaver.jar.so)
   at
org.aspectj.weaver.bcel.BcelWeaver.weave(org.aspectj.weaver.IClassFileProvider)
(/tmp/cache/local/aspectj1.2/lib/aspectjweaver.jar.so
)
   at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave() (Unknown Source)
   at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling()
(Unknown Source)
   at
org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(org.aspectj.org.eclipse.jdt.internal.compiler.env.ICompilationUnit[])
(Unknown Source)
   at
org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(java.util.List)
(Unknown Source)
   at
org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(org.aspectj.ajdt.internal.core.builder.AjBuildConfig,
org.aspectj.bridg
e.IMessageHandler, boolean) (Unknown Source)
   at
org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(org.aspectj.ajdt.internal.core.builder.AjBuildConfig,
org.aspectj.br
idge.IMessageHandler) (Unknown Source)
   at
org.aspectj.ajdt.ajc.AjdtCommand.doCommand(org.aspectj.bridge.IMessageHandler,
boolean) (Unknown Source)
   at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(java.lang.String[],
org.aspectj.bridge.IMessageHandler) (Unknown Source)
   at org.aspectj.tools.ajc.Main.run(java.lang.String[],
org.aspectj.bridge.IMessageHolder) (Unknown Source)
   at org.aspectj.tools.ajc.Main.runMain(java.lang.String[], boolean) (Unknown
Source)
   at org.aspectj.tools.ajc.Main.main(java.lang.String[]) (Unknown Source)
   at gnu.java.lang.MainThread.call_main() (/usr/lib/libgcj.so.6.0.0)
   at gnu.java.lang.MainThread.run() (/usr/lib/libgcj.so.6.0.0)

Unfortunately, the above stack trace contains no line number information;
however, by running the program under the gdb debugger, I was able to get a
backtrace with line numbers for the relevant part of the stack trace:

(gdb) bt
#0  0x011a0246 in
org.aspectj.apache.bcel.generic.InstructionComparator$1.equals(org.aspectj.apache.bcel.generic.Instruction,
org.aspectj.apache.bcel.generic.Instruction) (this=@5c71ea8, i1=@610fe70,
i2=@610fc60) at org/aspectj/apache/bcel/generic/InstructionComparator.java:79
#1  0x011a004e in
org.aspectj.apache.bcel.generic.Instruction.equals(java.lang.Object)
(this=@610fe70, that=@610fc60)
    at org/aspectj/apache/bcel/generic/Instruction.java:499
#2  0x031b5f9b in java.util.AbstractMap.equals(java.lang.Object,
java.lang.Object) (o1=@610fe70, o2=@610fc60)
    at ../../../libjava/java/util/AbstractMap.java:603
#3  0x031cc0ae in java.util.HashMap.put(java.lang.Object, java.lang.Object)
(this=@6483690, key=@610fe70, value=@2dfc0)
    at ../../../libjava/java/util/HashMap.java:349
#4  0x031cca00 in java.util.HashSet.add(java.lang.Object) (this=null,
o=@610fe70) at ../../../libjava/java/util/HashSet.java:151
#5  0x011b30ad in
org.aspectj.apache.bcel.generic.InstructionHandle.addTargeter(org.aspectj.apache.bcel.generic.InstructionTargeter)
(
    this=@6949d20, t=@610fe70) at
org/aspectj/apache/bcel/generic/InstructionHandle.java:208
#6  0x011861e6 in
org.aspectj.apache.bcel.generic.BranchInstruction.notifyTarget(org.aspectj.apache.bcel.generic.InstructionHandle,
org.aspectj.apache.bcel.generic.InstructionHandle,
org.aspectj.apache.bcel.generic.InstructionTargeter) (old_ih=null, new_ih=@6949d20,
    t=@610fe70) at org/aspectj/apache/bcel/generic/BranchInstruction.java:217
#7  0x01186133 in
org.aspectj.apache.bcel.generic.BranchInstruction.setTarget(org.aspectj.apache.bcel.generic.InstructionHandle)
(
    this=@610fe70, target=@6949d20) at
org/aspectj/apache/bcel/generic/BranchInstruction.java:205
#8  0x011857ef in
org.aspectj.apache.bcel.generic.BranchInstruction.BranchInstruction(short,
org.aspectj.apache.bcel.generic.InstructionHandle) (this=@610fe70, opcode=171,
target=@6949d20) at org/aspectj/apache/bcel/generic/BranchInstruction.java:86
#9  0x011d3489 in org.aspectj.apache.bcel.generic.Select.Select(short, int[],
org.aspectj.apache.bcel.generic.InstructionHandle[],
org.aspectj.apache.bcel.generic.InstructionHandle) (this=@610fe70, opcode=171,
match=@6f63b90, targets=@6eeabe0, target=@6949d20)
    at org/aspectj/apache/bcel/generic/Select.java:106
#10 0x011c3152 in
org.aspectj.apache.bcel.generic.LOOKUPSWITCH.LOOKUPSWITCH(int[],
org.aspectj.apache.bcel.generic.InstructionHandle[],
org.aspectj.apache.bcel.generic.InstructionHandle) (this=@610fe70,
match=@6f63b90, targets=@6eeabe0, target=@6949d20)
    at org/aspectj/apache/bcel/generic/LOOKUPSWITCH.java:80
#11 0x011d4f94 in org.aspectj.apache.bcel.generic.SWITCH.SWITCH(int[],
org.aspectj.apache.bcel.generic.InstructionHandle[],
org.aspectj.apache.bcel.generic.InstructionHandle, int) (this=@6a20978,
match=@5b1ccd0, targets=@6eeac08, target=@6949d20, max_gap=1)
    at org/aspectj/apache/bcel/generic/SWITCH.java:104
#12 0x011d5002 in org.aspectj.apache.bcel.generic.SWITCH.SWITCH(int[],
org.aspectj.apache.bcel.generic.InstructionHandle[],
org.aspectj.apache.bcel.generic.InstructionHandle) (this=@6a20978,
match=@5b1ccd0, targets=@6eeac08, target=@6949d20)
    at org/aspectj/apache/bcel/generic/SWITCH.java:109
#13 0x01332eb6 in
org.aspectj.weaver.bcel.Utility.copyInstruction(org.aspectj.apache.bcel.generic.Instruction)
(i=@610fc60)
    at org/aspectj/weaver/bcel/Utility.java:474
#14 0x01326f66 in
org.aspectj.weaver.bcel.LazyMethodGen.packBody(org.aspectj.apache.bcel.generic.MethodGen)
(this=@6d98000, gen=@6d983c0)
    at org/aspectj/weaver/bcel/LazyMethodGen.java:813
#15 0x01326d08 in org.aspectj.weaver.bcel.LazyMethodGen.pack() (this=@6d98000)
at org/aspectj/weaver/bcel/LazyMethodGen.java:790
#16 0x01324c81 in org.aspectj.weaver.bcel.LazyMethodGen.getMethod()
(this=@6d98000) at org/aspectj/weaver/bcel/LazyMethodGen.java:336
#17 0x0131b502 in
org.aspectj.weaver.bcel.LazyClassGen.writeBack(org.aspectj.weaver.bcel.BcelWorld)
(this=@610ff00, world=@5642d20)
    at org/aspectj/weaver/bcel/LazyClassGen.java:418
#18 0x0131b95e in
org.aspectj.weaver.bcel.LazyClassGen.getJavaClass(org.aspectj.weaver.bcel.BcelWorld)
(this=@610ff00, world=@5642d20)
    at org/aspectj/weaver/bcel/LazyClassGen.java:446
#19 0x01311589 in
org.aspectj.weaver.bcel.BcelWeaver.getClassFilesFor(org.aspectj.weaver.bcel.LazyClassGen)
(this=@a33c0, clazz=@610ff00)
&lt;snip&gt;

It might be difficult for me to provide a reproducable test case (it might
depend on the gij version, but I can try if wanted). However, happily, having
examined the bytecode of the BCEL classes from the first few lines of the stack
trace, I think I can explain why this exception occurs without needing to
provide a test case.

It's very simple. Whoever wrote the BCEL code in question, obviously never ran
it with a data set and on a virtual machine where a hash collision in the
HashSet would occur. Because, with this BCEL snapshot, if a hash collision does
occur, the object being added to the HashSet is *guaranteed* to cause a
NullPointerException in the Comparator method. This can be seen merely by
examining the code path described by this stack trace. The field "targets" in
the LOOKUPSWITCH object has not been initialized when notifyTarget is called, so
if there is a hash collision in the HashSet, the InstructionComparator will be
called - and it is guaranteed to call getTargets () and access its array length,
which will cause a NullPointerException.

I hope this explanation is sufficiently clear. If not, I will be happy to
provide further details.</description><comments/></buginformation><fixedCommits><commit id="0e1bb192d429beba6a2a8f9b2ab8218f85673405" author="default" date="2005-09-21 16:28:36"><file name="bcel-builder/src/org/aspectj/apache/bcel/generic/InstructionComparator.java"><method name="equals" returnType="boolean" parameters="Instruction Instruction"/></file></commit></fixedCommits></bug><bug id="191" opendate="2004-10-15 13:23:00" fixdate="2005-09-21 16:51:15"><buginformation><summary>Problem with declare parents when using non-public classes</summary><description>Non-public classes, when explicitly named, do not get woven.

The test case below exhibits this problem when the package declaration is
uncommented.

If the package declaration is commented out, the class is woven correctly.
If the package declaration is uncommented, a compilation failure occurs with
AspectJ 1.2.  According to Andrew Clement, AspectJ 1.2.1 compiles, but does not
weave.
If the "MyInnerClass" is changed to be public [regardless of the package
declaration status], the class is woven correctly.

Also:
When the "MyInnerClass" is moved out of "MyClass", but kept in the MyClass.java
file, then the following behavior is exhibited:
If the package declaration is commented out, the class is woven correctly.
If the package declaration is uncommented out, a compilation failure occurs with
AspectJ 1.2.
Note, in this case, MyInnerClass cannot be declared as public.

It also appears that if the RunnableAspect is placed in the same package as
"MyClass", weaving occurs correctly, regardless of any class access modifiers

&lt;MyClass.java&gt;

// package mypackage;

public class MyClass {
 public MyClass() {
   MyInnerClass mic = new MyInnerClass();
   if (mic instanceof Runnable)
     mic.run();
 }

 class MyInnerClass {
   public void run() {
     System.out.println("In MyInnerClass.run()!!");
   }
 }

 public static void main(String args[]) {
   new MyClass();
 }
}

&lt;/MyClass.java&gt;

&lt;RunnableAspect.aj&gt;

public aspect RunnableAspect {
 declare parents: MyClass$MyInnerClass implements Runnable;
 // declare parents: mypackage.MyClass$MyInnerClass implements Runnable;
}

&lt;/RunnableAspect.aj&gt;</description><comments/></buginformation><fixedCommits><commit id="ca9c1f7c57b64473042f3100a4159650da085111" author="default" date="2005-09-21 16:51:15"><file name="tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"><method name="testUnableToBuildShadows_pr109728" returnType="void" parameters=""/></file></commit></fixedCommits></bug><bug id="192" opendate="2005-09-12 08:37:00" fixdate="2005-09-22 15:45:06"><buginformation><summary>Invalid "indirect static access" warning on EnumSet.noneOf</summary><description>When compiling AspectJ enabled projects in Java 5.0 source mode with "Indirect
access to static modifier" warnings on, the following code incorrectly gives a
compiler warning (this doesn't occur in non-AspectJ enabled projects):

public class Test {
    enum Foo {
        Wibble,
        Wobble,
        Woo;
    }

    public static void main(String[] args) {
        EnumSet&lt;Foo&gt; set = EnumSet.noneOf(Foo.class);
    }
}</description><comments/></buginformation><fixedCommits><commit id="8a0f59ad18ace56ff59cd9108d18c70358a4f055" author="default" date="2005-09-22 15:45:06"><file name="weaver/src/org/aspectj/weaver/AjcMemberMaker.java"><method name="perTypeWithinAspectOfMethod" returnType="ResolvedMember" parameters="UnresolvedType"/><method name="perTypeWithinHasAspectMethod" returnType="ResolvedMember" parameters="UnresolvedType"/></file><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectDeclaration.java"><method name="buildPerClause" returnType="void" parameters="ClassScope"/></file><file name="weaver/src/org/aspectj/weaver/bcel/BcelPerClauseAspectAdder.java"><method name="generatePerTWAspectOfMethod" returnType="void" parameters="LazyClassGen"/><method name="generatePerTWHasAspectMethod" returnType="void" parameters="LazyClassGen"/></file><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"><method name="lookupBinding" returnType="ReferenceBinding" parameters="String"/></file></commit></fixedCommits></bug><bug id="193" opendate="2005-09-09 12:49:00" fixdate="2005-09-23 14:40:27"><buginformation><summary>Weaving Adaptor enhancements for performance, configuration and diagnosis</summary><description>Here are some suggested enhancements as a result of exhaustive testing in the 
Eclipse/OSGi environment.

1.	If no aspects are declared for a particular class loader, either 
because there are no visible aop.xml files or they contain no aspect 
definitions, then we should short-circuit the implementation of weaveClass() 
so that byte-code is not unnecessarily passed to the weaver. This is 
especially important under OSGi where there may be hundreds of class bundles, 
each with their own class loader only some of which are being woven. We can 
use the existing 鈥渆nabled鈥 flag.
2.	As previously discussed on aspectj-dev the META-INF directory is 
considered private in OSGi and is therefore an inappropriate location for 
aop.xml files declaring shared aspects. I therefore propose a System property 
to set the a resource names for finding aop.xml files which would default 
to 鈥淢ETA-INF/aop.xml鈥 e.g. -Dorg.aspectj.weaver.loadtime.configuration=META-
INF/aop.xml;org/aspectj/aop.xml.
3.	We should not be catching Throwable  in Aj. Instead we should catch 
known exceptions e.g. BCException and issue messages while letting other 
runtime exceptions pass back to the class loader. A user provided 
IMessageHandler implementation can decide under what circumstances to abort. 
Alternatively if Aj is considered to be a 鈥渟afe鈥 interface for weaving agents 
e.g. JVMTI then the dump logic it contains should be moved to the 
WeavingAdaptor so that it can be used directly from a class loader.</description><comments/></buginformation><fixedCommits><commit id="03b20bc1129e03d5e8594262b89021e54ab017f9" author="default" date="2005-09-23 14:40:27"><file name="loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"><method name="registerDefinitions" returnType="void" parameters="BcelWeaver"/><method name="acceptClass" returnType="void" parameters="String byte[]"/><method name="shouldDump" returnType="boolean" parameters="String"/><method name="registerAspects" returnType="void" parameters="BcelWeaver ClassLoader"/></file><file name="loadtime/src/org/aspectj/weaver/loadtime/Aj.java"><method name="initialize" returnType="void" parameters=""/><method name="getWeaver" returnType="WeavingAdaptor" parameters="ClassLoader"/></file></commit></fixedCommits></bug><bug id="194" opendate="2004-10-26 23:43:00" fixdate="2005-09-24 09:34:13"><buginformation><summary>Weaving into jar fails if some of the referred classes are unavailable</summary><description>I am trying to profile JDBC access in a Spring-based application.
Since all the JDBC interaction is performed through Spring classes,
I need to weave into spring.jar. However, many of the classes 
referred by spring.jar aren't available to me (I am not using 
the functionality implemented by many of the classes). When I 
try to weave into spring.jar I get errors complaining that it 
can't find types for those classes.

I expected that ajc would ignore unknown classes unless weaving
would be affected by content/API of those classes.

Using jar files that refer to foreign classes that one may
never have/need is a common scenario. For example, spring.jar
refers to Velocity, Struts, JDO, Hibernate, Quartz classes;
I am unlikely to use all of these referred frameworks in an
application. This bug/limitation prevents using AspectJ with
such jars.

To reproduce the bug in a controlled environment, I created
the following aspect which should make the weaving process
a pass-thru filter (no join point is matched by the pointcut)

class TemporaryClass {
}

public aspect NoWeaveAspect {
    before() : call(* TemporaryClass.*(..)) &amp;&amp; within(org.spring..*) {
    }
}

Weaving this aspect with spring.jar should result in logically
identical jar file. However, when I compile using the following
command (or equivalent ant task), I get the following errors:

C:\work\aop\bugs\injar-with-nonexisting-classes&gt;ajc -version
AspectJ Compiler 1.2.1rc1 built on Friday Oct 22, 2004 at 13:31:47 GMT

C:\work\aop\bugs\injar-with-nonexisting-classes&gt;ajc -injars spring.jar -outjar s
pring-woven.jar NoWeaveAspect.java
C:\work\aop\bugs\injar-with-nonexisting-classes\spring.jar [error] can't find ty
pe org.quartz.xml.JobSchedulingDataProcessor
(no source information available)
C:\work\aop\bugs\injar-with-nonexisting-classes\spring.jar [error] can't find ty
pe org.quartz.StatefulJob
(no source information available)
C:\work\aop\bugs\injar-with-nonexisting-classes\spring.jar [error] can't find ty
pe org.quartz.SimpleTrigger
(no source information available)
C:\work\aop\bugs\injar-with-nonexisting-classes\spring.jar [error] can't find ty
pe freemarker.cache.TemplateLoader
(no source information available)
C:\work\aop\bugs\injar-with-nonexisting-classes\spring.jar [error] can't find ty
pe org.aopalliance.intercept.MethodInterceptor
(no source information available)
C:\work\aop\bugs\injar-with-nonexisting-classes\spring.jar [error] can't find ty
pe org.quartz.CronTrigger
(no source information available)
C:\work\aop\bugs\injar-with-nonexisting-classes\spring.jar [error] can't find ty
pe org.aopalliance.intercept.MethodInterceptor
(no source information available)
C:\work\aop\bugs\injar-with-nonexisting-classes\spring.jar [error] can't find ty
pe org.quartz.JobDetail
(no source information available)
C:\work\aop\bugs\injar-with-nonexisting-classes\spring.jar [error] can't find ty
pe org.quartz.Job
(no source information available)
C:\work\aop\bugs\injar-with-nonexisting-classes\spring.jar [error] can't find ty
pe org.quartz.impl.jdbcjobstore.JobStoreCMT
(no source information available)
C:\work\aop\bugs\injar-with-nonexisting-classes\spring.jar [error] can't find ty
pe org.apache.struts.action.PlugIn
(no source information available)
C:\work\aop\bugs\injar-with-nonexisting-classes\spring.jar [error] can't find ty
pe org.apache.velocity.tools.generic.NumberTool
(no source information available)
C:\work\aop\bugs\injar-with-nonexisting-classes\spring.jar [error] can't find ty
pe org.apache.struts.action.Action
(no source information available)
C:\work\aop\bugs\injar-with-nonexisting-classes\spring.jar [error] can't find ty
pe org.apache.struts.tiles.TilesRequestProcessor
(no source information available)
C:\work\aop\bugs\injar-with-nonexisting-classes\spring.jar [error] can't find ty
pe org.apache.struts.action.RequestProcessor
(no source information available)
C:\work\aop\bugs\injar-with-nonexisting-classes\spring.jar [error] can't find ty
pe org.apache.velocity.runtime.resource.loader.ResourceLoader
(no source information available)
C:\work\aop\bugs\injar-with-nonexisting-classes\spring.jar [error] can't find ty
pe org.apache.velocity.runtime.log.LogSystem
(no source information available)
C:\work\aop\bugs\injar-with-nonexisting-classes\spring.jar [error] can't find ty
pe javax.faces.el.VariableResolver
(no source information available)
C:\work\aop\bugs\injar-with-nonexisting-classes\spring.jar [error] can't find ty
pe org.apache.velocity.tools.generic.DateTool
(no source information available)
C:\work\aop\bugs\injar-with-nonexisting-classes\spring.jar [error] can't find ty
pe org.apache.commons.attributes.AttributeRepositoryClass
(no source information available)
C:\work\aop\bugs\injar-with-nonexisting-classes\spring.jar [error] can't find ty
pe org.aopalliance.intercept.MethodInterceptor
(no source information available)
C:\work\aop\bugs\injar-with-nonexisting-classes\spring.jar [error] can't find ty
pe org.aopalliance.intercept.MethodInterceptor
(no source information available)
C:\work\aop\bugs\injar-with-nonexisting-classes\spring.jar [error] can't find ty
pe net.sf.cglib.proxy.MethodInterceptor
(no source information available)
C:\work\aop\bugs\injar-with-nonexisting-classes\spring.jar [error] can't find ty
pe org.aopalliance.intercept.MethodInterceptor
(no source information available)
C:\work\aop\bugs\injar-with-nonexisting-classes\spring.jar [error] can't find ty
pe org.apache.commons.pool.PoolableObjectFactory
(no source information available)
C:\work\aop\bugs\injar-with-nonexisting-classes\spring.jar [error] can't find ty
pe org.aopalliance.intercept.MethodInterceptor
(no source information available)
C:\work\aop\bugs\injar-with-nonexisting-classes\spring.jar [error] can't find ty
pe net.sf.cglib.proxy.MethodInterceptor
(no source information available)
C:\work\aop\bugs\injar-with-nonexisting-classes\spring.jar [error] can't find ty
pe net.sf.cglib.proxy.Dispatcher
(no source information available)
C:\work\aop\bugs\injar-with-nonexisting-classes\spring.jar [error] can't find ty
pe org.aopalliance.intercept.MethodInvocation
(no source information available)
C:\work\aop\bugs\injar-with-nonexisting-classes\spring.jar [error] can't find ty
pe net.sf.cglib.proxy.CallbackFilter
(no source information available)
C:\work\aop\bugs\injar-with-nonexisting-classes\spring.jar [error] can't find ty
pe net.sf.cglib.proxy.NoOp
(no source information available)
C:\work\aop\bugs\injar-with-nonexisting-classes\spring.jar [error] can't find ty
pe net.sf.hibernate.transaction.TransactionManagerLookup
(no source information available)
C:\work\aop\bugs\injar-with-nonexisting-classes\spring.jar [error] can't find ty
pe net.sf.hibernate.connection.ConnectionProvider
(no source information available)
C:\work\aop\bugs\injar-with-nonexisting-classes\spring.jar [error] can't find ty
pe net.sf.hibernate.UserType
(no source information available)
C:\work\aop\bugs\injar-with-nonexisting-classes\spring.jar [error] can't find ty
pe org.apache.ojb.broker.accesslayer.ConnectionFactoryManagedImpl
(no source information available)
C:\work\aop\bugs\injar-with-nonexisting-classes\spring.jar [error] can't find ty
pe org.aopalliance.intercept.MethodInterceptor
(no source information available)
C:\work\aop\bugs\injar-with-nonexisting-classes\spring.jar [error] can't find ty
pe net.sf.cglib.proxy.MethodInterceptor
(no source information available)
C:\work\aop\bugs\injar-with-nonexisting-classes\spring.jar [error] can't find ty
pe net.sf.cglib.proxy.CallbackFilter
(no source information available)
C:\work\aop\bugs\injar-with-nonexisting-classes\spring.jar [error] can't find ty
pe org.aopalliance.intercept.MethodInterceptor
(no source information available)
C:\work\aop\bugs\injar-with-nonexisting-classes\spring.jar [error] can't find ty
pe org.aopalliance.intercept.MethodInterceptor
(no source information available)
C:\work\aop\bugs\injar-with-nonexisting-classes\spring.jar [error] can't find ty
pe org.aopalliance.intercept.MethodInterceptor
(no source information available)

41 errors</description><comments/></buginformation><fixedCommits><commit id="a4a9090d88bd1a79d87f0bc08aff7fa627e81f99" author="default" date="2005-09-24 09:34:13"><file name="weaver/src/org/aspectj/weaver/JoinPointSignature.java"><method name="getJoinPointSignatures" returnType="JoinPointSignature[]" parameters="World"/></file><file name="weaver/src/org/aspectj/weaver/Member.java"><method name="getJoinPointSignatures" returnType="JoinPointSignature[]" parameters="World"/></file><file name="weaver/src/org/aspectj/weaver/MemberImpl.java"><method name="getJoinPointSignatures" returnType="JoinPointSignature[]" parameters="World"/></file><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"><method name="initBcelWorld" returnType="void" parameters="IMessageHandler"/></file><file name="org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/core/builder/OutjarTest.java"><method name="testOutjarDeletedOnError" returnType="void" parameters=""/></file></commit></fixedCommits></bug><bug id="195" opendate="2005-03-23 13:37:00" fixdate="2005-09-27 15:00:24"><buginformation><summary>Unnecessary warning for ITDs</summary><description>Consider the following aspect:

public aspect RunnableDefaultImpl {
    public void Runnable.run() {
    }
}

(Note that it makes little sense to have a default implementation for
 Runnable. However, I am using it to allow easy reproduction of the bug.)

Compiling this aspect leads to the following warning:

...\test\RunnableDefaultImpl.aj:9 [warning]
 this affected type is not exposed to the weaver: java.lang.Runnable [Xlint:type
NotExposedToWeaver]
public void Runnable.run() {
                     ^^^

This warning isn't really necessary as weaver doesn't (and shouldn't) need
to have Runnable exposed. In fact, everything works as expected already.

Now it will be a good warning (or even error), if I was trying to introduce a
new method, such as in the following aspect:
public aspect RunnableDefaultImpl {
    public void Runnable.walk() {
    }
}</description><comments/></buginformation><fixedCommits><commit id="e76b37012601cf67a069b4a78f60f183efad563d" author="default" date="2005-09-27 15:00:24"><file name="weaver/src/org/aspectj/weaver/ResolvedTypeMunger.java"><method name="matches" returnType="boolean" parameters="ResolvedType ResolvedType"/></file></commit></fixedCommits></bug><bug id="196" opendate="2005-06-23 02:44:00" fixdate="2005-09-27 21:08:24"><buginformation><summary>NullPointerException when selecting Save As in top menu</summary><description>The Steps of Reproduce:
1. Open BIRT
2. New a project
3. In top menu of File, click New -&gt; Report to create a report
4. Drag a table element from Palette into the report of Layout view
5. Save the report
6. Drag mouse to select two cells in the table
7. Select the report in Navigator view
8. In the top menu, select Save As... 
9. In the Save As pop up dialog window, change the file name in the File name 
field, then click OK button


Expected Result:
 There is no error to click OK button

Actual Result:
 Error window pops up and the error log as follows:
java.lang.NullPointerException
	at org.eclipse.gef.editparts.AbstractEditPart.getRoot
(AbstractEditPart.java:587)
	at org.eclipse.gef.editparts.AbstractEditPart.getRoot
(AbstractEditPart.java:587)
	at org.eclipse.gef.editparts.AbstractEditPart.getViewer
(AbstractEditPart.java:637)
	at 
org.eclipse.birt.report.designer.internal.ui.editors.schematic.editparts.TableU
til.getSelectionCells(TableUtil.java:258)
	at 
org.eclipse.birt.report.designer.internal.ui.editors.schematic.editparts.TableE
ditPart.canMerge(TableEditPart.java:1244)
	at 
org.eclipse.birt.report.designer.internal.ui.editors.schematic.actions.MergeAct
ion.calculateEnabled(MergeAction.java:51)
	at org.eclipse.gef.ui.actions.WorkbenchPartAction.isEnabled
(WorkbenchPartAction.java:111)
	at org.eclipse.ui.actions.RetargetAction.setActionHandler
(RetargetAction.java:249)
	at org.eclipse.ui.actions.RetargetAction.partActivated
(RetargetAction.java:144)
	at org.eclipse.ui.internal.PartListenerList$1.run
(PartListenerList.java:49)
	at org.eclipse.core.internal.runtime.InternalPlatform.run
(InternalPlatform.java:616)
	at org.eclipse.core.runtime.Platform.run(Platform.java:747)
	at org.eclipse.ui.internal.PartListenerList.firePartActivated
(PartListenerList.java:47)
	at org.eclipse.ui.internal.WorkbenchPage.firePartActivated
(WorkbenchPage.java:1370)
	at org.eclipse.ui.internal.WorkbenchPage.setActivePart
(WorkbenchPage.java:2738)
	at org.eclipse.ui.internal.WorkbenchPage.requestActivation
(WorkbenchPage.java:2415)
	at org.eclipse.ui.internal.PartPane.requestActivation
(PartPane.java:304)
	at org.eclipse.ui.internal.EditorPane.requestActivation
(EditorPane.java:127)
	at org.eclipse.ui.internal.PartPane.handleEvent(PartPane.java:284)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:82)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:796)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:820)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:801)
	at org.eclipse.swt.widgets.Shell.setActiveControl(Shell.java:935)
	at org.eclipse.swt.widgets.Control.sendFocusEvent(Control.java:1768)
	at org.eclipse.swt.widgets.Control.WM_SETFOCUS(Control.java:4139)
	at org.eclipse.swt.widgets.Canvas.WM_SETFOCUS(Canvas.java:239)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:3032)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:3338)
	at org.eclipse.swt.internal.win32.OS.SetFocus(Native Method)
	at org.eclipse.swt.widgets.Control.forceFocus(Control.java:607)
	at org.eclipse.swt.widgets.Control.setFocus(Control.java:2054)
	at org.eclipse.swt.widgets.Composite.setFocus(Composite.java:447)
	at org.eclipse.gef.ui.parts.GraphicalEditor.setFocus
(GraphicalEditor.java:346)
	at org.eclipse.ui.part.MultiPageEditorPart.setFocus
(MultiPageEditorPart.java:545)
	at org.eclipse.ui.part.MultiPageEditorPart.setFocus
(MultiPageEditorPart.java:519)
	at org.eclipse.ui.part.MultiPageEditorPart.setFocus
(MultiPageEditorPart.java:545)
	at org.eclipse.ui.part.MultiPageEditorPart.setFocus
(MultiPageEditorPart.java:519)
	at org.eclipse.ui.part.MultiPageEditorPart.pageChange
(MultiPageEditorPart.java:433)
	at org.eclipse.birt.report.designer.ui.editors.ReportEditor.pageChange
(ReportEditor.java:1179)
	at 
org.eclipse.birt.report.designer.ui.editors.ReportEditor.rebuildReportDesign
(ReportEditor.java:584)
	at org.eclipse.birt.report.designer.ui.editors.ReportEditor.setInput
(ReportEditor.java:547)
	at 
org.eclipse.birt.report.designer.ui.editors.ReportEditor.performSaveAs
(ReportEditor.java:870)
	at org.eclipse.birt.report.designer.ui.editors.ReportEditor.doSaveAs
(ReportEditor.java:812)
	at org.eclipse.ui.internal.SaveAsAction.run(SaveAsAction.java:64)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:881)
	at 
org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection
(ActionContributionItem.java:915)
	at org.eclipse.jface.action.ActionContributionItem.access$2
(ActionContributionItem.java:866)
	at org.eclipse.jface.action.ActionContributionItem$7.handleEvent
(ActionContributionItem.java:785)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:82)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:796)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:2772)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:2431)
	at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:1377)
	at org.eclipse.ui.internal.Workbench.runUI(Workbench.java:1348)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench
(Workbench.java:254)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:141)
	at org.eclipse.ui.internal.ide.IDEApplication.run
(IDEApplication.java:96)
	at org.eclipse.core.internal.runtime.PlatformActivator$1.run
(PlatformActivator.java:335)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run
(EclipseStarter.java:273)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run
(EclipseStarter.java:129)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke
(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke
(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:324)
	at org.eclipse.core.launcher.Main.basicRun(Main.java:185)
	at org.eclipse.core.launcher.Main.run(Main.java:704)
	at org.eclipse.core.launcher.Main.main(Main.java:688)</description><comments/></buginformation><fixedCommits><commit id="97520cf015afa87263c9497b4a60888ba2ada177" author="default" date="2005-09-27 21:08:24"><file name="bcel-builder/src/org/aspectj/apache/bcel/generic/LocalVariableGen.java"><method name="getLocalVariable" returnType="LocalVariable" parameters="ConstantPoolGen"/></file><file name="weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"><method name="unpackLocals" returnType="void" parameters="MethodGen"/><method name="packBody" returnType="void" parameters="MethodGen"/></file><file name="weaver/src/org/aspectj/weaver/bcel/LocalVariableTag.java"><method name="hashCode" returnType="int" parameters=""/><method name="equals" returnType="boolean" parameters="Object"/></file></commit></fixedCommits></bug><bug id="197" opendate="2005-08-26 10:37:00" fixdate="2005-09-29 15:42:52"><buginformation><summary>Complete implementation of @SuppressAjWarnings</summary><description>ensure that @SuppressAJWarnings are indeed suppressed during pointcut
operations. This requires wrapping major pointcut operations with calls to Lint
from the associated advice.</description><comments/></buginformation><fixedCommits><commit id="81a07900d1e2c4db563d5b4a833b404ac51ee5bd" author="default" date="2005-09-29 15:42:52"><file name="weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java"><method name="specializeOn" returnType="void" parameters="Shadow"/></file><file name="weaver/src/org/aspectj/weaver/bcel/Utility.java"><method name="isSuppressing" returnType="boolean" parameters="AnnotationX[] String"/></file></commit></fixedCommits></bug><bug id="198" opendate="2004-10-29 06:25:00" fixdate="2005-10-04 08:05:55"><buginformation><summary>Advice on inner classes not show in Outline view or gutter</summary><description>Advice associated with pointcuts that match join points in inner classes are 
not shown. Declare warning/error are shown however. See attached screenshot 
for example below. Notice WEAVEINFO messages indicate problem is in AJDT not 
AspectJ. Also notice phantom entry in Outline view "injar aspectL Test.java".

package bug_nnnnn;

public class Test {

	public void test () {
		new Runnable() {
			public void run() {
				try {
					throw new Exception();
				}
				catch (Exception ex) {
					handleException(ex);
				}
			}
		};
	}
	
	public static void handleException (Throwable th) {
		
	}
	
	public static void main(String[] args) {
		try {
			throw new Exception();
		}
		catch (Exception ex) {
			handleException(ex);
		}
	}
}
aspect Aspect {
	
	declare warning : call(void handleException(..)) &amp;&amp; !within(Aspect) :
		"Only Aspect should handle exceptions";
	
	pointcut caughtExceptions (Throwable th) :
		handler(Throwable+) &amp;&amp; args(th);
	
	before (Throwable th) : caughtExceptions(th) {
		Test.handleException(th);
	}
}</description><comments/></buginformation><fixedCommits><commit id="45730680627912726919028374403612047c23e3" author="default" date="2005-10-04 08:05:55"><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmHierarchyBuilder.java"><method name="visit" returnType="boolean" parameters="TypeDeclaration BlockScope"/></file><file name="asm/src/org/aspectj/asm/internal/AspectJElementHierarchy.java"><method name="findClassInNodes" returnType="IProgramElement" parameters="Collection String"/><method name="findElementForType" returnType="IProgramElement" parameters="String String"/></file></commit></fixedCommits></bug><bug id="199" opendate="2005-08-26 10:35:00" fixdate="2005-10-05 11:54:49"><buginformation><summary>Complete implementation of abstract generic aspects</summary><description>this requires
1/ completion of the parameterizeWith implementation in the pointcut AST nodes
2/ a much more exhaustive test suite around it.</description><comments/></buginformation><fixedCommits><commit id="451fea8a2f9b3640d6c133c3f01dad8b9a78f72c" author="default" date="2005-10-05 11:54:49"><file name="weaver/src/org/aspectj/weaver/patterns/DeclarePrecedence.java"><method name="parameterizeWith" returnType="Declare" parameters="Map"/></file><file name="weaver/src/org/aspectj/weaver/patterns/TypePattern.java"><method name="parameterizeWith" returnType="TypePattern" parameters="Map"/></file><file name="weaver/src/org/aspectj/weaver/patterns/Pointcut.java"><method name="parameterizeWith" returnType="Pointcut" parameters="Map"/></file><file name="weaver/src/org/aspectj/weaver/patterns/ArgsPointcut.java"><method name="getPossiblyBoxed" returnType="Class" parameters="UnresolvedType"/><method name="checkSignatureMatch" returnType="FuzzyBoolean" parameters="Class[]"/></file><file name="weaver/src/org/aspectj/weaver/patterns/DeclareAnnotation.java"><method name="parameterizeWith" returnType="Declare" parameters="Map"/></file></commit></fixedCommits></bug><bug id="200" opendate="2005-04-14 11:16:00" fixdate="2005-10-05 12:23:52"><buginformation><summary>-Xreweavable should be the default</summary><description>In order to facilitate widespread use of LTW we need to ensure code is 
compiled with 鈥揦reweavable. However we cannot rely on developers to use this 
flag so it must be the default. Unfortunately the current code bloat is 
unacceptable for large projects.</description><comments/></buginformation><fixedCommits><commit id="12e6334bf5f77d7c3bc2e66eeefa105f0507334a" author="default" date="2005-10-05 12:23:52"><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AspectJBuilder.java"><method name="initWorldAndWeaver" returnType="void" parameters="AjCompilerOptions"/></file><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java"><method name="parseOption" returnType="void" parameters="String LinkedList"/></file><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.java"><method name="getXreweavableCompressClasses" returnType="boolean" parameters=""/><method name="isXreweavable" returnType="boolean" parameters=""/><method name="setXreweavableCompressClasses" returnType="void" parameters="boolean"/><method name="installGlobals" returnType="void" parameters="AjBuildConfig"/><method name="setXreweavable" returnType="void" parameters="boolean"/></file><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"><method name="initBcelWorld" returnType="void" parameters="IMessageHandler"/></file><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjCompilerOptions.java"><method name="getMap" returnType="Map" parameters=""/><method name="set" returnType="void" parameters="Map"/><method name="toString" returnType="String" parameters=""/></file><file name="loadtime/src/org/aspectj/weaver/loadtime/Options.java"><method name="parse" returnType="WeaverOption" parameters="String ClassLoader"/></file><file name="taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java"><method name="next" returnType="String" parameters=""/><method name="toString" returnType="String" parameters=""/></file><file name="testing/newsrc/org/aspectj/testing/WeaveSpec.java"><method name="execute" returnType="void" parameters="AjcTestCase"/></file><file name="loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"><method name="registerOptions" returnType="void" parameters="BcelWeaver ClassLoader"/></file></commit></fixedCommits></bug><bug id="201" opendate="2005-04-26 17:48:00" fixdate="2005-10-05 14:01:43"><buginformation><summary>[inc-compilation] Incremental Compilation Fails for ITD's on Aspects</summary><description>On my project, when I save an aspect that calls an inter-type declaration 
defined on itself, the incremental compiler gives a message like this:
The method logError(String, Exception) is undefined for the type Foo Foo.java

Running a full build clears the error.

This might be a compiler bug, or it might be AJDT (I never run command-line 
incremental compilation, so I don't know :-)).

Unfortunately, simple test cases or extracts of just the 2 aspects aren't 
reproducing the issue, so let me know if you need me to spend some time trying 
to create a small isolated version of the issue.</description><comments/></buginformation><fixedCommits><commit id="727b0f5356e50761530655b52cbc0a96aff75c05" author="default" date="2005-10-05 14:01:43"><file name="tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java"><method name="testBuildingDependantProjects" returnType="void" parameters=""/></file></commit></fixedCommits></bug><bug id="202" opendate="2004-03-30 12:31:00" fixdate="2005-10-05 16:15:43"><buginformation><summary>[ajdoc] add ajdoc support for inter-type declarations and other declare forms</summary><description>Currently ajdoc only exposes the "Advises" and "Advised by" relationships from 
the structure model.  

It needs to support inter-type field and member declarations using a UI 
similar to how Javadoc presents inherited members.

It also needs to support the other declare forms: error, warning, soft, 
parents, and precedence.</description><comments/></buginformation><fixedCommits><commit id="ab6c7a562a887b70c6b5ad0ac644e7af58394aa3" author="default" date="2005-10-05 16:15:43"><file name="ajdoc/src/org/aspectj/tools/ajdoc/HtmlDecorator.java"><method name="decorateMemberDocumentation" returnType="void" parameters="IProgramElement"/><method name="generateAffects" returnType="String" parameters="IProgramElement boolean"/><method name="insertDeclarationsDetails" returnType="void" parameters="StringBuffer"/><method name="ArrayList" returnType="List" parameters=""/><method name="insertDeclarationsSummary" returnType="void" parameters="StringBuffer"/><method name="addAspectDocumentation" returnType="void" parameters="IProgramElement StringBuffer int"/><method name="generateHREFName" returnType="String" parameters="IProgramElement"/></file><file name="ajdoc/testsrc/org/aspectj/tools/ajdoc/PatternsTestCase.java"><method name="testSimpleExample" returnType="void" parameters=""/></file><file name="ajdoc/testsrc/org/aspectj/tools/ajdoc/ExecutionTestCase.java"><method name="testFailingBuild" returnType="void" parameters=""/></file><file name="ajdoc/testsrc/org/aspectj/tools/ajdoc/AjdocTests.java"><method name="suite" returnType="Test" parameters=""/></file><file name="ajdoc/src/org/aspectj/tools/ajdoc/StubFileGenerator.java"><method name="processMembers" returnType="void" parameters=""/></file><file name="ajdoc/src/org/aspectj/tools/ajdoc/StructureUtil.java"><method name="getTargets" returnType="List/*IProgramElement*/" parameters="IProgramElement IRelationship.Kind"/></file></commit></fixedCommits></bug><bug id="203" opendate="2005-10-11 14:27:00" fixdate="2005-10-13 10:44:13"><buginformation><summary>Compiler Core Dump with Apparent Fix</summary><description>I am seeing this exception when using ajc to do binary weaving:

     [iajc] Exception thrown from AspectJ 1.5.0M4

     [iajc] This might be logged as a bug already -- find current bugs at
     [iajc]    http://bugs.eclipse.org/bugs/buglist.cgi?product=AspectJ&amp;component 
=Compiler

     [iajc] Bugs for exceptions thrown have titles File:line from the top stack,

     [iajc] e.g., "SomeFile.java:243"

     [iajc] If you don't find the exception below in a bug, please add a new bug

     [iajc] at  http://bugs.eclipse.org/bugs/enter_bug.cgi?product=AspectJ 
     [iajc] To make the bug a priority, please include a test program
     [iajc] that can reproduce this exception.
     [iajc] org.aspectj.weaver.MissingResolvedTypeWithKnownSignature

     [iajc] when batch building with classpath: ...
     [iajc] org.aspectj.weaver.MissingResolvedTypeWithKnownSignature
     [iajc] java.lang.ClassCastException: org.aspectj.weaver.MissingResolvedType
WithKnownSignature
     [iajc]     at org.aspectj.weaver.bcel.BcelWorld.addSourceObjectType(BcelWor
ld.java:277)
     [iajc]     at org.aspectj.weaver.bcel.BcelWeaver.addClassFile(BcelWeaver.ja
va:373)
     [iajc]     at org.aspectj.weaver.bcel.BcelWeaver.addJarFile(BcelWeaver.java
:306)
     [iajc]     at org.aspectj.ajdt.internal.core.builder.AjBuildManager.initBce
lWorld(AjBuildManager.java:598)
     [iajc]     at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild
(AjBuildManager.java:204)
     [iajc]     at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBu
ild(AjBuildManager.java:151)
     [iajc]     at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:1
12)
     [iajc]     at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:
60)
     [iajc]     at org.aspectj.tools.ajc.Main.run(Main.java:326)
     [iajc]     at org.aspectj.tools.ajc.Main.runMain(Main.java:240)
     [iajc]     at org.aspectj.tools.ajc.Main.main(Main.java:83)


     [iajc] 1 fail|abort

I see this also in HEAD and used the debugger to determine it is trying to 
resolve the type that it's trying to load!

I am able to get it to finish the weave with no errors by changing BcelWorld as 
follows:

	public BcelObjectType addSourceObjectType(JavaClass jc) {
		BcelObjectType ret = null;
		String signature = UnresolvedType.forName(jc.getClassName
()).getSignature();
		ReferenceType nameTypeX = null;
		Object lookup = typeMap.get(signature);
		if (lookup instanceof ReferenceType) {
			nameTypeX = (ReferenceType)lookup;
		}

Instead of just casting. Then the result is null and it falls through to the 
usual lookup unresolved type logic. Is this fix correct?

I suspect it would take a few hours to narrow down a test case for this one.</description><comments/></buginformation><fixedCommits><commit id="04e8dca2fc16f5f834e124b7abea5847d90c3366" author="default" date="2005-10-13 10:44:13"><file name="weaver/src/org/aspectj/weaver/bcel/BcelWorld.java"><method name="addSourceObjectType" returnType="BcelObjectType" parameters="JavaClass"/></file><file name="weaver/src/org/aspectj/weaver/World.java"><method name="put" returnType="ResolvedType" parameters="String ResolvedType"/></file></commit></fixedCommits></bug><bug id="204" opendate="2005-08-18 01:41:00" fixdate="2005-10-15 03:20:41"><buginformation><summary>-aspectpath-inpath arguments fail without drive letter</summary><description>ajc doesn't recognize Windows absolute file paths that don't start with a drive 
letter, e.g., run:
ajc -inpath \test.jar
[error] build config error: bad inpath component: \test.jar

but

ajc -inpath c:\test.jar
works

ajc -aspectpath \test.jar Test.aj

[error] build config error: bad aspectpath: \test.jar

ajc -aspectpath c:\test.jar Test.aj
(works)</description><comments/></buginformation><fixedCommits><commit id="332a5df39711d17d13ef2c87fdaba023d4869538" author="default" date="2005-10-15 03:20:41"><file name="util/src/org/aspectj/util/ConfigParser.java"><method name="makeFile" returnType="File" parameters="File String"/></file></commit></fixedCommits></bug><bug id="205" opendate="2005-10-08 02:49:00" fixdate="2005-10-18 15:40:35"><buginformation><summary>unexpected error unboundFormalInPC</summary><description>In 1.5.0M4, I get error "the parameter tis is not bound in [all branches of]
pointcut".  Not true of 1.2.1.  Untested in other development versions of 1.5.0.
  No branches (all &amp;&amp;) but duplicate specification of this(..).

------------------------------------------
package demo;

/**
 * PerThis
 */
public class PerThis {
    public static void main(String[] args) {
        new This().test();
    }
}
aspect PerThisTest perthis(pc()) {
    // TutIndex example-basic-perthis
    pointcut pc() : this(This) &amp;&amp; !within(PerThisTest) &amp;&amp; call(void run());
    before(This tis) : pc() &amp;&amp; this(tis){
        System.out.println("bef " + this + " &lt;-- " + tis);
    }
}

class This {
    int i;
    void test() {
        run();
    }
    void run() {
        System.out.println("run " + this);
    }
}</description><comments/></buginformation><fixedCommits><commit id="ae612d9752200a3784de33ea6b79815e77aabaed" author="default" date="2005-10-18 15:40:35"><file name="weaver/src/org/aspectj/weaver/patterns/ExactTypePattern.java"><method name="hashCode" returnType="int" parameters=""/><method name="equals" returnType="boolean" parameters="Object"/></file><file name="weaver/src/org/aspectj/weaver/patterns/BindingTypePattern.java"><method name="hashCode" returnType="int" parameters=""/></file></commit></fixedCommits></bug><bug id="206" opendate="2005-10-19 09:24:00" fixdate="2005-10-20 13:54:50"><buginformation><summary>weaveinfo messages not reported if applying declare @method on an ITD'd method</summary><description>Given the following class:

@interface Annotation{}
aspect B {
	
	declare @method : public * C.anotherMethod(..) : @Annotation;
}

class C {
}

aspect D {
	public void C.anotherMethod(String s) {
	}
	public void C.anotherMethod() {
	}
}

I would expect a two weaveinfo messages of the form:

weaveinfo 'public void C.anotherMethod()' (pr99191_4.java) is annotated with
@Annotation method annotation from 'B' (pr99191_4.java:3)
weaveinfo 'public void C.anotherMethod(String)' (pr99191_4.java) is annotated
with @Annotation method annotation from 'B' (pr99191_4.java:3)

However, only the two "intertyped" messages are coming out.</description><comments/></buginformation><fixedCommits><commit id="f06df41e4038bbde47a9934b240a3c064aa26099" author="default" date="2005-10-20 13:54:50"><file name="weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"><method name="reportMethodCtorWeavingMessage" returnType="void" parameters="LazyClassGen LazyMethodGen DeclareAnnotation"/><method name="weaveDeclareAtMethodCtor" returnType="boolean" parameters="LazyClassGen"/></file></commit></fixedCommits></bug><bug id="207" opendate="2005-10-07 11:14:00" fixdate="2005-10-21 06:56:11"><buginformation><summary>illegal change to pointcut declaration</summary><description>org.aspectj.weaver.BCException
at
org.aspectj.weaver.patterns.ReferencePointcut.concretize1(ReferencePointcut.java:306)
at org.aspectj.weaver.patterns.Pointcut.concretize(Pointcut.java:229)
at
org.aspectj.weaver.patterns.ReferencePointcut.concretize1(ReferencePointcut.java:331)
at org.aspectj.weaver.patterns.Pointcut.concretize(Pointcut.java:229)
at org.aspectj.weaver.patterns.Pointcut.concretize(Pointcut.java:216)
at org.aspectj.weaver.Advice.concretize(Advice.java:273)
at org.aspectj.weaver.bcel.BcelAdvice.concretize(BcelAdvice.java:83)
at
org.aspectj.weaver.CrosscuttingMembers.addShadowMunger(CrosscuttingMembers.java:84)
at
org.aspectj.weaver.CrosscuttingMembers.addShadowMungers(CrosscuttingMembers.java:78)
at org.aspectj.weaver.ResolvedType.collectCrosscuttingMembers(ResolvedType.java:462)
at
org.aspectj.weaver.CrosscuttingMembersSet.addOrReplaceAspect(CrosscuttingMembersSet.java:62)
at org.aspectj.weaver.bcel.BcelWeaver.prepareForWeave(BcelWeaver.java:426)
at
org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave(AjCompilerAdapter.java:283)
at
org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling(AjCompilerAdapter.java:178)
at
org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$afterReturning$org_aspectj_ajdt_internal_compiler_CompilerAdapter$2$f9cc9ca0(CompilerAdapter.aj:70)
at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:367)
at
org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:760)
at
org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:225)
at
org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:151)
at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:122)
at
org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)

BCException thrown: illegal change to pointcut declaration:
spike.np.CommandCase.handleCommand(BindingTypePattern(spike.np.OtherHandler$MyWorld,
0))
when batch building
BuildConfig[/home/guido/workspace/.metadata/.plugins/org.eclipse.ajdt.core/np.generated.lst]
#Files=11</description><comments/></buginformation><fixedCommits><commit id="3021284f5d910a406d26a01ce836bbb5f5cd6bfc" author="default" date="2005-10-21 06:56:11"><file name="weaver/src/org/aspectj/weaver/patterns/ReferencePointcut.java"><method name="concretize1" returnType="Pointcut" parameters="ResolvedType"/><method name="resolveBindings" returnType="void" parameters="IScope Bindings"/></file></commit></fixedCommits></bug><bug id="208" opendate="2005-10-24 05:39:00" fixdate="2005-10-24 09:48:39"><buginformation><summary>LTW enhancements</summary><description>Alex, here is the basic patch that is working well before you leave for the
weekend ;-) I'll let Matthew post it officially to bugzilla since it was his
idea. The earlier return from !enabled is a small addition I made that seems
to help further. It would be great to have this in HEAD so I can report
performance numbers based on it in part 2 of my article on developerworks
;-)

Hope you are enjoying your new addition!

Thanks!

Index: ClassLoaderWeavingAdaptor.java
===================================================================
RCS file:
/home/technology/org.aspectj/modules/loadtime/src/org/aspectj/weaver/loadtim
e/ClassLoaderWeavingAdaptor.java,v
retrieving revision 1.18
diff -u -r1.18 ClassLoaderWeavingAdaptor.java
--- ClassLoaderWeavingAdaptor.java      19 Oct 2005 13:11:36 -0000      1.18
+++ ClassLoaderWeavingAdaptor.java      21 Oct 2005 16:04:41 -0000
@@ -107,8 +107,13 @@

        // register the definitions
        registerDefinitions(weaver, loader);
+        if (!enabled) {
+               return;
+        }
        messageHandler = bcelWorld.getMessageHandler();

+
bcelWorld.setResolutionLoader((ClassLoader)null);//loader.getParent());
+
        // after adding aspects
        weaver.prepareForWeave();
    }
@@ -148,7 +153,11 @@
                           definitions.add(DocumentParser.parse(xml));
                       }
               }
-
+               if (definitions.isEmpty()) {
+                       enabled = false;
+                       return;
+               }
+
            // still go thru if definitions is empty since we will
configure
            // the default message handler in there
            registerOptions(weaver, loader, definitions);</description><comments/></buginformation><fixedCommits><commit id="70888ddc862b717646b236db2767e11a586b6157" author="default" date="2005-10-24 09:48:39"><file name="loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"><method name="registerDefinitions" returnType="void" parameters="BcelWeaver"/><method name="addCrossReference" returnType="void" parameters="ISourceLocation ISourceLocation"/></file><file name="loadtime/src/org/aspectj/weaver/loadtime/Aj.java"><method name="getWeaver" returnType="WeavingAdaptor" parameters="ClassLoader IWeavingContext"/><method name="getWeaver" returnType="WeavingAdaptor" parameters="ClassLoader"/></file></commit></fixedCommits></bug><bug id="209" opendate="2005-10-14 08:26:00" fixdate="2005-10-25 12:40:39"><buginformation><summary>-XhasMember is not processed correctly when passed from AJDT</summary><description>To test this in AJDT install the bean example, add a new interface called I 
and then add the following line to BoundPoint.aj:

declare parents: hasmethod(* set*(..)) implements I;

Now open the AspectJ Compiler preference page and select "Has Member" on the 
advanced tab.  Click OK, rebuild and if the option was working the project 
would build correctly.  As it stands there is an error:

the type pattern hasmethod(* set*(..)) can only be used when the -XhasMember 
option is set</description><comments/></buginformation><fixedCommits><commit id="cc6862f2b54c3333d645a0efb28f5366b0a2bcc3" author="default" date="2005-10-25 12:40:39"><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.java"><method name="installGlobals" returnType="void" parameters="AjBuildConfig"/></file></commit></fixedCommits></bug><bug id="210" opendate="2005-06-09 12:08:00" fixdate="2005-10-27 15:49:49"><buginformation><summary>declare @field allowed for non existent fields</summary><description>///// in this code
@interface anInterface{}
aspect B {	
  declare @field : int B.noSuchField : @anInterface; // should be an error
}
//////////////////

I don't get an error, even though B.noSuchField doesn't exist.

If I try declare @field on NoSuchCLass.noSuchField I do get an error though.</description><comments/></buginformation><fixedCommits><commit id="2da9b31be2c1e5af9d33b25be798f3a47362fb88" author="default" date="2005-10-27 15:49:49"><file name="weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"><method name="weaveDeclareAtField" returnType="boolean" parameters="LazyClassGen"/><method name="weaveDeclareAtMethodCtor" returnType="boolean" parameters="LazyClassGen"/></file></commit></fixedCommits></bug><bug id="211" opendate="2005-10-26 14:01:00" fixdate="2005-10-27 18:01:54"><buginformation><summary>[generics] field-get problems when generic field is used.</summary><description>Hi, 

When i'm compiling the following example, i'm getting this errors:

TestAspect.aj:21 [error] incompatible return type applying to field-get
(java.util.Set com.mprv.secsph.Test.intsSet)

Test.java:18 [error] incompatible return type applying to field-get
(java.util.Set com.mprv.secsph.Test.intsSet)

Here is the example
-------------------

Java Code:

package com;

public class Test {

	Set&lt;Integer&gt; intsSet;

	public Set&lt;Integer&gt; foo() {
18:         return intsSet;
	}
}

Aspect:

public privileged aspect TestAspect {
    pointcut gettingMember(Test t) :
                target(t) &amp;&amp;
                get(!public Set&lt;Integer&gt; com.*.*) &amp;&amp;
                !within(TestAspect);

21: Set&lt;Integer&gt; around(Test t) : gettingMemberCollection(t)  {
        Set s =  proceed(t);
        return s;
    }
}

I've tried many kinds of workarounds, and the only thing which worked, is 
defining the member field without using generics (regular Set) ... 

One more disturbing is, that this fiture worked(!) in M2 release. 

This is an example of the functionality that worked in my project (with M2), 
but now, also reports the same error:

Java code is the same, Aspect is:

public privileged aspect TestAspect {
    pointcut gettingMember(Test t) :
                target(t) &amp;&amp;
                get(!public Set com.*.*) &amp;&amp;
                !within(TestAspect);

    Set around(Test t) : gettingMemberCollection(t)  {
        Set s =  proceed(t);
        return s;
    }
}

Is it a bug? Or am i doing something wrong?

Thanks!
Misha.</description><comments/></buginformation><fixedCommits><commit id="8cea30fedf7a74133c67623ec9286ac9578c9a88" author="default" date="2005-10-27 18:01:54"><file name="tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"><method name="testUnboundFormal_pr112027" returnType="void" parameters=""/><method name="testCCEGenerics_pr113445" returnType="void" parameters=""/></file><file name="weaver/src/org/aspectj/weaver/Advice.java"><method name="match" returnType="boolean" parameters="Shadow World"/></file></commit></fixedCommits></bug><bug id="212" opendate="2005-09-06 22:05:00" fixdate="2005-10-28 12:07:14"><buginformation><summary>Load Time Weaving problem with Aspect Definition at 2 Levels of Hierarchy</summary><description>I am trying to weave into Tomcat with a system-level aspect (META-INF/aop.xml 
is found in a jar on the system classpath), and also have a Web application 
with an aop.xml properly deployed. When I try to run them both together, only 
the system-level aspects work. If I remove the system-level aspect jar from the 
classpath, the application-level aspects work. What would be a reasonable way 
to isolate this into a test case? If I could package up a simple system.jar and 
app.war file for Tomcat 5.5.9, would that be useful for you to use in debugging 
it? I tried making a simple standalone version with 2 aop.xml files in the same 
app classloader but that works just fine.</description><comments/></buginformation><fixedCommits><commit id="794f9b5eafe34a7dbb48cda3edaec59ff57afef5" author="default" date="2005-10-28 12:07:14"><file name="weaver/src/org/aspectj/weaver/bcel/AtAjAttributes.java"><method name="readAj5ClassAttributes" returnType="List" parameters="JavaClass"/></file></commit></fixedCommits></bug><bug id="213" opendate="2005-10-24 05:36:00" fixdate="2005-11-02 10:36:05"><buginformation><summary>readAspect</summary><description>clearly define what the goal for readAspect is
old byte per byte reading cause NPE in some test case
current impl is hashcode for aspect name + classloader - ie unstable across
startups.</description><comments/></buginformation><fixedCommits><commit id="62d16d52c25f7b5ff389ee2de603bbb3dc186c8e" author="default" date="2005-11-02 10:36:05"><file name="loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"><method name="flushGeneratedClasses" returnType="void" parameters=""/><method name="readAspect" returnType="String" parameters="String ClassLoader"/><method name="registerAspects" returnType="void" parameters="BcelWeaver ClassLoader"/></file></commit></fixedCommits></bug><bug id="214" opendate="2005-11-02 07:56:00" fixdate="2005-11-02 16:16:29"><buginformation><summary>NPE at CaptureBinding.java on wildcard in intertype field type</summary><description>When compiling this program with ajc -1.5

public aspect Wildcard {
    Class&lt;? extends Wildcard&gt; Wildcard.cl;

    void foo() throws Exception {
	Wildcard ci = cl.newInstance();
    }
}

ajc throws this exception

java.lang.NullPointerException
        at
org.aspectj.org.eclipse.jdt.internal.compiler.lookup.CaptureBinding.initializeBounds(CaptureBinding.java:75)
        at
org.aspectj.org.eclipse.jdt.internal.compiler.lookup.ParameterizedTypeBinding.capture(ParameterizedTypeBinding.java:105)
        at
org.aspectj.org.eclipse.jdt.internal.compiler.ast.SingleNameReference.resolveType(SingleNameReference.java:772)
        at
org.aspectj.org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:293)
        at
org.aspectj.org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.resolve(LocalDeclaration.java:199)
        at
org.aspectj.org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:422)
        at
org.aspectj.org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:178)
        at
org.aspectj.org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:400)
        at
org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1076)
        at
org.aspectj.ajdt.internal.compiler.ast.AspectDeclaration.resolve(AspectDeclaration.java:114)
        at
org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1125)
        at
org.aspectj.org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:305)
        at
org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:514)
        at
org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:329)
        at
org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:759)
        at
org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:225)
        at
org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:151)
        at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:112)
        at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:60)
        at org.aspectj.tools.ajc.Main.run(Main.java:326)
        at org.aspectj.tools.ajc.Main.runMain(Main.java:240)
        at org.aspectj.tools.ajc.Main.main(Main.java:83)</description><comments/></buginformation><fixedCommits><commit id="ade32bc38c17b38811b617f54828feb43a4b7048" author="default" date="2005-11-02 16:16:29"><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"><method name="makeTypeBinding" returnType="TypeBinding" parameters="UnresolvedType"/><method name="makeTypeBinding1" returnType="TypeBinding" parameters="UnresolvedType"/></file></commit></fixedCommits></bug><bug id="215" opendate="2005-10-13 09:44:00" fixdate="2005-11-04 10:47:47"><buginformation><summary>"declare parents" does not work with bytecode weaving</summary><description>1. download and unpack  http://www.fuurou.org/downloads/aspectjtest.zip  (I 
couldn't find a way of attaching it) 
2. copy the aspectj jars into the lib directory 
3. run ant 
 
The ant file executes both source code and byte code weaving and then it 
veryfies that the class hierarchy was changed. As you can see from the output 
in case of source weaving the test is: 
 
[java] Is [class lib.C] subcass of [class weaved.SuperC]? true 
 
while when weaving bytecode: 
 
[java] Is [class lib.C] subcass of [class weaved.SuperC]? false</description><comments/></buginformation><fixedCommits><commit id="a7e13f10303623cbab5f84e8d9cecd882308b52a" author="default" date="2005-11-04 10:47:47"><file name="weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java"><method name="attemptToModifySuperCalls" returnType="boolean" parameters="BcelClassWeaver"/></file></commit></fixedCommits></bug><bug id="216" opendate="2005-04-04 06:46:00" fixdate="2005-11-04 16:26:06"><buginformation><summary>[itds] Problem with an ITD on an interface</summary><description>If an ITD method is declared on an interface with an anonymous inner class 
returned as the result, the compiler generates an error for any "super.xxx" 
calls in the anonymous inner class.  The example project shows this with a 
nested inner interface, but the same problem occurs with an ITD of this kind 
on any interface.  The error does not occur if the ITD is declared on an inner 
class (as shown in the example) or a normal class.</description><comments/></buginformation><fixedCommits><commit id="21cf37dd535baf1b9977044ce4f05520538116ba" author="default" date="2005-11-04 16:26:06"><file name="tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"><method name="testCantCallSuperMethods_pr90143" returnType="void" parameters=""/></file><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/InterSuperFixerVisitor.java"><method name="fixReceiver" returnType="Expression" parameters="Expression BlockScope"/></file></commit></fixedCommits></bug><bug id="217" opendate="2005-10-27 13:23:00" fixdate="2005-11-08 12:13:05"><buginformation><summary>annotated ITD fields on interfaces have no annotation</summary><description>As stated in the notebook it is allowed to annotate field ITDs.
This seems not to work properly with interfaces.


public interface TestInterface {

}

@Retention(RetentionPolicy.RUNTIME)
public @interface SampleAnnotation {

}

public aspect Declaration {

	declare parents: (@SampleAnnotation *) implements TestInterface;
	
        // this is fine
	@SampleAnnotation 
	public transient String Test.firstProperty;
	
        / this does not work
	@SampleAnnotation
	public transient String TestInterface.secondProperty;
	
        // this also does not work
	declare @field: * TestInterface+.*: @SampleAnnotation;
}

secondProperty has no Annotation as one can see with:


public class Test implements TestInterface {

	public static void main(String[] args) {
		for (Field field: Test.class.getFields()) {
			System.err.println(field.toString().concat(" ").concat
(String.valueOf(field.isAnnotationPresent(SampleAnnotation.class))));
		}
	}
}

I did not try whether this is also the case for method ITS on interfaces.
Secondly the field name is 
ajc$interField$test_Declaration$test_TestInterface$secondProperty instead of
simply secondProperty. Is this what is meant with  bug 73507 ?

What is with private and package protected ITD of fields and runtime 
reflection? Because the field name is mangled (Test.class.getField
("firstProperty") raises a NoSuchFieldException when declared private or 
package protected). Also "declare @field: * Test+.*: @SampleAnnotation;" is 
not applied for private or package protected declarations. So should one only
annotate public field IDTs (supported by compiler warnings) to have useful 
runtime behaviour (with runtime RetentionPolicy annotations)?

So it is strange that the introductory example on annotations shows annotated 
private field ITDs on interfaces :-)

Thank you very much for your help,
Vincenz</description><comments/></buginformation><fixedCommits><commit id="d9757d7c41bf2661455422ce3234e4794c9f533e" author="default" date="2005-11-08 12:13:05"><file name="tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"><method name="testITDCtor_pr112783" returnType="void" parameters=""/></file><file name="weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java"><method name="mungeNewField" returnType="boolean" parameters="BcelClassWeaver NewFieldTypeMunger"/></file></commit></fixedCommits></bug><bug id="218" opendate="2005-10-17 14:01:00" fixdate="2005-11-08 16:41:54"><buginformation><summary>Warning "couldn't find aspectjrt.jar on classpath"</summary><description>The compiler makes this warning if "aspectrt.jar" file has a different name like
"aspectrt-1.3.jar", which is the case when compiling with maven.</description><comments/></buginformation><fixedCommits><commit id="1f5149913ee859e466602f99a210dd76e0ade8ed" author="default" date="2005-11-08 16:41:54"><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"><method name="checkRtJar" returnType="String" parameters="AjBuildConfig"/></file></commit></fixedCommits></bug><bug id="219" opendate="2005-10-19 14:01:00" fixdate="2005-11-11 15:13:33"><buginformation><summary>ClassFormatException with tracing aspect</summary><description>Build id: 20051017111807
AspectJ version: 1.5.0.200510141300

The following aspect resulted in the CFE:

public aspect CallTrace {
	/**
	 * A marker interface used to pick the classes to trace. Declare any class you
want to
	 * trace to implement this interface. The best way is using an aspect like the
one in
	 * the class comment block above.
	 */
	public static interface Traced {}
	
	/**
	 * A marker annoation, can be used instead of {@link Traced}.
	 */
	@Documented
	@Retention(RetentionPolicy.RUNTIME)
	@Target({ElementType.TYPE, ElementType.ANNOTATION_TYPE})
	public @interface TracedAnno {}
	
	private static Level level = Level.INFO;
	
	/**
	 * Set the global logging level used for reporting traced calls. Defaults to INFO.
	 * @param newLevel
	 */
	public static void setLevel (Level newLevel) {
		level = newLevel;
	}
	
	/**
	 * @return the Level used for writing traced output.
	 */
	public static Level getLevel () {
		return level;
	}
	
	private static Logger log = Logger.getLogger(Traced.class);
	private int nesting = 0;
	private static StringBuffer prefixStr = null;
	static {
		new StringBuffer(1024);
		for (int i=0; i&lt;128; i++) { // stuff with "+".
			prefixStr.append("++++++++"); 
		}
	}
	public pointcut exclusions(): within(CallTrace) || within(*Tracer);
	
	// Distinguish between initialization JPs and other method calls, to work
	// around AJ limitation that around advice isn't supported for initializations.
	
	public pointcut traceIntfInit(): initialization(Traced+.new(..));
	public pointcut traceIntf(): call(* Traced+.*(..));
	
	public pointcut traceAnnoInit(): 
		initialization(com.adteractive..*.new(..)) &amp;&amp; @target(TracedAnno);
	public pointcut traceAnno(): 
		 call(* com.adteractive..*.*(..)) &amp;&amp; @target(TracedAnno);

	public pointcut traceInit(): !exclusions() &amp;&amp; (traceIntfInit() || traceAnnoInit());
	public pointcut trace(): !exclusions() &amp;&amp; (traceIntf() || traceAnno());
	
	before(): traceInit() {
		nesting++;
		String pre = prefixStr.substring(0,nesting);
		log.log (level, pre+"&gt; "+thisJoinPointStaticPart);
	}
	
	after(): traceInit() {
		String pre = prefixStr.substring(0,nesting);
		log.log (level, pre+"&lt; "+thisJoinPointStaticPart);
		nesting--;
	}
	
	Object around(): trace() {
		nesting++;
		String pre = prefixStr.substring(0,nesting);
		log.log (level, pre+"&gt; "+thisJoinPointStaticPart);
		Object result = proceed();
		log.log (level, pre+"&lt; "+thisJoinPointStaticPart);
		nesting--;
		return result;
	}
}

A separate aspect is used to "declare parent" or "declare @type" either the
marker interface or annotation, thereby adding tracing to the user-specified
classes. E.g.,

public aspect CallTraceTestTracer {
//	declare @type:   com.me.foo..*: @CallTrace.TracedAnno;
	declare parents: com.me.foo..* implements CallTrace.Traced;
}

The exception wasn't thrown in a previous version when I used just before advice
for both the "trace" and "traceInit" pointcuts. 

org.aspectj.apache.bcel.classfile.ClassFormatException
at org.aspectj.apache.bcel.classfile.Utility.typeOfSignature(Utility.java:1293)
at org.aspectj.apache.bcel.generic.Type.getTypeInternal(Type.java:166)
at org.aspectj.apache.bcel.generic.Type.getTypeInternal(Type.java:174)
at org.aspectj.apache.bcel.generic.Type.getType(Type.java:155)
at org.aspectj.weaver.bcel.BcelWorld.makeBcelType(BcelWorld.java:198)
at org.aspectj.weaver.bcel.BcelShadow.createMethodGen(BcelShadow.java:2999)
at org.aspectj.weaver.bcel.BcelShadow.extractMethod(BcelShadow.java:2826)
at org.aspectj.weaver.bcel.BcelShadow.weaveAroundInline(BcelShadow.java:2020)
at org.aspectj.weaver.bcel.BcelAdvice.implementOn(BcelAdvice.java:211)
at org.aspectj.weaver.Shadow.implementMungers(Shadow.java:514)
at org.aspectj.weaver.Shadow.implement(Shadow.java:391)
at org.aspectj.weaver.bcel.BcelClassWeaver.implement(BcelClassWeaver.java:1781)
at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:394)
at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:98)
at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1464)
at org.aspectj.weaver.bcel.BcelWeaver.weaveWithoutDump(BcelWeaver.java:1429)
at org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify(BcelWeaver.java:1203)
at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1039)
at
org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave(AjCompilerAdapter.java:300)
at
org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling(AjCompilerAdapter.java:178)
at
org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$afterReturning$org_aspectj_ajdt_internal_compiler_CompilerAdapter$2$f9cc9ca0(CompilerAdapter.aj:70)
at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:367)
at org.aspectj.a

jdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:759)
at
org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:249)
at
org.aspectj.ajdt.internal.core.builder.AjBuildManager.incrementalBuild(AjBuildManager.java:158)
at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:117)
at
org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)

trouble in: 
public class com.adteractive.framework.test.ConditionTestFilterTest extends
junit.framework.TestCase:
  com.adteractive.framework.ConditionTestFilter ctf
[Signature(Lcom/adteractive/framework/ConditionTestFilter&lt;Lcom/adteractive/framework/test/InputStub;Lcom/adteractive/framework/test/OutputStub;&gt;;)]
  static Class class$0
  private static final org.aspectj.lang.JoinPoint$StaticPart ajc$tjp_0
  public void &lt;init&gt;():
                    ALOAD_0     //
com.adteractive.framework.test.ConditionTestFilterTest this   (line 16)
                    INVOKESPECIAL junit.framework.TestCase.&lt;init&gt; ()V
    constructor-execution(void
com.adteractive.framework.test.ConditionTestFilterTest.&lt;init&gt;())
    |               ALOAD_0     //
com.adteractive.framework.test.ConditionTestFilterTest this   (line 17)
    |               ACONST_NULL
    |               PUTFIELD
com.adteractive.framework.test.ConditionTestFilterTest.ctf
Lcom/adteractive/framework/ConditionTestFilter;
    |               RETURN   (line 16)
    constructor-execution(void
com.adteractive.framework.test.ConditionTestFilterTest.&lt;init&gt;())
  end public void &lt;init&gt;()

  protected void setUp() throws java.lang.Exception   
org.aspectj.weaver.MethodDeclarationLineNumber: 23:543
:
    method-execution(void
com.adteractive.framework.test.ConditionTestFilterTest.setUp())
    |               ALOAD_0     //
com.adteractive.framework.test.ConditionTestFilterTest this   (line 24)
    |               INVOKESPECIAL junit.framework.TestCase.setUp ()V
    |               ALOAD_0     //
com.adteractive.framework.test.ConditionTestFilterTest this   (line 25)
    |               NEW com.adteractive.framework.test.ConditionTestFilterStub
    |               DUP
    |               LDC "ctf"
    |               ALOAD_0     //
com.adteractive.framework.test.ConditionTestFilterTest this
    |               ASTORE_1
    | method-call(com.adteractive.framework.Filter[]
com.adteractive.framework.test.ConditionTestFilterTest.makeBranches())
    | |             ALOAD_1
    | |             INVOKESPECIAL
com.adteractive.framework.test.ConditionTestFilterTest.makeBranches
()[Lcom/adteractive/framework/Filter;
    | method-call(com.adteractive.framework.Filter[]
com.adteractive.framework.test.ConditionTestFilterTest.makeBranches())
    |               INVOKESPECIAL
com.adteractive.framework.test.ConditionTestFilterStub.&lt;init&gt;
(Ljava/lang/String;[Lcom/adteractive/framework/Filter;)V
    |               PUTFIELD
com.adteractive.framework.test.ConditionTestFilterTest.ctf
Lcom/adteractive/framework/ConditionTestFilter;
    |               RETURN   (line 26)
    method-execution(void
com.adteractive.framework.test.ConditionTestFilterTest.setUp())
  end protected void setUp() throws java.lang.Exception

  public void testExecute()    org.aspectj.weaver.MethodDeclarationLineNumber:
31:754
:
    method-execution(void
com.adteractive.framework.test.ConditionTestFilterTest.testExecute())
    |               ALOAD_0     //
com.adteractive.framework.test.ConditionTestFilterTest this   (line 32)
    |               GETFIELD
com.adteractive.framework.test.ConditionTestFilterTest.ctf
Lcom/adteractive/framework/ConditionTestFilter;
    |               NEW com.adteractive.framework.test.InputStub
    |               DUP
    |               INVOKESPECIAL
com.adteractive.framework.test.InputStub.&lt;init&gt; ()V
    | method-call(com.adteractive.framework.Output
com.adteractive.framework.ConditionTestFilter.execute(com.adteractive.framework.Input))
    | |             INVOKEVIRTUAL
com.adteractive.framework.ConditionTestFilter.execute
(Lcom/adteractive/framework/Input;)Lcom/adteractive/framework/Output;
    | method-call(com.adteractive.framework.Output
com.adteractive.framework.ConditionTestFilter.execute(com.adteractive.framework.Input))
    |               CHECKCAST com.adteractive.framework.test.OutputStub
    |               ASTORE_1
    |               LDC "bf12"   (line 33)
    |               ALOAD_1     // com.adteractive.framework.test.OutputStub output
    | method-call(com.adteractive.framework.Status
com.adteractive.framework.test.OutputStub.getStatus())
    | |             INVOKEVIRTUAL
com.adteractive.framework.test.OutputStub.getStatus
()Lcom/adteractive/framework/Status;
    | method-call(com.adteractive.framework.Status
com.adteractive.framework.test.OutputStub.getStatus())
    | method-call(java.lang.String
com.adteractive.framework.Status.getAdditionalMessage())
    | |             INVOKEINTERFACE
com.adteractive.framework.Status.getAdditionalMessage ()Ljava/lang/String;
    | method-call(java.lang.String
com.adteractive.framework.Status.getAdditionalMessage())
    | method-call(void junit.framework.Assert.assertEquals(java.lang.String,
java.lang.String))
    | |             INVOKESTATIC
com.adteractive.framework.test.ConditionTestFilterTest.assertEquals
(Ljava/lang/String;Ljava/lang/String;)V
    | method-call(void junit.framework.Assert.assertEquals(java.lang.String,
java.lang.String))
    |               ALOAD_0     //
com.adteractive.framework.test.ConditionTestFilterTest this   (line 34)
    |               NEW com.adteractive.framework.test.ConditionTestFilterStub
    |               DUP
    |               INVOKESPECIAL
com.adteractive.framework.test.ConditionTestFilterStub.&lt;init&gt; ()V
    |               PUTFIELD
com.adteractive.framework.test.ConditionTestFilterTest.ctf
Lcom/adteractive/framework/ConditionTestFilter;
    |               ALOAD_0     //
com.adteractive.framework.test.ConditionTestFilterTest this   (line 35)
    |               GETFIELD
com.adteractive.framework.test.ConditionTestFilterTest.ctf
Lcom/adteractive/framework/ConditionTestFilter;
    |               NEW com.adteractive.framework.test.InputStub
    |               DUP
    |               INVOKESPECIAL
com.adteractive.framework.test.InputStub.&lt;init&gt; ()V
    | method-call(com.adteractive.framework.Output
com.adteractive.framework.ConditionTestFilter.execute(com.adteractive.framework.Input))
    | |             INVOKEVIRTUAL
com.adteractive.framework.ConditionTestFilter.execute
(Lcom/adteractive/framework/Input;)Lcom/adteractive/framework/Output;
    | method-call(com.adteractive.framework.Output
com.adteractive.framework.ConditionTestFilter.execute(com.adteractive.framework.Input))
    |               CHECKCAST com.adteractive.framework.test.OutputStub
    |               ASTORE_1     // com.adteractive.framework.test.OutputStub output
    |               ALOAD_1     // com.adteractive.framework.test.OutputStub
output   (line 36)
    | method-call(void junit.framework.Assert.assertNotNull(java.lang.Object))
    | |             INVOKESTATIC
com.adteractive.framework.test.ConditionTestFilterTest.assertNotNull
(Ljava/lang/Object;)V
    | method-call(void junit.framework.Assert.assertNotNull(java.lang.Object))
    |               RETURN   (line 37)
    method-execution(void
com.adteractive.framework.test.ConditionTestFilterTest.testExecute())
  end public void testExecute()

  public void testGetFilterBranches()   
org.aspectj.weaver.MethodDeclarationLineNumber: 42:1111
:
    method-execution(void
com.adteractive.framework.test.ConditionTestFilterTest.testGetFilterBranches())
    |               ALOAD_0     //
com.adteractive.framework.test.ConditionTestFilterTest this   (line 43)
    |               GETFIELD
com.adteractive.framework.test.ConditionTestFilterTest.ctf
Lcom/adteractive/framework/ConditionTestFilter;
    | method-call(com.adteractive.framework.Filter[]
com.adteractive.framework.ConditionTestFilter.getFilterBranches())
    | |             INVOKEVIRTUAL
com.adteractive.framework.ConditionTestFilter.getFilterBranches
()[Lcom/adteractive/framework/Filter;
    | method-call(com.adteractive.framework.Filter[]
com.adteractive.framework.ConditionTestFilter.getFilterBranches())
    | method-call(void junit.framework.Assert.assertNotNull(java.lang.Object))
    | |             INVOKESTATIC
com.adteractive.framework.test.ConditionTestFilterTest.assertNotNull
(Ljava/lang/Object;)V
    | method-call(void junit.framework.Assert.assertNotNull(java.lang.Object))
    |               ICONST_3   (line 44)
    |               ALOAD_0     //
com.adteractive.framework.test.ConditionTestFilterTest this
    |               GETFIELD
com.adteractive.framework.test.ConditionTestFilterTest.ctf
Lcom/adteractive/framework/ConditionTestFilter;
    | method-call(com.adteractive.framework.Filter[]
com.adteractive.framework.ConditionTestFilter.getFilterBranches())
    | |             INVOKEVIRTUAL
com.adteractive.framework.ConditionTestFilter.getFilterBranches
()[Lcom/adteractive/framework/Filter;
    | method-call(com.adteractive.framework.Filter[]
com.adteractive.framework.ConditionTestFilter.getFilterBranches())
    |               ARRAYLENGTH
    | method-call(void junit.framework.Assert.assertEquals(int, int))
    | |             INVOKESTATIC
com.adteractive.framework.test.ConditionTestFilterTest.assertEquals (II)V
    | method-call(void junit.framework.Assert.assertEquals(int, int))
    |               ALOAD_0     //
com.adteractive.framework.test.ConditionTestFilterTest this   (line 45)
    |               NEW com.adteractive.framework.test.ConditionTestFilterStub
    |               DUP
    |               INVOKESPECIAL
com.adteractive.framework.test.ConditionTestFilterStub.&lt;init&gt; ()V
    |               PUTFIELD
com.adteractive.framework.test.ConditionTestFilterTest.ctf
Lcom/adteractive/framework/ConditionTestFilter;
    |               ALOAD_0     //
com.adteractive.framework.test.ConditionTestFilterTest this   (line 46)
    |               GETFIELD
com.adteractive.framework.test.ConditionTestFilterTest.ctf
Lcom/adteractive/framework/ConditionTestFilter;
    | method-call(com.adteractive.framework.Filter[]
com.adteractive.framework.ConditionTestFilter.getFilterBranches())
    | |             INVOKEVIRTUAL
com.adteractive.framework.ConditionTestFilter.getFilterBranches
()[Lcom/adteractive/framework/Filter;
    | method-call(com.adteractive.framework.Filter[]
com.adteractive.framework.ConditionTestFilter.getFilterBranches())
    | method-call(void junit.framework.Assert.assertNull(java.lang.Object))
    | |             INVOKESTATIC
com.adteractive.framework.test.ConditionTestFilterTest.assertNull
(Ljava/lang/Object;)V
    | method-call(void junit.framework.Assert.assertNull(java.lang.Object))
    |               RETURN   (line 47)
    method-execution(void
com.adteractive.framework.test.ConditionTestFilterTest.testGetFilterBranches())
  end public void testGetFilterBranches()

  public void testSetFilterBranches()   
org.aspectj.weaver.MethodDeclarationLineNumber: 52:1441
:
    method-execution(void
com.adteractive.framework.test.ConditionTestFilterTest.testSetFilterBranches())
    |               ALOAD_0     //
com.adteractive.framework.test.ConditionTestFilterTest this   (line 53)
    | method-call(com.adteractive.framework.Filter[]
com.adteractive.framework.test.ConditionTestFilterTest.makeBranches())
    | |             INVOKESPECIAL
com.adteractive.framework.test.ConditionTestFilterTest.makeBranches
()[Lcom/adteractive/framework/Filter;
    | method-call(com.adteractive.framework.Filter[]
com.adteractive.framework.test.ConditionTestFilterTest.makeBranches())
    |               ASTORE_1
    |               ALOAD_0     //
com.adteractive.framework.test.ConditionTestFilterTest this   (line 54)
    |               GETFIELD
com.adteractive.framework.test.ConditionTestFilterTest.ctf
Lcom/adteractive/framework/ConditionTestFilter;
    |               ALOAD_1     // com.adteractive.framework.Filter[] branches
    | method-call(void
com.adteractive.framework.ConditionTestFilter.setFilterBranches(com.adteractive.framework.Filter[]))
    | |             INVOKEVIRTUAL
com.adteractive.framework.ConditionTestFilter.setFilterBranches
([Lcom/adteractive/framework/Filter;)V
    | method-call(void
com.adteractive.framework.ConditionTestFilter.setFilterBranches(com.adteractive.framework.Filter[]))
    |               ALOAD_0     //
com.adteractive.framework.test.ConditionTestFilterTest this   (line 55)
    |               GETFIELD
com.adteractive.framework.test.ConditionTestFilterTest.ctf
Lcom/adteractive/framework/ConditionTestFilter;
    | method-call(com.adteractive.framework.Filter[]
com.adteractive.framework.ConditionTestFilter.getFilterBranches())
    | |             INVOKEVIRTUAL
com.adteractive.framework.ConditionTestFilter.getFilterBranches
()[Lcom/adteractive/framework/Filter;
    | method-call(com.adteractive.framework.Filter[]
com.adteractive.framework.ConditionTestFilter.getFilterBranches())
    | method-call(void junit.framework.Assert.assertNotNull(java.lang.Object))
    | |             INVOKESTATIC
com.adteractive.framework.test.ConditionTestFilterTest.assertNotNull
(Ljava/lang/Object;)V
    | method-call(void junit.framework.Assert.assertNotNull(java.lang.Object))
    |               ICONST_3   (line 56)
    |               ALOAD_0     //
com.adteractive.framework.test.ConditionTestFilterTest this
    |               GETFIELD
com.adteractive.framework.test.ConditionTestFilterTest.ctf
Lcom/adteractive/framework/ConditionTestFilter;
    | method-call(com.adteractive.framework.Filter[]
com.adteractive.framework.ConditionTestFilter.getFilterBranches())
    | |             INVOKEVIRTUAL
com.adteractive.framework.ConditionTestFilter.getFilterBranches
()[Lcom/adteractive/framework/Filter;
    | method-call(com.adteractive.framework.Filter[]
com.adteractive.framework.ConditionTestFilter.getFilterBranches())
    |               ARRAYLENGTH
    | method-call(void junit.framework.Assert.assertEquals(int, int))
    | |             INVOKESTATIC
com.adteractive.framework.test.ConditionTestFilterTest.assertEquals (II)V
    | method-call(void junit.framework.Assert.assertEquals(int, int))
    |               ALOAD_0     //
com.adteractive.framework.test.ConditionTestFilterTest this   (line 57)
    |               GETFIELD
com.adteractive.framework.test.ConditionTestFilterTest.ctf
Lcom/adteractive/framework/ConditionTestFilter;
    |               ACONST_NULL
    | method-call(void
com.adteractive.framework.ConditionTestFilter.setFilterBranches(com.adteractive.framework.Filter[]))
    | |             INVOKEVIRTUAL
com.adteractive.framework.ConditionTestFilter.setFilterBranches
([Lcom/adteractive/framework/Filter;)V
    | method-call(void
com.adteractive.framework.ConditionTestFilter.setFilterBranches(com.adteractive.framework.Filter[]))
    |               ALOAD_0     //
com.adteractive.framework.test.ConditionTestFilterTest this   (line 58)
    |               GETFIELD
com.adteractive.framework.test.ConditionTestFilterTest.ctf
Lcom/adteractive/framework/ConditionTestFilter;
    | method-call(com.adteractive.framework.Filter[]
com.adteractive.framework.ConditionTestFilter.getFilterBranches())
    | |             INVOKEVIRTUAL
com.adteractive.framework.ConditionTestFilter.getFilterBranches
()[Lcom/adteractive/framework/Filter;
    | method-call(com.adteractive.framework.Filter[]
com.adteractive.framework.ConditionTestFilter.getFilterBranches())
    | method-call(void junit.framework.Assert.assertNull(java.lang.Object))
    | |             INVOKESTATIC
com.adteractive.framework.test.ConditionTestFilterTest.assertNull
(Ljava/lang/Object;)V
    | method-call(void junit.framework.Assert.assertNull(java.lang.Object))
    |               RETURN   (line 59)
    method-execution(void
com.adteractive.framework.test.ConditionTestFilterTest.testSetFilterBranches())
  end public void testSetFilterBranches()

  public void testConditionTestFilter()   
org.aspectj.weaver.MethodDeclarationLineNumber: 64:1847
:
    method-execution(void
com.adteractive.framework.test.ConditionTestFilterTest.testConditionTestFilter())
    |               ALOAD_0     //
com.adteractive.framework.test.ConditionTestFilterTest this   (line 65)
    |               NEW com.adteractive.framework.test.ConditionTestFilterStub
    |               DUP
    |               INVOKESPECIAL
com.adteractive.framework.test.ConditionTestFilterStub.&lt;init&gt; ()V
    |               PUTFIELD
com.adteractive.framework.test.ConditionTestFilterTest.ctf
Lcom/adteractive/framework/ConditionTestFilter;
    |               ALOAD_0     //
com.adteractive.framework.test.ConditionTestFilterTest this   (line 66)
    |               GETFIELD
com.adteractive.framework.test.ConditionTestFilterTest.ctf
Lcom/adteractive/framework/ConditionTestFilter;
    | method-call(com.adteractive.framework.Filter[]
com.adteractive.framework.ConditionTestFilter.getFilterBranches())
    | |             INVOKEVIRTUAL
com.adteractive.framework.ConditionTestFilter.getFilterBranches
()[Lcom/adteractive/framework/Filter;
    | method-call(com.adteractive.framework.Filter[]
com.adteractive.framework.ConditionTestFilter.getFilterBranches())
    | method-call(void junit.framework.Assert.assertNull(java.lang.Object))
    | |             INVOKESTATIC
com.adteractive.framework.test.ConditionTestFilterTest.assertNull
(Ljava/lang/Object;)V
    | method-call(void junit.framework.Assert.assertNull(java.lang.Object))
    |               LDC com.adteractive.framework.test.ConditionTestFilterStub 
 (line 67)
    | method-call(java.lang.String java.lang.Class.getSimpleName())
    | |             INVOKEVIRTUAL java.lang.Class.getSimpleName ()Ljava/lang/String;
    | method-call(java.lang.String java.lang.Class.getSimpleName())
    |               ALOAD_0     //
com.adteractive.framework.test.ConditionTestFilterTest this
    |               GETFIELD
com.adteractive.framework.test.ConditionTestFilterTest.ctf
Lcom/adteractive/framework/ConditionTestFilter;
    | method-call(java.lang.String com.adteractive.framework.FilterHelper.getName())
    | |             INVOKEVIRTUAL com.adteractive.framework.FilterHelper.getName
()Ljava/lang/String;
    | method-call(java.lang.String com.adteractive.framework.FilterHelper.getName())
    | method-call(void junit.framework.Assert.assertEquals(java.lang.String,
java.lang.String))
    | |             INVOKESTATIC
com.adteractive.framework.test.ConditionTestFilterTest.assertEquals
(Ljava/lang/String;Ljava/lang/String;)V
    | method-call(void junit.framework.Assert.assertEquals(java.lang.String,
java.lang.String))
    |               RETURN   (line 68)
    method-execution(void
com.adteractive.framework.test.ConditionTestFilterTest.testConditionTestFilter())
  end public void testConditionTestFilter()

  public void testConditionTestFilterString()   
org.aspectj.weaver.MethodDeclarationLineNumber: 73:2158
:
    method-execution(void
com.adteractive.framework.test.ConditionTestFilterTest.testConditionTestFilterString())
    |               ALOAD_0     //
com.adteractive.framework.test.ConditionTestFilterTest this   (line 74)
    |               NEW com.adteractive.framework.test.ConditionTestFilterStub
    |               DUP
    |               LDC "foo"
    |               INVOKESPECIAL
com.adteractive.framework.test.ConditionTestFilterStub.&lt;init&gt; (Ljava/lang/String;)V
    |               PUTFIELD
com.adteractive.framework.test.ConditionTestFilterTest.ctf
Lcom/adteractive/framework/ConditionTestFilter;
    |               ALOAD_0     //
com.adteractive.framework.test.ConditionTestFilterTest this   (line 75)
    |               GETFIELD
com.adteractive.framework.test.ConditionTestFilterTest.ctf
Lcom/adteractive/framework/ConditionTestFilter;
    | method-call(com.adteractive.framework.Filter[]
com.adteractive.framework.ConditionTestFilter.getFilterBranches())
    | |             INVOKEVIRTUAL
com.adteractive.framework.ConditionTestFilter.getFilterBranches
()[Lcom/adteractive/framework/Filter;
    | method-call(com.adteractive.framework.Filter[]
com.adteractive.framework.ConditionTestFilter.getFilterBranches())
    | method-call(void junit.framework.Assert.assertNull(java.lang.Object))
    | |             INVOKESTATIC
com.adteractive.framework.test.ConditionTestFilterTest.assertNull
(Ljava/lang/Object;)V
    | method-call(void junit.framework.Assert.assertNull(java.lang.Object))
    |               LDC "foo"   (line 76)
    |               ALOAD_0     //
com.adteractive.framework.test.ConditionTestFilterTest this
    |               GETFIELD
com.adteractive.framework.test.ConditionTestFilterTest.ctf
Lcom/adteractive/framework/ConditionTestFilter;
    | method-call(java.lang.String com.adteractive.framework.FilterHelper.getName())
    | |             INVOKEVIRTUAL com.adteractive.framework.FilterHelper.getName
()Ljava/lang/String;
    | method-call(java.lang.String com.adteractive.framework.FilterHelper.getName())
    | method-call(void junit.framework.Assert.assertEquals(java.lang.String,
java.lang.String))
    | |             INVOKESTATIC
com.adteractive.framework.test.ConditionTestFilterTest.assertEquals
(Ljava/lang/String;Ljava/lang/String;)V
    | method-call(void junit.framework.Assert.assertEquals(java.lang.String,
java.lang.String))
    |               RETURN   (line 77)
    method-execution(void
com.adteractive.framework.test.ConditionTestFilterTest.testConditionTestFilterString())
  end public void testConditionTestFilterString()

  public void testConditionTestFilterStringFilterOfIOArray()   
org.aspectj.weaver.MethodDeclarationLineNumber: 82:2456
:
    method-execution(void
com.adteractive.framework.test.ConditionTestFilterTest.testConditionTestFilterStringFilterOfIOArray())
    |               ALOAD_0     //
com.adteractive.framework.test.ConditionTestFilterTest this   (line 83)
    |               NEW com.adteractive.framework.test.ConditionTestFilterStub
    |               DUP
    |               LDC "foo"
    |               ALOAD_0     //
com.adteractive.framework.test.ConditionTestFilterTest this
    | method-call(com.adteractive.framework.Filter[]
com.adteractive.framework.test.ConditionTestFilterTest.makeBranches())
    | |             INVOKESPECIAL
com.adteractive.framework.test.ConditionTestFilterTest.makeBranches
()[Lcom/adteractive/framework/Filter;
    | method-call(com.adteractive.framework.Filter[]
com.adteractive.framework.test.ConditionTestFilterTest.makeBranches())
    |               INVOKESPECIAL
com.adteractive.framework.test.ConditionTestFilterStub.&lt;init&gt;
(Ljava/lang/String;[Lcom/adteractive/framework/Filter;)V
    |               PUTFIELD
com.adteractive.framework.test.ConditionTestFilterTest.ctf
Lcom/adteractive/framework/ConditionTestFilter;
    |               ALOAD_0     //
com.adteractive.framework.test.ConditionTestFilterTest this   (line 84)
    |               GETFIELD
com.adteractive.framework.test.ConditionTestFilterTest.ctf
Lcom/adteractive/framework/ConditionTestFilter;
    | method-call(com.adteractive.framework.Filter[]
com.adteractive.framework.ConditionTestFilter.getFilterBranches())
    | |             INVOKEVIRTUAL
com.adteractive.framework.ConditionTestFilter.getFilterBranches
()[Lcom/adteractive/framework/Filter;
    | method-call(com.adteractive.framework.Filter[]
com.adteractive.framework.ConditionTestFilter.getFilterBranches())
    | method-call(void junit.framework.Assert.assertNotNull(java.lang.Object))
    | |             INVOKESTATIC
com.adteractive.framework.test.ConditionTestFilterTest.assertNotNull
(Ljava/lang/Object;)V
    | method-call(void junit.framework.Assert.assertNotNull(java.lang.Object))
    |               ICONST_3   (line 85)
    |               ALOAD_0     //
com.adteractive.framework.test.ConditionTestFilterTest this
    |               GETFIELD
com.adteractive.framework.test.ConditionTestFilterTest.ctf
Lcom/adteractive/framework/ConditionTestFilter;
    | method-call(com.adteractive.framework.Filter[]
com.adteractive.framework.ConditionTestFilter.getFilterBranches())
    | |             INVOKEVIRTUAL
com.adteractive.framework.ConditionTestFilter.getFilterBranches
()[Lcom/adteractive/framework/Filter;
    | method-call(com.adteractive.framework.Filter[]
com.adteractive.framework.ConditionTestFilter.getFilterBranches())
    |               ARRAYLENGTH
    | method-call(void junit.framework.Assert.assertEquals(int, int))
    | |             INVOKESTATIC
com.adteractive.framework.test.ConditionTestFilterTest.assertEquals (II)V
    | method-call(void junit.framework.Assert.assertEquals(int, int))
    |               LDC "foo"   (line 86)
    |               ALOAD_0     //
com.adteractive.framework.test.ConditionTestFilterTest this
    |               GETFIELD
com.adteractive.framework.test.ConditionTestFilterTest.ctf
Lcom/adteractive/framework/ConditionTestFilter;
    | method-call(java.lang.String com.adteractive.framework.FilterHelper.getName())
    | |             INVOKEVIRTUAL com.adteractive.framework.FilterHelper.getName
()Ljava/lang/String;
    | method-call(java.lang.String com.adteractive.framework.FilterHelper.getName())
    | method-call(void junit.framework.Assert.assertEquals(java.lang.String,
java.lang.String))
    | |             INVOKESTATIC
com.adteractive.framework.test.ConditionTestFilterTest.assertEquals
(Ljava/lang/String;Ljava/lang/String;)V
    | method-call(void junit.framework.Assert.assertEquals(java.lang.String,
java.lang.String))
    |               RETURN   (line 87)
    method-execution(void
com.adteractive.framework.test.ConditionTestFilterTest.testConditionTestFilterStringFilterOfIOArray())
  end public void testConditionTestFilterStringFilterOfIOArray()

  private com.adteractive.framework.Filter[] makeBranches()   
org.aspectj.weaver.MethodDeclarationLineNumber: 89:2749
:
    method-execution(com.adteractive.framework.Filter[]
com.adteractive.framework.test.ConditionTestFilterTest.makeBranches())
    |               ICONST_3   (line 90)
    |               ANEWARRAY com.adteractive.framework.test.FilterHelperStub
    |               ASTORE_1
    |               ALOAD_1     // com.adteractive.framework.Filter[] branches 
 (line 91)
    |               ICONST_0
    |               NEW com.adteractive.framework.test.FilterHelperStub
    |               DUP
    |               LDC "bf1"
    |               INVOKESPECIAL
com.adteractive.framework.test.FilterHelperStub.&lt;init&gt; (Ljava/lang/String;)V
    |               AASTORE
    |               ALOAD_1     // com.adteractive.framework.Filter[] branches 
 (line 92)
    |               ICONST_1
    |               NEW com.adteractive.framework.test.FilterHelperStub
    |               DUP
    |               LDC "bf12"
    |               INVOKESPECIAL
com.adteractive.framework.test.FilterHelperStub.&lt;init&gt; (Ljava/lang/String;)V
    |               AASTORE
    |               ALOAD_1     // com.adteractive.framework.Filter[] branches 
 (line 93)
    |               ICONST_2
    |               NEW com.adteractive.framework.test.FilterHelperStub
    |               DUP
    |               LDC "bf"
    |               INVOKESPECIAL
com.adteractive.framework.test.FilterHelperStub.&lt;init&gt; (Ljava/lang/String;)V
    |               AASTORE
    |               ALOAD_1     // com.adteractive.framework.Filter[] branches 
 (line 94)
    |               ARETURN
    method-execution(com.adteractive.framework.Filter[]
com.adteractive.framework.test.ConditionTestFilterTest.makeBranches())
  end private com.adteractive.framework.Filter[] makeBranches()

end public class com.adteractive.framework.test.ConditionTestFilterTest

when implementing on shadow method-call(com.adteractive.framework.Filter[]
com.adteractive.framework.test.ConditionTestFilterTest.makeBranches())
when weaving type com.adteractive.framework.test.ConditionTestFilterTest
when weaving classes 
when weaving 
when incrementally building
BuildConfig[C:\cygwin\home\dwam</description><comments/></buginformation><fixedCommits><commit id="d7d5947ddd5a3b4f5c3bcaed6114b5445f0d6a01" author="default" date="2005-11-11 15:13:33"><file name="weaver/src/org/aspectj/weaver/bcel/LazyClassGen.java"><method name="fixupGenericSignatureAttribute" returnType="void" parameters=""/></file></commit></fixedCommits></bug><bug id="220" opendate="2005-11-06 07:26:00" fixdate="2005-11-14 10:38:47"><buginformation><summary>StackOverflowError on circular pointcut iff aspect parameterized</summary><description>The code below overflows when concretizing a circular pointcut from a
parameterized aspect.  Not true when the aspect is not parameterized.

---------------------------------------------
public class SelfPC {

	public static void main(String[] args) {
		new C().foo();
	}
	static class C { 
		pointcut doit() : C.doit(); // CE expected
		void foo() {} 
	}
	
	// ------------ pertarget&lt;T&gt;
	static abstract aspect PT_PARM&lt;T&gt; pertarget(pc()) {
		abstract protected pointcut pc();
		before() : pc() {}
	}
	static aspect CPT_PARM extends PT_PARM&lt;C&gt; {
		protected pointcut pc() : C.doit();
	}
	
//	// ------------ issingleton&lt;T&gt;
//	static abstract aspect IS_PARM&lt;T&gt; {
//		abstract protected pointcut pc();
//		before() : pc() {}
//	}
//	static aspect CIS_PARM extends IS_PARM&lt;C&gt; {
//		protected pointcut pc() : C.doit();
//	}
//	// ------------ pertarget
//	static abstract aspect PT pertarget(pc()) {
//		abstract protected pointcut pc();
//		before() : pc() {}
//	}
//	static aspect CPT extends PT{
//		protected pointcut pc() : C.doit();
//	}
//	// ------------ issingleton
//	static abstract aspect SIS {
//		abstract protected pointcut pc();
//		before() : pc() {}
//	}
//	static aspect CSIS extends SIS {
//		protected pointcut pc() : C.doit();
//	}

}
---------------------------------------------
java.lang.StackOverflowError
at java.lang.StringBuffer.append(StringBuffer.java:225)
at org.aspectj.weaver.UnresolvedType.nameToSignature(UnresolvedType.java:734)
at org.aspectj.weaver.UnresolvedType.forName(UnresolvedType.java:308)
at
org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.fromBinding(EclipseFactory.java:302)
at
org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.fromEclipse(EclipseFactory.java:129)
at
org.aspectj.ajdt.internal.compiler.lookup.EclipseSourceType.getSuperclass(EclipseSourceType.java:119)
at org.aspectj.weaver.ReferenceType.getSuperclass(ReferenceType.java:481)
at org.aspectj.weaver.ResolvedType.getDirectSupertypes(ResolvedType.java:65)
at org.aspectj.weaver.ResolvedType$6.get(ResolvedType.java:447)
at org.aspectj.weaver.Iterators$4.next(Iterators.java:148)
at org.aspectj.weaver.Iterators$3$1.hasNext(Iterators.java:117)
at org.aspectj.weaver.Iterators$3.hasNext(Iterators.java:128)
at org.aspectj.weaver.ResolvedType.findPointcut(ResolvedType.java:466)
at
org.aspectj.weaver.patterns.ReferencePointcut.concretize1(ReferencePointcut.java:269)
at org.aspectj.weaver.patterns.Pointcut.concretize(Pointcut.java:229)
at
org.aspectj.weaver.patterns.ReferencePointcut.concretize1(ReferencePointcut.java:326)
at org.aspectj.weaver.patterns.Pointcut.concretize(Pointcut.java:229)
...
---------------------------------------------</description><comments/></buginformation><fixedCommits><commit id="4b8bed7cff98b2aca5586e604a138c3674453c90" author="default" date="2005-11-14 10:38:47"><file name="weaver/src/org/aspectj/weaver/patterns/ReferencePointcut.java"><method name="concretize1" returnType="Pointcut" parameters="ResolvedType"/></file></commit></fixedCommits></bug><bug id="221" opendate="2005-11-14 14:16:00" fixdate="2005-11-15 09:15:14"><buginformation><summary>Unexpected error: can't determine implemented interfaces of missing type</summary><description>I have reusable library code that imports a type (a JAX-RPC Call in this case) 
for use in two ways:
1) matching in a method signature. 
2) casting and use in an advice body

It used to work properly when I used it in a load-time weaving configuration 
without the (Call) type being available on the classpath (I think it broke in 
the last week).

However, I am now getting an abort error "can't determine implemented 
interfaces of missing type" when weaving this aspect into another type when the 
imported (Call) type isn鈥檛 visible in a classloader. I tried changing the code 
to remove the import and to use a fully qualified name in the pointcut (and a 
reflective invocation in the advice body). However, this still fails in the 
same way.

These pointcuts are presumably causing the error:

public abstract aspect AbstractRequestMonitor {
    protected pointcut scope() : within(*);//if(true);
    protected pointcut monitorEnabled() : isMonitorEnabled() &amp;&amp; scope();
    protected abstract pointcut isMonitorEnabled();
...
}

public abstract aspect AbstractResourceMonitor extends AbstractRequestMonitor {
...
}

public aspect RemoteCallMonitor extends AbstractResourceMonitor {
    protected pointcut isMonitorEnabled() : if(aspectOf().isEnabled());

    public pointcut jaxRpcClientCall(Object wsCallObj) : 
        call(public * javax.xml.rpc.Call.invoke*(..)) &amp;&amp; target(wsCallObj);

    Object around(final Object wsCallObj) : jaxRpcClientCall(wsCallObj) &amp;&amp; 
monitorEnabled() {
...

Here is the output:

org.aspectj.bridge.AbortException: can't determine implemented interfaces of 
missing type javax.xml.rpc.Call
when matching pointcut ((((within(*) &amp;&amp; call(public * javax.xml.rpc.Call.invoke*
(..))) &amp;&amp; target(BindingTypePattern(java.lang.Object, 0))) &amp;&amp; if(boolean 
glassbox.inspector.monitor.resource.RemoteCallMonitor.ajc$if_12())) &amp;&amp; 
persingleton(glassbox.inspector.monitor.resource.RemoteCallMonitor))
when matching shadow method-call(java.util.Locale java.util.Locale.getDefault())
when weaving type org.apache.struts.action.ActionServlet
when weaving classes 
when weaving

	at 
org.aspectj.weaver.tools.WeavingAdaptor$WeavingAdaptorMessageHandler.handleMessa
ge(WeavingAdaptor.java:364)
	at org.aspectj.bridge.MessageUtil.error(MessageUtil.java:81)
	at 
org.aspectj.weaver.MissingResolvedTypeWithKnownSignature.raiseCantFindType
(MissingResolvedTypeWithKnownSignature.java:195)
	at 
org.aspectj.weaver.MissingResolvedTypeWithKnownSignature.getDeclaredInterfaces
(MissingResolvedTypeWithKnownSignature.java:77)
	at org.aspectj.weaver.ResolvedType.getDirectSupertypes
(ResolvedType.java:64)
	at org.aspectj.weaver.ReferenceType.isAssignableFrom
(ReferenceType.java:312)
	at org.aspectj.weaver.ReferenceType.isAssignableFrom
(ReferenceType.java:236)
	at org.aspectj.weaver.patterns.KindedPointcut.warnOnConfusingSig
(KindedPointcut.java:151)
	at org.aspectj.weaver.patterns.KindedPointcut.matchInternal
(KindedPointcut.java:108)
	at org.aspectj.weaver.patterns.Pointcut.match(Pointcut.java:145)
	at org.aspectj.weaver.patterns.AndPointcut.matchInternal
(AndPointcut.java:57)
	at org.aspectj.weaver.patterns.Pointcut.match(Pointcut.java:145)
	at org.aspectj.weaver.patterns.AndPointcut.matchInternal
(AndPointcut.java:55)
	at org.aspectj.weaver.patterns.Pointcut.match(Pointcut.java:145)
	at org.aspectj.weaver.patterns.AndPointcut.matchInternal
(AndPointcut.java:55)
	at org.aspectj.weaver.patterns.Pointcut.match(Pointcut.java:145)
	at org.aspectj.weaver.patterns.AndPointcut.matchInternal
(AndPointcut.java:55)
	at org.aspectj.weaver.patterns.Pointcut.match(Pointcut.java:145)
	at org.aspectj.weaver.ShadowMunger.match(ShadowMunger.java:64)
	at org.aspectj.weaver.Advice.match(Advice.java:109)
	at org.aspectj.weaver.bcel.BcelAdvice.match(BcelAdvice.java:98)
	at org.aspectj.weaver.bcel.BcelClassWeaver.match
(BcelClassWeaver.java:2098)
	at org.aspectj.weaver.bcel.BcelClassWeaver.matchInvokeInstruction
(BcelClassWeaver.java:2085)
	at org.aspectj.weaver.bcel.BcelClassWeaver.match
(BcelClassWeaver.java:1867)
	at org.aspectj.weaver.bcel.BcelClassWeaver.matchInit
(BcelClassWeaver.java:1731)
	at org.aspectj.weaver.bcel.BcelClassWeaver.match
(BcelClassWeaver.java:1660)
	at org.aspectj.weaver.bcel.BcelClassWeaver.weave
(BcelClassWeaver.java:445)
	at org.aspectj.weaver.bcel.BcelClassWeaver.weave
(BcelClassWeaver.java:101)
	at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1531)
	at org.aspectj.weaver.bcel.BcelWeaver.weaveWithoutDump
(BcelWeaver.java:1485)
	at org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify
(BcelWeaver.java:1266)
	at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1088)
	at org.aspectj.weaver.tools.WeavingAdaptor.getWovenBytes
(WeavingAdaptor.java:266)
	at org.aspectj.weaver.tools.WeavingAdaptor.weaveClass
(WeavingAdaptor.java:198)
	at org.aspectj.weaver.loadtime.Aj.preProcess(Aj.java:67)
	at org.aspectj.weaver.loadtime.ClassPreProcessorAgentAdapter.transform
(ClassPreProcessorAgentAdapter.java:52)
鈥</description><comments/></buginformation><fixedCommits><commit id="676aa089feb829d744fa054b52af39f83e22952f" author="default" date="2005-11-15 09:15:14"><file name="weaver/src/org/aspectj/weaver/patterns/KindedPointcut.java"><method name="warnOnConfusingSig" returnType="void" parameters="Shadow"/></file></commit></fixedCommits></bug><bug id="222" opendate="2005-11-14 11:17:00" fixdate="2005-11-15 17:04:00"><buginformation><summary>XML Linkage Error with LTW</summary><description>I am trying out a recent dev build of AspectJ and am now seeing a new linkage 
error when I load a Web app that contains an XML deployment descriptor. I'm 
trying to narrow down the date when this error first appeared. If I build and 
run with the Sept. 23 dev build all works properly. If I build and run with the 
Nov. 14 dev build it fails like this ...

Here's the output:

SEVERE: Error deploying configuration descriptor jpetstore.xml
java.lang.LinkageError: org/apache/xerces/jaxp/SAXParserFactoryImpl : already 
defined in loader
        at java.lang.ClassLoader.defineClass(Ljava.lang.String;
[BIILjava.security.ProtectionDomain;)Ljava.lang.Class;(Unknown Source
)
        at java.security.SecureClassLoader.defineClass
(SecureClassLoader.java:124)
        at org.apache.catalina.loader.WebappClassLoader.findClassInternal
(WebappClassLoader.java:1629)
        at org.apache.catalina.loader.WebappClassLoader.findClass
(WebappClassLoader.java:850)
        at org.apache.catalina.loader.WebappClassLoader.loadClass
(WebappClassLoader.java:1299)
        at org.apache.catalina.loader.WebappClassLoader.loadClass
(WebappClassLoader.java:1181)
        at javax.xml.parsers.FactoryFinder.newInstance(FactoryFinder.java:88)
        at javax.xml.parsers.FactoryFinder.findJarServiceProvider
(FactoryFinder.java:278)
        at javax.xml.parsers.FactoryFinder.find(FactoryFinder.java:185)
        at javax.xml.parsers.SAXParserFactory.newInstance
(SAXParserFactory.java:107)
        at org.apache.tomcat.util.digester.Digester.getFactory
(Digester.java:486)
        at org.apache.tomcat.util.digester.Digester.getParser(Digester.java:691)
        at org.apache.tomcat.util.digester.Digester.getXMLReader
(Digester.java:899)
        at org.apache.tomcat.util.digester.Digester.parse(Digester.java:1561)
        at org.apache.catalina.startup.TldConfig.tldScanStream
(TldConfig.java:513)
        at org.apache.catalina.startup.TldConfig.tldScanTld(TldConfig.java:545)
        at org.apache.catalina.startup.TldConfig.execute(TldConfig.java:300)
        at org.apache.catalina.core.StandardContext.processTlds
(StandardContext.java:4193)
        at org.apache.catalina.core.StandardContext.start
(StandardContext.java:4049)
        at org.apache.catalina.core.ContainerBase.addChildInternal
(ContainerBase.java:759)
        at org.apache.catalina.core.ContainerBase.addChild
(ContainerBase.java:739)
        at org.apache.catalina.core.StandardHost.addChild(StandardHost.java:524)
        at org.apache.catalina.startup.HostConfig.deployDescriptor
(HostConfig.java:589)
        at org.apache.catalina.startup.HostConfig.deployDescriptors
(HostConfig.java:536)
        at org.apache.catalina.startup.HostConfig.deployApps
(HostConfig.java:471)
        at org.apache.catalina.startup.HostConfig.start(HostConfig.java:1102)
        at org.apache.catalina.startup.HostConfig.lifecycleEvent
(HostConfig.java:311)
        at org.apache.catalina.util.LifecycleSupport.fireLifecycleEvent
(LifecycleSupport.java:119)
        at org.apache.catalina.core.ContainerBase.start(ContainerBase.java:1020)
        at org.apache.catalina.core.StandardHost.start(StandardHost.java:718)
        at org.apache.catalina.core.ContainerBase.start(ContainerBase.java:1012)
error can't determine implemented interfaces of missing type javax.xml.rpc.Call
when matching pointcut ((((within(*) &amp;&amp; call(public * javax.xml.rpc.Call.invoke*
(..))) &amp;&amp; target(BindingTypePattern(java.lang.Object
, 0))) &amp;&amp; if(boolean 
glassbox.inspector.monitor.resource.RemoteCallMonitor.ajc$if_12())) &amp;&amp; 
persingleton(glassbox.inspector.monitor.
resource.RemoteCallMonitor))
when matching shadow method-call(boolean 
org.apache.crimson.parser.ContentModel.empty())
when weaving type org.apache.crimson.parser.ContentModel
when weaving classes
when weaving

abort trouble in:
final class org.apache.crimson.parser.ContentModel extends java.lang.Object:
  public char type
  public Object content
  public org.apache.crimson.parser.ContentModel next
  private org.apache.crimson.parser.SimpleHashtable cache
  public void &lt;init&gt;(String):
                    ALOAD_0     // org.apache.crimson.parser.ContentModel 
this   (line 116)
                    INVOKESPECIAL java.lang.Object.&lt;init&gt; ()V
    constructor-execution(void org.apache.crimson.parser.ContentModel.&lt;init&gt;
(java.lang.String))
    |               ALOAD_0     // org.apache.crimson.parser.ContentModel 
this   (line 110)
    |               NEW org.apache.crimson.parser.SimpleHashtable
    |               DUP
    | constructor-call(void org.apache.crimson.parser.SimpleHashtable.&lt;init&gt;())
    | |             INVOKESPECIAL 
org.apache.crimson.parser.SimpleHashtable.&lt;init&gt; ()V
    | constructor-call(void org.apache.crimson.parser.SimpleHashtable.&lt;init&gt;())
    |               PUTFIELD org.apache.crimson.parser.ContentModel.cache 
Lorg/apache/crimson/parser/SimpleHashtable;
    |               ALOAD_0     // org.apache.crimson.parser.ContentModel 
this   (line 117)
    |               ICONST_0
    |               PUTFIELD org.apache.crimson.parser.ContentModel.type C
    |               ALOAD_0     // org.apache.crimson.parser.ContentModel 
this   (line 118)
    |               ALOAD_1     // java.lang.String element
    |               PUTFIELD org.apache.crimson.parser.ContentModel.content 
Ljava/lang/Object;
    |               RETURN   (line 119)
    constructor-execution(void org.apache.crimson.parser.ContentModel.&lt;init&gt;
(java.lang.String))
  end public void &lt;init&gt;(String)

  public void &lt;init&gt;(char, org.apache.crimson.parser.ContentModel):
                    ALOAD_0     // org.apache.crimson.parser.ContentModel 
this   (line 125)
                    INVOKESPECIAL java.lang.Object.&lt;init&gt; ()V
    constructor-execution(void org.apache.crimson.parser.ContentModel.&lt;init&gt;
(char, org.apache.crimson.parser.ContentModel))
    |               ALOAD_0     // org.apache.crimson.parser.ContentModel 
this   (line 110)
    |               NEW org.apache.crimson.parser.SimpleHashtable
    |               DUP
    | constructor-call(void org.apache.crimson.parser.SimpleHashtable.&lt;init&gt;())
    | |             INVOKESPECIAL 
org.apache.crimson.parser.SimpleHashtable.&lt;init&gt; ()V
    | constructor-call(void org.apache.crimson.parser.SimpleHashtable.&lt;init&gt;())
    |               PUTFIELD org.apache.crimson.parser.ContentModel.cache 
Lorg/apache/crimson/parser/SimpleHashtable;
    |               ALOAD_0     // org.apache.crimson.parser.ContentModel 
this   (line 126)
    |               ILOAD_1     // char type
    |               PUTFIELD org.apache.crimson.parser.ContentModel.type C
    |               ALOAD_0     // org.apache.crimson.parser.ContentModel 
this   (line 127)
    |               ALOAD_2     // org.apache.crimson.parser.ContentModel 
content
    |               PUTFIELD org.apache.crimson.parser.ContentModel.content 
Ljava/lang/Object;
    |               RETURN   (line 128)
    constructor-execution(void org.apache.crimson.parser.ContentModel.&lt;init&gt;
(char, org.apache.crimson.parser.ContentModel))
  end public void &lt;init&gt;(char, org.apache.crimson.parser.ContentModel)

  public boolean empty():
    method-execution(boolean org.apache.crimson.parser.ContentModel.empty())
    |               ALOAD_0     // org.apache.crimson.parser.ContentModel 
this   (line 137)
    |               GETFIELD org.apache.crimson.parser.ContentModel.type C
    |               LOOKUPSWITCH
    |                 0:        L1
    |                 42:       L0
    |                 43:       L1
    |                 44:       L7
    |                 63:       L0
    |                 124:      L2
    |                 default:  L13
    |           L0: ICONST_1   (line 140)
    |               IRETURN
    |           L1: ICONST_0   (line 144)
    |               IRETURN
    |           L2: ALOAD_0     // org.apache.crimson.parser.ContentModel 
this   (line 147)
    |               GETFIELD org.apache.crimson.parser.ContentModel.content 
Ljava/lang/Object;
    |               INSTANCEOF org.apache.crimson.parser.ContentModel
    |               IFEQ L3
    |               ALOAD_0     // org.apache.crimson.parser.ContentModel this
    |               GETFIELD org.apache.crimson.parser.ContentModel.content 
Ljava/lang/Object;
    |               CHECKCAST org.apache.crimson.parser.ContentModel
    | method-call(boolean org.apache.crimson.parser.ContentModel.empty())
    | |             INVOKEVIRTUAL org.apache.crimson.parser.ContentModel.empty 
()Z
    | method-call(boolean org.apache.crimson.parser.ContentModel.empty())
    |               IFEQ L3
    |               ICONST_1   (line 149)
    |               IRETURN
    |           L3: ALOAD_0     // org.apache.crimson.parser.ContentModel 
this   (line 151)
    |               GETFIELD org.apache.crimson.parser.ContentModel.next 
Lorg/apache/crimson/parser/ContentModel;
    |               ASTORE_1
    |               GOTO L6
    |           L4: ALOAD_1     // org.apache.crimson.parser.ContentModel m   
(line 154)
    |               INVOKEVIRTUAL org.apache.crimson.parser.ContentModel.empty 
()Z
    |               IFEQ L5
    |               ICONST_1   (line 155)
    |               IRETURN
    |           L5: ALOAD_1     // org.apache.crimson.parser.ContentModel m   
(line 153)
    |               GETFIELD org.apache.crimson.parser.ContentModel.next 
Lorg/apache/crimson/parser/ContentModel;
    |               ASTORE_1     // org.apache.crimson.parser.ContentModel m
    |           L6: ALOAD_1     // org.apache.crimson.parser.ContentModel m   
(line 152)
    |               IFNONNULL L4
    |               ICONST_0   (line 157)
    |               IRETURN
    |           L7: ALOAD_0     // org.apache.crimson.parser.ContentModel 
this   (line 160)
    |               GETFIELD org.apache.crimson.parser.ContentModel.content 
Ljava/lang/Object;
    |               INSTANCEOF org.apache.crimson.parser.ContentModel
    |               IFEQ L8
    |               ALOAD_0     // org.apache.crimson.parser.ContentModel 
this   (line 161)
    |               GETFIELD org.apache.crimson.parser.ContentModel.content 
Ljava/lang/Object;
    |               CHECKCAST org.apache.crimson.parser.ContentModel
    |               INVOKEVIRTUAL org.apache.crimson.parser.ContentModel.empty 
()Z
    |               IFNE L9
    |               ICONST_0   (line 162)
    |               IRETURN
    |           L8: ICONST_0   (line 165)
    |               IRETURN
    |           L9: ALOAD_0     // org.apache.crimson.parser.ContentModel 
this   (line 167)
    |               GETFIELD org.apache.crimson.parser.ContentModel.next 
Lorg/apache/crimson/parser/ContentModel;
    |               ASTORE_2
    |               GOTO L12
    |          L10: ALOAD_2     // org.apache.crimson.parser.ContentModel m   
(line 170)
    |               INVOKEVIRTUAL org.apache.crimson.parser.ContentModel.empty 
()Z
    |               IFNE L11
    |               ICONST_0   (line 171)
    |               IRETURN
    |          L11: ALOAD_2     // org.apache.crimson.parser.ContentModel m   
(line 169)
    |               GETFIELD org.apache.crimson.parser.ContentModel.next 
Lorg/apache/crimson/parser/ContentModel;
    |               ASTORE_2     // org.apache.crimson.parser.ContentModel m
    |          L12: ALOAD_2     // org.apache.crimson.parser.ContentModel m   
(line 168)
    |               IFNONNULL L10
    |               ICONST_1   (line 173)
    |               IRETURN
    |          L13: NEW java.lang.InternalError   (line 176)
    |               DUP
    |               INVOKESPECIAL java.lang.InternalError.&lt;init&gt; ()V
    |               ATHROW
    method-execution(boolean org.apache.crimson.parser.ContentModel.empty())
  end public boolean empty()

  public boolean first(String):
                    ALOAD_0     // org.apache.crimson.parser.ContentModel 
this   (line 186)
                    GETFIELD org.apache.crimson.parser.ContentModel.cache 
Lorg/apache/crimson/parser/SimpleHashtable;
                    ALOAD_1     // java.lang.String token
                    INVOKEVIRTUAL org.apache.crimson.parser.SimpleHashtable.get 
(Ljava/lang/String;)Ljava/lang/Object;
                    CHECKCAST java.lang.Boolean
                    ASTORE_2
                    ALOAD_2     // java.lang.Boolean b   (line 189)
                    IFNULL L0
                    ALOAD_2     // java.lang.Boolean b   (line 190)
                    INVOKEVIRTUAL java.lang.Boolean.booleanValue ()Z
                    IRETURN
                L0: ALOAD_0     // org.apache.crimson.parser.ContentModel 
this   (line 193)
                    GETFIELD org.apache.crimson.parser.ContentModel.type C
                    LOOKUPSWITCH
                      0:        L1
                      42:       L1
                      43:       L1
                      44:       L5
                      63:       L1
                      124:      L12
                      default:  L16
                L1: ALOAD_0     // org.apache.crimson.parser.ContentModel 
this   (line 198)
                    GETFIELD org.apache.crimson.parser.ContentModel.content 
Ljava/lang/Object;
                    INSTANCEOF java.lang.String
                    IFEQ L4
                    ALOAD_0     // org.apache.crimson.parser.ContentModel 
this   (line 199)
                    GETFIELD org.apache.crimson.parser.ContentModel.content 
Ljava/lang/Object;
                    ALOAD_1     // java.lang.String token
                    IF_ACMPNE L2
                    ICONST_1
                    GOTO L3
                L2: ICONST_0
                L3: ISTORE_3
                    GOTO L17
                L4: ALOAD_0     // org.apache.crimson.parser.ContentModel 
this   (line 201)
                    GETFIELD org.apache.crimson.parser.ContentModel.content 
Ljava/lang/Object;
                    CHECKCAST org.apache.crimson.parser.ContentModel
                    ALOAD_1     // java.lang.String token
                    INVOKEVIRTUAL org.apache.crimson.parser.ContentModel.first 
(Ljava/lang/String;)Z
                    ISTORE_3     // boolean retval
                    GOTO L17   (line 202)
                L5: ALOAD_0     // org.apache.crimson.parser.ContentModel 
this   (line 205)
                    GETFIELD org.apache.crimson.parser.ContentModel.content 
Ljava/lang/Object;
                    INSTANCEOF java.lang.String
                    IFEQ L8
                    ALOAD_0     // org.apache.crimson.parser.ContentModel 
this   (line 206)
                    GETFIELD org.apache.crimson.parser.ContentModel.content 
Ljava/lang/Object;
                    ALOAD_1     // java.lang.String token
                    IF_ACMPNE L6
                    ICONST_1
                    GOTO L7
                L6: ICONST_0
                L7: ISTORE_3     // boolean retval
                    GOTO L17
                L8: ALOAD_0     // org.apache.crimson.parser.ContentModel 
this   (line 207)
                    GETFIELD org.apache.crimson.parser.ContentModel.content 
Ljava/lang/Object;
                    CHECKCAST org.apache.crimson.parser.ContentModel
                    ALOAD_1     // java.lang.String token
                    INVOKEVIRTUAL org.apache.crimson.parser.ContentModel.first 
(Ljava/lang/String;)Z
                    IFEQ L9
                    ICONST_1   (line 208)
                    ISTORE_3     // boolean retval
                    GOTO L17
                L9: ALOAD_0     // org.apache.crimson.parser.ContentModel 
this   (line 209)
                    GETFIELD org.apache.crimson.parser.ContentModel.content 
Ljava/lang/Object;
                    CHECKCAST org.apache.crimson.parser.ContentModel
                    INVOKEVIRTUAL org.apache.crimson.parser.ContentModel.empty 
()Z
                    IFNE L10
                    ICONST_0   (line 210)
                    ISTORE_3     // boolean retval
                    GOTO L17
               L10: ALOAD_0     // org.apache.crimson.parser.ContentModel 
this   (line 211)
                    GETFIELD org.apache.crimson.parser.ContentModel.next 
Lorg/apache/crimson/parser/ContentModel;
                    IFNULL L11
                    ALOAD_0     // org.apache.crimson.parser.ContentModel 
this   (line 212)
                    GETFIELD org.apache.crimson.parser.ContentModel.next 
Lorg/apache/crimson/parser/ContentModel;
                    ALOAD_1     // java.lang.String token
                    INVOKEVIRTUAL org.apache.crimson.parser.ContentModel.first 
(Ljava/lang/String;)Z
                    ISTORE_3     // boolean retval
                    GOTO L17
               L11: ICONST_0   (line 214)
                    ISTORE_3     // boolean retval
                    GOTO L17   (line 215)
               L12: ALOAD_0     // org.apache.crimson.parser.ContentModel 
this   (line 218)
                    GETFIELD org.apache.crimson.parser.ContentModel.content 
Ljava/lang/Object;
                    INSTANCEOF java.lang.String
                    IFEQ L13
                    ALOAD_0     // org.apache.crimson.parser.ContentModel this
                    GETFIELD org.apache.crimson.parser.ContentModel.content 
Ljava/lang/Object;
                    ALOAD_1     // java.lang.String token
                    IF_ACMPNE L13
                    ICONST_1   (line 219)
                    ISTORE_3     // boolean retval
                    GOTO L17
               L13: ALOAD_0     // org.apache.crimson.parser.ContentModel 
this   (line 220)
                    GETFIELD org.apache.crimson.parser.ContentModel.content 
Ljava/lang/Object;
                    CHECKCAST org.apache.crimson.parser.ContentModel
                    ALOAD_1     // java.lang.String token
                    INVOKEVIRTUAL org.apache.crimson.parser.ContentModel.first 
(Ljava/lang/String;)Z
                    IFEQ L14
                    ICONST_1   (line 221)
                    ISTORE_3     // boolean retval
                    GOTO L17
               L14: ALOAD_0     // org.apache.crimson.parser.ContentModel 
this   (line 222)
                    GETFIELD org.apache.crimson.parser.ContentModel.next 
Lorg/apache/crimson/parser/ContentModel;
                    IFNULL L15
                    ALOAD_0     // org.apache.crimson.parser.ContentModel 
this   (line 223)
                    GETFIELD org.apache.crimson.parser.ContentModel.next 
Lorg/apache/crimson/parser/ContentModel;
                    ALOAD_1     // java.lang.String token
                    INVOKEVIRTUAL org.apache.crimson.parser.ContentModel.first 
(Ljava/lang/String;)Z
                    ISTORE_3     // boolean retval
                    GOTO L17
               L15: ICONST_0   (line 225)
                    ISTORE_3     // boolean retval
                    GOTO L17   (line 226)
               L16: NEW java.lang.InternalError   (line 229)
                    DUP
                    INVOKESPECIAL java.lang.InternalError.&lt;init&gt; ()V
                    ATHROW
               L17: ILOAD_3     // boolean retval   (line 233)
                    IFEQ L18
                    ALOAD_0     // org.apache.crimson.parser.ContentModel 
this   (line 234)
                    GETFIELD org.apache.crimson.parser.ContentModel.cache 
Lorg/apache/crimson/parser/SimpleHashtable;
                    ALOAD_1     // java.lang.String token
                    GETSTATIC java.lang.Boolean.TRUE Ljava/lang/Boolean;
                    INVOKEVIRTUAL org.apache.crimson.parser.SimpleHashtable.put 
(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Obj
ect;
                    POP
                    GOTO L19
               L18: ALOAD_0     // org.apache.crimson.parser.ContentModel 
this   (line 236)
                    GETFIELD org.apache.crimson.parser.ContentModel.cache 
Lorg/apache/crimson/parser/SimpleHashtable;
                    ALOAD_1     // java.lang.String token
                    GETSTATIC java.lang.Boolean.FALSE Ljava/lang/Boolean;
                    INVOKEVIRTUAL org.apache.crimson.parser.SimpleHashtable.put 
(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Obj
ect;
                    POP
               L19: ILOAD_3     // boolean retval   (line 238)
                    IRETURN
  end public boolean first(String)

end final class org.apache.crimson.parser.ContentModel</description><comments/></buginformation><fixedCommits><commit id="fabf1598298cb56705e20b4d6a6d64f5c72798eb" author="default" date="2005-11-15 17:04:00"><file name="loadtime/src/org/aspectj/weaver/loadtime/definition/DocumentParser.java"><method name="parse" returnType="Definition" parameters="URL"/></file></commit></fixedCommits></bug><bug id="223" opendate="2005-11-16 03:54:00" fixdate="2005-11-18 09:01:17"><buginformation><summary>Load-time weaving - exception from the weaver</summary><description>Hi again :-)

I'm trying to use loadtime weaving and getting an exception. Please look at the 
testcase:

Java code:
==========
public class Test&lt;T&gt; {

	Set&lt;T&gt; intsSet;

	public Test() {
		this.intsSet = new HashSet&lt;T&gt;();
	}

	public &lt;T&gt; T[] getObjs(T[] a) {
		return intsSet.toArray(a);
	}

	public static void main(String[] args) {
		System.out.println("AAA :-)");
		new TTT().foo();
	}
}

class TTT {
	public void foo() {
		Test&lt;Object&gt; mt = new Test&lt;Object&gt;();
		Object[] arr = mt.getObjs(new Object[]{});
	}
}

Aspect:
=======
public privileged aspect TestAspect {

      pointcut TestToArray(Test mt) :
                target(mt) &amp;&amp;
                !within(TestAspect);


    Object[] around(Test mt, Object[] objs) :
            TestToArray(mt) &amp;&amp;
            args(objs) &amp;&amp;
            execution(Object[] com.mprv.secsph.Test.getObjs(Object[])) {

        objs = proceed(mt, objs);
        System.out.println("GO Aspects!");
        return objs;
    }
}

aop.xml
=======
&lt;aspectj&gt;
	&lt;aspects&gt;
		&lt;aspect name="com.mprv.secsph.TestAspect"/&gt;
	&lt;/aspects&gt;

	&lt;weaver options="-verbose -XlazyTjp -showWeaveInfo"&gt;
		&lt;include within="com.mprv.*"/&gt;
	&lt;/weaver&gt;
&lt;/aspectj&gt;

Program output:
==============
AAA :-)
info weaving 'com/mprv/secsph/TestAspect'
java.lang.NullPointerException
	at 
org.aspectj.weaver.tools.WeavingAdaptor$WeavingClassFileProvider.getBytes
(WeavingAdaptor.java:390)
	at org.aspectj.weaver.tools.WeavingAdaptor.getAtAspectJAspectBytes
(WeavingAdaptor.java:259)
	at org.aspectj.weaver.tools.WeavingAdaptor.weaveClass
(WeavingAdaptor.java:181)
	at org.aspectj.weaver.loadtime.Aj.preProcess(Aj.java:66)
	at org.aspectj.weaver.loadtime.ClassPreProcessorAgentAdapter.transform
(ClassPreProcessorAgentAdapter.java:52)
	at sun.instrument.TransformerManager.transform
(TransformerManager.java:122)
	at sun.instrument.InstrumentationImpl.transform
(InstrumentationImpl.java:155)
	at java.lang.ClassLoader.defineClass1(Native Method)
	at java.lang.ClassLoader.defineClass(ClassLoader.java:620)
	at java.security.SecureClassLoader.defineClass
(SecureClassLoader.java:124)
	at java.net.URLClassLoader.defineClass(URLClassLoader.java:260)
	at java.net.URLClassLoader.access$100(URLClassLoader.java:56)
	at java.net.URLClassLoader$1.run(URLClassLoader.java:195)
	at java.security.AccessController.doPrivileged(Native Method)
	at java.net.URLClassLoader.findClass(URLClassLoader.java:188)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:306)
	at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:268)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:251)
	at java.lang.ClassLoader.loadClassInternal(ClassLoader.java:319)
	at com.mprv.secsph.Test.getObjs(Test.java:1)
	at com.mprv.secsph.TTT.foo(Test.java:34)
	at com.mprv.secsph.Test.main(Test.java:27)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke
(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke
(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:585)
	at com.intellij.rt.execution.application.AppMain.main(AppMain.java:86)
GO Aspects!

====

This exception doesn't happen all the time ... but if you will try a few times, 
you will probably get it. May you can understand what is the problem event 
without running the test case. 

Anyway, I took a look at your code, and have a guess (but it's only the guess) -
My aspect is in the application classpath. Actually it's in the same package, 
so may be you are trying to weave the aspect with itself somehow ...

Thanks!
Misha.</description><comments/></buginformation><fixedCommits><commit id="c7608950f0deb6f9951435f58209ad60aaf28e06" author="default" date="2005-11-18 09:01:17"><file name="tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"><method name="testNoStackOverflowWithCircularPCDInGenericAspect2" returnType="void" parameters=""/></file><file name="weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java"><method name="getBytes" returnType="byte[]" parameters=""/><method name="dontIgnore" returnType="void" parameters="IMessage.Kind"/></file></commit></fixedCommits></bug><bug id="224" opendate="2005-11-17 17:09:00" fixdate="2005-11-18 09:17:56"><buginformation><summary>[waitingOnAJDTdrop]Exception thrown from AspectJ compiler</summary><description>java.lang.ClassCastException
at org.aspectj.weaver.bcel.BcelClassWeaver.checkForOverride
(BcelClassWeaver.java:607)
at org.aspectj.weaver.bcel.BcelClassWeaver.calculateAnyRequiredBridgeMethods
(BcelClassWeaver.java:676)
at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1537)
at org.aspectj.weaver.bcel.BcelWeaver.weaveWithoutDump(BcelWeaver.java:1485)
at org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify(BcelWeaver.java:1266)
at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1088)
at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave
(AjCompilerAdapter.java:300)
at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling
(AjCompilerAdapter.java:178)
at 
org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$afterReturning$org_aspect
j_ajdt_internal_compiler_CompilerAdapter$2$f9cc9ca0(CompilerAdapter.aj:70)
at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile
(Compiler.java:367)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation
(AjBuildManager.java:809)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild
(AjBuildManager.java:254)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.incrementalBuild
(AjBuildManager.java:163)
at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:117)
at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run
(AspectJBuildManager.java:191)

trouble in: 
public class ts.simul.client.AbstractClient$OptionSetter extends 
ts.util.CmdLineProgram$OptionSetterBase:
  final ts.simul.client.AbstractClient this$0
  private static final org.aspectj.lang.JoinPoint$StaticPart ajc$tjp_0
  public void &lt;init&gt;(ts.simul.client.AbstractClient)    
org.aspectj.weaver.MethodDeclarationLineNumber: 59:1411
:
                    ALOAD_0     // ts.simul.client.AbstractClient$OptionSetter 
this   (line 60)
                    ALOAD_1
                    PUTFIELD ts.simul.client.AbstractClient$OptionSetter.this$0 
Lts/simul/client/AbstractClient;
                    ALOAD_0     // ts.simul.client.AbstractClient$OptionSetter 
this   (line 59)
                    ALOAD_1
                    INVOKESPECIAL 
ts.util.CmdLineProgram$OptionSetterBase.&lt;init&gt; (Lts/util/CmdLineProgram;)V
    constructor-execution(void 
ts.simul.client.AbstractClient$OptionSetter.&lt;init&gt;
(ts.simul.client.AbstractClient))
    |               RETURN
    constructor-execution(void 
ts.simul.client.AbstractClient$OptionSetter.&lt;init&gt;
(ts.simul.client.AbstractClient))
  end public void &lt;init&gt;(ts.simul.client.AbstractClient)

  public boolean setOption_file(String) throws 
ts.util.IllegalProgramArgumentException    
org.aspectj.weaver.MethodDeclarationLineNumber: 62:1469
:
    method-execution(boolean 
ts.simul.client.AbstractClient$OptionSetter.setOption_file(java.lang.String))
    |               ALOAD_1     // java.lang.String optParam   (line 65)
    | method-call(int java.lang.String.length())
    | |             INVOKEVIRTUAL java.lang.String.length ()I
    | method-call(int java.lang.String.length())
    |               IFLE L1
    |               ALOAD_0     // ts.simul.client.AbstractClient$OptionSetter 
this   (line 66)
    |               GETFIELD ts.simul.client.AbstractClient$OptionSetter.this$0 
Lts/simul/client/AbstractClient;
    |               ALOAD_1     // java.lang.String optParam
    |               PUTFIELD ts.simul.client.AbstractClient.fileName 
Ljava/lang/String;
    |               NEW java.io.File   (line 67)
    |               DUP
    |               ALOAD_0     // ts.simul.client.AbstractClient$OptionSetter 
this
    |               GETFIELD ts.simul.client.AbstractClient$OptionSetter.this$0 
Lts/simul/client/AbstractClient;
    |               GETFIELD ts.simul.client.AbstractClient.fileName 
Ljava/lang/String;
    | constructor-call(void java.io.File.&lt;init&gt;(java.lang.String))
    | |             INVOKESPECIAL java.io.File.&lt;init&gt; (Ljava/lang/String;)V
    | constructor-call(void java.io.File.&lt;init&gt;(java.lang.String))
    |               ASTORE_2
    |               ALOAD_2     // java.io.File file   (line 68)
    | method-call(boolean java.io.File.exists())
    | |             INVOKEVIRTUAL java.io.File.exists ()Z
    | method-call(boolean java.io.File.exists())
    |               IFNE L0
    |               NEW ts.util.IllegalProgramArgumentException   (line 69)
    |               DUP
    |               NEW java.lang.StringBuilder
    |               DUP
    |               LDC "Cannot find file: ["
    | constructor-call(void java.lang.StringBuilder.&lt;init&gt;(java.lang.String))
    | |             INVOKESPECIAL java.lang.StringBuilder.&lt;init&gt; 
(Ljava/lang/String;)V
    | constructor-call(void java.lang.StringBuilder.&lt;init&gt;(java.lang.String))
    |               ALOAD_0     // ts.simul.client.AbstractClient$OptionSetter 
this
    |               GETFIELD ts.simul.client.AbstractClient$OptionSetter.this$0 
Lts/simul/client/AbstractClient;
    |               GETFIELD ts.simul.client.AbstractClient.fileName 
Ljava/lang/String;
    | method-call(java.lang.StringBuilder java.lang.StringBuilder.append
(java.lang.String))
    | |             INVOKEVIRTUAL java.lang.StringBuilder.append 
(Ljava/lang/String;)Ljava/lang/StringBuilder;
    | method-call(java.lang.StringBuilder java.lang.StringBuilder.append
(java.lang.String))
    |               LDC "]"
    | method-call(java.lang.StringBuilder java.lang.StringBuilder.append
(java.lang.String))
    | |             INVOKEVIRTUAL java.lang.StringBuilder.append 
(Ljava/lang/String;)Ljava/lang/StringBuilder;
    | method-call(java.lang.StringBuilder java.lang.StringBuilder.append
(java.lang.String))
    | method-call(java.lang.String java.lang.StringBuilder.toString())
    | |             INVOKEVIRTUAL java.lang.StringBuilder.toString ()
Ljava/lang/String;
    | method-call(java.lang.String java.lang.StringBuilder.toString())
    | constructor-call(void ts.util.IllegalProgramArgumentException.&lt;init&gt;
(java.lang.String))
    | |             INVOKESPECIAL 
ts.util.IllegalProgramArgumentException.&lt;init&gt; (Ljava/lang/String;)V
    | constructor-call(void ts.util.IllegalProgramArgumentException.&lt;init&gt;
(java.lang.String))
    |               ATHROW
    |           L0: ICONST_1   (line 70)
    |               IRETURN
    |           L1: ICONST_0   (line 73)
    |               IRETURN
    method-execution(boolean 
ts.simul.client.AbstractClient$OptionSetter.setOption_file(java.lang.String))
  end public boolean setOption_file(String) throws 
ts.util.IllegalProgramArgumentException

  public boolean setOption_class(String) throws 
ts.util.IllegalProgramArgumentException    
org.aspectj.weaver.MethodDeclarationLineNumber: 76:1971
:
    method-execution(boolean 
ts.simul.client.AbstractClient$OptionSetter.setOption_class(java.lang.String))
    |               ALOAD_1     // java.lang.String optParam   (line 79)
    | method-call(int java.lang.String.length())
    | |             INVOKEVIRTUAL java.lang.String.length ()I
    | method-call(int java.lang.String.length())
    |               IFLE L1
    |               ALOAD_0     // ts.simul.client.AbstractClient$OptionSetter 
this   (line 80)
    |               GETFIELD ts.simul.client.AbstractClient$OptionSetter.this$0 
Lts/simul/client/AbstractClient;
    |               ALOAD_1     // java.lang.String optParam
    |               PUTFIELD ts.simul.client.AbstractClient.className 
Ljava/lang/String;
    | catch ts.simul.SimulationException -&gt; E0
    | |             ALOAD_0     // ts.simul.client.AbstractClient$OptionSetter 
this   (line 82)
    | |             GETFIELD ts.simul.client.AbstractClient$OptionSetter.this$0 
Lts/simul/client/AbstractClient;
    | |             ALOAD_0     // ts.simul.client.AbstractClient$OptionSetter 
this
    | |             GETFIELD ts.simul.client.AbstractClient$OptionSetter.this$0 
Lts/simul/client/AbstractClient;
    | |             GETFIELD ts.simul.client.AbstractClient.className 
Ljava/lang/String;
    | | method-call(java.lang.Class ts.simul.SceneFactory.getSceneClass
(java.lang.String))
    | | |           INVOKESTATIC ts.simul.SceneFactory.getSceneClass 
(Ljava/lang/String;)Ljava/lang/Class;
    | | method-call(java.lang.Class ts.simul.SceneFactory.getSceneClass
(java.lang.String))
    | |             PUTFIELD ts.simul.client.AbstractClient.sceneClass 
Ljava/lang/Class;
    | |             ALOAD_0     // ts.simul.client.AbstractClient$OptionSetter 
this   (line 83)
    | |             GETFIELD ts.simul.client.AbstractClient$OptionSetter.this$0 
Lts/simul/client/AbstractClient;
    | | method-call(void ts.simul.client.AbstractClient.setBeanInfoSearchPath())
    | | |           INVOKESTATIC ts.simul.Architecture.aspectOf ()
Lts/simul/Architecture;
    | | |           GETSTATIC 
ts.simul.client.AbstractClient$OptionSetter.ajc$tjp_0 
Lorg/aspectj/lang/JoinPoint$StaticPart;
    | | |           INVOKEVIRTUAL 
ts.simul.Architecture.ajc$before$ts_simul_Architecture$1$ae285a4d 
(Lorg/aspectj/lang/JoinPoint$StaticPart;)V
    | | |           INVOKEVIRTUAL 
ts.simul.client.AbstractClient.setBeanInfoSearchPath ()V
    | | method-call(void ts.simul.client.AbstractClient.setBeanInfoSearchPath())
    | |             GOTO L0
    | catch ts.simul.SimulationException -&gt; E0
    |           E0: ASTORE_2   (line 85)
    |               NEW ts.util.IllegalProgramArgumentException   (line 86)
    |               DUP
    |               ALOAD_2     // ts.simul.SimulationException e
    | method-call(java.lang.String ts.simul.SimulationException.getMessage())
    | |             INVOKEVIRTUAL ts.simul.SimulationException.getMessage ()
Ljava/lang/String;
    | method-call(java.lang.String ts.simul.SimulationException.getMessage())
    | constructor-call(void ts.util.IllegalProgramArgumentException.&lt;init&gt;
(java.lang.String))
    | |             INVOKESPECIAL 
ts.util.IllegalProgramArgumentException.&lt;init&gt; (Ljava/lang/String;)V
    | constructor-call(void ts.util.IllegalProgramArgumentException.&lt;init&gt;
(java.lang.String))
    |               ATHROW
    |           L0: ICONST_1   (line 88)
    |               IRETURN
    |           L1: ICONST_0   (line 91)
    |               IRETURN
    method-execution(boolean 
ts.simul.client.AbstractClient$OptionSetter.setOption_class(java.lang.String))
  end public boolean setOption_class(String) throws 
ts.util.IllegalProgramArgumentException

  public boolean setOption_name(String)    
org.aspectj.weaver.MethodDeclarationLineNumber: 94:2593
:
    method-execution(boolean 
ts.simul.client.AbstractClient$OptionSetter.setOption_name(java.lang.String))
    |               ALOAD_0     // ts.simul.client.AbstractClient$OptionSetter 
this   (line 96)
    |               GETFIELD ts.simul.client.AbstractClient$OptionSetter.this$0 
Lts/simul/client/AbstractClient;
    |               ALOAD_1     // java.lang.String optParam
    |               PUTFIELD ts.simul.client.AbstractClient.sceneName 
Ljava/lang/String;
    |               ICONST_1   (line 97)
    |               IRETURN
    method-execution(boolean 
ts.simul.client.AbstractClient$OptionSetter.setOption_name(java.lang.String))
  end public boolean setOption_name(String)

  public boolean setOption_actors(String)    
org.aspectj.weaver.MethodDeclarationLineNumber: 100:2739
:
    method-execution(boolean 
ts.simul.client.AbstractClient$OptionSetter.setOption_actors(java.lang.String))
    | catch java.lang.NumberFormatException -&gt; E0
    | |             ALOAD_1     // java.lang.String optParam   (line 103)
    | | method-call(int java.lang.Integer.parseInt(java.lang.String))
    | | |           INVOKESTATIC java.lang.Integer.parseInt (Ljava/lang/String;)
I
    | | method-call(int java.lang.Integer.parseInt(java.lang.String))
    | |             ISTORE_2
    | |             GOTO L0
    | catch java.lang.NumberFormatException -&gt; E0
    |           E0: ASTORE_2     // int n   (line 105)
    |               ICONST_0   (line 106)
    |               IRETURN
    |           L0: ICONST_1   (line 108)
    |               IRETURN
    method-execution(boolean 
ts.simul.client.AbstractClient$OptionSetter.setOption_actors(java.lang.String))
  end public boolean setOption_actors(String)

end public class ts.simul.client.AbstractClient$OptionSetter

when weaving type ts.simul.client.AbstractClient$OptionSetter
when weaving classes 
when weaving 
when incrementally building BuildConfig
[c:\Projects\eclipse\.metadata\.plugins\org.eclipse.ajdt.core\TS.generated.lst] 
#Files=79</description><comments/></buginformation><fixedCommits><commit id="dd9a9b284ab44b14ea3735d2663e85afb861220b" author="default" date="2005-11-18 09:17:56"><file name="weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"><method name="checkForOverride" returnType="ResolvedMember" parameters="ResolvedType"/></file></commit></fixedCommits></bug><bug id="225" opendate="2005-11-05 06:03:00" fixdate="2005-11-18 10:09:32"><buginformation><summary>WildAnnotationTypePattern.java:61 NPE after renaming method-annotation class</summary><description>Sorry I don't have a small test case.  It looks like the NPE happens when the
annotation refered to by a (compiled?) aspect no longer exists because it was
renamed.  The class being woven is the first one (alphabetically), and the
method being woven does not have the annotation on it.

Let me know if you need a test case.
(And sorry for the late bugs - I'm just now writing the article.)

------------------------------------------------------------------
java.lang.NullPointerException
at
org.aspectj.weaver.patterns.WildAnnotationTypePattern.matches(WildAnnotationTypePattern.java:61)
at
org.aspectj.weaver.patterns.SignaturePattern.matchesAnnotations(SignaturePattern.java:321)
at
org.aspectj.weaver.patterns.SignaturePattern.matchesExactly(SignaturePattern.java:169)
at org.aspectj.weaver.patterns.SignaturePattern.matches(SignaturePattern.java:131)
at
org.aspectj.weaver.patterns.WithincodePointcut.matchInternal(WithincodePointcut.java:73)
at org.aspectj.weaver.patterns.Pointcut.match(Pointcut.java:143)
at org.aspectj.weaver.patterns.AndPointcut.matchInternal(AndPointcut.java:55)
at org.aspectj.weaver.patterns.Pointcut.match(Pointcut.java:143)
at org.aspectj.weaver.patterns.AndPointcut.matchInternal(AndPointcut.java:55)
at org.aspectj.weaver.patterns.Pointcut.match(Pointcut.java:143)
at org.aspectj.weaver.ShadowMunger.match(ShadowMunger.java:64)
at org.aspectj.weaver.Advice.match(Advice.java:109)
at org.aspectj.weaver.bcel.BcelAdvice.match(BcelAdvice.java:97)
at org.aspectj.weaver.bcel.BcelClassWeaver.match(BcelClassWeaver.java:1749)
at
org.aspectj.weaver.bcel.BcelClassWeaver.matchInvokeInstruction(BcelClassWeaver.java:1736)
at org.aspectj.weaver.bcel.BcelClassWeaver.match(BcelClassWeaver.java:1533)
at org.aspectj.weaver.bcel.BcelClassWeaver.match(BcelClassWeaver.java:1359)
at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:382)
at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:98)
at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1478)
at org.aspectj.weaver.bcel.BcelWeaver.weaveWithoutDump(BcelWeaver.java:1443)
at org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify(BcelWeaver.java:1217)
at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1021)
at
org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave(AjCompilerAdapter.java:300)
at
org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling(AjCompilerAdapter.java:178)
at
org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$afterReturning$org_aspectj_ajdt_internal_compiler_CompilerAdapter$2$f9cc9ca0(CompilerAdapter.aj:70)
at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:367)
at
org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:759)
at
org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:225)
at
org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:151)
at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:122)
at
org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)

trouble in: 
public class com.isberg.articles.aop7.bean.ABeanTest$APlus extends java.lang.Object:
  TypeMungers: [(BcelTypeMunger ResolvedTypeMunger(Method, java.lang.String
com.isberg.articles.aop7.bean.ABeanTest$CPlus.propertyName(java.lang.String)))]
     declares: [declare parents: com.isberg.articles.aop7.bean.ABeanTest$CPlus
extends (com.isberg.articles.aop7.bean.ABean$IBean);]
  private static Throwable ajc$initFailureCause
  public static final com.isberg.articles.aop7.bean.ABeanTest$APlus
ajc$perSingletonInstance
  static void &lt;clinit&gt;():
    staticinitialization(void
com.isberg.articles.aop7.bean.ABeanTest$APlus.&lt;clinit&gt;())
    | catch java.lang.Throwable -&gt; E0
    | |             INVOKESTATIC
com.isberg.articles.aop7.bean.ABeanTest$APlus.ajc$postClinit ()V   (line 125)
    | catch java.lang.Throwable -&gt; E0
    |               GOTO L0
    |           E0: ASTORE_0
    |               ALOAD_0
    |               PUTSTATIC
com.isberg.articles.aop7.bean.ABeanTest$APlus.ajc$initFailureCause
Ljava/lang/Throwable;
    |           L0: RETURN
    staticinitialization(void
com.isberg.articles.aop7.bean.ABeanTest$APlus.&lt;clinit&gt;())
  end static void &lt;clinit&gt;()

  void &lt;init&gt;():
                    ALOAD_0     // com.isberg.articles.aop7.bean.ABeanTest$APlus
this   (line 125)
                    INVOKESPECIAL java.lang.Object.&lt;init&gt; ()V
    constructor-execution(void
com.isberg.articles.aop7.bean.ABeanTest$APlus.&lt;init&gt;())
    |               RETURN
    constructor-execution(void
com.isberg.articles.aop7.bean.ABeanTest$APlus.&lt;init&gt;())
  end void &lt;init&gt;()

  void ajc$declare_parents_1()   
org.aspectj.weaver.MethodDeclarationLineNumber: 127:3678
:
                    RETURN   (line 127)
  end void ajc$declare_parents_1()

  public static String
ajc$interMethod$com_isberg_articles_aop7_bean_ABeanTest$APlus$com_isberg_articles_aop7_bean_ABeanTest$CPlus$propertyName(com.isberg.articles.aop7.bean.ABeanTest$CPlus,
String)    EffectiveSignatureAttribute(java.lang.String
com.isberg.articles.aop7.bean.ABeanTest$CPlus.propertyName(java.lang.String),
method-execution)
:
    method-execution(java.lang.String
com.isberg.articles.aop7.bean.ABeanTest$CPlus.propertyName(java.lang.String))
    |               ALOAD_0     // com.isberg.articles.aop7.bean.ABeanTest$CPlus
ajc$this_   (line 132)
    |               ALOAD_1     // java.lang.String methodName
    |               INVOKESTATIC
com.isberg.articles.aop7.bean.ABean.ajc$interMethod$com_isberg_articles_aop7_bean_ABean$com_isberg_articles_aop7_bean_ABean$IBean$propertyName
(Lcom/isberg/articles/aop7/bean/ABean$IBean;Ljava/lang/String;)Ljava/lang/String;
    |               ASTORE_2
    |               LDC "something"   (line 133)
    |               ALOAD_2     // java.lang.String result
    | method-call(boolean java.lang.String.equals(java.lang.Object))
    | |             INVOKEVIRTUAL java.lang.String.equals (Ljava/lang/Object;)Z
    | method-call(boolean java.lang.String.equals(java.lang.Object))
    |               IFEQ L0
    |               LDC "a"   (line 134)
    |               ASTORE_2     // java.lang.String result
    |           L0: ALOAD_2     // java.lang.String result   (line 136)
    |               ARETURN
    method-execution(java.lang.String
com.isberg.articles.aop7.bean.ABeanTest$CPlus.propertyName(java.lang.String))
  end public static String
ajc$interMethod$com_isberg_articles_aop7_bean_ABeanTest$APlus$com_isberg_articles_aop7_bean_ABeanTest$CPlus$propertyName(com.isberg.articles.aop7.bean.ABeanTest$CPlus,
String)

  public static String
ajc$interMethodDispatch1$com_isberg_articles_aop7_bean_ABeanTest$APlus$com_isberg_articles_aop7_bean_ABeanTest$CPlus$propertyName(com.isberg.articles.aop7.bean.ABeanTest$CPlus,
String)    EffectiveSignatureAttribute(java.lang.String
com.isberg.articles.aop7.bean.ABeanTest$CPlus.propertyName(java.lang.String),
method-call)
:
                    ALOAD_0
                    ALOAD_1
                    INVOKEVIRTUAL
com.isberg.articles.aop7.bean.ABeanTest$CPlus.propertyName
(Ljava/lang/String;)Ljava/lang/String;
                    ARETURN
  end public static String
ajc$interMethodDispatch1$com_isberg_articles_aop7_bean_ABeanTest$APlus$com_isberg_articles_aop7_bean_ABeanTest$CPlus$propertyName(com.isberg.articles.aop7.bean.ABeanTest$CPlus,
String)

  public static com.isberg.articles.aop7.bean.ABeanTest$APlus aspectOf()   
org.aspectj.weaver.AjAttribute$AjSynthetic@591171
:
                    GETSTATIC
com.isberg.articles.aop7.bean.ABeanTest$APlus.ajc$perSingletonInstance
Lcom/isberg/articles/aop7/bean/ABeanTest$APlus;
                    IFNONNULL L0
                    NEW org.aspectj.lang.NoAspectBoundException
                    DUP
                    LDC "com_isberg_articles_aop7_bean_ABeanTest$APlus"
                    GETSTATIC
com.isberg.articles.aop7.bean.ABeanTest$APlus.ajc$initFailureCause
Ljava/lang/Throwable;
                    INVOKESPECIAL org.aspectj.lang.NoAspectBoundException.&lt;init&gt;
(Ljava/lang/String;Ljava/lang/Throwable;)V
                    ATHROW
                L0: GETSTATIC
com.isberg.articles.aop7.bean.ABeanTest$APlus.ajc$perSingletonInstance
Lcom/isberg/articles/aop7/bean/ABeanTest$APlus;
                    ARETURN
  end public static com.isberg.articles.aop7.bean.ABeanTest$APlus aspectOf()

  public static boolean hasAspect()   
org.aspectj.weaver.AjAttribute$AjSynthetic@16e3eb3
:
                    GETSTATIC
com.isberg.articles.aop7.bean.ABeanTest$APlus.ajc$perSingletonInstance
Lcom/isberg/articles/aop7/bean/ABeanTest$APlus;
                    IFNULL L0
                    ICONST_1
                    IRETURN
                L0: ICONST_0
                    IRETURN
  end public static boolean hasAspect()

  private static void ajc$postClinit()   
org.aspectj.weaver.AjAttribute$AjSynthetic@d7cf62
:
                    NEW com.isberg.articles.aop7.bean.ABeanTest$APlus
                    DUP
                    INVOKESPECIAL
com.isberg.articles.aop7.bean.ABeanTest$APlus.&lt;init&gt; ()V
                    PUTSTATIC
com.isberg.articles.aop7.bean.ABeanTest$APlus.ajc$perSingletonInstance
Lcom/isberg/articles/aop7/bean/ABeanTest$APlus;
                    RETURN
  end private static void ajc$postClinit()
end public class com.isberg.articles.aop7.bean.ABeanTest$APlus

when matching pointcut ((withincode(@(Parallel) * *(..)) &amp;&amp; call(void *(..))) &amp;&amp;
percflow(com.isberg.articles.aop7.concurrent.ParallelMethodImpl on
execution(@(Parallel) * *(..))))
when matching shadow method-call(boolean java.lang.String.equals(java.lang.Object))
when weaving type com.isberg.articles.aop7.bean.ABeanTest$APlus
when weaving aspects 
when weaving 
when batch building
BuildConfig[c:\home\ws\main-31\.metadata\.plugins\org.eclipse.ajdt.core\devworks-fall.generated.lst]
#Files=70</description><comments/></buginformation><fixedCommits><commit id="557f5b4676f6484dc9b43e2d1a5a8172ef76d5cf" author="default" date="2005-11-18 10:09:32"><file name="weaver/src/org/aspectj/weaver/patterns/WildAnnotationTypePattern.java"><method name="matches" returnType="FuzzyBoolean" parameters="AnnotatedElement"/></file></commit></fixedCommits></bug><bug id="226" opendate="2005-11-16 20:19:00" fixdate="2005-11-19 17:08:48"><buginformation><summary>PointcutParser is not configurable</summary><description>I'm testing the reflection and weaver tools APIs. When I using following code:

PointcutParser parse = new PointcutParser();
String expr = "call(public * main.hello(..)";
PointcutExpression pex = parse.parsePointcutExpression(expr);

Whenever I use a full qualified class name in pointcut expression, an 
exception is throwed out:
java.lang.IllegalArgumentException: warning no match for this type name: obj 
[Xlint:invalidAbsoluteTypeName]

I try to turn off this Lint exception. But it seems I must access to world 
field of PointcutParser. This is inconvenient because world field is not 
exposed by PointcutParser. 

The existing PointcutParser interface implicitly creates a World and does not 
allow any configuration including classpath or lint. But developers may need 
this kind of control.</description><comments/></buginformation><fixedCommits><commit id="522911ec81aeb3ec5b600939d3a2ee6e6297fd0c" author="default" date="2005-11-19 17:08:48"><file name="weaver/src/org/aspectj/weaver/bcel/BcelWorld.java"><method name="isAnnotationStyleAspect" returnType="boolean" parameters="String byte[]"/></file><file name="tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"><method name="testNoStackOverflowWithCircularPCDInGenericAspect2" returnType="void" parameters=""/></file><file name="weaver/src/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegate.java"><method name="getReflectionWorld" returnType="ReflectionWorld" parameters=""/><method name="hasAnnotation" returnType="boolean" parameters="UnresolvedType"/><method name="getSuperclass" returnType="ResolvedType" parameters=""/><method name="initialize" returnType="void" parameters="ReferenceType Class World"/></file><file name="tests/java5/ataspectj/annotationGen/RuntimePointcuts.java"><method name="main" returnType="void" parameters="String[]"/></file></commit></fixedCommits></bug><bug id="227" opendate="2005-11-09 04:35:00" fixdate="2005-11-21 16:33:56"><buginformation><summary>Incorrect structure model for simple declare @type program?</summary><description>This program:
---8&lt;-----
@interface I {}

class Simple {}

public aspect C {
  declare @type: Simple : @I;
}
---8&lt;-----
(all in a file called C.java, open with the AJ editor) when built shows
incorrect gutter markers, it shows a double headed arrow on Simple implying that
it annotates itself - rather than something outgoing from the declare statement
and something incoming on the Simple type.</description><comments/></buginformation><fixedCommits><commit id="9ed75a10abaca8a6c8569ead1b74eaaadc980b07" author="default" date="2005-11-21 16:33:56"><file name="tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"><method name="testBadRenderer_pr86903" returnType="void" parameters=""/></file></commit></fixedCommits></bug><bug id="228" opendate="2005-10-31 03:42:00" fixdate="2005-11-21 22:05:46"><buginformation><summary>Reflection API not detecting ITD method correctly in all circumstances</summary><description>As reported on the aspectj mailing list:

Hi,

I'm using the 'getDeclaredITDMethods' method (available in the
reflection api) to find all ITD methods in the Billing aspect (from
the aspectj examples).

The Billing aspect contains 4 ITD methods (Connection.callRate,
LongDistance.callRate, Local.callRate and Customer.addCharge), but I
got only 3 of them using this method.

The 'Connection.callRate' is not returned by the
'getDeclaredITDMethods' method (maybe because it is abstract). In the
implementation of method 'getDeclaredITDMethods' in
'org.aspectj.internal.lang.reflect.AjTypeImpl' there is the following
condition:

if (!m.getName().contains("ajc$interMethod$")) continue;

Looking the names in the debbuger, I could not find a:
public static long
telecom.Billing.ajc$interMethod$telecom_Billing$telecom_Connection$callRate(telecom.Connection)
But only:
public static long
telecom.Billing.ajc$interMethodDispatch1$telecom_Billing$telecom_Connection$callRate
(telecom.Connection)

if a take a concrete method, I get two objects, named:
public static long
telecom.Billing.ajc$interMethod$telecom_Billing$telecom_LongDistance$callRate(telecom.LongDistance)
public static long
telecom.Billing.ajc$interMethodDispatch1$telecom_Billing$telecom_LongDistance$callRate
(telecom.LongDistance)

One of them satisfies the predicate !m.getName().contains("ajc$interMethod$").

Is this behavior correct?

ps.: I'm using the example bellow.

----------------------------------------------------------------
public aspect Billing {
   ...
   public abstract long Connection.callRate();
   public long LongDistance.callRate() { return LONG_DISTANCE_RATE; }
   public long Local.callRate() { return LOCAL_RATE; }
   public void Customer.addCharge(long charge){
       totalCharge += charge;
   }
   ...
}

---------------------------------------------------------------------------------------
-
import org.aspectj.lang.reflect.AjType;
import org.aspectj.lang.reflect.AjTypeSystem;
import org.aspectj.lang.reflect.InterTypeMethodDeclaration;

import telecom.Billing;

public class Test {
       public static void main(String args[]) throws ClassNotFoundException{
               AjType c = AjTypeSystem.getAjType(Billing.class);
               InterTypeMethodDeclaration[] itdmethods = c.getDeclaredITDMethods();
               for (int i = 0; i &lt; itdmethods.length; i++) {
                       System.out.println("ITD Method:" +
itdmethods[i].getTargetType().getName()+"."+itdmethods[i].getName());
               }
       }
}
----------------------------------------------------------------
Output:
 ITD Method:telecom.LongDistance.callRate
 ITD Method:telecom.Local.callRate
 ITD Method:telecom.Customer.addCharge

Expected Output:
 ITD Method:telecom.Connection.callRate
 ITD Method:telecom.LongDistance.callRate
 ITD Method:telecom.Local.callRate
 ITD Method:telecom.Customer.addCharge

I'm using ajde 1.5.0.20051014142856.

Regards,
Eduardo Piveta
 http://www.inf.ufrgs.br/~epiveta</description><comments/></buginformation><fixedCommits><commit id="735d94f91a02e08bf5a1a86185b9318de4bd4319" author="default" date="2005-11-21 22:05:46"><file name="aspectj5rt/java5-src/org/aspectj/internal/lang/reflect/AjTypeImpl.java"><method name="getDeclaredITDMethod" returnType="InterTypeMethodDeclaration" parameters="String"/></file></commit></fixedCommits></bug><bug id="229" opendate="2005-07-07 14:03:00" fixdate="2005-11-22 09:28:09"><buginformation><summary>Declare Soft not Affecting Explicit Adviceexecution</summary><description>The following aspect should compile successfully:

import java.io.IOException;

public aspect SoftenAdvice {
    declare soft: IOException: within(SoftenAdvice) &amp;&amp; adviceexecution();

    before() : execution(* main(..)) {
        throw new IOException("test");
    }

    public static void main(String args[]) {
    }
}

But both 1.5.0M2 and HEAD (from 2 days ago) give this output:

C:\devel\scratch\err&gt;ajc SoftenAdvice.aj
C:\devel\scratch\err\SoftenAdvice.aj:7 [error] Unhandled exception type 
IOExcept
ion
throw new IOException("test");
^^^^^^^^^^^^^^^^^^^^

1 error

However if you change the declare soft to be the following, it correctly 
softens at the advice execution join point.

    declare soft: IOException: within(SoftenAdvice) &amp;&amp; !withincode(* *(..));</description><comments/></buginformation><fixedCommits><commit id="554e73397c0b80ce32e56cf3adeb6921783e005d" author="default" date="2005-11-22 09:28:09"><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseShadow.java"><method name="makeShadow" returnType="EclipseShadow" parameters="EclipseFactory ASTNode"/></file><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"><method name="makeResolvedMember" returnType="ResolvedMember" parameters="MethodBinding TypeBinding"/></file></commit></fixedCommits></bug><bug id="230" opendate="2005-11-19 13:05:00" fixdate="2005-11-23 09:01:53"><buginformation><summary>Contribution: reduce overhead when no aspects define</summary><description>This patch to the ClassLoaderWeavingAdaptor adds two optimizations when enabled 
is false for the adaptor: it immediately returns false for accept and it also 
avoids the overhead of constructing a weaver or world.

It also contains commented out code that was letting me improve performance by 
loading reflective proxies instead of creating BCEL objects for a resolution 
loader (which is currently broken since reflective proxies now require a 
ReflectionWorld...)</description><comments/></buginformation><fixedCommits><commit id="a5ac5af396426f2049abe52036748bd344a7d1fe" author="default" date="2005-11-23 09:01:53"><file name="weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java"><method name="weaveClass" returnType="byte[]" parameters="String byte[]"/><method name="shouldWeave" returnType="boolean" parameters="String byte[]"/></file><file name="loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"><method name="acceptClass" returnType="void" parameters="String byte[]"/><method name="registerDefinitions" returnType="void" parameters="BcelWeaver ClassLoader"/><method name="addCrossReference" returnType="void" parameters="ISourceLocation ISourceLocation"/></file></commit></fixedCommits></bug><bug id="231" opendate="2005-07-08 09:13:00" fixdate="2005-11-23 12:52:27"><buginformation><summary>after returning should not bind "null" as return value</summary><description>Today I found out the following. When writing an advice as...

    after() returning(Object o): staticinitialization(*) {
        System.out.println(o);
    }

This advice is indeed executed every time a type returns from 
staticinitialization. However, since there is no returned object, o is bound to 
"null".

I think this is inconsistent with the fact where we have something like:

    after() returning(T o): call(Object Foo.bar()) {
        System.out.println(o);
    }

Here, AFAIK the advice would not execute in cases where the returned object is 
not an instance of T.

Thus, I would propose that the first advice should only execute at joinpoints 
where a return value is available.</description><comments/></buginformation><fixedCommits><commit id="8b294d9e4f02625c4c3391612242969fb4b6be57" author="default" date="2005-11-23 12:52:27"><file name="weaver/src/org/aspectj/weaver/Shadow.java"><method name="hasHighPriorityExceptions" returnType="boolean" parameters=""/></file><file name="weaver/src/org/aspectj/weaver/Advice.java"><method name="match" returnType="boolean" parameters="Shadow World"/></file><file name="tests/new/ConstructorExecInit.java"><method name="main" returnType="void" parameters="String[]"/></file><file name="tests/new/AfterReturningParam.java"><method name="callEvent" returnType="void" parameters="String Object"/><method name="main" returnType="void" parameters="String[]"/></file></commit></fixedCommits></bug><bug id="232" opendate="2005-11-23 04:27:00" fixdate="2005-11-23 12:54:02"><buginformation><summary>VerifyError when using annotations to define inter-type annotation</summary><description>Using Sun JDK1.5.0_04

Audit.java
public interface Audit {
   public String getLastUpdatedBy();
   public void   setLastUpdatedBy(String un);
}

AuditImpl.java
public class AuditImpl implements Audit {
   private String lastUpdatedBy;
   public String getLastUpdatedBy() {
       return lastUpdatedBy;
   }
   public void setLastUpdatedBy(String un) {
       lastUpdatedBy = un;
   }
}

TestAspect.java
import org.aspectj.lang.annotation.*;

Test.java
@Aspect
public class TestAspect {
      @DeclareParents("Test")
      public static Audit introduced = new AuditImpl();
}
public class Test {
    public static void main(String[] args) {
        Test t = new Test();
        Audit a = (Audit)t;
	    a.setLastUpdatedBy("username");
		System.out.println("Username ="+a.getLastUpdatedBy());
    }
}

files.lst
Audit.java
AuditImpl.java
TestAspect.java
Test.java

Compiled using the following command
d:\aspectj1.5\bin\ajc -classpath "d:\aspectj1.5\lib\aspectjrt.jar" -argfi
le files.lst -1.5

d:\aspectj1.5\bin\aj5 Test
Exception in thread "main" java.lang.VerifyError: (class: Test, method: setLastUpdatedBy signature: (Ljava/lang/String;)V) Incompatible argument to function

d:\aspectj1.5\bin\aj5 -noverify Test
Username=</description><comments/></buginformation><fixedCommits><commit id="11ab99f1c46007b084873d1050da2f9e78e43c82" author="default" date="2005-11-23 12:54:02"><file name="weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java"><method name="mungeMethodDelegate" returnType="boolean" parameters="BcelClassWeaver"/></file></commit></fixedCommits></bug><bug id="233" opendate="2005-11-14 11:16:00" fixdate="2005-11-23 13:14:22"><buginformation><summary>AjTypeSystem interface cannot be used in LTW environment</summary><description>This API uses unqualified calls to Class.forName(). See  bug 116229  for more 
details. The attached patches better simulate a run-time environment and a fix 
that uses the class loader associated with the type provided by the user.</description><comments/></buginformation><fixedCommits><commit id="81e6b60e4eabeaf322651941c65f9f24a0ea80a9" author="default" date="2005-11-23 13:14:22"><file name="aspectj5rt/java5-src/org/aspectj/internal/lang/reflect/StringToType.java"><method name="makeParameterizedType" returnType="Type" parameters="String Class"/><method name="stringToType" returnType="Type" parameters="String Class"/></file></commit></fixedCommits></bug><bug id="234" opendate="2005-10-27 23:03:00" fixdate="2005-11-23 16:20:19"><buginformation><summary>NPE in CContentOutlinePage.createContentProvider()</summary><description>CUIPlugin.getActiveWorkbenchWindow().getActivePage() can return null.</description><comments/></buginformation><fixedCommits><commit id="a4caeb95261431c81f7beb0cddbff3b0865e614d" author="default" date="2005-11-23 16:20:19"><file name="weaver/src/org/aspectj/weaver/patterns/PerThisOrTargetPointcutVisitor.java"><method name="visit" returnType="Object" parameters="NotPointcut Object"/></file></commit></fixedCommits></bug><bug id="235" opendate="2005-11-01 05:43:00" fixdate="2005-11-23 19:21:03"><buginformation><summary>unqualified superaspect&lt;T&gt; pointcut sortafunny in subaspect</summary><description>Advice not applied in subaspect using parameterized superaspect pointcut without
qualifying with type parameter.  

Declare error using same locution works.  

Doc ambiguous:  "All references to a pointcut declared in a generic type from
outside of that type must be via a parameterized type reference, and not a raw
type reference."  I get no compiler error in either case, so perhaps "outside of
that type or subtypes."  But can't interfaces can be parameterized and pointcuts
declared on interfaces?  Eek!

This was disconcerting because the declare warning showed the pointcut was
correct, but still the advice was not being applied.  (My initial aspect was a
perthis(), so I thought that was the problem.)

Not sure if this is treated by  bug 112105  or any other generics bugs (is there a
tag for them?)

-------------------------------------------------------
package bugs;

public class ParameterizedTypeInPointcut {
	public static void main(String[] args) {
		C.go();
	}
	static class C {
		static void go() {}
	}
}

abstract aspect AA_ParameterizedTypeInPointcut&lt;Target&gt; {
	pointcut going() :call(void Target.go()) ;
	before() : going() {
		System.out.println("AA.going()");
	}
}
aspect A_ParameterizedTypeInPointcut extends 
AA_ParameterizedTypeInPointcut&lt;ParameterizedTypeInPointcut.C&gt;{
	declare warning : going() : "going()"; // works fine
	before() : going() { // advice not applied
		System.out.println("A.going()");
	}
}</description><comments/></buginformation><fixedCommits><commit id="86880f7281e04ed0c79781b5ddf2613821718b79" author="default" date="2005-11-23 19:21:03"><file name="weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java"><method name="parameterizeWith" returnType="ShadowMunger" parameters="ResolvedType"/></file><file name="weaver/src/org/aspectj/weaver/ReferenceType.java"><method name="ajMembersNeedParameterization" returnType="boolean" parameters=""/><method name="getAjMemberParameterizationMap" returnType="Map" parameters=""/></file><file name="weaver/src/org/aspectj/weaver/ResolvedType.java"><method name="getDeclaredAdvice" returnType="Collection" parameters=""/></file></commit></fixedCommits></bug><bug id="236" opendate="2005-11-17 12:31:00" fixdate="2005-11-24 09:27:06"><buginformation><summary>Using -verbose in aop.xml does not yield info messages</summary><description>The interpretation of the -verbose option for LTW is not consistent with other 
uses in AspectJ e.g. ajc, iajc. It should allow info as well as warining and 
error messages to be output. The option parser and testcase need to be updated.</description><comments/></buginformation><fixedCommits><commit id="76d7e83c7fdce7555ce9d9c6ca5bfaaf31d234db" author="default" date="2005-11-24 09:27:06"><file name="tests/src/org/aspectj/systemtest/ajc150/ataspectj/AtAjLTWTests.java"><method name="testLTWLog" returnType="void" parameters=""/></file><file name="loadtime/src/org/aspectj/weaver/loadtime/Options.java"><method name="parse" returnType="WeaverOption" parameters="String ClassLoader"/></file><file name="tests/java5/ataspectj/ataspectj/ltwlog/MessageHolder.java"><method name="ArrayList" returnType="List" parameters=""/></file></commit></fixedCommits></bug><bug id="237" opendate="2005-11-22 20:57:00" fixdate="2005-11-24 14:28:27"><buginformation><summary>ajc crashes on common-logging-1.0.4.jar</summary><description>--- Dump Properties ---
Dump file: ajcore.20051122.152749.326.txt
Dump reason: org.aspectj.weaver.BCException
Dump on exception: true
Dump at exit condition: abort
---- Exception Information ---
org.aspectj.weaver.BCException: bad resolve of void org.apache.log4j.Category.log(java.lang.String, org.apache.log4j.Level, java.lang.Object, java.lang.Throwable)
	at org.aspectj.weaver.World.getModifiers(World.java:216)
	at org.aspectj.weaver.Member.getModifiers(Member.java:406)
	at org.aspectj.weaver.patterns.KindedPointcut.warnOnConfusingSig(KindedPointcut.java:109)
	at org.aspectj.weaver.patterns.KindedPointcut.match(KindedPointcut.java:69)
	at org.aspectj.weaver.patterns.OrPointcut.match(OrPointcut.java:44)
	at org.aspectj.weaver.patterns.AndPointcut.match(AndPointcut.java:43)
	at org.aspectj.weaver.patterns.AndPointcut.match(AndPointcut.java:43)
	at org.aspectj.weaver.ShadowMunger.match(ShadowMunger.java:62)
	at org.aspectj.weaver.Advice.match(Advice.java:91)
	at org.aspectj.weaver.bcel.BcelClassWeaver.match(BcelClassWeaver.java:1126)
	at org.aspectj.weaver.bcel.BcelClassWeaver.matchInvokeInstruction(BcelClassWeaver.java:1115)
	at org.aspectj.weaver.bcel.BcelClassWeaver.match(BcelClassWeaver.java:987)
	at org.aspectj.weaver.bcel.BcelClassWeaver.match(BcelClassWeaver.java:827)
	at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:348)
	at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:83)
	at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:742)
	at org.aspectj.weaver.bcel.BcelWeaver.weaveWithoutDump(BcelWeaver.java:707)
	at org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify(BcelWeaver.java:634)
	at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:577)
	at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave(AjCompilerAdapter.java:243)
	at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling(AjCompilerAdapter.java:118)
	at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:383)
	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:680)
	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:168)
	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:102)
	at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:109)
	at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:60)
	at org.aspectj.tools.ajc.Main.run(Main.java:291)</description><comments/></buginformation><fixedCommits><commit id="6eb77c5a3b8328e67a047bc6410a858302a3c714" author="default" date="2005-11-24 14:28:27"><file name="weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"><method name="weaveAroundClosure" returnType="void" parameters="BcelAdvice boolean"/><method name="weaveAroundInline" returnType="void" parameters=""/></file><file name="weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java"><method name="collectCheckedExceptions" returnType="Collection" parameters="UnresolvedType[]"/></file><file name="weaver/src/org/aspectj/weaver/MissingResolvedTypeWithKnownSignature.java"><method name="raiseWarningOnMissingInterfaceWhilstFindingMethods" returnType="void" parameters=""/><method name="raiseCantFindType" returnType="void" parameters="String String"/><method name="raiseWarningOnJoinPointSignature" returnType="void" parameters="String"/><method name="raiseCantFindType" returnType="void" parameters="String"/></file><file name="weaver/src/org/aspectj/weaver/patterns/WithinAnnotationPointcut.java"><method name="matchInternal" returnType="FuzzyBoolean" parameters="Shadow"/></file><file name="weaver/src/org/aspectj/weaver/patterns/ArgsPointcut.java"><method name="findResidueNoEllipsis" returnType="Test" parameters="Shadow ExposedState"/></file><file name="weaver/src/org/aspectj/weaver/patterns/ArgsAnnotationPointcut.java"><method name="findResidueInternal" returnType="Test" parameters="Shadow ExposedState"/></file><file name="weaver/src/org/aspectj/weaver/patterns/WithinPointcut.java"><method name="matchInternal" returnType="FuzzyBoolean" parameters="Shadow"/></file><file name="weaver/src/org/aspectj/weaver/World.java"><method name="resolve" returnType="ResolvedType" parameters="UnresolvedType ISourceLocation"/></file><file name="weaver/src/org/aspectj/weaver/patterns/KindedPointcut.java"><method name="warnOnConfusingSig" returnType="void" parameters="Shadow"/></file><file name="tests/src/org/aspectj/systemtest/ajc150/GenericsTests.java"><method name="testSophisticatedAspectsX" returnType="void" parameters=""/></file></commit></fixedCommits></bug><bug id="238" opendate="2002-03-13 12:40:00" fixdate="2005-11-28 12:08:29"><buginformation><summary>[View Mgmt] Switching perspectives loses view maximized state</summary><description>1. Open the CVS repository view in the Java perspective.
2. Double click the title bar to maximize it
3. Switch to the resource perspective.
4. Come back to the Java perspective. The CVS repository view is no longer
maximized.

A view that is maximized should stay maximized.</description><comments/></buginformation><fixedCommits><commit id="508dbcbc90bc7526fc8cef9fe924a97c166e5a0e" author="default" date="2005-11-28 12:08:29"><file name="weaver/src/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateFactory.java"><method name="create15Delegate" returnType="ReflectionBasedReferenceTypeDelegate" parameters="ReferenceType Class ClassLoader World"/></file></commit></fixedCommits></bug><bug id="239" opendate="2005-11-28 20:24:00" fixdate="2005-11-29 19:35:57"><buginformation><summary>Use weaver's ClassLoader not the usingClassLoader in 1.5 factory</summary><description>In ReflectionBasedReferenceTypeDelegateFactory this line (44) of code is breaking my use of the weaver for looking up bootstrap classes (where the classloader is null and the AspectJ weaver isn't accessible to the bootstrap loader). The commented out code works just fine for me. 

Is there a real need to resolve the AspectJ runtime from a different classloader than the one that was already used to load this class from the AspectJ runtime?

			Class delegateClass = Class.forName("org.aspectj.weaver.reflect.Java15ReflectionBasedReferenceTypeDelegate",false,usingClassLoader);//ReflectionBasedReferenceTypeDelegate.class.getClassLoader());</description><comments/></buginformation><fixedCommits><commit id="d1a295c3205f87277ed9ae5b3dd70ca50e3a806e" author="default" date="2005-11-29 19:35:57"><file name="weaver/src/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateFactory.java"><method name="create15Delegate" returnType="ReflectionBasedReferenceTypeDelegate" parameters="ReferenceType Class ClassLoader World"/></file></commit></fixedCommits></bug><bug id="240" opendate="2005-10-05 14:34:00" fixdate="2005-11-30 17:23:35"><buginformation><summary>Produce a compile warning when default advice precedence is applied</summary><description>I propose that the compiler spit out a warning anytime that it has to apply 
the default advice precedence.  Also, it should spit out the recommendation 
that default ordering is not guaranteed from release to release of the 
compiler.

You can see the thread on aspectj-dev titled "change in runtime execution 
order" and the one on aspectj-users titled "AJDT 1.3 and aspectj" for the 
reasoning behind why this is a good thing.</description><comments/></buginformation><fixedCommits><commit id="2c8190702e95baf0489e384767c816f30d870c86" author="default" date="2005-11-30 17:23:35"><file name="tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"><method name="testBadRenderer_pr86903" returnType="void" parameters=""/></file><file name="weaver/src/org/aspectj/weaver/Shadow.java"><method name="sortMungers" returnType="void" parameters=""/></file></commit></fixedCommits></bug><bug id="241" opendate="2005-11-20 01:07:00" fixdate="2005-11-30 19:51:24"><buginformation><summary>Runtime error - Stack size too large, </summary><description>AspectJ compiler version: 1.5M5
AJDT plugin version: 1.3.0

This is the same error as reported by  Bug#69706 , even the bug is resolved I'm 
still experiencing problem by using the classes attached at the bottom.

// RUNTIME ERROR MESSAGE
========================
Exception in thread "main" java.lang.VerifyError: (class: 
DefaultInterfaceImplementationRecipe, method: &lt;clinit&gt; signature: ()V) Stack 
size too large
	at MyClass_ch16.main(MyClass_ch16.java:15)


// MyClass_ch16.java
====================
public class MyClass_ch16
{
        public void foo(int number, String name)
	{
		System.out.println("Inside foo (int, String) with args: " + 
number + ":" + name);
	}

	public static void main(String[] args)
	{
		// Create an instance of MyClass
		MyInterface_ch16 myObject = (MyInterface_ch16)new MyClass_ch16
();
		
		// Make the call to foo
		myObject.bar("Russ");
	}
}

//MyInterface_ch16.java
=======================
public interface MyInterface_ch16
{
	public void bar(String name);
}

// DefaultInterfaceImplementationRecipe.aj
==========================================
public aspect DefaultInterfaceImplementationRecipe
{
	declare parents : MyClass_ch16 implements MyInterface_ch16;
	
	// Declare the default implementation of the bar method
	public void MyInterface_ch16.bar(String name)
	{
		System.out.println("bar(String) called on " + this);
	}
}</description><comments/></buginformation><fixedCommits><commit id="551b9ca14c28b843c1dbbc14a48427bf4bb9f097" author="default" date="2005-11-30 19:51:24"><file name="tests/src/org/aspectj/systemtest/incremental/tools/AjdeInteractionTestbed.java"><method name="getNonStandardOptions" returnType="String" parameters=""/></file><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.java"><method name="installGlobals" returnType="void" parameters="AjBuildConfig"/></file><file name="tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java"><method name="testPr92837" returnType="void" parameters=""/></file></commit></fixedCommits></bug><bug id="242" opendate="2005-12-01 03:43:00" fixdate="2005-12-01 15:00:22"><buginformation><summary>[waiting-on-build]VerifyError in AspectJ</summary><description>I'm fairly new to AspectJ, so this is probably not going to be well explained. I've started working on a project that was working fine. Then I added methods to classes that take a 2-dimensional string array parameter and suddenly I'm getting a VerifyError exception.

java.lang.VerifyError: (class: com/drkw/cpds/obligor/facades/version_1_00/ObligorDetailFacade_1_00, method: searchForObligorSummariesByGroup_aroundBody24 signature: (Lcom/drkw/cpds/obligor/facades/version_1_00/ObligorDetailFacade_1_00;[[[Ljava/lang/String;Ljava/lang/String;Ljava脌(&amp;#130;
	at com.drkw.cpds.obligor.facades.version_1_00.obligor.ObligorManager.&lt;clinit&gt;(ObligorManager.java:48)
	at com.drkw.cpds.obligor.integration.version_1_00.obligor.GetObligorDetailsGroupingTest.testGetObligorDetailsUsingGroups(GetObligorDetailsGroupingTest.java:45)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)</description><comments/></buginformation><fixedCommits><commit id="a75b7fa48b233e41ed7aeb7d50fbdd411eadd8e6" author="default" date="2005-12-01 15:00:22"><file name="weaver/src/org/aspectj/weaver/World.java"><method name="resolve" returnType="ResolvedType" parameters="UnresolvedType boolean"/><method name="put" returnType="ResolvedType" parameters="String ResolvedType"/></file></commit></fixedCommits></bug><bug id="243" opendate="2005-11-30 15:18:00" fixdate="2005-12-02 11:06:37"><buginformation><summary>Not Allowing Access to Private ITD inside Nested Type</summary><description>AspectJ is failing to allow access to a private ITD field from a type nested inside the aspect, which is inconsistent with Java's access rules.

Here is the source. See also the follow up patch to tests that integrates it into the ajc150 test suite.

public aspect prUnknown {
    private static interface Marker {}   

    private class Foo implements Marker {
		public Foo() {
            bar = null; // allowed
            listener = null; // should also be allowed
            this.listener = null; // so should this
            Marker.this.listener = null; // and this
            ((Marker)this).listener = null; // and this
        }
    }

    private Object Marker.listener;
    private Object bar;
}</description><comments/></buginformation><fixedCommits><commit id="6d94d09c4bba8431d810019fe09e989fd026c3d1" author="default" date="2005-12-02 11:06:37"><file name="tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"><method name="testBadRenderer_pr86903" returnType="void" parameters=""/></file></commit></fixedCommits></bug><bug id="244" opendate="2005-11-27 01:01:00" fixdate="2005-12-06 03:20:59"><buginformation><summary>AspectJ compiler crahses possibly due to poincut context binding issue</summary><description>I am using the latest version of AJDT (1.3.0.20051125115230).


The reason is not entirely clear, but I have a pointcut of form 
    public pointcut realPC(Common entity)
    	: pc1(entity) || pc2(entity);

Just a few hours back, I used to get an error regarding incompatible binding
of entity in the || poincut. When I got that error, Eclipse was frozen to the 
point that clicking "Details" on exception report made Eclipse hang and 
had to kill it using the task manager. So I modified the program to avoid
|| expression in pointcut, after unsuccessfully trying various ways to 
express the pointcut. It was an ugly thing to do, since I essentially had to 
duplicate the advice for both pointcuts. Anyway...

Then I tried to reproduce on a smaller project to provide a minimal
program to reproduced the bug. However, it worked just fine on that project
(and I couldn't see any material difference in the pointcuts or the classes
involved). Encouraged by this, I retried the or-ed version of the pointcut
on the real project. This time, I get the crash and can acccess the stack
trace.

java.lang.NullPointerException
at org.aspectj.weaver.ast.Test.makeInstanceof(Test.java:78)
at org.aspectj.weaver.patterns.IfPointcut.findResidueInternal(IfPointcut.java:181)
at org.aspectj.weaver.patterns.Pointcut.findResidue(Pointcut.java:267)
at org.aspectj.weaver.patterns.AndPointcut.findResidueInternal(AndPointcut.java:97)
at org.aspectj.weaver.patterns.Pointcut.findResidue(Pointcut.java:267)
at org.aspectj.weaver.patterns.AndPointcut.findResidueInternal(AndPointcut.java:97)
at org.aspectj.weaver.patterns.Pointcut.findResidue(Pointcut.java:267)
at org.aspectj.weaver.patterns.OrPointcut.findResidueInternal(OrPointcut.java:99)
at org.aspectj.weaver.patterns.Pointcut.findResidue(Pointcut.java:267)
at org.aspectj.weaver.patterns.OrPointcut.findResidueInternal(OrPointcut.java:99)
at org.aspectj.weaver.patterns.Pointcut.findResidue(Pointcut.java:267)
at org.aspectj.weaver.bcel.BcelAdvice.specializeOn(BcelAdvice.java:133)
at org.aspectj.weaver.bcel.BcelShadow.prepareForMungers(BcelShadow.java:308)
at org.aspectj.weaver.Shadow.implement(Shadow.java:404)
at org.aspectj.weaver.bcel.BcelClassWeaver.implement(BcelClassWeaver.java:2146)
at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:467)
at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:102)
at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1534)
at org.aspectj.weaver.bcel.BcelWeaver.weaveWithoutDump(BcelWeaver.java:1485)
at org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify(BcelWeaver.java:1266)
at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1088)
at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave(AjCompilerAdapter.java:300)
at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling(AjCompilerAdapter.java:178)
at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$afterReturning$org_aspectj_ajdt_internal_compiler_CompilerAdapter$2$f9cc9ca0(CompilerAdapter.aj:70)
at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:367)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:809)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:230)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:156)
at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:122)
at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)

trouble in: 
public abstract class com.aspectivity.mgmt.web.entity.ManageEntity extends com.aspectivity.mgmt.web.TemplatePage:
  public void &lt;init&gt;(com.aspectivity.mgmt.model.Entity, boolean, String, String, String, String, String)    org.aspectj.weaver.MethodDeclarationLineNumber: 19:557
:
                    ALOAD_0     // com.aspectivity.mgmt.web.entity.ManageEntity this   (line 19)
                    INVOKESPECIAL com.aspectivity.mgmt.web.TemplatePage.&lt;init&gt; ()V
                    ALOAD_1
                    ASTORE 9
                    ILOAD_2
                    ISTORE 10
                    ALOAD_3
                    ASTORE 11
                    ALOAD 4
                    ASTORE 12
                    ALOAD 5
                    ASTORE 13
                    ALOAD 6
                    ASTORE 14
                    ALOAD 7
                    ASTORE 15
    constructor-execution(void com.aspectivity.mgmt.web.entity.ManageEntity.&lt;init&gt;(com.aspectivity.mgmt.model.Entity, boolean, java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String))
    |               ALOAD_0     // com.aspectivity.mgmt.web.entity.ManageEntity this   (line 23)
    |               ALOAD_3     // java.lang.String pageTitle
    |               INVOKEVIRTUAL com.aspectivity.mgmt.web.entity.ManageEntity.setPageTitle (Ljava/lang/String;)V
    |               ALOAD_0     // com.aspectivity.mgmt.web.entity.ManageEntity this   (line 25)
    |               ALOAD_0     // com.aspectivity.mgmt.web.entity.ManageEntity this
    |               ALOAD_1     // com.aspectivity.mgmt.model.Entity entity
    |               ALOAD 5     // java.lang.String addEntityLinkText
    |               INVOKEVIRTUAL com.aspectivity.mgmt.web.entity.ManageEntity.getEntitiesListView (Lcom/aspectivity/mgmt/model/Entity;Ljava/lang/String;)Lwicket/markup/html/list/ListView;
    |               INVOKEVIRTUAL com.aspectivity.mgmt.web.entity.ManageEntity.add (Lwicket/Component;)Lwicket/MarkupContainer;
    |               POP
    |               ALOAD_0     // com.aspectivity.mgmt.web.entity.ManageEntity this   (line 27)
    |               LDC "addEntityLink"
    |               ACONST_NULL
    |               INVOKEVIRTUAL com.aspectivity.mgmt.web.entity.ManageEntity.getEditLink (Ljava/lang/String;Lcom/aspectivity/mgmt/model/Entity;)Lwicket/markup/html/link/Link;
    |               ASTORE 8
    |               ALOAD_0     // com.aspectivity.mgmt.web.entity.ManageEntity this   (line 28)
    |               ALOAD 8     // wicket.markup.html.link.Link addEntityLink
    |               INVOKEVIRTUAL com.aspectivity.mgmt.web.entity.ManageEntity.add (Lwicket/Component;)Lwicket/MarkupContainer;
    |               POP
    |               ALOAD 8     // wicket.markup.html.link.Link addEntityLink   (line 29)
    |               NEW wicket.markup.html.basic.Label
    |               DUP
    |               LDC "addEntityLinkText"
    |               ALOAD 5     // java.lang.String addEntityLinkText
    |               INVOKESPECIAL wicket.markup.html.basic.Label.&lt;init&gt; (Ljava/lang/String;Ljava/lang/String;)V
    |               INVOKEVIRTUAL wicket.markup.html.link.Link.add (Lwicket/Component;)Lwicket/MarkupContainer;
    |               POP
    |               ILOAD_2     // boolean isInitialView   (line 31)
    |               IFEQ L0
    |               ALOAD_0     // com.aspectivity.mgmt.web.entity.ManageEntity this   (line 32)
    |               NEW wicket.markup.html.basic.Label
    |               DUP
    |               LDC "editEntity"
    |               LDC ""
    |               INVOKESPECIAL wicket.markup.html.basic.Label.&lt;init&gt; (Ljava/lang/String;Ljava/lang/String;)V
    |               INVOKEVIRTUAL com.aspectivity.mgmt.web.entity.ManageEntity.add (Lwicket/Component;)Lwicket/MarkupContainer;
    |               POP
    |               GOTO L1
    |           L0: ALOAD_0     // com.aspectivity.mgmt.web.entity.ManageEntity this   (line 34)
    |               ALOAD_0     // com.aspectivity.mgmt.web.entity.ManageEntity this
    |               ALOAD_1     // com.aspectivity.mgmt.model.Entity entity
    |               ILOAD_2     // boolean isInitialView
    |               ALOAD 6     // java.lang.String addPanelTtile
    |               ALOAD 7     // java.lang.String editPanelTitle
    |               INVOKESPECIAL com.aspectivity.mgmt.web.entity.ManageEntity.getEditPanel (Lcom/aspectivity/mgmt/model/Entity;ZLjava/lang/String;Ljava/lang/String;)Lwicket/Component;
    |               INVOKEVIRTUAL com.aspectivity.mgmt.web.entity.ManageEntity.add (Lwicket/Component;)Lwicket/MarkupContainer;
    |               POP
    |           L1: ALOAD_0     // com.aspectivity.mgmt.web.entity.ManageEntity this   (line 37)
    |               NEW wicket.markup.html.basic.Label
    |               DUP
    |               LDC "listViewTitle"
    |               ALOAD 4     // java.lang.String listViewTitle
    |               INVOKESPECIAL wicket.markup.html.basic.Label.&lt;init&gt; (Ljava/lang/String;Ljava/lang/String;)V
    |               INVOKEVIRTUAL com.aspectivity.mgmt.web.entity.ManageEntity.add (Lwicket/Component;)Lwicket/MarkupContainer;
    |               POP
    |               RETURN   (line 38)
    constructor-execution(void com.aspectivity.mgmt.web.entity.ManageEntity.&lt;init&gt;(com.aspectivity.mgmt.model.Entity, boolean, java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String))
  end public void &lt;init&gt;(com.aspectivity.mgmt.model.Entity, boolean, String, String, String, String, String)

  protected abstract com.aspectivity.mgmt.model.Entity createNewEntity()    org.aspectj.weaver.MethodDeclarationLineNumber: 40:1233
;

  protected abstract void removeEntity(com.aspectivity.mgmt.model.Entity)    org.aspectj.weaver.MethodDeclarationLineNumber: 41:1278
;

  protected abstract java.util.List getAllEntities()    org.aspectj.weaver.MethodDeclarationLineNumber: 42:1351
;

  protected abstract com.aspectivity.mgmt.web.entity.ManageEntity createNewPage(com.aspectivity.mgmt.model.Entity, boolean)    org.aspectj.weaver.MethodDeclarationLineNumber: 44:1406
;

  protected abstract wicket.Component createEditPanel(String, String, com.aspectivity.mgmt.model.Entity)    org.aspectj.weaver.MethodDeclarationLineNumber: 45:1490
;

  protected wicket.markup.html.list.ListView getEntitiesListView(com.aspectivity.mgmt.model.Entity, String)    org.aspectj.weaver.MethodDeclarationLineNumber: 47:1581
:
                    NEW com.aspectivity.mgmt.web.entity.EntityListView   (line 48)
                    DUP
                    ALOAD_0     // com.aspectivity.mgmt.web.entity.ManageEntity this
                    LDC "entityList"
                    ALOAD_0     // com.aspectivity.mgmt.web.entity.ManageEntity this
                    INVOKEVIRTUAL com.aspectivity.mgmt.web.entity.ManageEntity.getAllEntities ()Ljava/util/List;
                    ALOAD_1     // com.aspectivity.mgmt.model.Entity entity
                    INVOKESPECIAL com.aspectivity.mgmt.web.entity.EntityListView.&lt;init&gt; (Lcom/aspectivity/mgmt/web/entity/ManageEntity;Ljava/lang/String;Ljava/util/List;Lcom/aspectivity/mgmt/model/Entity;)V
                    ARETURN
  end protected wicket.markup.html.list.ListView getEntitiesListView(com.aspectivity.mgmt.model.Entity, String)

  protected wicket.markup.html.link.Link getEditLink(String, com.aspectivity.mgmt.model.Entity)    org.aspectj.weaver.MethodDeclarationLineNumber: 51:1743
:
                    NEW wicket.markup.html.link.PageLink   (line 52)
                    DUP
                    ALOAD_1     // java.lang.String name
                    NEW com.aspectivity.mgmt.web.entity.ManageEntity$1
                    DUP
                    ALOAD_0     // com.aspectivity.mgmt.web.entity.ManageEntity this
                    ALOAD_2     // com.aspectivity.mgmt.model.Entity entity
                    INVOKESPECIAL com.aspectivity.mgmt.web.entity.ManageEntity$1.&lt;init&gt; (Lcom/aspectivity/mgmt/web/entity/ManageEntity;Lcom/aspectivity/mgmt/model/Entity;)V
                    INVOKESPECIAL wicket.markup.html.link.PageLink.&lt;init&gt; (Ljava/lang/String;Lwicket/markup/html/link/IPageLink;)V
                    ARETURN
  end protected wicket.markup.html.link.Link getEditLink(String, com.aspectivity.mgmt.model.Entity)

  protected wicket.markup.html.link.Link getRemoveLink(String, wicket.markup.html.list.ListItem)    org.aspectj.weaver.MethodDeclarationLineNumber: 63:2013
:
                    NEW com.aspectivity.mgmt.web.entity.ManageEntity$2   (line 64)
                    DUP
                    ALOAD_0     // com.aspectivity.mgmt.web.entity.ManageEntity this
                    ALOAD_1     // java.lang.String id
                    ALOAD_2     // wicket.markup.html.list.ListItem item
                    INVOKESPECIAL com.aspectivity.mgmt.web.entity.ManageEntity$2.&lt;init&gt; (Lcom/aspectivity/mgmt/web/entity/ManageEntity;Ljava/lang/String;Lwicket/markup/html/list/ListItem;)V
                    ARETURN
  end protected wicket.markup.html.link.Link getRemoveLink(String, wicket.markup.html.list.ListItem)

  private wicket.Component getEditPanel(com.aspectivity.mgmt.model.Entity, boolean, String, String)    org.aspectj.weaver.MethodDeclarationLineNumber: 75:2376
:
                    ALOAD_1     // com.aspectivity.mgmt.model.Entity entity   (line 77)
                    IFNONNULL L0
                    ALOAD_3     // java.lang.String addPanelTtile
                    GOTO L1
                L0: ALOAD 4     // java.lang.String editPanelTitle
                L1: ASTORE 5
                    ALOAD_1     // com.aspectivity.mgmt.model.Entity entity   (line 78)
                    IFNONNULL L2
                    ALOAD_0     // com.aspectivity.mgmt.web.entity.ManageEntity this   (line 79)
                    INVOKEVIRTUAL com.aspectivity.mgmt.web.entity.ManageEntity.createNewEntity ()Lcom/aspectivity/mgmt/model/Entity;
                    ASTORE_1     // com.aspectivity.mgmt.model.Entity entity
                L2: ALOAD_0     // com.aspectivity.mgmt.web.entity.ManageEntity this   (line 81)
                    LDC "editEntity"
                    ALOAD 5     // java.lang.String panelTitle
                    ALOAD_1     // com.aspectivity.mgmt.model.Entity entity
                    INVOKEVIRTUAL com.aspectivity.mgmt.web.entity.ManageEntity.createEditPanel (Ljava/lang/String;Ljava/lang/String;Lcom/aspectivity/mgmt/model/Entity;)Lwicket/Component;
                    ARETURN
  end private wicket.Component getEditPanel(com.aspectivity.mgmt.model.Entity, boolean, String, String)

end public abstract class com.aspectivity.mgmt.web.entity.ManageEntity

when implementing on shadow constructor-execution(void com.aspectivity.mgmt.web.entity.ManageEntity.&lt;init&gt;(com.aspectivity.mgmt.model.Entity, boolean, java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String))
when weaving type com.aspectivity.mgmt.web.entity.ManageEntity
when weaving classes 
when weaving 
when batch building BuildConfig[C:\work\projects\workspace\.metadata\.plugins\org.eclipse.ajdt.core\Aspectivity.generated.lst] #Files=87</description><comments/></buginformation><fixedCommits><commit id="d43e74b5c919ebaef67a4b7551a464b8db3b289a" author="default" date="2005-12-06 03:20:59"><file name="weaver/src/org/aspectj/weaver/patterns/IfPointcut.java"><method name="findResidueInternal" returnType="Test" parameters="Shadow ExposedState"/></file></commit></fixedCommits></bug><bug id="245" opendate="2005-11-30 16:53:00" fixdate="2005-12-06 13:02:38"><buginformation><summary>Load Time Weaving wipes out Xlint files if no Xlint values</summary><description>In ClassLoaderWeavingAdaptor if weaverOption.lint is null, then a loaded Xlint properties file gets overwritten by the default Xlint properties. See attached patch to fix this problem.</description><comments/></buginformation><fixedCommits><commit id="1e1bbb3f2e7aab4757d715d76730cb68cceb3b87" author="default" date="2005-12-06 13:02:38"><file name="testing/newsrc/org/aspectj/testing/OutputSpec.java"><method name="matchAgainst" returnType="void" parameters="String"/></file><file name="testing/newsrc/org/aspectj/testing/RunSpec.java"><method name="execute" returnType="void" parameters="AjcTestCase"/></file><file name="weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java"><method name="warn" returnType="boolean" parameters="String Throwable"/></file><file name="loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"><method name="registerOptions" returnType="void" parameters="BcelWeaver ClassLoader"/></file><file name="testing/newsrc/org/aspectj/testing/XMLBasedAjcTestCase.java"><method name="getDigester" returnType="Digester" parameters=""/></file></commit></fixedCommits></bug><bug id="246" opendate="2005-12-05 23:04:00" fixdate="2005-12-06 15:39:08"><buginformation><summary>AjType.getSupertype breaks for null</summary><description>I ran into this while using reflection proxies with LTW... See attached patches for these test cases and my fix:

	public void testObjectSupertype() {
		AjType&lt;?&gt; objectSuper = AjTypeSystem.getAjType(Object.class).getSupertype();
		assertNull(objectSuper);		
	}

	public void testInterfaceSupertype() {
		AjType&lt;?&gt; serializableSuper = AjTypeSystem.getAjType(Serializable.class).getSupertype();
		assertNull(serializableSuper);		
	}
	
	public AjType&lt;? super T&gt; getSupertype() {
		Class&lt;? super T&gt; superclass = clazz.getSuperclass();
		return superclass==null ? null : (AjType&lt;? super T&gt;) new AjTypeImpl(superclass);
	}</description><comments/></buginformation><fixedCommits><commit id="6e8bf5292686224d2110cbf8c2184e2568bcabe3" author="default" date="2005-12-06 15:39:08"><file name="aspectj5rt/java5-testsrc/org/aspectj/internal/lang/reflect/AjTypeTests.java"><method name="testGetSupertype" returnType="void" parameters=""/></file><file name="aspectj5rt/java5-src/org/aspectj/internal/lang/reflect/AjTypeImpl.java"><method name="getModifiers" returnType="int" parameters=""/></file></commit></fixedCommits></bug><bug id="247" opendate="2005-09-15 09:57:00" fixdate="2005-12-08 11:43:16"><buginformation><summary>[waiting-on-build] [iajc.task] java.lang.RuntimeException: Ranges must be updated with an enclosing instructionList</summary><description>I am getting following error when compiling code using iajc ant task:


[iajc.task] trouble in:
[iajc.task] public class admin.modelbean.AdminUserMB extends web.FormSupport:
[iajc.task]   private static final org.apache.log4j.Logger log
....

(Ljava/lang/String;)Ljava/lang/StringBuffer;
[iajc.task]     | method-call(java.lang.StringBuffer
java.lang.StringBuffer.append(java.lang.String))
[iajc.task]     |               LDC_W "}"   (line 249)
[iajc.task]     | method-call(java.lang.StringBuffer
java.lang.StringBuffer.append(java.lang.String))
[iajc.task]     | |             INVOKEVIRTUAL java.lang.StringBuffer.append
(Ljava/lang/String;)Ljava/lang/StringBuffer;
[iajc.task]     | method-call(java.lang.StringBuffer
java.lang.StringBuffer.append(java.lang.String))
[iajc.task]     | method-call(java.lang.String java.lang.StringBuffer.toString())
[iajc.task]     | |             INVOKEVIRTUAL java.lang.StringBuffer.toString
()Ljava/lang/String;   (line 236)
[iajc.task]     | method-call(java.lang.String java.lang.StringBuffer.toString())
[iajc.task]     |               ARETURN
[iajc.task]     method-execution(java.lang.String
admin.modelbean.AdminUserMB.toString())
[iajc.task]   end public String toString()
[iajc.task] end public class admin.modelbean.AdminUserMB
[iajc.task] java.lang.RuntimeException: Ranges must be updated with an enclosing
instructionList
[iajc.task]     at org.aspectj.weaver.bcel.Range.updateTarget(Range.java:170)
[iajc.task]     at
org.aspectj.weaver.bcel.BcelShadow.retargetFrom(BcelShadow.java:235)
[iajc.task]     at
org.aspectj.weaver.bcel.BcelShadow.deleteNewAndDup(BcelShadow.java:212)
[iajc.task]     at
org.aspectj.weaver.bcel.BcelShadow.prepareForMungers(BcelShadow.java:252)
[iajc.task]     at org.aspectj.weaver.Shadow.implement(Shadow.java:374)
[iajc.task]     at
org.aspectj.weaver.bcel.BcelClassWeaver.implement(BcelClassWeaver.java:1754)
[iajc.task]     at
org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:393)
[iajc.task]     at
org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:96)
[iajc.task]     at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1372)
[iajc.task]     at
org.aspectj.weaver.bcel.BcelWeaver.weaveWithoutDump(BcelWeaver.java:1337)
[iajc.task]     at
org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify(BcelWeaver.java:1114)
[iajc.task]     at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1001)
[iajc.task]     at
org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave(AjCompilerAdapter.java:286)
[iajc.task]     at
org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling(AjCompilerAdapter.java:165)
[iajc.task]     at
org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$afterReturning$org_aspectj_ajdt_internal_compiler_CompilerAdapter$2$f9cc9ca0(CompilerAdapter.aj:70)
[iajc.task]     at
org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:367)
[iajc.task]     at
org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:728)
[iajc.task]     at
org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:206)
[iajc.task]     at
org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:140)
[iajc.task]     at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:112)
[iajc.task]     at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:60)
[iajc.task]     at org.aspectj.tools.ajc.Main.run(Main.java:324)
[iajc.task]     at org.aspectj.tools.ajc.Main.runMain(Main.java:238)
[iajc.task]     at org.aspectj.tools.ajc.Main.main(Main.java:82)
[iajc.task] ABORT
[iajc.task]
[iajc.task] Exception thrown from AspectJ 1.5.0_M3a

[iajc.task] This might be logged as a bug already -- find current bugs at
[iajc.task]  
 http://bugs.eclipse.org/bugs/buglist.cgi?product=AspectJ&amp;component=Compiler 

[iajc.task] Bugs for exceptions thrown have titles File:line from the top stack,
[iajc.task] e.g., "SomeFile.java:243"

[iajc.task] If you don't find the exception below in a bug, please add a new bug
[iajc.task] at  http://bugs.eclipse.org/bugs/enter_bug.cgi?product=AspectJ 
[iajc.task] To make the bug a priority, please include a test program
[iajc.task] that can reproduce this exception.
[iajc.task] Ranges must be updated with an enclosing instructionList
[iajc.task] Ranges must be updated with an enclosing instructionList
[iajc.task] java.lang.RuntimeException: Ranges must be updated with an enclosing
instructionList
[iajc.task]     at org.aspectj.weaver.bcel.Range.updateTarget(Range.java:170)
[iajc.task]     at
org.aspectj.weaver.bcel.BcelShadow.retargetFrom(BcelShadow.java:235)
[iajc.task]     at
org.aspectj.weaver.bcel.BcelShadow.deleteNewAndDup(BcelShadow.java:212)
[iajc.task]     at
org.aspectj.weaver.bcel.BcelShadow.prepareForMungers(BcelShadow.java:252)
[iajc.task]     at org.aspectj.weaver.Shadow.implement(Shadow.java:374)
[iajc.task]     at
org.aspectj.weaver.bcel.BcelClassWeaver.implement(BcelClassWeaver.java:1754)
[iajc.task]     at
org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:393)
[iajc.task]     at
org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:96)
[iajc.task]     at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1372)
[iajc.task]     at
org.aspectj.weaver.bcel.BcelWeaver.weaveWithoutDump(BcelWeaver.java:1337)
[iajc.task]     at
org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify(BcelWeaver.java:1114)
[iajc.task]     at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1001)
[iajc.task]     at
org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave(AjCompilerAdapter.java:286)
[iajc.task]     at
org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling(AjCompilerAdapter.java:165)
[iajc.task]     at
org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$afterReturning$org_aspectj_ajdt_internal_compiler_CompilerAdapter$2$f9cc9ca0(CompilerAdapter.aj:70)
[iajc.task]     at
org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:367)
[iajc.task]     at
org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:728)
[iajc.task]     at
org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:206)
[iajc.task]     at
org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:140)
[iajc.task]     at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:112)
[iajc.task]     at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:60)
[iajc.task]     at org.aspectj.tools.ajc.Main.run(Main.java:324)
[iajc.task]     at org.aspectj.tools.ajc.Main.runMain(Main.java:238)
[iajc.task]     at org.aspectj.tools.ajc.Main.main(Main.java:82)


[iajc.task] 1 fail|abort

BUILD FAILED
/home/sbhatti/workspace/devint/build.xml:100: The following error occurred while
executing this line:
/home/sbhatti/workspace/devint/build.xml:164: The following error occurred while
executing this line:
/home/sbhatti/workspace/devint/modules/novo/build.xml:59: The following error
occurred while executing this line:
/opt/sbhatti/dev/current/novo/build.xml:326: failure[-1] running ajc</description><comments/></buginformation><fixedCommits><commit id="94159f9e80233497e02899c91a126ea5a3b605cc" author="default" date="2005-12-08 11:43:16"><file name="weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"><method name="deleteNewAndDup" returnType="void" parameters=""/><method name="retargetFrom" returnType="void" parameters="InstructionHandle InstructionHandle"/></file></commit></fixedCommits></bug><bug id="248" opendate="2005-12-05 23:11:00" fixdate="2005-12-09 08:40:12"><buginformation><summary>Inconsistent Implementations of ReferenceType.getDeclaredMethods()</summary><description>I am running into a problem in load-time weaving when I use reflection delegates because the weaver is generating an incorrect bridge method when I perform an inter-type declaration on Struts.ActionServlet for the init method. On investigation, the BCEL world is recognizing this as an overriding method, because its version of getDeclaredMethods is returning the declared methods for all ancestor superclasses. However, the reflection world is returning only the declared methods for this one class. It therefore appears that the weaver expects getDeclaredMethods to return all of them (making the name quite misleading). I think previously the method was being implemented inconsistently between 1.5 reflection and &lt;1.5 reflection delegates. But it looks like it needs to be handled consistently to include all superclass methods.

However, I don鈥檛 know what other places (e.g., the MAP) are really expecting getDeclaredMethods and its siblings to behave like Java reflection's version鈥

I started work on adding a getAllDeclaredMethods method to ReferenceType and delegates, as an alternative to provide the weaver the ability to check method overriding as in this case, but it's a little bit involved and I wanted to flag the issue first.

Here's a test that fails and illustrates the issue:
Index: ReflectionBasedReferenceTypeDelegateTest.java
===================================================================
RCS file: /home/technology/org.aspectj/modules/weaver/testsrc/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateTest.java,v
retrieving revision 1.5
diff -u -r1.5 ReflectionBasedReferenceTypeDelegateTest.java
--- ReflectionBasedReferenceTypeDelegateTest.java	28 Nov 2005 17:44:40 -0000	1.5
+++ ReflectionBasedReferenceTypeDelegateTest.java	6 Dec 2005 04:11:41 -0000
@@ -238,6 +238,18 @@
         assertTrue("Superclass for Map generic type should be Object but was "+rt2,rt2.equals(UnresolvedType.OBJECT));         
     }
     
+    public void testCompareSubclassDelegates() {
+        world.setBehaveInJava5Way(true);
+        
+        BcelWorld bcelWorld = new BcelWorld();
+        bcelWorld.setBehaveInJava5Way(true);
+        UnresolvedType javaUtilHashMap = UnresolvedType.forName("java.util.HashMap");
+        ReferenceType rawType = (ReferenceType)bcelWorld.resolve(javaUtilHashMap );
+        
+        ReferenceType rawReflectType = (ReferenceType)world.resolve(javaUtilHashMap );
+        assertEquals(rawType.getDelegate().getDeclaredMethods().length, rawReflectType.getDelegate().getDeclaredMethods().length);
+    }
+    
 	// todo: array of int	
 
 	protected void setUp() throws Exception {


This results in:
junit.framework.AssertionFailedError: expected:&lt;41&gt; but was:&lt;29&gt;
	at junit.framework.Assert.fail(Assert.java:47)
	at junit.framework.Assert.failNotEquals(Assert.java:282)
	at junit.framework.Assert.assertEquals(Assert.java:64)
	at junit.framework.Assert.assertEquals(Assert.java:201)
	at junit.framework.Assert.assertEquals(Assert.java:207)
	at org.aspectj.weaver.reflect.ReflectionBasedReferenceTypeDelegateTest.testCompareSubclassDelegates(ReflectionBasedReferenceTypeDelegateTest.java:250)
	at java.lang.reflect.Method.invoke(Native Method)
	at junit.framework.TestCase.runTest(TestCase.java:154)
	at junit.framework.TestCase.runBare(TestCase.java:127)
	at junit.framework.TestResult$1.protect(TestResult.java:106)
	at junit.framework.TestResult.runProtected(TestResult.java:124)
	at junit.framework.TestResult.run(TestResult.java:109)
	at junit.framework.TestCase.run(TestCase.java:118)
	at junit.framework.TestSuite.runTest(TestSuite.java:208)
	at junit.framework.TestSuite.run(TestSuite.java:203)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:478)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:344)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196)</description><comments/></buginformation><fixedCommits><commit id="b52515fc2319ca34a045a0823ca0f5c8ffeaa2de" author="default" date="2005-12-09 08:40:12"><file name="weaver/testsrc/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateTest.java"><method name="testGetDeclaredMethods" returnType="void" parameters=""/></file><file name="weaver/src/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateFactory.java"><method name="createResolvedConstructor" returnType="ResolvedMember" parameters="Constructor"/></file><file name="weaver5/java5-src/org/aspectj/weaver/reflect/Java15ReflectionBasedReferenceTypeDelegate.java"><method name="createGenericConstructorMember" returnType="ResolvedMember" parameters=""/></file></commit></fixedCommits></bug><bug id="249" opendate="2005-12-06 12:39:00" fixdate="2005-12-09 10:32:57"><buginformation><summary>AJDoc produces incorrect warning for package accessed aspects</summary><description>// Main.java
package bug;

public class Main {
}

aspect LogMain {
	
}

Generating ajdoc through Eclipse (AJDT 1.3.0.20051206092602, AspectJ 1.5.0.20051206103951) generate incorrect warning for the LogMain aspect:

 &gt; Calling ajc...
&gt; Building signature files...
&gt; Calling javadoc... 
Loading source file C:\work\aop\src\ajdocworkingdir\bug\Main.java...
Constructing Javadoc information...
C:\work\aop\src\ajdocworkingdir\bug\Main.java:11: class LogMain is public, should be declared in a file named LogMain.java
public class  LogMain {
       ^
Standard Doclet version 1.5.0_04
Building tree for all the packages and classes...
Generating c:\work\aop\src\workspace\AJDocPackageAspect\doc\bug/\LogMain.html...
Generating c:\work\aop\src\workspace\AJDocPackageAspect\doc\bug/\Main.html...
Generating c:\work\aop\src\workspace\AJDocPackageAspect\doc\bug/\package-frame.html...
Generating c:\work\aop\src\workspace\AJDocPackageAspect\doc\bug/\package-summary.html...
Generating c:\work\aop\src\workspace\AJDocPackageAspect\doc\bug/\package-tree.html...
Generating c:\work\aop\src\workspace\AJDocPackageAspect\doc\constant-values.html...
Building index for all the packages and classes...
Generating c:\work\aop\src\workspace\AJDocPackageAspect\doc\overview-tree.html...
Generating c:\work\aop\src\workspace\AJDocPackageAspect\doc\index-all.html...
Generating c:\work\aop\src\workspace\AJDocPackageAspect\doc\deprecated-list.html...
Building index for all classes...
Generating c:\work\aop\src\workspace\AJDocPackageAspect\doc\allclasses-frame.html...
Generating c:\work\aop\src\workspace\AJDocPackageAspect\doc\allclasses-noframe.html...
Generating c:\work\aop\src\workspace\AJDocPackageAspect\doc\index.html...
Generating c:\work\aop\src\workspace\AJDocPackageAspect\doc\help-doc.html...
Generating c:\work\aop\src\workspace\AJDocPackageAspect\doc\stylesheet.css...
1 warning
 &gt; Decorating html files...
&gt; Decorating C:\work\aop\src\workspace\AJDocPackageAspect\doc\bug\Main.html...
&gt; Removing generated tags (this may take a while)...
&gt; Finished.</description><comments/></buginformation><fixedCommits><commit id="5f8d2cdff480ac9d04cc73a4a69eb11563a0bb01" author="default" date="2005-12-09 10:32:57"><file name="ajde/testsrc/org/aspectj/ajde/AsmDeclarationsTest.java"><method name="testAspectAccessibility" returnType="void" parameters=""/></file><file name="ajdoc/src/org/aspectj/tools/ajdoc/StubFileGenerator.java"><method name="genSourceSignature" returnType="String" parameters="IProgramElement"/></file><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectDeclaration.java"><method name="printHeader" returnType="StringBuffer" parameters="int StringBuffer"/></file></commit></fixedCommits></bug><bug id="250" opendate="2005-12-12 05:17:00" fixdate="2005-12-12 10:48:46"><buginformation><summary>cflowbelow issue when binding, in @AJ</summary><description>Sam wrote:

 &gt; I'm trying something and it works from .aj but not from .java.  When
&gt; I try it with annotation based stuff I get a nasty exception: 
&gt;
 &gt;       [iajc] trouble in:
&gt;       [iajc] public class gsc.repository.IdentifierTest extends
&gt; junit.framework.TestCase:
&gt;       [iajc]   private static final org.aspectj.lang.JoinPoint
&gt; $StaticPart ajc$tjp_0
&gt;       [iajc]   public void &lt;init&gt;():
&gt;       [iajc]                     ALOAD_0
&gt;       [iajc]                     INVOKESPECIAL
&gt; junit.framework.TestCase.&lt;init&gt; ()V
&gt;       [iajc]     constructor-execution(void
&gt; gsc.repository.IdentifierTest.&lt;init&gt;())
&gt;       [iajc]     |               RETURN
&gt;       [iajc]     constructor-execution(void
&gt; gsc.repository.IdentifierTest.&lt;init&gt;())
&gt;       [iajc]   end public void &lt;init&gt;() 
&gt;
 &gt;       [iajc]   public void testIdentifierExactMatch() throws
&gt; java.security.NoSuchAlgorithmException, java.io.IOException:
&gt;       [iajc]     method-execution(void
&gt; gsc.repository.IdentifierTest.testIdentifierExactMatch())
&gt;       [iajc]     |               NEW java.io.File
&gt;       [iajc]     |               DUP
&gt;       [iajc]     |               LDC "test-repository/ant-test/jars/
&gt; ant-1.6.2.jar"
&gt;       [iajc]     |               INVOKESPECIAL java.io.File.&lt;init&gt;
&gt; (Ljava/lang/String;)V
&gt;       [iajc]     |               INVOKESTATIC
&gt; gsc.repository.Identifier.interrogate (Ljava/io/File;)Ljava/util/List;
&gt;       [iajc]     |               ASTORE_1
&gt;       [iajc]     |               ALOAD_1
&gt;       [iajc]     |               ICONST_0
&gt;       [iajc]     |               INVOKEINTERFACE java.util.List.get
&gt; (I)Ljava/lang/Object;
&gt;       [iajc]     |               CHECKCAST gsc.repository.ejb.Jar
&gt;       [iajc]     |               ASTORE_2
&gt;       [iajc]     |               ALOAD_2
&gt;       [iajc]     |               INVOKEVIRTUAL
&gt; gsc.repository.ejb.Jar.getVersion ()Ljava/lang/String;
&gt;       [iajc]     |               LDC "1.6.2"
&gt;       [iajc]     |               INVOKESTATIC
&gt; gsc.repository.IdentifierTest.assertEquals (Ljava/lang/String;Ljava/
&gt; lang/String;)V
&gt;       [iajc]     |               RETURN
&gt;       [iajc]     method-execution(void
&gt; gsc.repository.IdentifierTest.testIdentifierExactMatch())
&gt;       [iajc]   end public void testIdentifierExactMatch() throws
&gt; java.security.NoSuchAlgorithmException, java.io.IOException 
&gt;
 &gt;       [iajc]   public void testIdentifierExactSameClasses() throws
&gt; java.security.NoSuchAlgorithmException, java.io.IOException:
&gt;       [iajc]     method-execution(void
&gt; gsc.repository.IdentifierTest.testIdentifierExactSameClasses())
&gt;       [iajc]     |               NEW java.io.File
&gt;       [iajc]     |               DUP
&gt;       [iajc]     |               LDC "test-jars/ant-1.6.2-test.jar"
&gt;       [iajc]     |               INVOKESPECIAL java.io.File.&lt;init&gt;
&gt; (Ljava/lang/String;)V
&gt;       [iajc]     |               INVOKESTATIC
&gt; gsc.repository.Identifier.interrogate (Ljava/io/File;)Ljava/util/List;
&gt;       [iajc]     |               ASTORE_1
&gt;       [iajc]     |               ALOAD_1
&gt;       [iajc]     |               ICONST_0
&gt;       [iajc]     |               INVOKEINTERFACE java.util.List.get
&gt; (I)Ljava/lang/Object;
&gt;       [iajc]     |               CHECKCAST gsc.repository.ejb.Jar
&gt;       [iajc]     |               ASTORE_2
&gt;       [iajc]     |               ALOAD_2
&gt;       [iajc]     |               INVOKEVIRTUAL
&gt; gsc.repository.ejb.Jar.getVersion ()Ljava/lang/String;
&gt;       [iajc]     |               LDC "1.6.2"
&gt;       [iajc]     |               INVOKESTATIC
&gt; gsc.repository.IdentifierTest.assertEquals (Ljava/lang/String;Ljava/
&gt; lang/String;)V
&gt;       [iajc]     |               RETURN
&gt;       [iajc]     method-execution(void
&gt; gsc.repository.IdentifierTest.testIdentifierExactSameClasses())
&gt;       [iajc]   end public void testIdentifierExactSameClasses()
&gt; throws java.security.NoSuchAlgorithmException, java.io.IOException 
&gt;
 &gt;       [iajc]   public void testIdentifierMixedUp() throws
&gt; java.security.NoSuchAlgorithmException, java.io.IOException:
&gt;       [iajc]     method-execution(void
&gt; gsc.repository.IdentifierTest.testIdentifierMixedUp())
&gt;       [iajc]     |               NEW java.io.File
&gt;       [iajc]     |               DUP
&gt;       [iajc]     |               LDC "test-jars/groovy-1.0-beta-4-and-
&gt; commons-logging-1.0.2.jar"
&gt;       [iajc]     |               INVOKESPECIAL java.io.File.&lt;init&gt;
&gt; (Ljava/lang/String;)V
&gt;       [iajc]     |               INVOKESTATIC
&gt; gsc.repository.Identifier.interrogate (Ljava/io/File;)Ljava/util/List;
&gt;       [iajc]     |               ASTORE_1
&gt;       [iajc]     |               ALOAD_1
&gt;       [iajc]     |               INVOKEINTERFACE java.util.List.size ()I
&gt;       [iajc]     |               ICONST_2
&gt;       [iajc]     |               INVOKESTATIC
&gt; gsc.repository.IdentifierTest.assertEquals (II)V
&gt;       [iajc]     |               ICONST_2
&gt;       [iajc]     |               ISTORE_2
&gt;       [iajc]     |               ALOAD_1
&gt;       [iajc]     |               INVOKEINTERFACE
&gt; java.util.List.iterator ()Ljava/util/Iterator;
&gt;       [iajc]     |               ASTORE_3
&gt;       [iajc]     |           L0: ALOAD_3
&gt;       [iajc]     |               INVOKEINTERFACE
&gt; java.util.Iterator.hasNext ()Z
&gt;       [iajc]     |               IFEQ L3
&gt;       [iajc]     |               ALOAD_3
&gt;       [iajc]     |               INVOKEINTERFACE
&gt; java.util.Iterator.next ()Ljava/lang/Object;
&gt;       [iajc]     |               CHECKCAST gsc.repository.ejb.Jar
&gt;       [iajc]     |               ASTORE 4
&gt;       [iajc]     |               ALOAD 4
&gt;       [iajc]     |               INVOKEVIRTUAL
&gt; gsc.repository.ejb.Jar.getGroupid ()Ljava/lang/String;
&gt;       [iajc]     |               LDC "groovy"
&gt;       [iajc]     |               INVOKEVIRTUAL
&gt; java.lang.String.equals (Ljava/lang/Object;)Z
&gt;       [iajc]     |               IFEQ L1
&gt;       [iajc]     |               ALOAD 4
&gt;       [iajc]     |               INVOKEVIRTUAL
&gt; gsc.repository.ejb.Jar.getGroupid ()Ljava/lang/String;
&gt;       [iajc]     |               LDC "groovy"
&gt;       [iajc]     |               INVOKESTATIC
&gt; gsc.repository.IdentifierTest.assertEquals (Ljava/lang/String;Ljava/
&gt; lang/String;)V
&gt;       [iajc]     |               ALOAD 4
&gt;       [iajc]     |               INVOKEVIRTUAL
&gt; gsc.repository.ejb.Jar.getArtifactid ()Ljava/lang/String;
&gt;       [iajc]     |               LDC "groovy"
&gt;       [iajc]     |               INVOKESTATIC
&gt; gsc.repository.IdentifierTest.assertEquals (Ljava/lang/String;Ljava/
&gt; lang/String;)V
&gt;       [iajc]     |               ALOAD 4
&gt;       [iajc]     |               INVOKEVIRTUAL
&gt; gsc.repository.ejb.Jar.getVersion ()Ljava/lang/String;
&gt;       [iajc]     |               LDC "1.0-beta-4"
&gt;       [iajc]     |               INVOKESTATIC
&gt; gsc.repository.IdentifierTest.assertEquals (Ljava/lang/String;Ljava/
&gt; lang/String;)V
&gt;       [iajc]     |               IINC 2 -1
&gt;       [iajc]     |               GOTO L2
&gt;       [iajc]     |           L1: ALOAD 4
&gt;       [iajc]     |               INVOKEVIRTUAL
&gt; gsc.repository.ejb.Jar.getGroupid ()Ljava/lang/String;
&gt;       [iajc]     |               LDC "commons-logging"
&gt;       [iajc]     |               INVOKESTATIC
&gt; gsc.repository.IdentifierTest.assertEquals (Ljava/lang/String;Ljava/
&gt; lang/String;)V
&gt;       [iajc]     |               ALOAD 4
&gt;       [iajc]     |               INVOKEVIRTUAL
&gt; gsc.repository.ejb.Jar.getArtifactid ()Ljava/lang/String;
&gt;       [iajc]     |               LDC "commons-logging"
&gt;       [iajc]     |               INVOKESTATIC
&gt; gsc.repository.IdentifierTest.assertEquals (Ljava/lang/String;Ljava/
&gt; lang/String;)V
&gt;       [iajc]     |               ALOAD 4
&gt;       [iajc]     |               INVOKEVIRTUAL
&gt; gsc.repository.ejb.Jar.getVersion ()Ljava/lang/String;
&gt;       [iajc]     |               LDC "1.0.2"
&gt;       [iajc]     |               INVOKESTATIC
&gt; gsc.repository.IdentifierTest.assertEquals (Ljava/lang/String;Ljava/
&gt; lang/String;)V
&gt;       [iajc]     |               IINC 2 -1
&gt;       [iajc]     |           L2: GOTO L0
&gt;       [iajc]     |           L3: ILOAD_2
&gt;       [iajc]     |               ICONST_0
&gt;       [iajc]     |               INVOKESTATIC
&gt; gsc.repository.IdentifierTest.assertEquals (II)V
&gt;       [iajc]     |               RETURN
&gt;       [iajc]     method-execution(void
&gt; gsc.repository.IdentifierTest.testIdentifierMixedUp())
&gt;       [iajc]   end public void testIdentifierMixedUp() throws
&gt; java.security.NoSuchAlgorithmException, java.io.IOException 
&gt;
 &gt;       [iajc] end public class gsc.repository.IdentifierTest 
&gt;
 &gt;       [iajc]
&gt;       [iajc] Exception thrown from AspectJ 1.5.0M5 
&gt;
 &gt;       [iajc] This might be logged as a bug already -- find current
&gt; bugs at
&gt;       [iajc]    http://bugs.eclipse.org/bugs/buglist.cgi ?
&gt; product=AspectJ&amp;component=Compiler 
&gt;
 &gt;       [iajc] Bugs for exceptions thrown have titles File:line from
&gt; the top stack,
&gt;       [iajc] e.g., "SomeFile.java:243" 
&gt;
 &gt;       [iajc] If you don't find the exception below in a bug, please
&gt; add a new bug
&gt;       [iajc] at  http://bugs.eclipse.org/bugs/enter_bug.cgi ?
&gt; product=AspectJ
&gt;       [iajc] To make the bug a priority, please include a test program
&gt;       [iajc] that can reproduce this exception.
&gt;       [iajc] Incorrectly attempting counter operation on stacked cflow 
&gt;
 &gt;       [iajc] when implementing on shadow method-execution(void
&gt; gsc.repository.IdentifierTest.testIdentifierExactMatch())
&gt;       [iajc] when weaving type gsc.repository.IdentifierTest
&gt;       [iajc] when weaving classes
&gt;       [iajc] when weaving
&gt;       [iajc] when batch building with classpath: /Users/sam/Library/
&gt; Java/Extensions/jsk-policy.jar:/System/Library/Java/Extensions/
&gt; CoreAudio.jar:/System/Library/Java/Extensions/dns_sd.jar:/System/
&gt; Library/Java/Extensions/j3daudio.jar:/System/Library/Java/Extensions/
&gt; j3dcore.jar:/System/Library/Java/Extensions/j3dutils.jar:/System/
&gt; Library/Java/Extensions/jai_codec.jar:/System/Library/Java/Extensions/
&gt; jai_core.jar:/System/Library/Java/Extensions/mlibwrapper_jai.jar:/
&gt; System/Library/Java/Extensions/MRJToolkit.jar:/System/Library/Java/
&gt; Extensions/QTJava.zip:/System/Library/Java/Extensions/QTJSupport.jar:/
&gt; System/Library/Java/Extensions/vecmath.jar:/System/Library/Frameworks/
&gt; JavaVM.framework/Versions/1.5.0/Home/lib/ext/apple_provider.jar:/
&gt; System/Library/Frameworks/JavaVM.framework/Versions/1.5.0/Home/lib/
&gt; ext/dnsns.jar:/System/Library/Frameworks/JavaVM.framework/Versions/
&gt; 1.5.0/Home/lib/ext/localedata.jar:/System/Library/Frameworks/
&gt; JavaVM.framework/Versions/1.5.0/Home/lib/ext/sunjce_provider.jar:/
&gt; Users/sam/gs/squire/jardb/.aspectj-lib/aspectjrt-1.5.0_M5.jar:/Users/
&gt; sam/gs/squire/jardb/.aspectj-lib/aspectjtools-1.5.0_M5.jar:/Users/sam/
&gt; gs/squire/jardb/target/classes:/Users/sam/gs/squire/jardb/target/test-
&gt; classes:/Users/sam/gs/squire/jardb/.lib/antlr-2.7.5.jar:/Users/sam/gs/
&gt; squire/jardb/.lib/asm-1.5.3.jar:/Users/sam/gs/squire/jardb/.lib/
&gt; cglib-2.1_2.jar:/Users/sam/gs/squire/jardb/.lib/commons-
&gt; collections-2.1.1.jar:/Users/sam/gs/squire/jardb/.lib/commons-
&gt; logging-1.0.4.jar:/Users/sam/gs/squire/jardb/.lib/dom4j-1.6.jar:/
&gt; Users/sam/gs/squire/jardb/.lib/ehcache-1.1.jar:/Users/sam/gs/squire/
&gt; jardb/.lib/ejb3-persistence-pr.jar:/Users/sam/gs/squire/jardb/.lib/
&gt; emma-2.0.latest.jar:/Users/sam/gs/squire/jardb/.lib/
&gt; emma_ant-2.0.latest.jar:/Users/sam/gs/squire/jardb/.lib/
&gt; hibernate-3.1alpha1.jar:/Users/sam/gs/squire/jardb/.lib/hibernate-
&gt; annotations-3.1beta3.jar:/Users/sam/gs/squire/jardb/.lib/hibernate-
&gt; entitymanager-3.1beta1.jar:/Users/sam/gs/squire/jardb/.lib/
&gt; jta-1.0.jar:/Users/sam/gs/squire/jardb/.lib/junit-3.8.1.jar:/Users/
&gt; sam/gs/squire/jardb/.lib/postgresql-7.4.1-jdbc3.jar:/Users/sam/gs/
&gt; squire/jardb/.lib/svn-javahl-1.2.0.jar:/Users/sam/gs/squire/jardb/lib/
&gt; testng-4.2-jdk15.jar:/Users/sam/gs/squire/jardb/target/aspects.jar:
&gt;       [iajc] Incorrectly attempting counter operation on stacked cflow
&gt;       [iajc] java.lang.RuntimeException: Incorrectly attempting
&gt; counter operation on stacked cflow
&gt;       [iajc]     at org.aspectj.weaver.bcel.BcelShadow.weaveCflowEntry
&gt; (BcelShadow.java:1890)
&gt;       [iajc]     at org.aspectj.weaver.bcel.BcelAdvice.implementOn
&gt; (BcelAdvice.java:231)
&gt;       [iajc]     at org.aspectj.weaver.Shadow.implementMungers
&gt; (Shadow.java:514)
&gt;       [iajc]     at org.aspectj.weaver.Shadow.implement(Shadow.java:391)
&gt;       [iajc]     at org.aspectj.weaver.bcel.BcelClassWeaver.implement
&gt; (BcelClassWeaver.java:2142)
&gt;       [iajc]     at org.aspectj.weaver.bcel.BcelClassWeaver.weave
&gt; (BcelClassWeaver.java:467)
&gt;       [iajc]     at org.aspectj.weaver.bcel.BcelClassWeaver.weave
&gt; (BcelClassWeaver.java:102)
&gt;       [iajc]     at org.aspectj.weaver.bcel.BcelWeaver.weave
&gt; (BcelWeaver.java:1534)
&gt;       [iajc]     at
&gt; org.aspectj.weaver.bcel.BcelWeaver.weaveWithoutDump(BcelWeaver.java:
&gt; 1485)
&gt;       [iajc]     at org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify
&gt; (BcelWeaver.java:1266)
&gt;       [iajc]     at org.aspectj.weaver.bcel.BcelWeaver.weave
&gt; (BcelWeaver.java:1088)
&gt;       [iajc]     at
&gt; org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave
&gt; (AjCompilerAdapter.java:300)
&gt;       [iajc]     at
&gt; org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling
&gt; (AjCompilerAdapter.java:178)
&gt;       [iajc]     at
&gt; org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$afterReturning
&gt; $org_aspectj_ajdt_internal_compiler_CompilerAdapter$2$f9cc9ca0
&gt; (CompilerAdapter.aj:70)
&gt;       [iajc]     at
&gt; org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile
&gt; (Compiler.java:367)
&gt;       [iajc]     at
&gt; org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation
&gt; (AjBuildManager.java:809)
&gt;       [iajc]     at
&gt; org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild
&gt; (AjBuildManager.java:230)
&gt;       [iajc]     at
&gt; org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild
&gt; (AjBuildManager.java:156)
&gt;       [iajc]     at org.aspectj.ajdt.ajc.AjdtCommand.doCommand
&gt; (AjdtCommand.java:112)
&gt;       [iajc]     at org.aspectj.ajdt.ajc.AjdtCommand.runCommand
&gt; (AjdtCommand.java:60)
&gt;       [iajc]     at org.aspectj.tools.ajc.Main.run(Main.java:326)
&gt;       [iajc]     at org.aspectj.tools.ajc.Main.runMain(Main.java:240)
&gt;       [iajc]     at
&gt; org.aspectj.tools.ant.taskdefs.AjcTask.executeInSameVM(AjcTask.java:
&gt; 1210)
&gt;       [iajc]     at org.aspectj.tools.ant.taskdefs.AjcTask.execute
&gt; (AjcTask.java:1001)
&gt;       [iajc]     at org.apache.tools.ant.UnknownElement.execute
&gt; (UnknownElement.java:275)
&gt;       [iajc]     at org.apache.tools.ant.Task.perform(Task.java:364)
&gt;       [iajc]     at org.apache.tools.ant.taskdefs.Sequential.execute
&gt; (Sequential.java:64)
&gt;       [iajc]     at org.apache.tools.ant.UnknownElement.execute
&gt; (UnknownElement.java:275)
&gt;       [iajc]     at org.apache.tools.ant.Task.perform(Task.java:364)
&gt;       [iajc]     at
&gt; org.apache.tools.ant.taskdefs.MacroInstance.execute
&gt; (MacroInstance.java:378)
&gt;       [iajc]     at org.apache.tools.ant.UnknownElement.execute
&gt; (UnknownElement.java:275)
&gt;       [iajc]     at org.apache.tools.ant.Task.perform(Task.java:364)
&gt;       [iajc]     at org.apache.tools.ant.Target.execute(Target.java:341)
&gt;       [iajc]     at org.apache.tools.ant.Target.performTasks
&gt; (Target.java:369)
&gt;       [iajc]     at org.apache.tools.ant.Project.executeSortedTargets
&gt; (Project.java:1216)
&gt;       [iajc]     at org.apache.tools.ant.Project.executeTarget
&gt; (Project.java:1185)
&gt;       [iajc]     at
&gt; org.apache.tools.ant.helper.DefaultExecutor.executeTargets
&gt; (DefaultExecutor.java:40)
&gt;       [iajc]     at org.apache.tools.ant.Project.executeTargets
&gt; (Project.java:1068)
&gt;       [iajc]     at org.apache.tools.ant.Main.runBuild(Main.java:668)
&gt;       [iajc]     at org.apache.tools.ant.Main.startAnt(Main.java:187)
&gt;       [iajc]     at org.apache.tools.ant.launch.Launcher.run
&gt; (Launcher.java:246)
&gt;       [iajc]     at org.apache.tools.ant.launch.Launcher.main
&gt; (Launcher.java:67) 
&gt;
&gt;
 &gt; package gsc.aspects.testing; 
&gt;
 &gt; import junit.framework.*;
&gt; import java.io.*;
&gt; import java.util.*; 
&gt;
 &gt; import org.aspectj.lang.annotation.Pointcut;
&gt; import org.aspectj.lang.annotation.Before;
&gt; import org.aspectj.lang.annotation.Aspect;
&gt; import org.aspectj.lang.annotation.After;
&gt; import org.aspectj.lang.JoinPoint; 
&gt;
 &gt; @Aspect
&gt; public class TestMethodMapperAnnotations { 
&gt;
 &gt;      @Pointcut("this(testCase) &amp;&amp; this(TestCase) &amp;&amp; execution(void
&gt; test*())")
&gt;      public void inTestClass(TestCase testCase) {
&gt;      } 
&gt;
 &gt;      private Map&lt;String, Map&lt;String, Integer&gt;&gt; coverage; 
&gt;
 &gt;      @Before("cflowbelow(inTestClass(testCase)) &amp;&amp; execution(* *(..))")
&gt;      public void beforeMethodExecution(JoinPoint thisJoinPoint,
&gt; TestCase testCase) {
&gt;          String testname = testCase.getClass().getName();
&gt;          String methodSignature = thisJoinPoint.getStaticPart
&gt; ().getSignature().toString();
&gt;          Map&lt;String, Integer&gt; tests = coverage.get(methodSignature);
&gt;          if (tests == null) {
&gt;              tests = new HashMap&lt;String, Integer&gt;();
&gt;              coverage.put(methodSignature, tests);
&gt;          }
&gt;          Integer count = tests.get(testname);
&gt;          if (count == null) {
&gt;              count = 1;
&gt;          } else {
&gt;              count++;
&gt;          }
&gt;          tests.put(testname, count);
&gt;      } 
&gt;
 &gt;      @Before("inTestClass(testCase)")
&gt;      public void beforeExecutingTestMethod(TestCase testCase) {
&gt;          try {
&gt;              File file = new File("results.ser");
&gt;              if (file.exists()) {
&gt;                  ObjectInputStream ois = new ObjectInputStream(new
&gt; FileInputStream(file));
&gt;                  coverage = (Map&lt;String, Map&lt;String, Integer&gt;&gt;)
&gt; ois.readObject();
&gt;                  ois.close();
&gt;              } else {
&gt;                  coverage = new HashMap&lt;String, Map&lt;String, Integer&gt;&gt;();
&gt;              }
&gt;          } catch (Exception e) {
&gt;              e.printStackTrace();
&gt;          }
&gt;      } 
&gt;
 &gt;      @After("inTestClass(testCase)")
&gt;      public void afterExecutingTestMethod(TestCase testCase) {
&gt;          try {
&gt;              File file = new File("results.ser");
&gt;              ObjectOutputStream oos = new ObjectOutputStream(new
&gt; FileOutputStream(file));
&gt;              oos.writeObject(coverage);
&gt;              oos.close();
&gt;          } catch (Exception e) {
&gt;              e.printStackTrace();
&gt;          }
&gt;      } 
&gt;
 &gt; } 
&gt;
 &gt; vs. 
&gt;
 &gt; package gsc.aspects.testing; 
&gt;
 &gt; import junit.framework.*;
&gt; import java.io.*;
&gt; import java.util.*; 
&gt;
 &gt; public aspect TestMethodMapper { 
&gt;
 &gt;      pointcut inTestClass(TestCase testCase) : this(testCase) &amp;&amp; this
&gt; (TestCase) &amp;&amp; execution(void test*());
&gt;      private Map&lt;String, Map&lt;String, Integer&gt;&gt; coverage; 
&gt;
 &gt;      before(TestCase testCase) : cflowbelow(inTestClass(testCase)) &amp;&amp;
&gt; execution(* *(..)) {
&gt;         String testname = testCase.getClass().getName();
&gt;         String methodSignature = thisJoinPointStaticPart.getSignature
&gt; ().toString();
&gt;         Map&lt;String, Integer&gt; tests = coverage.get(methodSignature);
&gt;         if (tests == null) {
&gt;             tests = new HashMap&lt;String, Integer&gt;();
&gt;             coverage.put(methodSignature, tests);
&gt;         }
&gt;         Integer count = tests.get(testname);
&gt;         if (count == null) {
&gt;             count = 1;
&gt;         } else {
&gt;              count++;
&gt;         }
&gt;         tests.put(testname, count);
&gt;      } 
&gt;
 &gt;      before(TestCase testCase) : inTestClass(testCase) {
&gt;         try {
&gt;             File file = new File("results.ser");
&gt;             if (file.exists()) {
&gt;                 ObjectInputStream ois = new ObjectInputStream(new FileInputStream
&gt; (file));
&gt;                 coverage = (Map&lt;String, Map&lt;String, Integer&gt;&gt;) ois.readObject();
&gt;                 ois.close();
&gt;             } else {
&gt;                 coverage = new HashMap&lt;String, Map&lt;String, Integer&gt;&gt;();
&gt;             }
&gt;         } catch (Exception e) {
&gt;             e.printStackTrace();
&gt;         }
&gt;      } 
&gt;
 &gt;      after(TestCase testCase) : inTestClass(testCase) {
&gt;         try {
&gt;             File file = new File("results.ser");
&gt;             ObjectOutputStream oos = new ObjectOutputStream(new
&gt; FileOutputStream(file));
&gt;             oos.writeObject(coverage);
&gt;             oos.close();
&gt;         } catch (Exception e) {
&gt;             e.printStackTrace();
&gt;         }
&gt;      } 
&gt;
 &gt; } 
&gt;
&gt;
&gt;</description><comments/></buginformation><fixedCommits><commit id="979124d0fe6ac23df1dd5ee41838056bbaed6789" author="default" date="2005-12-12 10:48:46"><file name="weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"><method name="weaveAroundClosure" returnType="void" parameters="BcelAdvice boolean"/><method name="getRedoneProceedCall" returnType="InstructionList" parameters=""/><method name="weaveCflowEntry" returnType="void" parameters="BcelAdvice Member"/><method name="getAdviceInstructions" returnType="InstructionList" parameters=""/></file><file name="weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java"><method name="getExposedStateAsBcelVars" returnType="BcelVar[]" parameters=""/></file></commit></fixedCommits></bug><bug id="251" opendate="2005-12-12 08:42:00" fixdate="2005-12-12 15:42:19"><buginformation><summary>LTW weaver include and exclude does not behave correctly</summary><description>According to the specification ( http://www.eclipse.org/aspectj/doc/next/adk15notebook/ltw-configuration.html ) "The set of types to be woven are those types matched by at least one weaver include element and not matched by any weaver exclude element." However if an includ elemement can be fast matched e.g. "com.foo..*" any exclude elements are ignored (see  bug 117854 ). There is no explicit test in the harness for this feature.</description><comments/></buginformation><fixedCommits><commit id="9edb4b6f9e8ca59b309ac382e6049321832d0700" author="default" date="2005-12-12 15:42:19"><file name="tests/src/org/aspectj/systemtest/ajc150/ataspectj/AtAjLTWTests.java"><method name="testLTWDumpProxy" returnType="void" parameters=""/><method name="testLTWDumpBeforeAndAfter" returnType="void" parameters=""/></file><file name="loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"><method name="accept" returnType="boolean" parameters="String byte[]"/></file></commit></fixedCommits></bug><bug id="252" opendate="2005-12-12 12:11:00" fixdate="2005-12-12 17:13:35"><buginformation><summary>add signature to UnresolvedType.parameterize(..) exception</summary><description>I keep getting UnresolvedType UnsupportedOperationException unhelpful message "resolve this type first," so I'm adding the signature to the message (without permission, hence the bug as notice).

throw new UnsupportedOperationException("unable to parameterize unresolved type: " + signature);


-------------------------------
java.lang.UnsupportedOperationException
at org.aspectj.weaver.UnresolvedType.parameterize(UnresolvedType.java:218)
at org.aspectj.weaver.patterns.ExactTypePattern.parameterizeWith(ExactTypePattern.java:242)
at org.aspectj.weaver.patterns.TypePatternList.parameterizeWith(TypePatternList.java:195)
at org.aspectj.weaver.patterns.DeclareParents.parameterizeWith(DeclareParents.java:77)
at org.aspectj.weaver.ReferenceType.getDeclares(ReferenceType.java:484)
at org.aspectj.weaver.ResolvedType.collectDeclares(ResolvedType.java:523)
at org.aspectj.weaver.ResolvedType.collectCrosscuttingMembers(ResolvedType.java:488)
at org.aspectj.weaver.CrosscuttingMembersSet.addOrReplaceAspect(CrosscuttingMembersSet.java:60)
at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.addCrosscuttingStructures(AjLookupEnvironment.java:378)
at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.addCrosscuttingStructures(AjLookupEnvironment.java:388)
at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.collectAllITDsAndDeclares(AjLookupEnvironment.java:314)
at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.completeTypeBindings(AjLookupEnvironment.java:168)
at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.beginToCompile(Compiler.java:301)
at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:315)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:811)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:230)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:185)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.incrementalBuild(AjBuildManager.java:163)
at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:117)
at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)

UnsupportedOperationException thrown: resolve this type first</description><comments/></buginformation><fixedCommits><commit id="3ac46270398a3e9ddde620e03c9dc2123cbe78d0" author="default" date="2005-12-12 17:13:35"><file name="weaver/src/org/aspectj/weaver/UnresolvedType.java"><method name="parameterize" returnType="UnresolvedType" parameters="Map"/></file></commit></fixedCommits></bug><bug id="253" opendate="2005-12-13 03:18:00" fixdate="2005-12-13 09:25:38"><buginformation><summary>named pointcut not resolved in pertarget pointcut</summary><description>Get incorrect error "can't find pointcut ..." when declaring pertarget pointcut using pointcut declared outside the aspect.  

True of HEAD right now.  Not true of pointcuts declared inside the aspect or issingleton aspects.

I thought this was reported and fixed, but I couldn't find the bug.  Sorry if it is a duplicate.

-------------------------------------------------
package bugs;

public class PerTargetSubaspectError {
	public static void main(String[] args) {
		C.run();
	}
	static class C {
		static void run() {}
	}
	pointcut doit() : execution(void C.run());

	// no error if not pertarget
	static aspect CPT pertarget(pc()){ 
                // no error if doit() defined in CPT
		protected pointcut pc() : doit(); // unexpected CE
		before() : doit() {} // no CE
	}
}</description><comments/></buginformation><fixedCommits><commit id="ae500c6ac89fef8b7bb6cf4bd2a9cf1ec16cdd6a" author="default" date="2005-12-13 09:25:38"><file name="tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"><method name="getSpecFile" returnType="File" parameters=""/></file></commit></fixedCommits></bug><bug id="254" opendate="2005-12-13 06:40:00" fixdate="2005-12-13 14:03:53"><buginformation><summary>Issue version message during load-time weaving</summary><description>It would be very useful to know exactly which version of the weaver is being used for LTW. An informational message could be issued when each WeavingAdaptor instance is created (it is possible to have multiple versions of AspectJ in a system). This message could be similar to the that issued by "ajc -version".</description><comments/></buginformation><fixedCommits><commit id="9d32b76c9b48e6a2593bff77dc120eb8c5f17cff" author="default" date="2005-12-13 14:03:53"><file name="weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java"><method name="createMessageHandler" returnType="void" parameters=""/></file></commit></fixedCommits></bug><bug id="255" opendate="2005-12-13 15:03:00" fixdate="2005-12-13 21:04:36"><buginformation><summary>Contribution: More Efficient Lint Warnings: ~15% Performance Increase</summary><description>In profiling a load-time weaving configuration from HEAD, I found that 9% of total time (over 10% of weaving time) is spent in org.aspectj.weaver.Lint.clearSuppressions(), mostly from use inside BcelClassWeaver.match

I made a small change in the parts of BcelAdvice that clear suppressions to save the list that was cleared and to only clear these. This alone saves about 15% of total CPU time in start up on my sample configuration.</description><comments/></buginformation><fixedCommits><commit id="bdafe3184768eb8b76ab653ef2e9f57b0399ca07" author="default" date="2005-12-13 21:04:36"><file name="weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java"><method name="match" returnType="boolean" parameters="Shadow World"/><method name="clearLintSuppressions" returnType="void" parameters="World"/><method name="specializeOn" returnType="void" parameters="Shadow"/><method name="concretize" returnType="ShadowMunger" parameters="ResolvedType World PerClause"/></file><file name="weaver/src/org/aspectj/weaver/Lint.java"><method name="clearSuppressions" returnType="void" parameters=""/></file></commit></fixedCommits></bug><bug id="256" opendate="2005-12-13 16:15:00" fixdate="2005-12-13 22:23:24"><buginformation><summary>Improvements to define new server wizard page</summary><description>On the panel where the server location and button to install the server is shown, a couple of usability improvements could be made...

(1) If I choose browse and choose a location.  Then hit install server, the fs browser should not be brought back up since I have already hitten browse and selected a location.

(2) If (1) and the location chosen contains no server, and the server is downlodable, classpath validation errors should not show, but a message stating that no server is found but can be installed by selecting the install server button.</description><comments/></buginformation><fixedCommits><commit id="588e7b91e892db8db779142184ae3cad169c4a11" author="default" date="2005-12-13 22:23:24"><file name="loadtime/src/org/aspectj/weaver/loadtime/Aj.java"><method name="initialize" returnType="void" parameters=""/><method name="getWeaver" returnType="WeavingAdaptor" parameters="ClassLoader"/></file></commit></fixedCommits></bug><bug id="257" opendate="2005-12-14 11:58:00" fixdate="2005-12-15 15:57:36"><buginformation><summary>Test failures using IBM Java 5</summary><description>1. ReflectionBasedReferenceTypeDelegateTest.testCompareSubclassDelegates() 

junit.framework.AssertionFailedError: Errors:Couldn't find void java.util.HashMap.onEntry() in the bcel set 
Couldn't find void java.util.HashMap.onExit() in the bcel set 
Couldn't find void java.util.HashMap.transfer0(java.util.HashMap$Entry[]) in the bcel set 

聽 聽 聽 聽 at junit.framework.Assert.fail(Assert.java:47) 
聽 聽 聽 聽 at junit.framework.Assert.assertTrue(Assert.java:20) 
聽 聽 聽 聽 at org.aspectj.weaver.reflect.ReflectionBasedReferenceTypeDelegateTest.testCompareSubclassDelegates(ReflectionBasedReferenceTypeDelegateTest.java:278) 
聽 聽 聽 聽 at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 
聽 聽 聽 聽 at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64) 
聽 聽 聽 聽 at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 
聽 聽 聽 聽 at java.lang.reflect.Method.invoke(Method.java:615) 
聽 聽 聽 聽 at junit.framework.TestCase.runTest(TestCase.java:154) 
聽 聽 聽 聽 at junit.framework.TestCase.runBare(TestCase.java:127) 
聽 聽 聽 聽 at junit.framework.TestResult$1.protect(TestResult.java:106) 
聽 聽 聽 聽 at junit.framework.TestResult.runProtected(TestResult.java:124) 
聽 聽 聽 聽 at junit.framework.TestResult.run(TestResult.java:109) 
聽 聽 聽 聽 at junit.framework.TestCase.run(TestCase.java:118) 
聽 聽 聽 聽 at junit.framework.TestSuite.runTest(TestSuite.java:208) 
聽 聽 聽 聽 at junit.framework.TestSuite.run(TestSuite.java:203) 
聽 聽 聽 聽 at junit.framework.TestSuite.runTest(TestSuite.java:208) 
聽 聽 聽 聽 at junit.framework.TestSuite.run(TestSuite.java:203) 
聽 聽 聽 聽 at junit.framework.TestSuite.runTest(TestSuite.java:208) 
聽 聽 聽 聽 at junit.framework.TestSuite.run(TestSuite.java:203) 
聽 聽 聽 聽 at junit.framework.TestSuite.runTest(TestSuite.java:208) 
聽 聽 聽 聽 at junit.framework.TestSuite.run(TestSuite.java:203) 
聽 聽 聽 聽 at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:478) 
聽 聽 聽 聽 at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:344) 
聽 聽 聽 聽 at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196) 

This failure occures because when we compare BeclWorld with ReflectionWorld we are still picking up the default (Sun) version of HashMap in JRE15_LIB for BCEL. The solution is to create both worlds with the same class loader.

2. Ajc150Tests.testModifierOverrides() 

junit.framework.AssertionFailedError: Expecting output: 
execution(void pr119749.C.m()): execMe[@pr119749$Me()] 
execution(void pr119749.C.m()): execEx 
But found output: 
execution(void pr119749.C.m()): execMe[@pr119749.Me()] 
execution(void pr119749.C.m()): execEx 

First difference is on line 1 

聽 聽 聽 聽 at junit.framework.Assert.fail(Assert.java:47) 
聽 聽 聽 聽 at org.aspectj.testing.OutputSpec.matchAgainst(OutputSpec.java:58) 
聽 聽 聽 聽 at org.aspectj.testing.RunSpec.execute(RunSpec.java:61) 
聽 聽 聽 聽 at org.aspectj.testing.AjcTest.runTest(AjcTest.java:68) 
聽 聽 聽 聽 at org.aspectj.testing.XMLBasedAjcTestCase.runTest(XMLBasedAjcTestCase.java:111) 
聽 聽 聽 聽 at org.aspectj.systemtest.ajc150.Ajc150Tests.testModifierOverrides(Ajc150Tests.java:852) 
聽 聽 聽 聽 at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 
聽 聽 聽 聽 at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64) 
聽 聽 聽 聽 at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 
聽 聽 聽 聽 at java.lang.reflect.Method.invoke(Method.java:615) 
聽 聽 聽 聽 at junit.framework.TestCase.runTest(TestCase.java:154) 
聽 聽 聽 聽 at junit.framework.TestCase.runBare(TestCase.java:127) 
聽 聽 聽 聽 at junit.framework.TestResult$1.protect(TestResult.java:106) 
聽 聽 聽 聽 at junit.framework.TestResult.runProtected(TestResult.java:124) 
聽 聽 聽 聽 at junit.framework.TestResult.run(TestResult.java:109) 
聽 聽 聽 聽 at junit.framework.TestCase.run(TestCase.java:118) 
聽 聽 聽 聽 at junit.framework.TestSuite.runTest(TestSuite.java:208) 
聽 聽 聽 聽 at junit.framework.TestSuite.run(TestSuite.java:203) 
聽 聽 聽 聽 at junit.framework.TestSuite.runTest(TestSuite.java:208) 
聽 聽 聽 聽 at junit.framework.TestSuite.run(TestSuite.java:203) 
聽 聽 聽 聽 at junit.extensions.TestDecorator.basicRun(TestDecorator.java:22) 
聽 聽 聽 聽 at junit.extensions.TestSetup$1.protect(TestSetup.java:19) 
聽 聽 聽 聽 at junit.framework.TestResult.runProtected(TestResult.java:124) 
聽 聽 聽 聽 at junit.extensions.TestSetup.run(TestSetup.java:23) 
聽 聽 聽 聽 at junit.framework.TestSuite.runTest(TestSuite.java:208) 
聽 聽 聽 聽 at junit.framework.TestSuite.run(TestSuite.java:203) 
聽 聽 聽 聽 at junit.framework.TestSuite.runTest(TestSuite.java:208) 
聽 聽 聽 聽 at junit.framework.TestSuite.run(TestSuite.java:203) 
聽 聽 聽 聽 at junit.framework.TestSuite.runTest(TestSuite.java:208) 
聽 聽 聽 聽 at junit.framework.TestSuite.run(TestSuite.java:203) 
聽 聽 聽 聽 at junit.framework.TestSuite.runTest(TestSuite.java:208) 
聽 聽 聽 聽 at junit.framework.TestSuite.run(TestSuite.java:203) 
聽 聽 聽 聽 at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:478) 
聽 聽 聽 聽 at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:344) 
聽 聽 聽 聽 at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196) 

This failure is due a difference between JDKs in the implementation of toString() for annotations.</description><comments/></buginformation><fixedCommits><commit id="9abfc4044b23629af408459a3a5c638d7978e443" author="default" date="2005-12-15 15:57:36"><file name="weaver/testsrc/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateTest.java"><method name="setUp" returnType="void" parameters=""/><method name="testCompareSubclassDelegates" returnType="void" parameters=""/></file><file name="weaver/testsrc/org/aspectj/weaver/reflect/ReflectionWorldTest.java"><method name="testPrimitiveTypes" returnType="void" parameters=""/><method name="testArrayTypes" returnType="void" parameters=""/><method name="testDelegateCreation" returnType="void" parameters=""/></file></commit></fixedCommits></bug><bug id="258" opendate="2004-04-14 13:29:00" fixdate="2005-12-21 10:37:43"><buginformation><summary>ajdoc doesn't navigate to target details in some cases</summary><description>When a file is advised, javadoc uses the following naming convention for 
setting its "A NAME":

  convertCheckedException(java.lang.Throwable)

However, ajdoc uses the unqualified name for the argument, resuting in the 
follwing in-file anchor link:

  &lt;class-name&gt;.html#convertCheckedException(Throwable)聽

Which fails to navigate to the anchor within the file, although it does always 
go to the right file.</description><comments/></buginformation><fixedCommits><commit id="bbdd4966a79864ea9979da81ca4725d6471b2fa9" author="default" date="2005-12-21 10:37:43"><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmHierarchyBuilder.java"><method name="visit" returnType="boolean" parameters="MethodDeclaration ClassScope"/></file><file name="ajdoc/testsrc/org/aspectj/tools/ajdoc/AjdocTests.java"><method name="suite" returnType="Test" parameters=""/></file><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmElementFormatter.java"><method name="setParameters" returnType="void" parameters="MethodDeclaration IProgramElement"/></file></commit></fixedCommits></bug><bug id="259" opendate="2005-12-19 05:32:00" fixdate="2005-12-21 17:21:57"><buginformation><summary>around advice does not work when LTW</summary><description>I defined a aop.xml and a aspect, I have already copy aspectjweaver.jar D:\work\BTM\lib\aspectjweaver.jar, and added -javaagent:D:\work\BTM\lib\aspectjweaver.jar option to the JVM in Eclipse, it works fine if there are before and after advice in aspect, but it will be wrong once I used around advice. if I use compile-time weaving, this around advice works fine.
my Eclipse env: eclipse 3.0.2 + AJDT 1.2.1 RC1 release + Sun JDK 1.5.0.

aspect file:
import org.aspectj.lang.Signature;
import org.aspectj.lang.JoinPoint;
public abstract aspect World { 
    //private Object result;
	pointcut greeting() : execution(* Hello.sayWorld(..)); 
    
	Object around(): greeting() {
    	System.out.println("around start!");
    	Object result = proceed();
    	System.out.println("around end!");
    	return result;
	}
    
//    before() : greeting() { 
//    	Signature signature = thisJoinPoint.getSignature();
//        System.out.println("before " + signature.getName()); 
//    } 
    
//    after() returning () : greeting() { 
//    	Signature signature = thisJoinPoint.getSignature();
//        System.out.println("after " + signature.getName()); 
//    } 

} 

aop.xml file:
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;aspectj&gt;
	&lt;aspects&gt;
		&lt;aspect name="World"/&gt;
		&lt;concrete-aspect name="World1" extends="World"&gt;
          &lt;pointcut name="greeting" expression="execution(* Hello.sayWorld(..)) ||
          execution(* Hello.sayHello(..))"/&gt;
        &lt;/concrete-aspect&gt;
	&lt;/aspects&gt;
	&lt;weaver options="-Xreweavable -verbose -XlazyTjp -showWeaveInfo"&gt;
		&lt;include within="Hello"/&gt;
	&lt;/weaver&gt;
&lt;/aspectj&gt;

around advice error message in eclipse console as below:
info register aspect World
info generating class 'World1'
info weaving 'Hello'
info weaver operating in reweavable mode.  Need to verify any required types exist.
abort trouble in: 
public class Hello extends java.lang.Object:
  public void &lt;init&gt;():
                    ALOAD_0     // Hello this   (line 2)
                    INVOKESPECIAL java.lang.Object.&lt;init&gt; ()V
    constructor-execution(void Hello.&lt;init&gt;())
    |               RETURN
    constructor-execution(void Hello.&lt;init&gt;())
  end public void &lt;init&gt;()

  public static void main(String[])    org.aspectj.weaver.MethodDeclarationLineNumber: 7:75
:
                    INVOKESTATIC Hello.sayHello ()V   (line 9)
                    RETURN   (line 10)
  end public static void main(String[])

  public static void sayHello()    org.aspectj.weaver.MethodDeclarationLineNumber: 12:180
:
  end public static void sayHello()

  public static int sayWorld()    org.aspectj.weaver.MethodDeclarationLineNumber: 17:268
:
    method-execution(int Hello.sayWorld())
    |               GETSTATIC java.lang.System.out Ljava/io/PrintStream;   (line 18)
    |               LDC "World"
    |               INVOKEVIRTUAL java.io.PrintStream.println (Ljava/lang/String;)V
    |               ICONST_0   (line 19)
    |               IRETURN
    method-execution(int Hello.sayWorld())
  end public static int sayWorld()

  static final void sayHello_aroundBody0():
                    GETSTATIC java.lang.System.out Ljava/io/PrintStream;   (line 13)
                    LDC "Hello"
                    INVOKEVIRTUAL java.io.PrintStream.println (Ljava/lang/String;)V
                    INVOKESTATIC Hello.sayWorld ()I   (line 14)
                    POP
                    RETURN   (line 15)
  end static final void sayHello_aroundBody0()
end public class Hello

public class Hello$AjcClosure1 extends org.aspectj.runtime.internal.AroundClosure:
  public void &lt;init&gt;(Object[]):
                    ALOAD_0
                    ALOAD_1
                    INVOKESPECIAL org.aspectj.runtime.internal.AroundClosure.&lt;init&gt; ([Ljava/lang/Object;)V
                    RETURN
  end public void &lt;init&gt;(Object[])

  public Object run(Object[]):
                    ALOAD_0
                    GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                    ASTORE_2
                    INVOKESTATIC Hello.sayHello_aroundBody0 ()V
                    ACONST_NULL
                    ARETURN
  end public Object run(Object[])
end public class Hello$AjcClosure1
 -- (NullPointerException) null
null
java.lang.NullPointerException
	at org.aspectj.weaver.bcel.BcelAdvice.getAdviceArgSetup(BcelAdvice.java:457)
	at org.aspectj.weaver.bcel.BcelShadow.weaveAroundClosure(BcelShadow.java:2685)
	at org.aspectj.weaver.bcel.BcelAdvice.implementOn(BcelAdvice.java:230)
	at org.aspectj.weaver.Shadow.implementMungers(Shadow.java:588)
	at org.aspectj.weaver.Shadow.implement(Shadow.java:405)
	at org.aspectj.weaver.bcel.BcelClassWeaver.implement(BcelClassWeaver.java:2146)
	at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:467)
	at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:102)
	at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1543)
	at org.aspectj.weaver.bcel.BcelWeaver.weaveWithoutDump(BcelWeaver.java:1494)
	at org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify(BcelWeaver.java:1275)
	at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1097)
	at org.aspectj.weaver.tools.WeavingAdaptor.getWovenBytes(WeavingAdaptor.java:263)
	at org.aspectj.weaver.tools.WeavingAdaptor.weaveClass(WeavingAdaptor.java:196)
	at org.aspectj.weaver.loadtime.Aj.preProcess(Aj.java:65)
	at org.aspectj.weaver.loadtime.ClassPreProcessorAgentAdapter.transform(ClassPreProcessorAgentAdapter.java:52)
	at sun.instrument.TransformerManager.transform(TransformerManager.java:122)
	at sun.instrument.InstrumentationImpl.transform(InstrumentationImpl.java:155)
	at java.lang.ClassLoader.defineClass1(Native Method)
	at java.lang.ClassLoader.defineClass(ClassLoader.java:620)
	at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:124)
	at java.net.URLClassLoader.defineClass(URLClassLoader.java:260)
	at java.net.URLClassLoader.access$100(URLClassLoader.java:56)
	at java.net.URLClassLoader$1.run(URLClassLoader.java:195)
	at java.security.AccessController.doPrivileged(Native Method)
	at java.net.URLClassLoader.findClass(URLClassLoader.java:188)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:306)
	at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:268)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:251)
	at java.lang.ClassLoader.loadClassInternal(ClassLoader.java:319)

Message: abort trouble in: 
public class Hello extends java.lang.Object:
  public void &lt;init&gt;():
                    ALOAD_0     // Hello this   (line 2)
                    INVOKESPECIAL java.lang.Object.&lt;init&gt; ()V
    constructor-execution(void Hello.&lt;init&gt;())
    |               RETURN
    constructor-execution(void Hello.&lt;init&gt;())
  end public void &lt;init&gt;()

  public static void main(String[])    org.aspectj.weaver.MethodDeclarationLineNumber: 7:75
:
                    INVOKESTATIC Hello.sayHello ()V   (line 9)
                    RETURN   (line 10)
  end public static void main(String[])

  public static void sayHello()    org.aspectj.weaver.MethodDeclarationLineNumber: 12:180
:
  end public static void sayHello()

  public static int sayWorld()    org.aspectj.weaver.MethodDeclarationLineNumber: 17:268
:
    method-execution(int Hello.sayWorld())
    |               GETSTATIC java.lang.System.out Ljava/io/PrintStream;   (line 18)
    |               LDC "World"
    |               INVOKEVIRTUAL java.io.PrintStream.println (Ljava/lang/String;)V
    |               ICONST_0   (line 19)
    |               IRETURN
    method-execution(int Hello.sayWorld())
  end public static int sayWorld()

  static final void sayHello_aroundBody0():
                    GETSTATIC java.lang.System.out Ljava/io/PrintStream;   (line 13)
                    LDC "Hello"
                    INVOKEVIRTUAL java.io.PrintStream.println (Ljava/lang/String;)V
                    INVOKESTATIC Hello.sayWorld ()I   (line 14)
                    POP
                    RETURN   (line 15)
  end static final void sayHello_aroundBody0()
end public class Hello

public class Hello$AjcClosure1 extends org.aspectj.runtime.internal.AroundClosure:
  public void &lt;init&gt;(Object[]):
                    ALOAD_0
                    ALOAD_1
                    INVOKESPECIAL org.aspectj.runtime.internal.AroundClosure.&lt;init&gt; ([Ljava/lang/Object;)V
                    RETURN
  end public void &lt;init&gt;(Object[])

  public Object run(Object[]):
                    ALOAD_0
                    GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                    ASTORE_2
                    INVOKESTATIC Hello.sayHello_aroundBody0 ()V
                    ACONST_NULL
                    ARETURN
  end public Object run(Object[])
end public class Hello$AjcClosure1
 -- (NullPointerException) null
null
java.lang.NullPointerException
	at org.aspectj.weaver.bcel.BcelAdvice.getAdviceArgSetup(BcelAdvice.java:457)
	at org.aspectj.weaver.bcel.BcelShadow.weaveAroundClosure(BcelShadow.java:2685)
	at org.aspectj.weaver.bcel.BcelAdvice.implementOn(BcelAdvice.java:230)
	at org.aspectj.weaver.Shadow.implementMungers(Shadow.java:588)
	at org.aspectj.weaver.Shadow.implement(Shadow.java:405)
	at org.aspectj.weaver.bcel.BcelClassWeaver.implement(BcelClassWeaver.java:2146)
	at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:467)
	at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:102)
	at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1543)
	at org.aspectj.weaver.bcel.BcelWeaver.weaveWithoutDump(BcelWeaver.java:1494)
	at org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify(BcelWeaver.java:1275)
	at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1097)
	at org.aspectj.weaver.tools.WeavingAdaptor.getWovenBytes(WeavingAdaptor.java:263)
	at org.aspectj.weaver.tools.WeavingAdaptor.weaveClass(WeavingAdaptor.java:196)
	at org.aspectj.weaver.loadtime.Aj.preProcess(Aj.java:65)
	at org.aspectj.weaver.loadtime.ClassPreProcessorAgentAdapter.transform(ClassPreProcessorAgentAdapter.java:52)
	at sun.instrument.TransformerManager.transform(TransformerManager.java:122)
	at sun.instrument.InstrumentationImpl.transform(InstrumentationImpl.java:155)
	at java.lang.ClassLoader.defineClass1(Native Method)
	at java.lang.ClassLoader.defineClass(ClassLoader.java:620)
	at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:124)
	at java.net.URLClassLoader.defineClass(URLClassLoader.java:260)
	at java.net.URLClassLoader.access$100(URLClassLoader.java:56)
	at java.net.URLClassLoader$1.run(URLClassLoader.java:195)
	at java.security.AccessController.doPrivileged(Native Method)
	at java.net.URLClassLoader.findClass(URLClassLoader.java:188)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:306)
	at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:268)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:251)
	at java.lang.ClassLoader.loadClassInternal(ClassLoader.java:319)

org.aspectj.bridge.AbortException: trouble in: 
public class Hello extends java.lang.Object:
  public void &lt;init&gt;():
                    ALOAD_0     // Hello this   (line 2)
                    INVOKESPECIAL java.lang.Object.&lt;init&gt; ()V
    constructor-execution(void Hello.&lt;init&gt;())
    |               RETURN
    constructor-execution(void Hello.&lt;init&gt;())
  end public void &lt;init&gt;()

  public static void main(String[])    org.aspectj.weaver.MethodDeclarationLineNumber: 7:75
:
                    INVOKESTATIC Hello.sayHello ()V   (line 9)
                    RETURN   (line 10)
  end public static void main(String[])

  public static void sayHello()    org.aspectj.weaver.MethodDeclarationLineNumber: 12:180
:
  end public static void sayHello()

  public static int sayWorld()    org.aspectj.weaver.MethodDeclarationLineNumber: 17:268
:
    method-execution(int Hello.sayWorld())
    |               GETSTATIC java.lang.System.out Ljava/io/PrintStream;   (line 18)
    |               LDC "World"
    |               INVOKEVIRTUAL java.io.PrintStream.println (Ljava/lang/String;)V
    |               ICONST_0   (line 19)
    |               IRETURN
    method-execution(int Hello.sayWorld())
  end public static int sayWorld()

  static final void sayHello_aroundBody0():
                    GETSTATIC java.lang.System.out Ljava/io/PrintStream;   (line 13)
                    LDC "Hello"
                    INVOKEVIRTUAL java.io.PrintStream.println (Ljava/lang/String;)V
                    INVOKESTATIC Hello.sayWorld ()I   (line 14)
                    POP
                    RETURN   (line 15)
  end static final void sayHello_aroundBody0()
end public class Hello

public class Hello$AjcClosure1 extends org.aspectj.runtime.internal.AroundClosure:
  public void &lt;init&gt;(Object[]):
                    ALOAD_0
                    ALOAD_1
                    INVOKESPECIAL org.aspectj.runtime.internal.AroundClosure.&lt;init&gt; ([Ljava/lang/Object;)V
                    RETURN
  end public void &lt;init&gt;(Object[])

  public Object run(Object[]):
                    ALOAD_0
                    GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                    ASTORE_2
                    INVOKESTATIC Hello.sayHello_aroundBody0 ()V
                    ACONST_NULL
                    ARETURN
  end public Object run(Object[])
end public class Hello$AjcClosure1

	at org.aspectj.bridge.MessageWriter.handleMessage(MessageWriter.java:47)
	at org.aspectj.weaver.tools.WeavingAdaptor$WeavingAdaptorMessageHandler.handleMessage(WeavingAdaptor.java:395)
	at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1554)
	at org.aspectj.weaver.bcel.BcelWeaver.weaveWithoutDump(BcelWeaver.java:1494)
	at org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify(BcelWeaver.java:1275)
	at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1097)
	at org.aspectj.weaver.tools.WeavingAdaptor.getWovenBytes(WeavingAdaptor.java:263)
	at org.aspectj.weaver.tools.WeavingAdaptor.weaveClass(WeavingAdaptor.java:196)
	at org.aspectj.weaver.loadtime.Aj.preProcess(Aj.java:65)
	at org.aspectj.weaver.loadtime.ClassPreProcessorAgentAdapter.transform(ClassPreProcessorAgentAdapter.java:52)
	at sun.instrument.TransformerManager.transform(TransformerManager.java:122)
	at sun.instrument.InstrumentationImpl.transform(InstrumentationImpl.java:155)
	at java.lang.ClassLoader.defineClass1(Native Method)
	at java.lang.ClassLoader.defineClass(ClassLoader.java:620)
	at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:124)
	at java.net.URLClassLoader.defineClass(URLClassLoader.java:260)
	at java.net.URLClassLoader.access$100(URLClassLoader.java:56)
	at java.net.URLClassLoader$1.run(URLClassLoader.java:195)
	at java.security.AccessController.doPrivileged(Native Method)
	at java.net.URLClassLoader.findClass(URLClassLoader.java:188)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:306)
	at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:268)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:251)
	at java.lang.ClassLoader.loadClassInternal(ClassLoader.java:319)
Hello
World</description><comments/></buginformation><fixedCommits><commit id="a778ac41009cdc13412ca79cf7a1649ccec93571" author="default" date="2005-12-21 17:21:57"><file name="weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"><method name="weaveAroundInline" returnType="void" parameters=""/><method name="weaveAroundClosure" returnType="void" parameters="BcelAdvice boolean"/></file><file name="weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java"><method name="getAdviceArgSetup" returnType="InstructionList" parameters=""/></file></commit></fixedCommits></bug><bug id="260" opendate="2006-01-05 03:21:00" fixdate="2006-01-09 13:31:55"><buginformation><summary>ajdoc crashes</summary><description>When trying to run ajdoc on a moderate size code base (266 classes / interfaces / aspects), ajdoc crashes. Here's what happens:

D:\work\napa\jnapa\core&gt;ajdoc -source 1.5 -classpath D:\work\napa\jnapa\core\lib\aspectjrt.jar;D:\work\napa\jnapa\core\l
ib\dom4j-1.5.2.jar;D:\work\napa\jnapa\core\lib\groovy-all-1.0-jsr-03.jar -d D:\work\napa\jnapa\core\build\doc\internal -
author -package -argfile D:\work\napa\jnapa\core\jnapafilelist34352.lst
 &gt; Calling ajc... 
D:\work\napa\jnapa\commons\utils\src\fi\napa\util\aspects\CachingAspect.aj:72 [warning] advice defined in fi.napa.util.a
spects.CachingAspect has not been applied [Xlint:adviceDidNotMatch]


1 warning
 &gt; Building signature files... 
An internal error occured in ajdoc
Please copy the following text into an email message and send it,
along with any additional information you can add to:

        aspectj-dev@eclipse.org 


java.lang.IndexOutOfBoundsException: Index: 3, Size: 3
java.lang.IndexOutOfBoundsException: Index: 3, Size: 3
        at java.util.ArrayList.RangeCheck(ArrayList.java:546)
        at java.util.ArrayList.get(ArrayList.java:321)
        at org.aspectj.tools.ajdoc.StubFileGenerator.processMembers(StubFileGenerator.java:124)
        at org.aspectj.tools.ajdoc.StubFileGenerator.processTypeDeclaration(StubFileGenerator.java:99)
        at org.aspectj.tools.ajdoc.StubFileGenerator.processMembers(StubFileGenerator.java:113)
        at org.aspectj.tools.ajdoc.StubFileGenerator.processTypeDeclaration(StubFileGenerator.java:99)
        at org.aspectj.tools.ajdoc.StubFileGenerator.processFile(StubFileGenerator.java:61)
        at org.aspectj.tools.ajdoc.StubFileGenerator.doFiles(StubFileGenerator.java:38)
        at org.aspectj.tools.ajdoc.Main.main(Main.java:157)

  The file jnapafilelist34352.lst contains only file entries w/ absolute paths, e.g. 
D:\work\napa\jnapa\core\src\fi\napa\core\tableprocessing\transfer\mapping\Transformation.java

I am using ajc and ajdoc 1.5.0 release version. I'll be happy to provide any other information that may help in solving this issue.

D:\work\napa\jnapa\core&gt;ajdoc -v
ajdoc version 1.5.0

D:\work\napa\jnapa\core&gt;ajc -v
AspectJ Compiler 1.5.0 built on Tuesday Dec 20, 2005 at 12:05:54 GMT</description><comments/></buginformation><fixedCommits><commit id="d69ce9aebb3ed4410f07e9992105748b69a0ff5e" author="default" date="2006-01-09 13:31:55"><file name="ajdoc/testsrc/org/aspectj/tools/ajdoc/AjdocTests.java"><method name="suite" returnType="Test" parameters=""/></file><file name="ajdoc/src/org/aspectj/tools/ajdoc/StubFileGenerator.java"><method name="processMembers" returnType="void" parameters=""/></file></commit></fixedCommits></bug><bug id="261" opendate="2005-10-13 07:31:00" fixdate="2006-01-10 09:44:47"><buginformation><summary>Property Editor still shows the properties of layout items when switch to Master page viewer.</summary><description>Description:
Property Editor still shows the properties of layout items when switch to 
Master page viewer.

Steps to reproduce:
1. New a report and insert a label.
2. Select the label.(Property Editor shows label's properties)
3. Switch to Master Page.

Expected result:
Property Editor changs to reflect Master Page properties.

Actual result:
It still showed the label's properties. This will confuse customers if they 
thought it as Master Page Editor and set properties without click Master Page 
viewer at first.</description><comments/></buginformation><fixedCommits><commit id="53284da53f628e7c5071b87888f0624aa7528697" author="default" date="2006-01-10 09:44:47"><file name="tests/src/org/aspectj/systemtest/AllTests15.java"><method name="suite" returnType="Test" parameters=""/></file><file name="tests/src/org/aspectj/systemtest/ajc150/AllTestsAspectJ150.java"><method name="suite" returnType="Test" parameters=""/></file><file name="weaver/src/org/aspectj/weaver/TypeFactory.java"><method name="createTypeFromSignature" returnType="UnresolvedType" parameters="String"/></file></commit></fixedCommits></bug><bug id="262" opendate="2006-01-02 12:16:00" fixdate="2006-01-10 09:47:15"><buginformation><summary>java.lang.StringIndexOutOfBoundsException when compiling (build no.: 20051220093604)</summary><description>This exception occurs using the ajdt eclipse plugin when compiling a project the first time I add the ajdt nature. There are no aspects defined in the project.
I suppose the exception occurs when compiling a class (sorry I can't post the entire source code) with this signature: 

public class FixedWidthParser&lt;T&gt; extends TabularDataParser&lt;T&gt;

The only noticeable things about this class are the presence of an inherited type parameter (and redefined with same name) some custom annotations on methods and a varags on a method parameter, but all of this things are present on other classes in the same project that AspectJ apprently compiles well (I'm not sure about the fact it compiles them).

Hope I helped you with this clues, here's the complete stacktrace.

java.lang.StringIndexOutOfBoundsException
at java.lang.String.substring(Unknown Source)
at org.aspectj.weaver.TypeFactory.createTypeFromSignature(TypeFactory.java:86)
at org.aspectj.weaver.TypeFactory.createTypeFromSignature(TypeFactory.java:116)
at org.aspectj.weaver.UnresolvedType.forSignature(UnresolvedType.java:430)
at org.aspectj.weaver.UnresolvedType.makeArray(UnresolvedType.java:286)
at org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.fromBinding(EclipseFactory.java:214)
at org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.makeResolvedMember(EclipseFactory.java:516)
at org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.makeResolvedMember(EclipseFactory.java:494)
at org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.makeResolvedMember(EclipseFactory.java:451)
at org.aspectj.ajdt.internal.core.builder.AsmHierarchyBuilder.genBytecodeInfo(AsmHierarchyBuilder.java:525)
at org.aspectj.ajdt.internal.core.builder.AsmHierarchyBuilder.visit(AsmHierarchyBuilder.java:400)
at org.aspectj.org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.traverse(MethodDeclaration.java:185)
at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.traverse(TypeDeclaration.java:1195)
at org.aspectj.org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.traverse(CompilationUnitDeclaration.java:339)
at org.aspectj.ajdt.internal.core.builder.AsmHierarchyBuilder.internalBuild(AsmHierarchyBuilder.java:142)
at org.aspectj.ajdt.internal.core.builder.AsmHierarchyBuilder.buildStructureForCompilationUnit(AsmHierarchyBuilder.java:82)
at org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.finishedCompilationUnit(EclipseFactory.java:926)
at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterProcessing(AjCompilerAdapter.java:195)
at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$afterReturning$org_aspectj_ajdt_internal_compiler_CompilerAdapter$4$6b855184(CompilerAdapter.aj:89)
at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:528)
at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:329)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:811)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:230)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:156)
at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:122)
at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)

StringIndexOutOfBoundsException thrown: String index out of range: -2</description><comments/></buginformation><fixedCommits><commit id="24a785febccd12facf9fefceef03a2b7ab693bd9" author="default" date="2006-01-10 09:47:15"><file name="weaver/src/org/aspectj/weaver/TypeFactory.java"><method name="createTypeFromSignature" returnType="UnresolvedType" parameters="String"/></file></commit></fixedCommits></bug><bug id="263" opendate="2005-12-28 09:35:00" fixdate="2006-01-15 21:33:55"><buginformation><summary>BUG for ajdt_1.3_for_eclipse_3.1.zip</summary><description>Hi !!
I use ajdt_1.3_for_eclipse_3.1.zip with eclipse 3.1.1 and fick this error when the eclipse try to make the workbrench:


java.lang.IllegalStateException
at org.aspectj.weaver.TypeFactory.createParameterizedType(TypeFactory.java:42)
at org.aspectj.weaver.bcel.BcelGenericSignatureToTypeXConverter.classTypeSignature2TypeX(BcelGenericSignatureToTypeXConverter.java:82)
at org.aspectj.weaver.bcel.BcelGenericSignatureToTypeXConverter.classTypeSignature2TypeX(BcelGenericSignatureToTypeXConverter.java:42)
at org.aspectj.weaver.bcel.BcelObjectType.unpackGenericSignature(BcelObjectType.java:657)
at org.aspectj.weaver.bcel.BcelObjectType.getSuperclass(BcelObjectType.java:181)
at org.aspectj.weaver.ReferenceType.getSuperclass(ReferenceType.java:514)
at org.aspectj.weaver.bcel.BcelWeaver.weaveParentsFor(BcelWeaver.java:1192)
at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1047)
at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave(AjCompilerAdapter.java:300)
at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling(AjCompilerAdapter.java:178)
at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$afterReturning$org_aspectj_ajdt_internal_compiler_CompilerAdapter$2$f9cc9ca0(CompilerAdapter.aj:70)
at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:367)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:811)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:230)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:156)
at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:122)
at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)

IllegalStateException thrown: Expecting raw type</description><comments/></buginformation><fixedCommits><commit id="3f77e755e504d24e0dc6fd640972d56de15a6bef" author="default" date="2006-01-15 21:33:55"><file name="weaver/src/org/aspectj/weaver/bcel/BcelObjectType.java"><method name="unpackGenericSignature" returnType="void" parameters=""/></file><file name="weaver/testsrc/org/aspectj/weaver/MemberTestCase15.java"><method name="testCanBeParameterizedGenericMethod" returnType="void" parameters=""/><method name="testCanBeParameterizedMethodInGenericType" returnType="void" parameters=""/></file><file name="weaver/src/org/aspectj/weaver/bcel/BcelField.java"><method name="unpackGenericSignature" returnType="void" parameters=""/></file><file name="weaver/src/org/aspectj/weaver/bcel/BcelMethod.java"><method name="unpackGenericSignature" returnType="void" parameters=""/></file></commit></fixedCommits></bug><bug id="264" opendate="2006-01-12 11:08:00" fixdate="2006-01-17 15:32:20"><buginformation><summary>ArrayIndexOutOfBoundsException with incremental and declare @type</summary><description>Given the following code:

-------------------------------------------------
public aspect A {
	declare @type : C : @MyAnnotation;
}
@interface MyAnnotation {	
}

class C {
}
-------------------------------------------------

if you comment out the declare @type statement and do an incremental build, then the following ArrayIndexOutOfBoundsException occurs:

java.lang.ArrayIndexOutOfBoundsException: 0
	at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.doDeclareAnnotations(AjLookupEnvironment.java:754)
	at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.weaveInterTypeDeclarations(AjLookupEnvironment.java:571)
	at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.weaveIntertypes(AjLookupEnvironment.java:357)
	at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.completeTypeBindings(AjLookupEnvironment.java:209)
	at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.beginToCompile(Compiler.java:301)
	at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:315)
	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:811)
	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:254)
	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.incrementalBuild(AjBuildManager.java:163)
	at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:117)
	at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)



This is against the latest code in HEAD.</description><comments/></buginformation><fixedCommits><commit id="ab2f89bd7314680eda5ff5efeb7e97409ff878d1" author="default" date="2006-01-17 15:32:20"><file name="weaver/src/org/aspectj/weaver/CrosscuttingMembersSet.java"><method name="clearCaches" returnType="void" parameters=""/></file></commit></fixedCommits></bug><bug id="265" opendate="2005-12-29 18:49:00" fixdate="2006-01-18 17:59:28"><buginformation><summary>Contribution: Memory Efficient Expendable Type Map</summary><description>Here is a patch for a single file (weaver/src/org/aspectj/weaver/World) that significantly improves the memory footprint of weaves (see details below). I would like help in resolving the one bug that this hit in the AspectJ weaver tests.

It does the following:
* Keeps Weak References to the values in the expendable map to allow evicting them (whereas the Weak Hash Map keeps weak references only to the keys)
* Allows configuring the expendable map to keep hard references to up to N types with -Dorg.aspectj.weaver.World.cacheRetention=number (the current default is 0). It's a nice tuning option so projects can use a bit more memory to avoid evicting types.
* Moves the isExpendible check from the typeMap to the world, to allow different worlds (such as the LTWWorld) to change what's evictable (this lets the LTWWorld not keep references to already defined classes)

This change breaks 3 tests in the "run these tests before checking in code" suite, all of them an NPE in the same line of ReferenceType.getTypeVariables for generic signatures. Presumably this code is implicitly relying on "expendable" types never being evicted. I have attached the error output for all 3 cases.

My initial tests have shown a relatively small performance loss in return for significant memory footprint gains. E.g., using the AspectJ in CVS HEAD with the standard BcelWorld implementation (not LTWWorld) as the world, in Tomcat with the Glassbox Inspector &amp; 4 web apps the AspectJ overhead with this optimization is 48 million heap bytes (of 60 million total heap bytes) versus 61 million bytes using CVS HEAD. 

The optimization has limited benefit for a BcelWorld where almost all the code is exposed to the weaver (since few types are expendible). However, Martin Lippert tried a version of this in his AJEER Eclipse load-time weaving environment and reported a reduction from 230 MB of heap to 30 MB heap used at a cost of a 25% increase in start up time. Likewise, this facility is the major contributor to enabling my other LTW optimizations that can reduce the heap overhead in my test case to 9 million heap bytes (principally having the LTW world allow evicting types that are already woven and using reflective proxies). 

I see similar start up times when using this expendable map in my tests. The ability to increase the number of hard references in cache should provide users an ability to allocate more memory to speed up performance.

Note that the only hard reference to the keys (the signatures) is from the values (at least I haven't noticed any cases in my load-time weaving tests), so the weak hash map is compacting itself properly: when the reference type is weakly reachable, the key is then weakly reachable and the map ultimately purges theses entries.</description><comments/></buginformation><fixedCommits><commit id="04067a6017182b42f520e450240dc90a2ed86bb4" author="default" date="2006-01-18 17:59:28"><file name="weaver/src/org/aspectj/weaver/bcel/BcelWorld.java"><method name="tidyUp" returnType="void" parameters=""/></file><file name="weaver/src/org/aspectj/weaver/World.java"><method name="put" returnType="ResolvedType" parameters="String ResolvedType"/><method name="remove" returnType="ResolvedType" parameters="String"/><method name="isTargettingAspectJRuntime12" returnType="boolean" parameters=""/><method name="get" returnType="ResolvedType" parameters="String"/><method name="isExpendable" returnType="boolean" parameters="ResolvedType"/><method name="dumpthem" returnType="String" parameters="Map"/></file></commit></fixedCommits></bug><bug id="266" opendate="2006-01-22 09:50:00" fixdate="2006-01-23 10:47:29"><buginformation><summary>[generics] mixing and matching numbers of type variables/parameters in a hierarchy</summary><description>Hi guys!

I didn't talk to you for a while, but I've found several new issues related to generics. Here is the first and the most annoying one:

1) Just compile the testcase with iajc and you will get "java.lang.IllegalStateException: Wrong number of type parameters supplied"

Java Code:
=========

public interface Generic1&lt;T extends Number&gt; {
	public void foo(T p);
}


public interface Generic2&lt;T extends Number, Y extends Number&gt; extends Generic1&lt;T&gt; {
	public void foo2(Y p);
}

public class Test&lt;Y extends Number&gt; implements Generic2&lt;Y,Y&gt;{
	public void foo2(Y p) {
	}
	public void foo(Y p) {
	}
}


Aspect:
=======

public privileged aspect TestAspect {
	pointcut TestInheritance(Test test) : target(test) &amp;&amp; execution (* com.mprv.secsph.Generic1.*(..));

	after (Test test) : TestInheritance(test) {
		System.out.println("GO Aspects!");
	}
}

Exception:
==========
iajc
abort trouble in: 
public class com.mprv.secsph.Test extends java.lang.Object implements com.mprv.secsph.Generic2:
  public void &lt;init&gt;():
                    ALOAD_0     // com.mprv.secsph.Test this   (line 10)
                    INVOKESPECIAL java.lang.Object.&lt;init&gt; ()V
    constructor-execution(void com.mprv.secsph.Test.&lt;init&gt;())
    |               RETURN
    constructor-execution(void com.mprv.secsph.Test.&lt;init&gt;())
  end public void &lt;init&gt;()

  public void foo2(Number)    org.aspectj.weaver.MethodDeclarationLineNumber: 11:259
:
                    RETURN   (line 12)
  end public void foo2(Number)

  public void foo(Number)    org.aspectj.weaver.MethodDeclarationLineNumber: 13:287
:
                    RETURN   (line 14)
  end public void foo(Number)

end public class com.mprv.secsph.Test
 -- (IllegalStateException) Wrong number of type parameters supplied
Wrong number of type parameters supplied
java.lang.IllegalStateException: Wrong number of type parameters supplied
	at org.aspectj.weaver.ResolvedMemberImpl.parameterizedWith(ResolvedMemberImpl.java:609)
	at org.aspectj.weaver.ResolvedMemberImpl.parameterizedWith(ResolvedMemberImpl.java:590)
	at org.aspectj.weaver.ReferenceType.getDeclaredMethods(ReferenceType.java:472)
	at org.aspectj.weaver.ResolvedType.addAndRecurse(ResolvedType.java:262)
	at org.aspectj.weaver.ResolvedType.addAndRecurse(ResolvedType.java:301)
	at org.aspectj.weaver.ResolvedType.getMethodsWithoutIterator(ResolvedType.java:257)
	at org.aspectj.weaver.ResolvedType.lookupResolvedMember(ResolvedType.java:375)
	at org.aspectj.weaver.JoinPointSignatureIterator.findSignaturesFromSupertypes(JoinPointSignatureIterator.java:177)
	at org.aspectj.weaver.JoinPointSignatureIterator.hasNext(JoinPointSignatureIterator.java:68)
	at org.aspectj.weaver.patterns.SignaturePattern.matches(SignaturePattern.java:286)
	at org.aspectj.weaver.patterns.KindedPointcut.matchInternal(KindedPointcut.java:106)
	at org.aspectj.weaver.patterns.Pointcut.match(Pointcut.java:145)
	at org.aspectj.weaver.patterns.AndPointcut.matchInternal(AndPointcut.java:55)
	at org.aspectj.weaver.patterns.Pointcut.match(Pointcut.java:145)
	at org.aspectj.weaver.patterns.AndPointcut.matchInternal(AndPointcut.java:55)
	at org.aspectj.weaver.patterns.Pointcut.match(Pointcut.java:145)
	at org.aspectj.weaver.ShadowMunger.match(ShadowMunger.java:64)
	at org.aspectj.weaver.Advice.match(Advice.java:109)
	at org.aspectj.weaver.bcel.BcelAdvice.match(BcelAdvice.java:104)
	at org.aspectj.weaver.bcel.BcelClassWeaver.match(BcelClassWeaver.java:2149)
	at org.aspectj.weaver.bcel.BcelClassWeaver.match(BcelClassWeaver.java:1716)
	at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:458)
	at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:105)
	at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1543)
	at org.aspectj.weaver.bcel.BcelWeaver.weaveWithoutDump(BcelWeaver.java:1494)
	at org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify(BcelWeaver.java:1275)
	at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1097)
	at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave(AjCompilerAdapter.java:300)
	at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling(AjCompilerAdapter.java:178)
	at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$afterReturning$org_aspectj_ajdt_internal_compiler_CompilerAdapter$2$f9cc9ca0(CompilerAdapter.aj:70)
	at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:367)
	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:819)
	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:234)
	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:157)
	at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:112)
	at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:60)
	at org.aspectj.tools.ajc.Main.run(Main.java:326)
	at org.aspectj.tools.ajc.Main.runMain(Main.java:240)
	at org.aspectj.tools.ant.taskdefs.AjcTask.executeInSameVM(AjcTask.java:1254)
	at org.aspectj.tools.ant.taskdefs.AjcTask.execute(AjcTask.java:1048)
	at org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:275)
	at org.apache.tools.ant.Task.perform(Task.java:364)
	at org.apache.tools.ant.Target.execute(Target.java:341)
	at org.apache.tools.ant.Target.performTasks(Target.java:369)
	at org.apache.tools.ant.Project.executeSortedTargets(Project.java:1216)
	at org.apache.tools.ant.Project.executeTarget(Project.java:1185)
	at org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:40)
	at org.apache.tools.ant.Project.executeTargets(Project.java:1068)
	at org.apache.tools.ant.Main.runBuild(Main.java:668)
	at org.apache.tools.ant.Main.startAnt(Main.java:187)
	at org.apache.tools.ant.launch.Launcher.run(Launcher.java:246)
	at org.apache.tools.ant.launch.Launcher.main(Launcher.java:67)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:585)
	at com.intellij.rt.ant.execution.AntMain2.main(AntMain2.java:16)
warning at after (Test test) : TestInheritance(test) {
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/IdeaProjects/aspectsTest/src/com/mprv/secsph/TestAspect.aj:44:0::0 advice defined in com.mprv.secsph.TestAspect has not been applied [Xlint:adviceDidNotMatch]</description><comments/></buginformation><fixedCommits><commit id="8676df9bca4e5e169206f314c8ad5d3da38bc28e" author="default" date="2006-01-23 10:47:29"><file name="weaver/src/org/aspectj/weaver/ReferenceType.java"><method name="getWeaverState" returnType="WeaverStateInfo" parameters=""/></file></commit></fixedCommits></bug><bug id="267" opendate="2006-01-22 11:12:00" fixdate="2006-01-23 14:25:06"><buginformation><summary>[generics] detecting field-get of field of parameterized type.</summary><description>Hi,

Here is the second generics issue:

Java code:
==========

public class Test&lt;T extends Integer&gt; {
	Set&lt;T&gt; ints = new HashSet&lt;T&gt;();

	public Set&lt;T&gt; foo() {
		return ints;
	}

	public static void main(String[] args) {
		Test&lt;Integer&gt; t = new Test&lt;Integer&gt;();
		Set&lt;Integer&gt; ints = t.foo();
	}
}

Aspect:
=======
public privileged aspect TestAspect {

    pointcut gettingMemberCollection(Test t) :
                   target(t) &amp;&amp;
                   get(!public Set&lt;Number+&gt; com.mprv.secsph.*.*) &amp;&amp;
                   !within(TestAspect);

	after (Test test) : gettingMemberCollection(test) {
		System.out.println("GO Aspects!");
	}
}

Compiler output:
================
warning at after (Test test) : gettingMemberCollection(test) {
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/IdeaProjects/aspectsTest/src/com/mprv/secsph/TestAspect.aj:19:0::0 advice defined in com.mprv.secsph.TestAspect has not been applied [Xlint:adviceDidNotMatch]


I would expect "gettingMemberCollection" to catch access to "ints" member of "Test" ...

Thanks a lot!
Misha.</description><comments/></buginformation><fixedCommits><commit id="01a8b2eb36e1a34c80697c2034f9657b74dc281a" author="default" date="2006-01-23 14:25:06"><file name="weaver/src/org/aspectj/weaver/patterns/TypePattern.java"><method name="matchesSubtypes" returnType="boolean" parameters="ResolvedType"/></file><file name="weaver/src/org/aspectj/weaver/patterns/ExactTypePattern.java"><method name="matchesTypeVariable" returnType="boolean" parameters="TypeVariableReferenceType"/></file></commit></fixedCommits></bug><bug id="268" opendate="2006-01-20 10:32:00" fixdate="2006-01-23 15:21:18"><buginformation><summary>Capture method annotation in generic aspect does not compile</summary><description>The following aspect won't compile with aspect 1.5:

package aj;

import java.lang.annotation.Annotation;

public abstract aspect GenericAnnotation&lt;A extends Annotation&gt; {

    pointcut annotatedCall(A a) : call(@A * *.*(..)) &amp;&amp; @annotation(a);

    /* does not compile */
    before(A a) : annotatedCall(a) {
        System.out.println(a.annotationType());
    }
    /* */

    /* OK */
    before(A a) : call(@A * *.*(..)) &amp;&amp; @annotation(a) {
        System.out.println(a.annotationType());
    }

}

----------------------

 &gt;ajc -1.5 -d aj src\aj\* 
...\src\aj\GenericAnnotation.aj:10 [error] incompatible type, expected java.lang.annotation.Annotation found BindingTypePattern(TA;, 0).  Check the type specified in your pointcut before(A a) : annotatedCall(a) {

1 error

----------------

Commenting out the first advice lets this program run as expected:

package aj;

import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;

public class Main {

    @Retention(RetentionPolicy.RUNTIME)
    @interface MyAnnotation {
    }

    static aspect ConcreteAnnotation extends GenericAnnotation&lt;MyAnnotation&gt; {
    }

    public static void main(String[] args) {
        someMethod();
    }

    @MyAnnotation
    private static void someMethod() {
    }

}</description><comments/></buginformation><fixedCommits><commit id="28f8c695ccc8513e9dcbe0c4fb6ebdc71cf84313" author="default" date="2006-01-23 15:21:18"><file name="weaver/src/org/aspectj/weaver/patterns/ReferencePointcut.java"><method name="resolveBindings" returnType="void" parameters="IScope Bindings"/></file></commit></fixedCommits></bug><bug id="269" opendate="2006-01-18 16:59:00" fixdate="2006-01-24 09:59:17"><buginformation><summary>AJDT AspectJ Internal Compiler Error</summary><description>In Eclipse 3.1.1 with AJDT 1.3 (the December 20th 2005 release) I got this message in an error dialog:

org.aspectj.weaver.BCException
at org.aspectj.weaver.bcel.LazyClassGen.getLazyMethodGen(LazyClassGen.java:1216)
at org.aspectj.weaver.bcel.LazyClassGen.getLazyMethodGen(LazyClassGen.java:1201)
at org.aspectj.weaver.bcel.BcelShadow.weaveAroundInline(BcelShadow.java:2048)
at org.aspectj.weaver.bcel.BcelAdvice.implementOn(BcelAdvice.java:232)
at org.aspectj.weaver.Shadow.implementMungers(Shadow.java:588)
at org.aspectj.weaver.Shadow.implement(Shadow.java:405)
at org.aspectj.weaver.bcel.BcelClassWeaver.implement(BcelClassWeaver.java:2146)
at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:467)
at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:102)
at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1543)
at org.aspectj.weaver.bcel.BcelWeaver.weaveWithoutDump(BcelWeaver.java:1494)
at org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify(BcelWeaver.java:1275)
at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1097)
at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave(AjCompilerAdapter.java:300)
at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling(AjCompilerAdapter.java:178)
at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$afterReturning$org_aspectj_ajdt_internal_compiler_CompilerAdapter$2$f9cc9ca0(CompilerAdapter.aj:70)
at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:367)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:811)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:254)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.incrementalBuild(AjBuildManager.java:163)
at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:117)
at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)

trouble in: 
public class edu.ucsd.aosd.MyApplication extends java.lang.Object:
  public void &lt;init&gt;():
                    ALOAD_0     // edu.ucsd.aosd.MyApplication this   (line 5)
                    INVOKESPECIAL java.lang.Object.&lt;init&gt; ()V
    constructor-execution(void edu.ucsd.aosd.MyApplication.&lt;init&gt;())
    |               RETURN
    constructor-execution(void edu.ucsd.aosd.MyApplication.&lt;init&gt;())
  end public void &lt;init&gt;()

  public static void main(String[])    org.aspectj.weaver.MethodDeclarationLineNumber: 8:124
:
    method-execution(void edu.ucsd.aosd.MyApplication.main(java.lang.String[]))
    |               ALOAD_0     // java.lang.String[] args   (line 9)
    |               ASTORE 4
    |               ICONST_0
    |               ISTORE_2
    |               ALOAD 4
    |               ARRAYLENGTH
    |               ISTORE_3
    |               GOTO L1
    |           L0: ALOAD 4
    |               ILOAD_2
    |               AALOAD
    |               ASTORE_1
    |               GETSTATIC java.lang.System.out Ljava/io/PrintStream;   (line 10)
    |               NEW java.lang.StringBuilder
    |               DUP
    |               LDC "got: "
    |               INVOKESPECIAL java.lang.StringBuilder.&lt;init&gt; (Ljava/lang/String;)V
    |               ALOAD_1     // java.lang.String arg
    | method-call(java.lang.StringBuilder java.lang.StringBuilder.append(java.lang.String))
    | |             INVOKEVIRTUAL java.lang.StringBuilder.append (Ljava/lang/String;)Ljava/lang/StringBuilder;
    | method-call(java.lang.StringBuilder java.lang.StringBuilder.append(java.lang.String))
    | method-call(java.lang.String java.lang.StringBuilder.toString())
    | |             INVOKEVIRTUAL java.lang.StringBuilder.toString ()Ljava/lang/String;
    | method-call(java.lang.String java.lang.StringBuilder.toString())
    |               ASTORE 5
    |               ASTORE 6
    | method-call(void java.io.PrintStream.println(java.lang.String))
    | |             ALOAD 6
    | |             ALOAD 5
    | |             INVOKEVIRTUAL java.io.PrintStream.println (Ljava/lang/String;)V
    | method-call(void java.io.PrintStream.println(java.lang.String))
    |               GETSTATIC java.lang.System.out Ljava/io/PrintStream;   (line 11)
    |               LDC "got: %s\n"
    |               ICONST_1
    |               ANEWARRAY java.lang.Object
    |               DUP
    |               ICONST_0
    |               ALOAD_1     // java.lang.String arg
    |               AASTORE
    | method-call(java.io.PrintStream java.io.PrintStream.printf(java.lang.String, java.lang.Object[]))
    | |             INVOKEVIRTUAL java.io.PrintStream.printf (Ljava/lang/String;[Ljava/lang/Object;)Ljava/io/PrintStream;
    | method-call(java.io.PrintStream java.io.PrintStream.printf(java.lang.String, java.lang.Object[]))
    |               POP
    |               IINC 2 1   (line 9)
    |           L1: ILOAD_2
    |               ILOAD_3
    |               IF_ICMPLT L0
    |               RETURN   (line 13)
    method-execution(void edu.ucsd.aosd.MyApplication.main(java.lang.String[]))
  end public static void main(String[])

end public class edu.ucsd.aosd.MyApplication

when implementing on shadow method-call(void java.io.PrintStream.println(java.lang.String))
when weaving type edu.ucsd.aosd.MyApplication
when weaving classes 
when weaving 
when incrementally building BuildConfig[C:\EclipseWorkspace\.metadata\.plugins\org.eclipse.ajdt.core\AspectJSemanticsTest.generated.lst] #Files=2

It occured when I editing this file, in an AspectJ project with an recently renamed .aj extension:

package edu.ucsd.aosd;

import java.io.PrintStream;

public class MyApplication
{
    // main
    public static void main(String[] args) {
        for (String arg : args) {
            System.out.println("got: " + arg);
            System.out.printf("got: %s\n", arg);
        }
    }
}

aspect Printing {
    pointcut printlnCalls(PrintStream ps, String out):
        call(* PrintStream+.println(String)) &amp;&amp; target(ps) &amp;&amp; args(out);
    Object around(PrintStream ps, String out):
        printlnCalls(ps, out) &amp;&amp; !adviceexecution() {
        return proceed(ps, out);
    }
    
    pointcut printfCalls(PrintStream ps, String fmt, Object[] objs):
        call(* PrintStream+.printf(String, Object...#####))
        &amp;&amp; target(ps) &amp;&amp; args(fmt, objs);
}

Where "#####" is where my cursor was when I saved. My previously saved version didn't have the printfCalls pointcut nor the call to printf in the main. (Thus, you might want to try the println version first, save it, and then make the new additions. Though, I hope the debug information is enough.)</description><comments/></buginformation><fixedCommits><commit id="d916002f3d0ba392915ec323ff7ae189a5bdb474" author="default" date="2006-01-24 09:59:17"><file name="tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java"><method name="testPr115251" returnType="void" parameters=""/></file></commit></fixedCommits></bug><bug id="270" opendate="2006-01-24 08:41:00" fixdate="2006-01-24 16:47:42"><buginformation><summary>[generics] Incorrect call to generic inherited method in around advice</summary><description>The following case produces a runtime error:

package aj;

public abstract aspect GenericInheritedMethod&lt;T&gt; {

    protected final T getSomething() {
        return null;
    }

}


package aj;

aspect UseInheritedMethod extends GenericInheritedMethod&lt;Integer&gt; {

    // works as expected
    before() : execution(void someMethod()) {
        System.out.println(getSomething());
    }

    // Runtime Error
    void around() : execution(void someMethod()) {
        System.out.println(getSomething());
    }

    public static void main(String[] args) {
        someMethod();
    }

    private static void someMethod() {
    }

}


 &gt;java aj.UseInheritedMethod 
null
Exception in thread "main" java.lang.NoSuchMethodError: aj.UseInheritedMethod.getSomething()Ljava/lang/Integer;
        at aj.UseInheritedMethod.ajc$inlineAccessMethod$aj_UseInheritedMethod$aj_UseInheritedMethod$getSomething(UseInheritedMethod.aj)
        at aj.UseInheritedMethod.ajc$around$aj_UseInheritedMethod$2$c74e36b7(UseInheritedMethod.aj:12)
        at aj.UseInheritedMethod.someMethod(UseInheritedMethod.aj:1)
        at aj.UseInheritedMethod.main(UseInheritedMethod.aj:16)

The "inlineAccessMethod" should call "getSomething()Ljava/lang/Object;" as the before advice does.</description><comments/></buginformation><fixedCommits><commit id="a4bd19d25597a31e1b76cc5fc188c3112bf0f5ff" author="default" date="2006-01-24 16:47:42"><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AccessForInlineVisitor.java"><method name="getAccessibleMethod" returnType="MethodBinding" parameters="MethodBinding"/></file></commit></fixedCommits></bug><bug id="271" opendate="2006-01-26 04:12:00" fixdate="2006-01-26 15:32:48"><buginformation><summary>fix for </summary><description>The fix for  bug 58520  has caused two AJDT marker tests to fail. The reason for the failures is that the test is checking that the markers have a specific message i.e. advises Demo.foo(int, Object) (runtime test). However, due to the fix for  bug 58520 , the message is now saying advises Demo.foo(int, java.lang.Object) (runtime test). Since everything in AJDT works of the same model, the xref view is also showing the fully qualified arguments. However, this is inconsistent with the Outline view.

The fix is along the lines of adding the capability to choose whether you want the fully qualified name or not.</description><comments/></buginformation><fixedCommits><commit id="7e40a6094541d2191f09d810b3330c4858ed8952" author="default" date="2006-01-26 15:32:48"><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmElementFormatter.java"><method name="setParameters" returnType="void" parameters="MethodDeclaration IProgramElement"/></file><file name="asm/src/org/aspectj/asm/internal/ProgramElement.java"><method name="toLabelString" returnType="String" parameters=""/><method name="toLinkLabelString" returnType="String" parameters=""/><method name="toSignatureString" returnType="String" parameters=""/></file></commit></fixedCommits></bug><bug id="272" opendate="2005-12-19 06:28:00" fixdate="2006-01-27 12:30:21"><buginformation><summary>invalid aspectj path throws filenotfoundexception</summary><description>An invalid aspectj path (missing jar file) throws an filenotfoundexception:

java.io.FileNotFoundException
at java.io.FileInputStream.open(Native Method)
at java.io.FileInputStream.&lt;init&gt;(FileInputStream.java:106)
at org.aspectj.weaver.bcel.BcelWeaver.addAspectsFromJarFile(BcelWeaver.java:202)
at org.aspectj.weaver.bcel.BcelWeaver.addLibraryJarFile(BcelWeaver.java:192)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.initBcelWorld(AjBuildManager.java:623)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:209)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:185)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.incrementalBuild(AjBuildManager.java:163)
at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:117)
at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)

FileNotFoundException thrown: /Users/frankstolle/Documents/workspace/lib_aspects/deploy/lib_aspects.jar (No such file or directory)



should generate an problem entry in the problems-list.</description><comments/></buginformation><fixedCommits><commit id="551b446bec83bef0f7df1f57353fdb4297bc14a6" author="default" date="2006-01-27 12:30:21"><file name="tests/src/org/aspectj/systemtest/incremental/tools/AjdeInteractionTestbed.java"><method name="getAspectPath" returnType="Set" parameters=""/></file><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"><method name="initBcelWorld" returnType="void" parameters="IMessageHandler"/></file><file name="tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java"><method name="testTheBasics" returnType="void" parameters=""/></file></commit></fixedCommits></bug><bug id="273" opendate="2006-01-15 08:39:00" fixdate="2006-01-29 10:12:10"><buginformation><summary>NPE in AccessForInlineVisitor.endVisit(AccessForInlineVisitor.java:105)</summary><description>java.lang.NullPointerException
at org.aspectj.ajdt.internal.compiler.ast.AccessForInlineVisitor.endVisit(AccessForInlineVisitor.java:105)
at org.aspectj.org.eclipse.jdt.internal.compiler.ast.QualifiedNameReference.traverse(QualifiedNameReference.java(Compiled Code))
at org.aspectj.org.eclipse.jdt.internal.compiler.ast.MessageSend.traverse(MessageSend.java(Compiled Code))
at org.aspectj.org.eclipse.jdt.internal.compiler.ast.MessageSend.traverse(MessageSend.java(Compiled Code))
at org.aspectj.org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.traverse(MethodDeclaration.java(Compiled Code))
at org.aspectj.ajdt.internal.compiler.ast.AdviceDeclaration.resolveStatements(AdviceDeclaration.java:172)
at org.aspectj.org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java(Compiled Code))
at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java(Compiled Code))
at org.aspectj.ajdt.internal.compiler.ast.AspectDeclaration.resolve(AspectDeclaration.java:115)
at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java(Inlined Compiled Code))
at org.aspectj.org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java(Compiled Code))
at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:514)
at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:329)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java(Compiled Code))
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:230)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:185)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.incrementalBuild(AjBuildManager.java:163)
at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:117)
at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)

NullPointerException thrown: null</description><comments/></buginformation><fixedCommits><commit id="693945fed3ea7482c5c312063dfac881f0d0d1c9" author="default" date="2006-01-29 10:12:10"><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AccessForInlineVisitor.java"><method name="endVisit" returnType="void" parameters="QualifiedNameReference BlockScope"/></file><file name="tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java"><method name="testIncorrectlyReferencingPointcuts_pr122452_2" returnType="void" parameters=""/></file></commit></fixedCommits></bug><bug id="274" opendate="2006-01-29 18:45:00" fixdate="2006-01-30 10:24:49"><buginformation><summary>NullPointerException from BcelShadow.java:1313</summary><description>From within Eclipse 3.0 (RAD 6.0.1) I get an error with the (partial) details listed below.  My aspect looks like this:

public aspect AAwtEventDispatcherThreadProtection
{
  pointcut awtComponentMethod(java.awt.Component component):
    target(component) &amp;&amp; call(* *.*(..));

  before(java.awt.Component component): awtComponentMethod(component) {
    if (!SwingUtilities.isEventDispatchThread() &amp;&amp; component.isDisplayable())
    {
      System.err.println("AWT Component method called from another Thread than the AWT-EventDispatchThread! source: " + 
                         thisJoinPoint.getSourceLocation() + ", target: " + thisJoinPoint.toLongString());
    }
  }
}

----------------
DETAILS (shortened because the size exceeded the 65k limit):


java.lang.NullPointerException
at 	at org.aspectj.weaver.bcel.BcelShadow.ensureTargetTypeIsCorrect(BcelShadow.java:1313)
at 	at org.aspectj.weaver.bcel.BcelShadow.initializeTargetVar(BcelShadow.java:1274)
at 	at org.aspectj.weaver.bcel.BcelShadow.getTargetVar(BcelShadow.java:968)
at 	at org.aspectj.weaver.patterns.ThisOrTargetPointcut.findResidueInternal(ThisOrTargetPointcut.java:185)
at 	at org.aspectj.weaver.patterns.Pointcut.findResidue(Pointcut.java:268)
at 	at org.aspectj.weaver.patterns.AndPointcut.findResidueInternal(AndPointcut.java:97)
at 	at org.aspectj.weaver.patterns.Pointcut.findResidue(Pointcut.java:268)
at 	at org.aspectj.weaver.patterns.AndPointcut.findResidueInternal(AndPointcut.java:97)
at 	at org.aspectj.weaver.patterns.Pointcut.findResidue(Pointcut.java:268)
at 	at org.aspectj.weaver.bcel.BcelAdvice.specializeOn(BcelAdvice.java:132)
at 	at org.aspectj.weaver.bcel.BcelShadow.prepareForMungers(BcelShadow.java:313)
at 	at org.aspectj.weaver.Shadow.implement(Shadow.java:404)
at 	at org.aspectj.weaver.bcel.BcelClassWeaver.implement(BcelClassWeaver.java:2146)
at 	at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:467)
at 	at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:102)
at 	at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1543)
at 	at org.aspectj.weaver.bcel.BcelWeaver.weaveWithoutDump(BcelWeaver.java:1494)
at 	at org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify(BcelWeaver.java:1275)
at 	at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1097)
at 	at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave(AjCompilerAdapter.java:300)
at 	at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling(AjCompilerAdapter.java:178)
at 	at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$afterReturning$org_aspectj_ajdt_internal_compiler_CompilerAdapter$2$f9cc9ca0(CompilerAdapter.aj:70)
at 	at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:367)
at 	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:811)
at 	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:230)
at 	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:156)
at 	at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:122)
at 	at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)

trouble in: 
public class com.sun.imageio.plugins.gif.GIFImageMetadata extends javax.imageio.metadata.IIOMetadata:</description><comments/></buginformation><fixedCommits><commit id="49341327b19da8e97c12194be2c162eae9916b40" author="default" date="2006-01-30 10:24:49"><file name="weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"><method name="ensureTargetTypeIsCorrect" returnType="UnresolvedType" parameters="UnresolvedType"/></file></commit></fixedCommits></bug><bug id="275" opendate="2006-01-31 06:23:00" fixdate="2006-01-31 12:53:10"><buginformation><summary>AjTypeDeclaration in the dom shouldn't have the properties of it's subtype AspectDeclaration</summary><description>The AjTypeDeclaration should not have the properties 'privileged' and 'perClause' which it's subtype AspectDeclaration has. This was shown up whilst building an aspectj for ajdt and a failure in one of the visitor tests.</description><comments/></buginformation><fixedCommits><commit id="eec4990f7d6cad43994490193a4f76be5c580f9f" author="default" date="2006-01-31 12:53:10"><file name="org.aspectj.ajdt.core/testsrc/org/aspectj/tools/ajc/AjASTTest.java"><method name="testPropertyDescriptorsForAspectDeclaration" returnType="void" parameters=""/></file></commit></fixedCommits></bug><bug id="276" opendate="2006-01-10 04:12:00" fixdate="2006-02-10 07:55:32"><buginformation><summary>Skip subversion resources when copying files from input to output folders</summary><description>Exception when compile a project under svn.

java.io.FileNotFoundException
at java.io.FileOutputStream.open(Native Method)
at java.io.FileOutputStream.&lt;init&gt;(FileOutputStream.java:179)
at java.io.FileOutputStream.&lt;init&gt;(FileOutputStream.java:131)
at org.aspectj.util.FileUtil.makeOutputStream(FileUtil.java:1258)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.writeResource(AjBuildManager.java:466)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.copyResourcesFromFile(AjBuildManager.java:444)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.copyResourcesToDestination(AjBuildManager.java:386)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:298)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:185)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.incrementalBuild(AjBuildManager.java:163)
at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:117)
at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)

FileNotFoundException thrown: /home/chomats/Fede/svn/fede-repos/Tool.Product.ProductServer/classes/.svn/format (Permission non accord茅e)</description><comments/></buginformation><fixedCommits><commit id="d856e4fedb65e12104851967690ef751b2c7b09b" author="default" date="2006-02-10 07:55:32"><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"><method name="acceptResource" returnType="boolean" parameters="String"/></file></commit></fixedCommits></bug><bug id="277" opendate="2005-12-12 07:07:00" fixdate="2006-02-10 11:25:44"><buginformation><summary>@AJ decl err/warn does not show cross structure view</summary><description>Perhaps an issue in the ASM struct for DEOW
since cross struct. is empty in AJDT , despite error / warning gutter and message is ok.</description><comments/></buginformation><fixedCommits><commit id="f743fb210e1b7aa8cdb45e7bda53aa336f912edf" author="default" date="2006-02-10 11:25:44"><file name="weaver/src/org/aspectj/weaver/bcel/AtAjAttributes.java"><method name="handleDeclareErrorOrWarningAnnotation" returnType="boolean" parameters=""/></file></commit></fixedCommits></bug><bug id="278" opendate="2005-12-08 10:53:00" fixdate="2006-02-13 10:51:11"><buginformation><summary>BCException when deleting a java-source-file</summary><description>org.aspectj.weaver.BCException
at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1087)
at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave(AjCompilerAdapter.java:300)
at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling(AjCompilerAdapter.java:178)
at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$afterReturning$org_aspectj_ajdt_internal_compiler_CompilerAdapter$2$f9cc9ca0(CompilerAdapter.aj:70)
at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:367)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:811)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:254)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.incrementalBuild(AjBuildManager.java:163)
at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:117)
at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)

BCException thrown: Can't find bcel delegate for training.casino.Konto type=class org.aspectj.weaver.ReferenceType
when weaving classes 
when weaving 
when incrementally building BuildConfig[C:\Documents and Settings\mheidt\workspace 3.1.1\.metadata\.plugins\org.eclipse.ajdt.core\AspJTraining.generated.lst] #Files=11

deleted  a java-source-file before (but not the class-file), possibly pointed by a LogAspect. Created a new source file. Error occurs after saving the new file.</description><comments/></buginformation><fixedCommits><commit id="0b39aa5dd0218561f11258ac272112ada447065e" author="default" date="2006-02-13 10:51:11"><file name="weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java"><method name="weave" returnType="Collection" parameters="IClassFileProvider"/></file><file name="tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java"><method name="testPr113531" returnType="void" parameters=""/></file></commit></fixedCommits></bug><bug id="279" opendate="2005-12-30 00:54:00" fixdate="2006-02-16 16:50:34"><buginformation><summary>[@AspectJ] @DeclareParents/declare parents not equivalent</summary><description>Adding a setter to the Moody example makes it clear that the annotation style (@DeclareParents) results in different behavior than the classic (declare parents) style.

Calling the setter in a "declare parents"-advised object behaves as one would expect.  However, calling the setter with a "@DeclareParents"-advised object has no effect -- that is, you can call the setter (and see that it's been called) and immediately call the getter, only to find that the value didn't change.  The following examples (all in "package moody;") illustrate:

public enum Mood { HAPPY, JOLLY }

Classic style:
-------------
public aspect ClassicMoodIndicator {
   public interface Moody {
      Mood getMood();
      void setMood(Mood mood);
   }

   private Mood Moody.mood = Mood.HAPPY;

   public Mood Moody.getMood() { return mood; }
   public void Moody.setMood(Mood mood) { this.mood = mood; }

   declare parents : moody.ClassicMoodImplementor implements Moody;
}

public class ClassicMoodImplementor { }

Annotation style:
----------------
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.DeclareParents;

@Aspect
public class AnnotationMoodIndicator {
   public interface Moody {
      Mood getMood();
      void setMood(Mood mood);
   }

   public static class MoodyImpl implements Moody {
      private Mood mood = Mood.HAPPY;

      public Mood getMood() { return mood; }
      public void setMood(Mood mood) { this.mood = mood; }
   }

   @DeclareParents(value="moody.AnnotationMoodImplementor",defaultImpl=MoodyImpl.class)
   private Moody implementedInterface;
}

public class AnnotationMoodImplementor { }

JUnit TestCase:
--------------
import junit.framework.TestCase;

public class MoodTester extends TestCase {
   public MoodTester(String name) { super(name); }

   public void testClassic() {
      ClassicMoodImplementor cmi0 = new ClassicMoodImplementor();
      ClassicMoodImplementor cmi1 = new ClassicMoodImplementor();
      
      assertEquals("cmi0 should be HAPPY", Mood.HAPPY, cmi0.getMood());
      
      cmi1.setMood(Mood.JOLLY);
      assertEquals("cmi1 should be JOLLY", Mood.JOLLY, cmi1.getMood());
      assertEquals("cmi0 should be *still* be HAPPY", Mood.HAPPY, cmi0.getMood());
   }
   
   public void testAnnotation() {
      AnnotationMoodImplementor ami0 = new AnnotationMoodImplementor();
      AnnotationMoodImplementor ami1 = new AnnotationMoodImplementor();
      
      assertEquals("ami0 should be HAPPY", Mood.HAPPY, ((AnnotationMoodIndicator.Moody) ami0).getMood());
      
      ((AnnotationMoodIndicator.Moody) ami1).setMood(Mood.JOLLY);
      assertEquals("ami1 should be JOLLY", Mood.JOLLY, ((AnnotationMoodIndicator.Moody) ami1).getMood());
      assertEquals("ami0 should be *still* be HAPPY", Mood.HAPPY, ((AnnotationMoodIndicator.Moody) ami0).getMood());
   }
}

Result:
------
The test run is as follows:
..F
Time: 0.021
There was 1 failure:
1) testAnnotation(moody.MoodTester)junit.framework.AssertionFailedError: ami1 should be JOLLY expected:&lt;JOLLY&gt; but was:&lt;HAPPY&gt;
       at moody.MoodTester.testAnnotation(MoodTester.java:27)
       at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
       at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
       at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
       at moody.MoodTester.main(MoodTester.java:7)

FAILURES!!!
Tests run: 2,  Failures: 1,  Errors: 0

For classic, you can see that cmi1.setMood was successful and cmi0/cmi1 are decoupled (that is, calling setMood on cmi1 has no impact on cmi0).  The annotation style, however, fails because ami1.setMood appears to have done nothing.  The result should have been that ami1 is JOLLY and ami0 HAPPY (I include the second assert because both ami0 &amp; ami1 ended up JOLLY in RC1).

The current behavior makes @DeclareParents unusable for retaining field state (near as I can tell, it retains state throughout the method invocation, but not beyond it, like it is creating and discarding a backing object with each method invocation).</description><comments/></buginformation><fixedCommits><commit id="e87458179ab929aae2bc6966a6e092813bdd14a3" author="default" date="2006-02-16 16:50:34"><file name="weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java"><method name="mungeMethodDelegate" returnType="boolean" parameters="BcelClassWeaver"/></file></commit></fixedCommits></bug><bug id="280" opendate="2006-02-20 13:08:00" fixdate="2006-02-20 19:32:59"><buginformation><summary>Incorrect error on "declare" statements</summary><description>The error associated with the declare construct is incorrect. 
The current message is:

"expected one of error, warning, parents, soft, dominates"

dominates should be changed to "precendence" and new annotation related declararions should be mentioned. Here is a suggestion:

"expected one of error, warning, parents, soft, precedence, @type, @method, @constructor, @field"</description><comments/></buginformation><fixedCommits><commit id="f95d2c96edd293b98c27a19bb9f3cc2748b365cb" author="default" date="2006-02-20 19:32:59"><file name="weaver/src/org/aspectj/weaver/patterns/PatternParser.java"><method name="parseDeclare" returnType="Declare" parameters=""/></file></commit></fixedCommits></bug><bug id="281" opendate="2006-02-20 23:38:00" fixdate="2006-02-21 15:52:36"><buginformation><summary>LTW doesn't work using JRE1.4 in Eclipse</summary><description>LTW doesn't work using JRE1.4 in Eclipse

now I want to support JRE1.4 when LTW.
I defined a aop.xml file in application META-INF path, it works fine using JRE1.4 in command-line, aop.xml file is used when LTW, the command as below:

"D:\work\BTM\eclipse 3.1.1\eclipse-SDK-3.1.1-win32\eclipse-1.4.2\jre\bin\java" -classpath "C:\aspectj1.5\lib\aspectjweaver.jar" "-Djava.system.class.loader=org.aspectj.weaver.loadtime.WeavingURLClassLoader" "-Daj.class.path=D:\work\BTM\eclipse 3.1.1\jre1.4.2\myTest;C:\aspectj1.5\doc\examples\armtest\jar\btm-deps-e3.1.jar;C:\aspectj1.5\doc\examples\armtest\jar\btm-rt.jar" Hello


but it doesn't work in Eclipse, I added upper command to VM arguments, it can't find aop.xml, because if I changed aop.xml to be wrong, there is no any error when execute the application in Eclipse , but there will be error when execute it in command-line, based on this point, I think that aop.xml didn't be used in Eclipse, I also tried to add "-Daj.aspect.path=D:\work\BTM\eclipse 3.1.1\jre1.4.2\myTest", but it is still. so I want to confirm if AspectJ only supports command-line for JRE1.4? doesn't support Eclipse for JRE1.4?

BTW, my Eclipse env: eclipse 3.1.1 + ajdt_1.3_for_eclipse_3.1 + Sun JDK 1.4.2.
I also tried to use eclipse 3.1.2, but this problem is still existed.</description><comments/></buginformation><fixedCommits><commit id="7a2087ef985e8af73045bac1e7e0195bb87c7f40" author="default" date="2006-02-21 15:52:36"><file name="loadtime/src/org/aspectj/weaver/loadtime/ConcreteAspectCodeGen.java"><method name="validate" returnType="boolean" parameters=""/></file></commit></fixedCommits></bug><bug id="282" opendate="2006-02-16 11:21:00" fixdate="2006-02-21 15:55:33"><buginformation><summary>[@AspectJ] NPE on @AJ code with pointcut which contains logical OR operation.</summary><description>I got NullPointerException during compilation of any @AspectJ code with pointcut which contains logical OR operation.

-----Here is my test case for this bug----------------

import java.io.IOException;

import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Pointcut;

@Aspect
class AbstractTracer 
{
	@Pointcut("(execution(public * Foo+.* (..)) || execution(public * Foo+.blablabla (..)))&amp;&amp; !execution(public Foo+.new (..))")
//	@Pointcut("(execution(public * Foo+.* (..)))&amp;&amp; !execution(public Foo+.new (..))")
	protected void methodCall(){};

	@Pointcut("methodCall()&amp;&amp; this(obj)")
	private void objectCall(Object obj) {
	};

	@Around("objectCall(obj)")
	public Object aroundMethodCall(ProceedingJoinPoint thisJoinPoint,
			Object obj) throws Throwable {
		System.out.println("Before "+thisJoinPoint.getSignature().toString());
		if ( thisJoinPoint.getSignature().toString().indexOf("A")!= -1)
		{
			throw new IOException("Hello from Aspect!");
//			throw new Exception("Hello from Aspect!");
		}
		Object result = thisJoinPoint.proceed();
		System.out.println("After "+thisJoinPoint.getSignature().toString());
		return result;
	}

}


public class Foo {
	public void methodA() throws IOException {
		throw new IOException("Foo.methodA");
	}

	public void methodB(boolean b) throws Exception
	{
		if ( b )
		{
			throw new Exception("Foo.methodB");
		}
	}
	/**
	 * @param args
	 */
	public static void main(String[] args) {
		Foo obj = new Foo();
		try
		{
			obj.methodA();
			System.out.println("Something going wrong!");
		}
		catch ( IOException e)
		{
			System.out.println("All right! We got exception");
			e.printStackTrace(System.out);
		}
		try
		{
			obj.methodB(false);
			System.out.println("All right!");
		}
		catch ( Exception e)
		{
			System.out.println("Something going wrong! We got exception");
			e.printStackTrace(System.out);
		}
		
	}

}

------------------------------------------------------

and here is acj error log
------------------------------------------------------
---- AspectJ Properties ---
AspectJ Compiler 1.5.0 built on Tuesday Dec 20, 2005 at 12:05:54 GMT
---- Dump Properties ---
Dump file: ajcore.20060216.175147.608.txt
Dump reason: java.lang.NullPointerException
Dump on exception: true
Dump at exit condition: abort
---- Exception Information ---
java.lang.NullPointerException
	at org.aspectj.weaver.bcel.BcelWeaver.validateOrBranch(BcelWeaver.java:611)
	at org.aspectj.weaver.bcel.BcelWeaver.validateBindings(BcelWeaver.java:579)
	at org.aspectj.weaver.bcel.BcelWeaver.rewritePointcuts(BcelWeaver.java:511)
	at org.aspectj.weaver.bcel.BcelWeaver.prepareForWeave(BcelWeaver.java:449)
	at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave(AjCompilerAdapter.java:283)
	at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling(AjCompilerAdapter.java:178)
	at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$afterReturning$org_aspectj_ajdt_internal_compiler_CompilerAdapter$2$f9cc9ca0(CompilerAdapter.aj:70)
	at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:367)
	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:811)
	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:230)
	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:156)
	at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:112)
	at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:60)
	at org.aspectj.tools.ajc.Main.run(Main.java:326)
	at org.aspectj.tools.ajc.Main.runMain(Main.java:240)
	at org.aspectj.tools.ajc.Main.main(Main.java:83)
---- System Properties ---
java.runtime.name=Java(TM) 2 Runtime Environment, Standard Edition
sun.boot.library.path=/opt/Java/jdk1.5.0_04/jre/lib/i386
java.vm.version=1.5.0_04-b05
java.vm.vendor=Sun Microsystems Inc.
java.vendor.url= http://java.sun.com/ 
path.separator=:
java.vm.name=Java HotSpot(TM) Client VM
file.encoding.pkg=sun.io
user.country=RU
sun.os.patch.level=unknown
java.vm.specification.name=Java Virtual Machine Specification
user.dir=/home/kei/ajdt-workspace/AspectJTests
java.runtime.version=1.5.0_04-b05
java.awt.graphicsenv=sun.awt.X11GraphicsEnvironment
java.endorsed.dirs=/opt/Java/jdk1.5.0_04/jre/lib/endorsed
os.arch=i386
java.io.tmpdir=/tmp
line.separator=

java.vm.specification.vendor=Sun Microsystems Inc.
os.name=Linux
sun.jnu.encoding=UTF-8
java.library.path=/opt/Java/jdk1.5.0_04/jre/lib/i386/client:/opt/Java/jdk1.5.0_04/jre/lib/i386:/opt/Java/jdk1.5.0_04/jre/../lib/i386:.:
java.specification.name=Java Platform API Specification
java.class.version=49.0
sun.management.compiler=HotSpot Client Compiler
os.version=2.6.15-1.1831_FC4
user.home=/home/kei
user.timezone=Europe/Kiev
java.awt.printerjob=sun.print.PSPrinterJob
file.encoding=UTF-8
java.specification.version=1.5
java.class.path=components/aspectjweaver.jar:components/aspectjtools.jar:components/aspectjrt.jar:components/aspectjlib.jar:/build/auroratest.jar:/opt/Java/aspectj1.5/lib/aspectjtools.jar:/opt/Java/jdk1.5.0_04/lib/tools.jar
user.name=kei
java.vm.specification.version=1.0
java.home=/opt/Java/jdk1.5.0_04/jre
sun.arch.data.model=32
user.language=ru
java.specification.vendor=Sun Microsystems Inc.
java.vm.info=mixed mode, sharing
java.version=1.5.0_04
java.ext.dirs=/opt/Java/jdk1.5.0_04/jre/lib/ext
sun.boot.class.path=/opt/Java/jdk1.5.0_04/jre/lib/rt.jar:/opt/Java/jdk1.5.0_04/jre/lib/i18n.jar:/opt/Java/jdk1.5.0_04/jre/lib/sunrsasign.jar:/opt/Java/jdk1.5.0_04/jre/lib/jsse.jar:/opt/Java/jdk1.5.0_04/jre/lib/jce.jar:/opt/Java/jdk1.5.0_04/jre/lib/charsets.jar:/opt/Java/jdk1.5.0_04/jre/classes
java.vendor=Sun Microsystems Inc.
file.separator=/
java.vendor.url.bug= http://java.sun.com/cgi-bin/bugreport.cgi 
sun.io.unicode.encoding=UnicodeLittle
sun.cpu.endian=little
sun.cpu.isalist=
---- Command Line ---
-1.5
Foo.java
---- Full Classpath ---
/opt/Java/jdk1.5.0_04/jre/lib/rt.jar(39713589 bytes)
/opt/Java/jdk1.5.0_04/jre/lib/i18n.jar(missing)
/opt/Java/jdk1.5.0_04/jre/lib/sunrsasign.jar(missing)
/opt/Java/jdk1.5.0_04/jre/lib/jsse.jar(549315 bytes)
/opt/Java/jdk1.5.0_04/jre/lib/jce.jar(81799 bytes)
/opt/Java/jdk1.5.0_04/jre/lib/charsets.jar(8627836 bytes)
/opt/Java/jdk1.5.0_04/jre/classes(missing)
/opt/Java/jdk1.5.0_04/jre/lib/ext/localedata.jar(802502 bytes)
/opt/Java/jdk1.5.0_04/jre/lib/ext/sunpkcs11.jar(175414 bytes)
/opt/Java/jdk1.5.0_04/jre/lib/ext/dnsns.jar(8176 bytes)
/opt/Java/jdk1.5.0_04/jre/lib/ext/sunjce_provider.jar(153235 bytes)
/opt/Java/jdk1.5.0_04/jre/lib/ext/bctsp-jdk15-129.jar(38357 bytes)
/opt/Java/jdk1.5.0_04/jre/lib/ext/bcprov-jdk15-129.jar(1168795 bytes)
/opt/Java/jdk1.5.0_04/jre/lib/ext/j3daudio.jar(1386793 bytes)
/opt/Java/jdk1.5.0_04/jre/lib/ext/bcmail-jdk15-129.jar(124831 bytes)
/opt/Java/jdk1.5.0_04/jre/lib/ext/j3dcore.jar(2514820 bytes)
/opt/Java/jdk1.5.0_04/jre/lib/ext/j3dutils.jar(1401997 bytes)
/opt/Java/jdk1.5.0_04/jre/lib/ext/vecmath.jar(290018 bytes)
/opt/Java/jdk1.5.0_04/jre/lib/ext/bcprov-jdk14-129.jar(1157625 bytes)
/opt/Java/jdk1.5.0_04/jre/lib/ext/bcmail-jdk14-129.jar(126679 bytes)
/home/kei/ajdt-workspace/AspectJTests/components/aspectjweaver.jar(1746917 bytes)
/home/kei/ajdt-workspace/AspectJTests/components/aspectjrt.jar(108647 bytes)
/home/kei/ajdt-workspace/AspectJTests/components/aspectjlib.jar(7845 bytes)
/build/auroratest.jar(missing)
/opt/Java/jdk1.5.0_04/lib/tools.jar(7015499 bytes)
/opt/Java/jdk1.5.0_04/jre/lib/ext/localedata.jar(802502 bytes)
/opt/Java/jdk1.5.0_04/jre/lib/ext/sunpkcs11.jar(175414 bytes)
/opt/Java/jdk1.5.0_04/jre/lib/ext/dnsns.jar(8176 bytes)
/opt/Java/jdk1.5.0_04/jre/lib/ext/sunjce_provider.jar(153235 bytes)
/opt/Java/jdk1.5.0_04/jre/lib/ext/bctsp-jdk15-129.jar(38357 bytes)
/opt/Java/jdk1.5.0_04/jre/lib/ext/bcprov-jdk15-129.jar(1168795 bytes)
/opt/Java/jdk1.5.0_04/jre/lib/ext/j3daudio.jar(1386793 bytes)
/opt/Java/jdk1.5.0_04/jre/lib/ext/bcmail-jdk15-129.jar(124831 bytes)
/opt/Java/jdk1.5.0_04/jre/lib/ext/j3dcore.jar(2514820 bytes)
/opt/Java/jdk1.5.0_04/jre/lib/ext/j3dutils.jar(1401997 bytes)
/opt/Java/jdk1.5.0_04/jre/lib/ext/vecmath.jar(290018 bytes)
/opt/Java/jdk1.5.0_04/jre/lib/ext/bcprov-jdk14-129.jar(1157625 bytes)
/opt/Java/jdk1.5.0_04/jre/lib/ext/bcmail-jdk14-129.jar(126679 bytes)
/home/kei/ajdt-workspace/AspectJTests/components/aspectjweaver.jar(1746917 bytes)
/home/kei/ajdt-workspace/AspectJTests/components/aspectjrt.jar(108647 bytes)
/home/kei/ajdt-workspace/AspectJTests/components/aspectjlib.jar(7845 bytes)
/build/auroratest.jar(missing)
/opt/Java/jdk1.5.0_04/lib/tools.jar(7015499 bytes)
---- Compiler Messages ---
abort ABORT -- (NullPointerException) null
null
java.lang.NullPointerException
	at org.aspectj.weaver.bcel.BcelWeaver.validateOrBranch(BcelWeaver.java:611)
	at org.aspectj.weaver.bcel.BcelWeaver.validateBindings(BcelWeaver.java:579)
	at org.aspectj.weaver.bcel.BcelWeaver.rewritePointcuts(BcelWeaver.java:511)
	at org.aspectj.weaver.bcel.BcelWeaver.prepareForWeave(BcelWeaver.java:449)
	at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave(AjCompilerAdapter.java:283)
	at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling(AjCompilerAdapter.java:178)
	at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$afterReturning$org_aspectj_ajdt_internal_compiler_CompilerAdapter$2$f9cc9ca0(CompilerAdapter.aj:70)
	at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:367)
	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:811)
	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:230)
	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:156)
	at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:112)
	at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:60)
	at org.aspectj.tools.ajc.Main.run(Main.java:326)
	at org.aspectj.tools.ajc.Main.runMain(Main.java:240)
	at org.aspectj.tools.ajc.Main.main(Main.java:83)

---- org.aspectj.weaver.bcel.BcelWorld ----
Shadow mungers:
(around(extraFlags: 2): (persingleton(AbstractTracer) &amp;&amp; (((execution(public * Foo+.*(..)) || execution(public * Foo+.blablabla(..))) &amp;&amp; !execution(public Foo+.new(..))) &amp;&amp; this(BindingTypePattern(java.lang.Object, 1))))-&gt;java.lang.Object AbstractTracer.aroundMethodCall(org.aspectj.lang.ProceedingJoinPoint, java.lang.Object))
Type mungers:
(BcelTypeMunger null)
(BcelTypeMunger ResolvedTypeMunger(PrivilegedAccess, void java.lang.Object.()))
Late Type mungers:
(BcelTypeMunger null)
------------------------------------------------------------------

I got same error with latest (aspectj-DEVELOPMENT-20060216105006) night build.</description><comments/></buginformation><fixedCommits><commit id="ba42a09551519a4b611ab06edb161ecb0c629f53" author="default" date="2006-02-21 15:55:33"><file name="weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java"><method name="validateOrBranch" returnType="void" parameters="OrPointcut Pointcut"/></file></commit></fixedCommits></bug><bug id="283" opendate="2006-02-20 06:36:00" fixdate="2006-02-21 16:07:04"><buginformation><summary>[incremental] XLint warnings in the wrong place with incremental compilation</summary><description>The zip file I am about to attach contains two AspectJ  project, one depending on the other.  If you make a small change to MainClass.java in 'Test Project' and save you will see a strange warning in that class - "advice defined in ras.FFDC has not been applied [Xlint:adviceDidNotMatch]".  If you do a full build the warning goes away.  Note that the error would be on line 36 if there were 36 lines in the class, which relates to a line in the FFDC aspect that contains advice.</description><comments/></buginformation><fixedCommits><commit id="89d66dc89110db0f89538a7b78308db61e5539cc" author="default" date="2006-02-21 16:07:04"><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/WeaverMessageHandler.java"><method name="handleMessage" returnType="boolean" parameters="IMessage"/></file></commit></fixedCommits></bug><bug id="284" opendate="2006-01-05 06:31:00" fixdate="2006-02-21 16:13:44"><buginformation><summary>[@AspectJ] VerifyError with @AfterThrowing/@AfterReturning and extra JoinPoint argument</summary><description>If an @AspectJ aspect advises itself using after throwing advice that itself throws an exception running the resulting program causes a VerifyError:

java.lang.VerifyError: (class: A, method: stop signature: ()V) catch_type not a subclass of Throwable
	at java.lang.Class.getDeclaredMethods0(Native Method)
	at java.lang.Class.privateGetDeclaredMethods(Class.java:2365)
	at java.lang.Class.getMethod0(Class.java:2611)
	at java.lang.Class.getMethod(Class.java:1579)
	at org.aspectj.tools.ajc.AjcTestCase.run(AjcTestCase.java:608)
	at org.aspectj.testing.RunSpec.execute(RunSpec.java:56)
	at org.aspectj.testing.AjcTest.runTest(AjcTest.java:68)
	at org.aspectj.testing.XMLBasedAjcTestCase.runTest(XMLBasedAjcTestCase.java:111)
	at org.aspectj.systemtest.ajc150.Ajc150Tests.testError(Ajc150Tests.java:877)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:585)
	at junit.framework.TestCase.runTest(TestCase.java:154)
	at junit.framework.TestCase.runBare(TestCase.java:127)
	at junit.framework.TestResult$1.protect(TestResult.java:106)
	at junit.framework.TestResult.runProtected(TestResult.java:124)
	at junit.framework.TestResult.run(TestResult.java:109)
	at junit.framework.TestCase.run(TestCase.java:118)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:478)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:344)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196)</description><comments/></buginformation><fixedCommits><commit id="3fa1bddb79a5e20a38cb39555e932df46f3d4dfa" author="default" date="2006-02-21 16:13:44"><file name="weaver/src/org/aspectj/weaver/Advice.java"><method name="getExtraParameterType" returnType="UnresolvedType" parameters=""/></file></commit></fixedCommits></bug><bug id="285" opendate="2005-12-17 02:53:00" fixdate="2006-02-23 11:34:16"><buginformation><summary>[performance]Contribution: Refactoring to Support LTW World with Reflection Delegates for Bootstrap Types</summary><description>This patch adds an IReflectionWorld interface, changes the various places in code where casts are made to ReflectionWorld to use that interface, creates some common methods and creates an LTWWorld that implements this interface, and sets up the ClassLoaderWeavingAdaptor to use it. It's important that the LTWWorld have just one type map for performance and memory efficiency.</description><comments/></buginformation><fixedCommits><commit id="cafdecb1028a9a72bfb4beb0e57a91f42c5c35cb" author="default" date="2006-02-23 11:34:16"><file name="weaver/src/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateFactory.java"><method name="createResolvedField" returnType="ResolvedMember" parameters="Field World"/><method name="createHandlerMember" returnType="ResolvedMember" parameters="Class Class World"/><method name="createResolvedMethod" returnType="ResolvedMember" parameters="Method World"/><method name="createResolvedConstructor" returnType="ResolvedMember" parameters="Constructor World"/><method name="createResolvedAdviceMember" returnType="ResolvedMember" parameters="Method World"/><method name="createStaticInitMember" returnType="ResolvedMember" parameters="Class World"/><method name="toResolvedTypeArray" returnType="ResolvedType[]" parameters="Class[] World"/><method name="toResolvedType" returnType="ResolvedType" parameters="Class ReflectionWorld"/></file><file name="weaver/src/org/aspectj/weaver/ltw/LTWWorld.java"><method name="makePerClauseAspect" returnType="ConcreteTypeMunger" parameters="ResolvedType Kind"/><method name="makeCflowStackFieldAdder" returnType="ConcreteTypeMunger" parameters="ResolvedMember"/><method name="createAdviceMunger" returnType="Advice" parameters="AdviceAttribute Pointcut Member"/><method name="makeCflowCounterFieldAdder" returnType="ConcreteTypeMunger" parameters="ResolvedMember"/><method name="concreteTypeMunger" returnType="ConcreteTypeMunger" parameters="ResolvedTypeMunger ResolvedType"/></file></commit></fixedCommits></bug><bug id="286" opendate="2006-02-24 03:45:00" fixdate="2006-02-24 12:11:15"><buginformation><summary>Contribution: Remove Memory Consuming Declared Signature</summary><description>The code for weaver.Member#getDeclaredSignature() is never used in the weaver. My memory analysis showed this can pin several megabytes of memory in a large system. This patch removes it. YAGNI :-)</description><comments/></buginformation><fixedCommits><commit id="a116142da250286f414946a76112c907e59c6beb" author="default" date="2006-02-24 12:11:15"><file name="weaver/src/org/aspectj/weaver/JoinPointSignature.java"><method name="getDeclaredSignature" returnType="String" parameters=""/></file><file name="weaver/src/org/aspectj/weaver/Member.java"><method name="getDeclaredSignature" returnType="String" parameters=""/></file><file name="weaver/src/org/aspectj/weaver/MemberImpl.java"><method name="getDeclaredSignature" returnType="String" parameters=""/></file></commit></fixedCommits></bug><bug id="287" opendate="2006-03-03 06:27:00" fixdate="2006-03-05 17:00:04"><buginformation><summary>Remove, hide or obfuscate -XnoWeave</summary><description>This option is redundant apart from use in AspectJ development and maintenance. It is confusing to users and is a source new problems for LTW.</description><comments/></buginformation><fixedCommits><commit id="b2259116b8731725743d255a85c894d6f998afb1" author="default" date="2006-03-05 17:00:04"><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/AjCompilerAdapter.java"><method name="afterProcessing" returnType="void" parameters="CompilationUnitDeclaration int"/><method name="afterCompiling" returnType="void" parameters="CompilationUnitDeclaration[]"/></file><file name="tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"><method name="testIllegalAccessErrorWithAroundAdviceNoWeaveLTW_pr119657" returnType="void" parameters=""/></file><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java"><method name="parseOption" returnType="void" parameters="String LinkedList"/></file><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.java"><method name="isNoWeave" returnType="boolean" parameters=""/><method name="installGlobals" returnType="void" parameters="AjBuildConfig"/><method name="setNoWeave" returnType="void" parameters="boolean"/></file><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"><method name="getAdapter" returnType="ICompilerAdapter" parameters=""/></file><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjCompilerOptions.java"><method name="getMap" returnType="Map" parameters=""/><method name="set" returnType="void" parameters="Map"/><method name="toString" returnType="String" parameters=""/></file><file name="taskdefs/testsrc/org/aspectj/tools/ant/taskdefs/AjcTaskTest.java"><method name="testDefaultFileComplete" returnType="void" parameters=""/></file><file name="org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/BcweaverJarMaker.java"><method name="makeJar1a" returnType="void" parameters=""/></file><file name="taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java"><method name="next" returnType="String" parameters=""/><method name="toString" returnType="String" parameters=""/><method name="setXNoweave" returnType="void" parameters="boolean"/></file><file name="ajde/testsrc/org/aspectj/ajde/BuildConfigurationTests.java"><method name="testNonStandardOptions" returnType="void" parameters=""/></file></commit></fixedCommits></bug><bug id="288" opendate="2005-06-23 03:47:00" fixdate="2006-03-09 17:24:19"><buginformation><summary>SerialVersionUID handling</summary><description>from emails - needs a decision
---------------
Hi Andy

is there a way for the weaver to add to weaved classes the serial ver
uid field based on the pre-weaved bytecode computation.
Right now it issues lint warning when a Serializable class without
serial ver uid is encountered and due to evil #75442 this is very
annoying for LTW.
A first step would be to at least deal with that when we had the
perObbjectTypeMunger (then should not change any kind previous stuff).

Alex

------------
Andy,

Generating the suid sounds like a nice idea but the code the JVM used is
private inside ObjectStreamClass. Also we need to take care with ITD fields
to ensure correct behaviour when sending and receiving from non-woven
classes. Basically the programmer needs to be engaged, it only affects
serializable classes and in 1.5 there is a warning if you don't declare the
field so there is a strong hint to the programmer to solve the problem. For
LTW we should make an enhancement to allow the user to configure Lint and
other things. For example they may or may not be interested in advice not
matching.

Matthew Webster

----------------------


Alex,

We should make a distinction between benign changes to suid and those that
affect members. Generating suid when we add a static initializer (to
support thisJoinPoint or the staticinitialization join point), accessor
methods for privileged aspects or transient per-fields is OK. Doing for
ITDs is more problematic.

Matthew Webster</description><comments/></buginformation><fixedCommits><commit id="6e6658a5e9e1665d18f3b4eb8d94609592b56228" author="default" date="2006-03-09 17:24:19"><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java"><method name="parseOption" returnType="void" parameters="String LinkedList"/></file><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.java"><method name="installGlobals" returnType="void" parameters="AjBuildConfig"/></file><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"><method name="initBcelWorld" returnType="void" parameters="IMessageHandler"/></file><file name="tests/src/org/aspectj/systemtest/ajc151/AllTestsAspectJ151.java"><method name="suite" returnType="Test" parameters=""/></file></commit></fixedCommits></bug><bug id="289" opendate="2006-03-13 05:37:00" fixdate="2006-03-15 12:34:48"><buginformation><summary>Generated aop.xml files contain aspects for all the projects ever built</summary><description>Using the -outxml option in AJDT the generated aop.xml files are not correct after the first build and contain all the aspects that have ever been built (including those in different projects and duplicates if an aspect has been built twice).  It seems that there is a global list of aspects (aspectNames in AjBuildManager) that is never cleared.</description><comments/></buginformation><fixedCommits><commit id="b3cd01d587219969e7c7b58ecda5b1aeb7722c2e" author="default" date="2006-03-15 12:34:48"><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"><method name="accept" returnType="boolean" parameters="File"/><method name="addAspectName" returnType="void" parameters="String"/><method name="writeOutxmlFile" returnType="void" parameters=""/></file><file name="tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java"><method name="log" returnType="void" parameters="String"/></file></commit></fixedCommits></bug><bug id="290" opendate="2006-03-15 09:46:00" fixdate="2006-03-16 11:01:54"><buginformation><summary>grotty ClassCastException on referring to pointcut in generic type</summary><description>import java.util.List;

public aspect Slide71 {
	before(): GenericType&lt;String&gt;.foo() {}
	before(): GenericType&lt;MyList&gt;.foo() {}
	//before(): GenericType.foo() {}
}
	
class GenericType&lt;T&gt; {
	public pointcut foo(): execution(* T.*(..));
}

that programs gives:  (because MyList is not a known type)

java.lang.ClassCastException
at org.aspectj.weaver.patterns.TypePattern.resolveExactType(TypePattern.java:193)
at org.aspectj.weaver.patterns.ReferencePointcut.resolveBindings(ReferencePointcut.java:130)
at org.aspectj.weaver.patterns.Pointcut.resolve(Pointcut.java:194)
at org.aspectj.ajdt.internal.compiler.ast.PointcutDesignator.finishResolveTypes(PointcutDesignator.java:84)
at org.aspectj.ajdt.internal.compiler.ast.AdviceDeclaration.resolveStatements(AdviceDeclaration.java:118)
at org.aspectj.org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:400)
at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1088)
at org.aspectj.ajdt.internal.compiler.ast.AspectDeclaration.resolve(AspectDeclaration.java:116)
at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1137)
at org.aspectj.org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:305)
at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:514)
at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:329)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:843)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:268)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.incrementalBuild(AjBuildManager.java:170)
at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:117)
at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)

ClassCastException thrown: org.aspectj.weaver.patterns.WildTypePattern</description><comments/></buginformation><fixedCommits><commit id="f2cd94f88a9976fc98786955a764522a8ccb37f1" author="default" date="2006-03-16 11:01:54"><file name="weaver/src/org/aspectj/weaver/patterns/TypePattern.java"><method name="resolveExactType" returnType="UnresolvedType" parameters="IScope Bindings"/></file></commit></fixedCommits></bug><bug id="291" opendate="2006-03-15 09:45:00" fixdate="2006-03-16 15:34:26"><buginformation><summary>structure model bug: generic method ITD</summary><description>import java.util.List;

public aspect Slide74 {

	public X Bar&lt;X&gt;.getFirst() {
		return lts.get(0);
	}
	
	static class Bar&lt;T&gt; {
		List&lt;T&gt; lts;
	}
}

in AJDT, this program incorrectly shows the relationship from the TYPE to the Bar class rather than from the ITD to the Bar class.</description><comments/></buginformation><fixedCommits><commit id="e2703cf67fe6c68cc0e91aecdbfa4e07e51c6fc7" author="default" date="2006-03-16 15:34:26"><file name="weaver/src/org/aspectj/weaver/NewConstructorTypeMunger.java"><method name="parameterizedFor" returnType="ResolvedTypeMunger" parameters="ResolvedType"/></file><file name="weaver/src/org/aspectj/weaver/NewFieldTypeMunger.java"><method name="parameterizedFor" returnType="ResolvedTypeMunger" parameters="ResolvedType"/></file><file name="weaver/src/org/aspectj/weaver/NewMethodTypeMunger.java"><method name="parameterizedFor" returnType="ResolvedTypeMunger" parameters="ResolvedType"/></file></commit></fixedCommits></bug><bug id="292" opendate="2006-03-16 06:24:00" fixdate="2006-03-17 16:47:06"><buginformation><summary>Missing relationship for declare @method when annotating a co-located method</summary><description>For this program (when all entered into *one* file) I don't see a marker from the declare to the annotated method.  If the annotated method is in another file, I do... (not sure if fields/ctors/types are also a problem..)

public aspect basic {

        declare @method:
                 * debit(..):
                 @Secured(role="supervisor");

}

class BankAccount {
        public void debit(long accId,long amount) {
        }
}

@interface Secured {
        String role();
}</description><comments/></buginformation><fixedCommits><commit id="9dca72e7c63a5623f3d442bf43bb88810368a65a" author="default" date="2006-03-17 16:47:06"><file name="ajde/testsrc/org/aspectj/ajde/AsmDeclarationsTest.java"><method name="testAdvice" returnType="void" parameters=""/><method name="testInterTypeMemberDeclares" returnType="void" parameters=""/><method name="testPointcuts" returnType="void" parameters=""/></file><file name="ajdoc/testsrc/org/aspectj/tools/ajdoc/CoverageTestCase.java"><method name="testAdviceNamingCoverage" returnType="void" parameters=""/></file><file name="tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java"><method name="testIProgramElementMethods_pr125295" returnType="void" parameters=""/></file><file name="asm/src/org/aspectj/asm/internal/ProgramElement.java"><method name="toSignatureString" returnType="String" parameters="boolean"/></file><file name="ajde/testsrc/org/aspectj/ajde/AsmRelationshipsTest.java"><method name="testInterTypeDeclarations" returnType="void" parameters=""/></file></commit></fixedCommits></bug><bug id="293" opendate="2006-03-22 20:05:00" fixdate="2006-03-24 10:10:02"><buginformation><summary>Compiler crashes processing annotations</summary><description>Just upgraded to latest AJDT (Version: 1.3.1, Build id: 20060322082516
AspectJ version: 1.5.1.20060320075953)
and the compiler crashed while rebulding the project (which used to work fine 
using using the March 16th version). Retrying with 'clean' build produced the
same crash.

java.lang.NullPointerException
at org.aspectj.weaver.AnnotationX.ensureAtTargetInitialized(AnnotationX.java:158)
at org.aspectj.weaver.AnnotationX.specifiesTarget(AnnotationX.java:98)
at org.aspectj.weaver.bcel.BcelWeaver.verifyTargetIsOK(BcelWeaver.java:1450)
at org.aspectj.weaver.bcel.BcelWeaver.applyDeclareAtType(BcelWeaver.java:1417)
at org.aspectj.weaver.bcel.BcelWeaver.weaveParentTypeMungers(BcelWeaver.java:1366)
at org.aspectj.weaver.bcel.BcelWeaver.weaveParentsFor(BcelWeaver.java:1223)
at org.aspectj.weaver.bcel.BcelWeaver.weaveParentsFor(BcelWeaver.java:1211)
at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1058)
at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave(AjCompilerAdapter.java:311)
at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling(AjCompilerAdapter.java:183)
at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$afterReturning$org_aspectj_ajdt_internal_compiler_CompilerAdapter$2$f9cc9ca0(CompilerAdapter.aj:70)
at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:367)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:845)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:241)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:161)
at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:122)
at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)

NullPointerException thrown: null</description><comments/></buginformation><fixedCommits><commit id="2fb86fe604b613774492df5185b1c5717c434d29" author="default" date="2006-03-24 10:10:02"><file name="weaver/src/org/aspectj/weaver/AnnotationX.java"><method name="ensureAtTargetInitialized" returnType="void" parameters=""/></file></commit></fixedCommits></bug><bug id="294" opendate="2006-03-26 21:05:00" fixdate="2006-03-27 13:42:23"><buginformation><summary>declare parents implementing generic interface referencing same type</summary><description>I have the following construct:

public interface TestIF&lt;T extends TestIF&gt; {}

public class TestClass {}

public aspect TestAspect {

    declare parents: TestClass implements TestIF&lt;TestClass&gt;; 

}



The later aspect does not compile, although 

public class TestClass implements TestIF&lt;TestClass&gt; {

}
is a valid class.</description><comments/></buginformation><fixedCommits><commit id="c9a60e519d73bb7aa4d8cf4615445089202bd3ad" author="default" date="2006-03-27 13:42:23"><file name="weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java"><method name="checkBoundsOK" returnType="boolean" parameters="IScope ResolvedType boolean"/><method name="verifyTypeParameters" returnType="boolean" parameters="ResolvedType IScope"/></file><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java"><method name="completeTypeBindings" returnType="void" parameters=""/></file><file name="weaver/src/org/aspectj/weaver/CrosscuttingMembersSet.java"><method name="reset" returnType="void" parameters=""/><method name="hasChangedSinceLastReset" returnType="boolean" parameters=""/></file></commit></fixedCommits></bug><bug id="295" opendate="2006-03-16 09:52:00" fixdate="2006-03-27 19:11:57"><buginformation><summary>NPE in SingleTypeReference</summary><description>I was C&amp;P'ing the guts of another aspect into a new file (from another project that I'm porting over).  There are a number of errors in the aspect (as most of the references point to the other project).  I just changed an object from one type (in the other project) to a type in the project that the file is in.


Eclipse SDK
Version: 3.1.2
Build id: M20060118-1600

Version: 1.3.0
Build id: 20051220093604
AspectJ version: 1.5.0

----------------------------------------------------------------

java.lang.NullPointerException
at org.aspectj.org.eclipse.jdt.internal.compiler.ast.SingleTypeReference.getTypeBinding(SingleTypeReference.java:39)
at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeReference.getTypeBindingPublic(TypeReference.java:98)
at org.aspectj.ajdt.internal.core.builder.AsmElementFormatter.genLabelAndKind(AsmElementFormatter.java:230)
at org.aspectj.ajdt.internal.core.builder.AsmHierarchyBuilder.visit(AsmHierarchyBuilder.java:399)
at org.aspectj.org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.traverse(MethodDeclaration.java:185)
at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.traverse(TypeDeclaration.java:1250)
at org.aspectj.org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.traverse(QualifiedAllocationExpression.java:392)
at org.aspectj.org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.traverse(LocalDeclaration.java:242)
at org.aspectj.org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.traverse(MethodDeclaration.java:212)
at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.traverse(TypeDeclaration.java:1195)
at org.aspectj.org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.traverse(CompilationUnitDeclaration.java:339)
at org.aspectj.ajdt.internal.core.builder.AsmHierarchyBuilder.internalBuild(AsmHierarchyBuilder.java:142)
at org.aspectj.ajdt.internal.core.builder.AsmHierarchyBuilder.buildStructureForCompilationUnit(AsmHierarchyBuilder.java:82)
at org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.finishedCompilationUnit(EclipseFactory.java:926)
at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterProcessing(AjCompilerAdapter.java:195)
at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$afterReturning$org_aspectj_ajdt_internal_compiler_CompilerAdapter$4$6b855184(CompilerAdapter.aj:89)
at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:528)
at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:329)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:811)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:230)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:185)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.incrementalBuild(AjBuildManager.java:163)
at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:117)
at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)

NullPointerException thrown: null</description><comments/></buginformation><fixedCommits><commit id="91473b3badbc89811be8c6223adc6b6641e496d2" author="default" date="2006-03-27 19:11:57"><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmElementFormatter.java"><method name="genLabelAndKind" returnType="void" parameters="MethodDeclaration"/></file></commit></fixedCommits></bug><bug id="296" opendate="2006-03-15 23:56:00" fixdate="2006-03-27 21:39:46"><buginformation><summary>NPE from unbound variable in advice</summary><description>I get this error from having an unbound reference to a variable in an aspect. See attached AJDT project for an example.

java.lang.NullPointerException
at org.aspectj.ajdt.internal.core.builder.AsmHierarchyBuilder.visit(AsmHierarchyBuilder.java:412)
at org.aspectj.org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.traverse(MethodDeclaration.java:185)
at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.traverse(TypeDeclaration.java:1250)
at org.aspectj.org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.traverse(QualifiedAllocationExpression.java:392)
at org.aspectj.org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.traverse(LocalDeclaration.java:242)
at org.aspectj.org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.traverse(MethodDeclaration.java:212)
at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.traverse(TypeDeclaration.java:1195)
at org.aspectj.org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.traverse(CompilationUnitDeclaration.java:339)
at org.aspectj.ajdt.internal.core.builder.AsmHierarchyBuilder.internalBuild(AsmHierarchyBuilder.java:143)
at org.aspectj.ajdt.internal.core.builder.AsmHierarchyBuilder.buildStructureForCompilationUnit(AsmHierarchyBuilder.java:82)
at org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.finishedCompilationUnit(EclipseFactory.java:927)
at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterProcessing(AjCompilerAdapter.java:201)
at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$afterReturning$org_aspectj_ajdt_internal_compiler_CompilerAdapter$4$6b855184(CompilerAdapter.aj:90)
at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:528)
at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:329)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:843)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:243)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:163)
at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:122)
at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)

NullPointerException thrown: null</description><comments/></buginformation><fixedCommits><commit id="fa2ed1b8d8350afe051a21a510fb4fc929d5f43d" author="default" date="2006-03-27 21:39:46"><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmHierarchyBuilder.java"><method name="visit" returnType="boolean" parameters="MethodDeclaration ClassScope"/></file></commit></fixedCommits></bug><bug id="297" opendate="2006-04-03 12:03:00" fixdate="2006-04-06 10:44:14"><buginformation><summary>adviceDidNotMatch's line number doesn't keep up with line number of advice</summary><description>When advice doesn't match in a 1.5.0 enabled project, there is an adviceDidNotMatch warning against the line number of the advice. If you insert a line before this advice and save then the warning stays associated with the original line and not the new one. Full building puts the warning against the new line. 

This is a regression and didn't happen in AJ 1.5.0.</description><comments/></buginformation><fixedCommits><commit id="94d8b82fbf3cb18a14d77508b3adad6d50434080" author="default" date="2006-04-06 10:44:14"><file name="weaver/src/org/aspectj/weaver/CrosscuttingMembersSet.java"><method name="addOrReplaceAspect" returnType="boolean" parameters="ResolvedType"/></file><file name="weaver/src/org/aspectj/weaver/CrosscuttingMembers.java"><method name="replaceWith" returnType="boolean" parameters="CrosscuttingMembers"/></file></commit></fixedCommits></bug><bug id="298" opendate="2006-04-05 07:10:00" fixdate="2006-04-06 11:45:02"><buginformation><summary>NPE at at org.aspectj.weaver.bcel.BcelShadow.weaveAroundInline</summary><description>java.lang.NullPointerException
at org.aspectj.weaver.bcel.BcelShadow.weaveAroundInline(BcelShadow.java:2109)
at org.aspectj.weaver.bcel.BcelAdvice.implementOn(BcelAdvice.java:232)
at org.aspectj.weaver.Shadow.implementMungers(Shadow.java:639)
at org.aspectj.weaver.Shadow.implement(Shadow.java:456)
at org.aspectj.weaver.bcel.BcelClassWeaver.implement(BcelClassWeaver.java:2236)
at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:491)
at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:109)
at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1560)
at org.aspectj.weaver.bcel.BcelWeaver.weaveWithoutDump(BcelWeaver.java:1511)
at org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify(BcelWeaver.java:1291)
at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1113)
at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave(AjCompilerAdapter.java:311)
at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling(AjCompilerAdapter.java:183)
at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$afterReturning$org_aspectj_ajdt_internal_compiler_CompilerAdapter$2$f9cc9ca0(CompilerAdapter.aj:70)
at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:367)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:862)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:242)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:161)
at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:122)
at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)</description><comments/></buginformation><fixedCommits><commit id="1a6f69583137f03d2a8052148a17eebe8e79e162" author="default" date="2006-04-06 11:45:02"><file name="weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"><method name="weaveAroundInline" returnType="void" parameters=""/></file><file name="weaver/src/org/aspectj/weaver/bcel/BcelWorld.java"><method name="resolveDelegate" returnType="ReferenceTypeDelegate" parameters="ReferenceType"/><method name="resolve" returnType="ResolvedType" parameters="Type"/></file><file name="tests/src/org/aspectj/systemtest/AllTests15.java"><method name="suite" returnType="Test" parameters=""/></file><file name="weaver/testsrc/org/aspectj/weaver/bcel/AsmDelegateTests.java"><method name="testLoadingAttributesForMethods" returnType="void" parameters=""/><method name="testLoadingAttributesForTypes" returnType="void" parameters=""/><method name="testWeDontGoBang" returnType="void" parameters=""/></file></commit></fixedCommits></bug><bug id="299" opendate="2006-04-13 11:34:00" fixdate="2006-04-18 10:51:38"><buginformation><summary>Bug: ajc fails on missing classpath entries with fix</summary><description>[iajc] error at (no source information available)
     [iajc] File.aj:0::0 Internal compiler error
     [iajc] org.aspectj.weaver.BCException: Can't open archive: missingjar

     [iajc] when resolving types defined in compilation unit File.aj
     [iajc] when processing compilation unit File.aj
     [iajc] when batch building BuildConfig[null] #Files=14
     [iajc]
     [iajc]     at org.aspectj.weaver.bcel.ClassPathManager$ZipFileEntry.ensureO
pen(ClassPathManager.java:258)
     [iajc]     at org.aspectj.weaver.bcel.ClassPathManager$ZipFileEntry.find(Cl
assPathManager.java:225)
     [iajc]     at org.aspectj.weaver.bcel.ClassPathManager.find(ClassPathManage
r.java:92)
     [iajc]     at org.aspectj.weaver.bcel.BcelWorld.resolveDelegate(BcelWorld.j
ava:287)
     [iajc]     at org.aspectj.weaver.World.resolveToReferenceType(World.java:33
5)
     [iajc]     at org.aspectj.weaver.World.resolve(World.java:251)
     [iajc]     at org.aspectj.weaver.patterns.WildTypePattern.lookupTypeInWorld
(WildTypePattern.java:716)
     [iajc]     at org.aspectj.weaver.patterns.WildTypePattern.resolveBindingsFr
omFullyQualifiedTypeName(WildTypePattern.java:690)
     [iajc]     at org.aspectj.weaver.patterns.WildTypePattern.resolveBindings(W
ildTypePattern.java:623)
     [iajc]     at org.aspectj.weaver.patterns.SignaturePattern.resolveBindings(
SignaturePattern.java:82)
     [iajc]     at org.aspectj.weaver.patterns.KindedPointcut.resolveBindings(Ki
ndedPointcut.java:259)
     [iajc]     at org.aspectj.weaver.patterns.AndPointcut.resolveBindings(AndPo
intcut.java:74)
     [iajc]     at org.aspectj.weaver.patterns.Pointcut.resolve(Pointcut.java:19
4)
     [iajc]     at org.aspectj.ajdt.internal.compiler.ast.PointcutDesignator.fin
ishResolveTypes(PointcutDesignator.java:84)
     [iajc]     at org.aspectj.ajdt.internal.compiler.ast.AdviceDeclaration.reso
lveStatements(AdviceDeclaration.java:118)
     [iajc]     at org.aspectj.org.eclipse.jdt.internal.compiler.ast.AbstractMet
hodDeclaration.resolve(AbstractMethodDeclaration.java:400)
     [iajc]     at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclara
tion.resolve(TypeDeclaration.java:1088)
     [iajc]     at org.aspectj.ajdt.internal.compiler.ast.AspectDeclaration.reso
lve(AspectDeclaration.java:116)
     [iajc]     at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclara
tion.resolve(TypeDeclaration.java:1137)
     [iajc]     at org.aspectj.org.eclipse.jdt.internal.compiler.ast.Compilation
UnitDeclaration.resolve(CompilationUnitDeclaration.java:305)
     [iajc]     at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.proces
s(Compiler.java:514)
     [iajc]     at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compil
e(Compiler.java:329)
     [iajc]     at org.aspectj.ajdt.internal.core.builder.AjBuildManager.perform
Compilation(AjBuildManager.java:845)
     [iajc]     at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild
(AjBuildManager.java:241)
     [iajc]     at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBu
ild(AjBuildManager.java:161)
     [iajc]     at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:1
12)
     [iajc]     at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:
60)
     [iajc]     at org.aspectj.tools.ajc.Main.run(Main.java:356)
     [iajc]     at org.aspectj.tools.ajc.Main.runMain(Main.java:246)
     [iajc]     at org.aspectj.tools.ant.taskdefs.AjcTask.executeInSameVM(AjcTas
k.java:1262)
     [iajc]     at org.aspectj.tools.ant.taskdefs.AjcTask.execute(AjcTask.java:1
056)
     [iajc]     at org.apache.tools.ant.UnknownElement.execute(UnknownElement.ja
va:275)
     [iajc]     at org.apache.tools.ant.Task.perform(Task.java:364)
     [iajc]     at org.apache.tools.ant.Target.execute(Target.java:341)
     [iajc]     at org.apache.tools.ant.Target.performTasks(Target.java:369)
     [iajc]     at org.apache.tools.ant.Project.executeTarget(Project.java:1214)

     [iajc]     at org.apache.tools.ant.taskdefs.Ant.execute(Ant.java:386)
     [iajc]     at org.apache.tools.ant.taskdefs.CallTarget.execute(CallTarget.j
ava:106)
     [iajc]     at org.apache.tools.ant.UnknownElement.execute(UnknownElement.ja
va:275)
     [iajc]     at org.apache.tools.ant.Task.perform(Task.java:364)
     [iajc]     at org.apache.tools.ant.Target.execute(Target.java:341)
     [iajc]     at org.apache.tools.ant.Target.performTasks(Target.java:369)
     [iajc]     at org.apache.tools.ant.Project.executeTarget(Project.java:1214)

     [iajc]     at org.apache.tools.ant.Project.executeTargets(Project.java:1062
)
     [iajc]     at org.apache.tools.ant.Main.runBuild(Main.java:673)
     [iajc]     at org.apache.tools.ant.Main.startAnt(Main.java:188)
     [iajc]     at org.apache.tools.ant.launch.Launcher.run(Launcher.java:196)
     [iajc]     at org.apache.tools.ant.launch.Launcher.main(Launcher.java:55)
     [iajc] Caused by: java.util.zip.ZipException: error in opening zip file
     [iajc] java.util.zip.ZipException: error in opening zip file
     [iajc]     at java.util.zip.ZipFile.open(Native Method)
     [iajc]     at java.util.zip.ZipFile.&lt;init&gt;(ZipFile.java:111)
     [iajc]     at java.util.zip.ZipFile.&lt;init&gt;(ZipFile.java:127)
     [iajc]     at org.aspectj.weaver.bcel.ClassPathManager$ZipFileEntry.ensureO
pen(ClassPathManager.java:252)
     [iajc]     at org.aspectj.weaver.bcel.ClassPathManager$ZipFileEntry.find(Cl
assPathManager.java:225)
     [iajc]     at org.aspectj.weaver.bcel.ClassPathManager.find(ClassPathManage
r.java:92)
     [iajc]     at org.aspectj.weaver.bcel.BcelWorld.resolveDelegate(BcelWorld.j
ava:287)
     [iajc]     at org.aspectj.weaver.World.resolveToReferenceType(World.java:33
5)
     [iajc]     at org.aspectj.weaver.World.resolve(World.java:251)
     [iajc]     at org.aspectj.weaver.patterns.WildTypePattern.lookupTypeInWorld
(WildTypePattern.java:716)
     [iajc]     at org.aspectj.weaver.patterns.WildTypePattern.resolveBindingsFr
omFullyQualifiedTypeName(WildTypePattern.java:690)
     [iajc]     at org.aspectj.weaver.patterns.WildTypePattern.resolveBindings(W
ildTypePattern.java:623)
     [iajc]     at org.aspectj.weaver.patterns.SignaturePattern.resolveBindings(
SignaturePattern.java:82)
     [iajc]     at org.aspectj.weaver.patterns.KindedPointcut.resolveBindings(Ki
ndedPointcut.java:259)
     [iajc]     at org.aspectj.weaver.patterns.AndPointcut.resolveBindings(AndPo
intcut.java:74)
     [iajc]     at org.aspectj.weaver.patterns.Pointcut.resolve(Pointcut.java:19
4)
     [iajc]     at org.aspectj.ajdt.internal.compiler.ast.PointcutDesignator.fin
ishResolveTypes(PointcutDesignator.java:84)
     [iajc]     at org.aspectj.ajdt.internal.compiler.ast.AdviceDeclaration.reso
lveStatements(AdviceDeclaration.java:118)
     [iajc]     at org.aspectj.org.eclipse.jdt.internal.compiler.ast.AbstractMet
hodDeclaration.resolve(AbstractMethodDeclaration.java:400)
     [iajc]     at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclara
tion.resolve(TypeDeclaration.java:1088)
     [iajc]     at org.aspectj.ajdt.internal.compiler.ast.AspectDeclaration.reso
lve(AspectDeclaration.java:116)
     [iajc]     at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclara
tion.resolve(TypeDeclaration.java:1137)
     [iajc]     at org.aspectj.org.eclipse.jdt.internal.compiler.ast.Compilation
UnitDeclaration.resolve(CompilationUnitDeclaration.java:305)
     [iajc]     at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.proces
s(Compiler.java:514)
     [iajc]     at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compil
e(Compiler.java:329)
     [iajc]     at org.aspectj.ajdt.internal.core.builder.AjBuildManager.perform
Compilation(AjBuildManager.java:845)
     [iajc]     at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild
(AjBuildManager.java:241)
     [iajc]     at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBu
ild(AjBuildManager.java:161)
     [iajc]     at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:1
12)
     [iajc]     at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:
60)
     [iajc]     at org.aspectj.tools.ajc.Main.run(Main.java:356)
     [iajc]     at org.aspectj.tools.ajc.Main.runMain(Main.java:246)
     [iajc]     at org.aspectj.tools.ant.taskdefs.AjcTask.executeInSameVM(AjcTas
k.java:1262)
     [iajc]     at org.aspectj.tools.ant.taskdefs.AjcTask.execute(AjcTask.java:1
056)
     [iajc]     at org.apache.tools.ant.UnknownElement.execute(UnknownElement.ja
va:275)
     [iajc]     at org.apache.tools.ant.Task.perform(Task.java:364)
     [iajc]     at org.apache.tools.ant.Target.execute(Target.java:341)
     [iajc]     at org.apache.tools.ant.Target.performTasks(Target.java:369)
     [iajc]     at org.apache.tools.ant.Project.executeTarget(Project.java:1214)

     [iajc]     at org.apache.tools.ant.taskdefs.Ant.execute(Ant.java:386)
     [iajc]     at org.apache.tools.ant.taskdefs.CallTarget.execute(CallTarget.j
ava:106)
     [iajc]     at org.apache.tools.ant.UnknownElement.execute(UnknownElement.ja
va:275)
     [iajc]     at org.apache.tools.ant.Task.perform(Task.java:364)
     [iajc]     at org.apache.tools.ant.Target.execute(Target.java:341)
     [iajc]     at org.apache.tools.ant.Target.performTasks(Target.java:369)
     [iajc]     at org.apache.tools.ant.Project.executeTarget(Project.java:1214)

     [iajc]     at org.apache.tools.ant.Project.executeTargets(Project.java:1062
)
     [iajc]     at org.apache.tools.ant.Main.runBuild(Main.java:673)
     [iajc]     at org.apache.tools.ant.Main.startAnt(Main.java:188)
     [iajc]     at org.apache.tools.ant.launch.Launcher.run(Launcher.java:196)
     [iajc]     at org.apache.tools.ant.launch.Launcher.main(Launcher.java:55)
     [iajc] abort ABORT -- (BCException) Can't open archive: wissing.jar
     [iajc] when resolving types defined in compilation unit File.aj
     [iajc] when processing compilation unit File.aj
     [iajc] when batch building BuildConfig[null] #Files=14</description><comments/></buginformation><fixedCommits><commit id="d1a252e911bd19747b0cd6815291f62706f202d6" author="default" date="2006-04-18 10:51:38"><file name="weaver/src/org/aspectj/weaver/bcel/ClassPathManager.java"><method name="getAllClassFiles" returnType="List" parameters=""/><method name="find" returnType="ClassFile" parameters="String"/><method name="find" returnType="ClassFile" parameters="UnresolvedType"/><method name="ensureOpen" returnType="void" parameters=""/></file></commit></fixedCommits></bug><bug id="300" opendate="2006-04-13 05:38:00" fixdate="2006-04-19 13:36:39"><buginformation><summary>NullPointerException in PerObjectInterfaceTypeMunger.java:33</summary><description>AspectJ 1.5.1a + AJDT 1.4.0-dev on Eclipse 3.2M6
Using the Sapcewar example, open Game.java and add:
   public void foo() {}
save and an incremental build will fail with:

java.lang.NullPointerException
at org.aspectj.weaver.PerObjectInterfaceTypeMunger.equals(PerObjectInterfaceTypeMunger.java:33)
at org.aspectj.weaver.bcel.BcelTypeMunger.equals(BcelTypeMunger.java:1672)
at java.util.AbstractList.equals(AbstractList.java:610)
at org.aspectj.weaver.CrosscuttingMembers.replaceWith(CrosscuttingMembers.java:321)
at org.aspectj.weaver.CrosscuttingMembersSet.addOrReplaceAspect(CrosscuttingMembersSet.java:73)
at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.addCrosscuttingStructures(AjLookupEnvironment.java:397)
at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.collectAllITDsAndDeclares(AjLookupEnvironment.java:333)
at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.completeTypeBindings(AjLookupEnvironment.java:173)
at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.beginToCompile(Compiler.java:301)
at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:315)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:862)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:269)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.incrementalBuild(AjBuildManager.java:168)
at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:117)
at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)

NullPointerException thrown: null</description><comments/></buginformation><fixedCommits><commit id="1535ee721c16509713642e20316b226ece69fda9" author="default" date="2006-04-19 13:36:39"><file name="weaver/src/org/aspectj/weaver/PerObjectInterfaceTypeMunger.java"><method name="equals" returnType="boolean" parameters="Object"/></file></commit></fixedCommits></bug><bug id="301" opendate="2006-04-25 20:18:00" fixdate="2006-04-26 07:25:49"><buginformation><summary>Patch to add support for -Xset: options</summary><description>I needed to add X="set:activateLightweightDelegates=false鈥 to my ant build configuration, to troubleshoot the out of memory permgen condition. However, the ant task support doesn't currently support adding the new -Xset style options Andy added.

Here is a small patch to pass any -Xset: options through, that worked for me.</description><comments/></buginformation><fixedCommits><commit id="99882cb91a94c468c185cf11cd6a728604e95bdb" author="default" date="2006-04-26 07:25:49"><file name="taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java"><method name="setX" returnType="void" parameters="String"/></file></commit></fixedCommits></bug><bug id="302" opendate="2006-04-24 18:29:00" fixdate="2006-04-26 16:45:17"><buginformation><summary>perthis() causes ClassCastException</summary><description>When using perthis() with an aspect, I see the following Internal Compiler 

AJDT 1.3.1 / AspectJ 1.5.1a
Build 20060406092046
Eclipse 3.1.2, Windows XP, JDK 1.5


Error:

java.lang.ClassCastException
at org.aspectj.weaver.patterns.PerThisOrTargetPointcutVisitor.getPerTypePointcut(PerThisOrTargetPointcutVisitor.java:41)
at org.aspectj.weaver.patterns.PerThisOrTargetPointcutVisitor.visit(PerThisOrTargetPointcutVisitor.java:108)
at org.aspectj.weaver.patterns.AndPointcut.accept(AndPointcut.java:119)
at org.aspectj.weaver.patterns.PerThisOrTargetPointcutVisitor.getPerTypePointcut(PerThisOrTargetPointcutVisitor.java:41)
at org.aspectj.weaver.PerObjectInterfaceTypeMunger.getTestTypePattern(PerObjectInterfaceTypeMunger.java:64)
at org.aspectj.weaver.PerObjectInterfaceTypeMunger.matches(PerObjectInterfaceTypeMunger.java:85)
at org.aspectj.weaver.ConcreteTypeMunger.matches(ConcreteTypeMunger.java:65)
at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:508)
at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:109)
at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1560)
at org.aspectj.weaver.bcel.BcelWeaver.weaveWithoutDump(BcelWeaver.java:1511)
at org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify(BcelWeaver.java:1291)
at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1089)
at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave(AjCompilerAdapter.java:311)
at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling(AjCompilerAdapter.java:183)
at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$afterReturning$org_aspectj_ajdt_internal_compiler_CompilerAdapter$2$f9cc9ca0(CompilerAdapter.aj:70)
at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:367)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:862)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:242)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:161)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:278)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.incrementalBuild(AjBuildManager.java:168)
at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:117)
at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)

trouble in: 
public abstract class org.apache.tapestry.internal.aspects.AbstractClassTargetting extends java.lang.Object:
  public void &lt;init&gt;():
                    ALOAD_0     // Lorg/apache/tapestry/internal/aspects/AbstractClassTargetting; this   (line 10)
                    INVOKESPECIAL java.lang.Object.&lt;init&gt; ()V
    initialization(void org.apache.tapestry.internal.aspects.AbstractClassTargetting.&lt;init&gt;())
    |               ALOAD_0
    |               INVOKEVIRTUAL java.lang.Object.getClass ()Ljava/lang/Class;
    |               LDC org.apache.tapestry.internal.annotations.Synchronized
    |               INVOKEVIRTUAL java.lang.Class.isAnnotationPresent (Ljava/lang/Class;)Z
    |               IFEQ L0
    |               ALOAD_0
    |               INVOKESTATIC org.apache.tapestry.internal.aspects.InternalSynchronization.ajc$perObjectBind (Ljava/lang/Object;)V
    | constructor-execution(void org.apache.tapestry.internal.aspects.AbstractClassTargetting.&lt;init&gt;())
    | |         L0: ALOAD_0
    | |             INVOKEVIRTUAL java.lang.Object.getClass ()Ljava/lang/Class;
    | |             LDC org.apache.tapestry.internal.annotations.Synchronized
    | |             INVOKEVIRTUAL java.lang.Class.isAnnotationPresent (Ljava/lang/Class;)Z
    | |             IFEQ L1
    | |             ALOAD_0
    | |             INVOKESTATIC org.apache.tapestry.internal.aspects.InternalSynchronization.ajc$perObjectBind (Ljava/lang/Object;)V
    | |         L1: RETURN
    | constructor-execution(void org.apache.tapestry.internal.aspects.AbstractClassTargetting.&lt;init&gt;())
    initialization(void org.apache.tapestry.internal.aspects.AbstractClassTargetting.&lt;init&gt;())
  end public void &lt;init&gt;()

  abstract void ajc$pointcut$$targetClasses$274()    org.aspectj.weaver.MethodDeclarationLineNumber: 16:628
;

end public abstract class org.apache.tapestry.internal.aspects.AbstractClassTargetting

when weaving type org.apache.tapestry.internal.aspects.AbstractClassTargetting
when weaving aspects 
when weaving 
when batch building BuildConfig[C:\workspace\.metadata\.plugins\org.eclipse.ajdt.core\tapestry5.generated.lst] #Files=70



I'll attach the corresponding files.</description><comments/></buginformation><fixedCommits><commit id="c667bcb5088379d74b89c3dc8556b87429e4efb7" author="default" date="2006-04-26 16:45:17"><file name="weaver/src/org/aspectj/weaver/patterns/PerThisOrTargetPointcutVisitor.java"><method name="visit" returnType="Object" parameters="WithinAnnotationPointcut Object"/><method name="visit" returnType="Object" parameters="ThisOrTargetAnnotationPointcut Object"/></file></commit></fixedCommits></bug><bug id="303" opendate="2006-04-09 22:27:00" fixdate="2006-05-03 16:18:25"><buginformation><summary>Java 1.2 dependency in aspectjrt.jar bug with fix</summary><description>The thisJoinPoint.printString() fails on a 1.1 VM because it relies on a java.lang.ref.SoftReference. I need this to work because we're using AspectJ on an embedded device that is still using a pre-1.2 VM.

The problem lies in org.aspectj.runtime.reflect.SignatureImpl. The attached patch fixes it and passes all the tests. I tested the failing program manually on a 1.1 VM, but automating the test would require adding a 1.1 VM to the regression test infrastructure.

Sample:

public aspect Java11Test {
    before() : execution(* *(..)) {
        System.out.println(thisJoinPoint.toString());
    }
    public static void main(String args[]) {}
}

 &gt;ajc -target 1.1 Java11Test.aj 

 &gt;\java\jre1.1.8_010\bin\jre -cp .;%CLASSPATH% Java11Test 
Exception in thread "main" java.lang.NoClassDefFoundError: java/lang/ref/SoftRef
erence
        at org.aspectj.runtime.reflect.JoinPointImpl$StaticPartImpl.toString(Joi
nPointImpl.java:43)
        at org.aspectj.runtime.reflect.JoinPointImpl$StaticPartImpl.toString(Joi
nPointImpl.java:48)
        at Java11Test.ajc$before$Java11Test$1$3444dde4(Java11Test.aj:3)
        at Java11Test.main(Java11Test.aj)</description><comments/></buginformation><fixedCommits><commit id="cb5dfe759852d4965c692934ed7e14c41f61b715" author="default" date="2006-05-03 16:18:25"><file name="runtime/src/org/aspectj/runtime/reflect/SignatureImpl.java"><method name="toString" returnType="String" parameters="StringMaker"/></file></commit></fixedCommits></bug><bug id="304" opendate="2006-04-01 12:05:00" fixdate="2006-05-05 09:46:43"><buginformation><summary>ClassCastException in AjState.recordClassFile()</summary><description>I got this exception while working on a static inner aspect. A full rebuild avoided the problem. 

java.lang.ClassCastException: org.aspectj.weaver.MissingResolvedTypeWithKnownSignature
	at org.aspectj.ajdt.internal.core.builder.AjState.recordClassFile(AjState.java:774)
	at org.aspectj.ajdt.internal.core.builder.AjState.noteResult(AjState.java:627)
	at org.aspectj.ajdt.internal.core.builder.AjBuildManager$3.acceptResult(AjBuildManager.java:867)
	at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterProcessing(AjCompilerAdapter.java:206)
	at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$afterReturning$org_aspectj_ajdt_internal_compiler_CompilerAdapter$4$6b855184(CompilerAdapter.aj:90)
	at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:528)
	at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:329)
	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:845)
	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:266)
	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.incrementalBuild(AjBuildManager.java:168)
	at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:117)
	at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)</description><comments/></buginformation><fixedCommits><commit id="299c3a4f2c5205102b89d63c4a8f1bccb158eef1" author="default" date="2006-05-05 09:46:43"><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java"><method name="recordClassFile" returnType="void" parameters="UnwovenClassFile File"/></file><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectDeclaration.java"><method name="generatePerObjectInterface" returnType="TypeBinding" parameters=""/><method name="generatePerSupportMembers" returnType="void" parameters="ClassFile"/></file></commit></fixedCommits></bug><bug id="305" opendate="2006-05-05 09:43:00" fixdate="2006-05-05 14:08:35"><buginformation><summary>NPE or StackOverflow when resolving reference pointcut in ReflectionWorld</summary><description>Given a type such as :

private static class NamedPointcutResolution {
		
  @Pointcut("execution(* *(..))")
  public void a() {}
		
		  
  @Pointcut("this(org.aspectj.weaver.tools.Java15PointcutExpressionTest.A)")
  public void b() {}
		
  @Pointcut("a() &amp;&amp; b()")
  public void c() {}

}

The reflection based delegate is unable to resolve the pointcut c() failing
with either (1) an NPE, or (2) a StackOverflow, depending on the order of the
pointcut definitions in the type.

The problem occurs because in resolving "c()" we get all the pointcuts in the
type, which gets a(), b(), and c(), and tries to resolve them...</description><comments/></buginformation><fixedCommits><commit id="b954b2664c25a74062a5a75b3d99a99e5ddf176d" author="default" date="2006-05-05 14:08:35"><file name="weaver/src/org/aspectj/weaver/tools/PointcutParser.java"><method name="setWorld" returnType="void" parameters="ReflectionWorld"/><method name="setClassLoader" returnType="void" parameters="ClassLoader"/></file><file name="weaver5/java5-src/org/aspectj/weaver/reflect/Java15ReflectionBasedReferenceTypeDelegate.java"><method name="createGenericFieldMember" returnType="ResolvedMember" parameters="Field"/></file><file name="weaver5/java5-testsrc/org/aspectj/weaver/tools/Java15PointcutExpressionTest.java"><method name="foo" returnType="void" parameters=""/></file></commit></fixedCommits></bug><bug id="306" opendate="2006-04-25 10:58:00" fixdate="2006-05-12 08:17:43"><buginformation><summary>java.lang.ClassFormatError: Invalid method Code length 83071 in class file org/eclipse/jdt/internal/compiler/impl/Constant</summary><description>The weaver generates invalid bytecode when weaving a large method. Instead it should issue an error (or even split the method). The problem has been reported before but for a different reason:  bug 113796 .</description><comments/></buginformation><fixedCommits><commit id="5d2b5b8892cc6e714565326b70d7c6a4b7007129" author="default" date="2006-05-12 08:17:43"><file name="bcel-builder/src/org/aspectj/apache/bcel/generic/InstructionList.java"><method name="setPositions" returnType="void" parameters="boolean"/></file></commit></fixedCommits></bug><bug id="307" opendate="2006-02-27 20:32:00" fixdate="2006-05-12 10:41:42"><buginformation><summary>BCException</summary><description>org.aspectj.weaver.BCException
at org.aspectj.weaver.bcel.BcelShadow.initializeKindedAnnotationVars(BcelShadow.java:1553)
at org.aspectj.weaver.bcel.BcelShadow.getKindedAnnotationVar(BcelShadow.java:995)
at org.aspectj.weaver.patterns.AnnotationPointcut.findResidueInternal(AnnotationPointcut.java:196)
at org.aspectj.weaver.patterns.Pointcut.findResidue(Pointcut.java:268)
at org.aspectj.weaver.patterns.AndPointcut.findResidueInternal(AndPointcut.java:97)
at org.aspectj.weaver.patterns.Pointcut.findResidue(Pointcut.java:268)
at org.aspectj.weaver.patterns.AndPointcut.findResidueInternal(AndPointcut.java:97)
at org.aspectj.weaver.patterns.Pointcut.findResidue(Pointcut.java:268)
at org.aspectj.weaver.patterns.AndPointcut.findResidueInternal(AndPointcut.java:97)
at org.aspectj.weaver.patterns.Pointcut.findResidue(Pointcut.java:268)
at org.aspectj.weaver.bcel.BcelAdvice.specializeOn(BcelAdvice.java:132)
at org.aspectj.weaver.bcel.BcelShadow.prepareForMungers(BcelShadow.java:313)
at org.aspectj.weaver.Shadow.implement(Shadow.java:404)
at org.aspectj.weaver.bcel.BcelClassWeaver.implement(BcelClassWeaver.java:2146)
at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:467)
at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:102)
at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1543)
at org.aspectj.weaver.bcel.BcelWeaver.weaveWithoutDump(BcelWeaver.java:1494)
at org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify(BcelWeaver.java:1275)
at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1097)
at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave(AjCompilerAdapter.java:300)
at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling(AjCompilerAdapter.java:178)
at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$afterReturning$org_aspectj_ajdt_internal_compiler_CompilerAdapter$2$f9cc9ca0(CompilerAdapter.aj:70)
at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:367)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:811)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:230)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:156)
at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:122)
at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)

trouble in: 
public class com.ytg.bilette.client.core.providers.DomainContentProvider extends java.lang.Object implements com.ytg.bilette.client.core.providers.IRefreshableStructuredContentProvider:
  private java.util.HashSet listeners [Signature(Ljava/util/HashSet&lt;Lcom/ytg/bilette/client/core/providers/IDomainObjectChangeListener&lt;TT;&gt;;&gt;;)]
  private com.ytg.bilette.client.core.providers.DomainContentProvider$State state [Signature(Lcom/ytg/bilette/client/core/providers/DomainContentProvider$State;)]
  private Class clazz [Signature(Ljava/lang/Class&lt;+Lcom/ytg/bilette/model/GenericDomainObject;&gt;;)]
  private boolean deletable
  private java.util.List summaries [Signature(Ljava/util/List&lt;TT;&gt;;)]
  static Class class$0
  public void &lt;init&gt;(Class)    org.aspectj.weaver.MethodDeclarationLineNumber: 47:1136
:
                    ALOAD_0     // com.ytg.bilette.client.core.providers.DomainContentProvider this   (line 47)
                    &amp;#304;NVOKESPEC&amp;#304;AL java.lang.Object.&lt;init&gt; ()V
    constructor-execution(void com.ytg.bilette.client.core.providers.DomainContentProvider.&lt;init&gt;(java.lang.Class))
    |               ALOAD_0     // com.ytg.bilette.client.core.providers.DomainContentProvider this   (line 34)
    |               NEW java.util.HashSet
    |               DUP
    |               &amp;#304;NVOKESPEC&amp;#304;AL java.util.HashSet.&lt;init&gt; ()V
    |               PUTF&amp;#304;ELD com.ytg.bilette.client.core.providers.DomainContentProvider.listeners Ljava/util/HashSet;
    |               ALOAD_0     // com.ytg.bilette.client.core.providers.DomainContentProvider this   (line 36)
    |               GETSTAT&amp;#304;C com.ytg.bilette.client.core.providers.DomainContentProvider$State.NOT_INITIALIZED Lcom/ytg/bilette/client/core/providers/DomainContentProvider$State;
    |               PUTF&amp;#304;ELD com.ytg.bilette.client.core.providers.DomainContentProvider.state Lcom/ytg/bilette/client/core/providers/DomainContentProvider$State;
    |               ALOAD_0     // com.ytg.bilette.client.core.providers.DomainContentProvider this   (line 40)
    |               &amp;#304;CONST_0
    |               PUTF&amp;#304;ELD com.ytg.bilette.client.core.providers.DomainContentProvider.deletable Z
    |               ALOAD_0     // com.ytg.bilette.client.core.providers.DomainContentProvider this   (line 48)
    |               ALOAD_1     // java.lang.Class clazz
    |               PUTF&amp;#304;ELD com.ytg.bilette.client.core.providers.DomainContentProvider.clazz Ljava/lang/Class;
    |               ALOAD_1     // java.lang.Class clazz   (line 50)
    |               &amp;#304;NVOKEV&amp;#304;RTUAL java.lang.Class.getInterfaces ()[Ljava/lang/Class;
    |               ASTORE_2
    |               &amp;#304;CONST_0   (line 51)
    |               &amp;#304;STORE_3
    |               GOTO L2
    |           L0: ALOAD_2     // java.lang.Class[] interfaces   (line 52)
    |               &amp;#304;LOAD_3     // int i
    |               AALOAD
    |               LDC com.ytg.bilette.model.Deletable
    |               &amp;#304;NVOKEV&amp;#304;RTUAL java.lang.Object.equals (Ljava/lang/Object;)Z
    |               &amp;#304;FEQ L1
    |               ALOAD_0     // com.ytg.bilette.client.core.providers.DomainContentProvider this   (line 53)
    |               &amp;#304;CONST_1
    |               PUTF&amp;#304;ELD com.ytg.bilette.client.core.providers.DomainContentProvider.deletable Z
    |               GOTO L3   (line 54)
    |           L1: &amp;#304;&amp;#304;NC 3 1     // int i   (line 51)
    |           L2: &amp;#304;LOAD_3     // int i
    |               ALOAD_2     // java.lang.Class[] interfaces
    |               ARRAYLENGTH
    |               &amp;#304;F_&amp;#304;CMPLT L0
    |           L3: RETURN   (line 57)
    constructor-execution(void com.ytg.bilette.client.core.providers.DomainContentProvider.&lt;init&gt;(java.lang.Class))
  end public void &lt;init&gt;(Class)

  public Object[] getElements(Object)    org.aspectj.weaver.MethodDeclarationLineNumber: 65:1611
:
                    ALOAD_0     // com.ytg.bilette.client.core.providers.DomainContentProvider this   (line 66)
                    ALOAD_1     // java.lang.Object input
                    &amp;#304;NVOKESPEC&amp;#304;AL com.ytg.bilette.client.core.providers.DomainContentProvider.checkInput (Ljava/lang/Object;)Z
                    &amp;#304;STORE_2
                    ALOAD_0     // com.ytg.bilette.client.core.providers.DomainContentProvider this   (line 68)
                    &amp;#304;LOAD_2     // boolean includeDeleted
                    &amp;#304;NVOKEV&amp;#304;RTUAL com.ytg.bilette.client.core.providers.DomainContentProvider.getSummaries (Z)Ljava/util/List;
                    &amp;#304;NVOKE&amp;#304;NTERFACE java.util.List.toArray ()[Ljava/lang/Object;
                    ARETURN
  end public Object[] getElements(Object)

  private void checkInitialized(boolean)    org.aspectj.weaver.MethodDeclarationLineNumber: 71:1759
:
                    GETSTAT&amp;#304;C com.ytg.bilette.client.core.providers.DomainContentProvider$State.NOT_INITIALIZED Lcom/ytg/bilette/client/core/providers/DomainContentProvider$State;   (line 72)
                    ALOAD_0     // com.ytg.bilette.client.core.providers.DomainContentProvider this
                    GETF&amp;#304;ELD com.ytg.bilette.client.core.providers.DomainContentProvider.state Lcom/ytg/bilette/client/core/providers/DomainContentProvider$State;
                    &amp;#304;NVOKEV&amp;#304;RTUAL com.ytg.bilette.client.core.providers.DomainContentProvider$State.equals (Ljava/lang/Object;)Z
                    &amp;#304;FNE L0
                    GETSTAT&amp;#304;C com.ytg.bilette.client.core.providers.DomainContentProvider$State.LIGHT_INITIALIZED Lcom/ytg/bilette/client/core/providers/DomainContentProvider$State;   (line 73)
                    ALOAD_0     // com.ytg.bilette.client.core.providers.DomainContentProvider this
                    GETF&amp;#304;ELD com.ytg.bilette.client.core.providers.DomainContentProvider.state Lcom/ytg/bilette/client/core/providers/DomainContentProvider$State;
                    &amp;#304;NVOKEV&amp;#304;RTUAL com.ytg.bilette.client.core.providers.DomainContentProvider$State.equals (Ljava/lang/Object;)Z
                    &amp;#304;FEQ L1
                    &amp;#304;LOAD_1     // boolean includeDeleted
                    &amp;#304;FEQ L1
                L0: ALOAD_0     // com.ytg.bilette.client.core.providers.DomainContentProvider this   (line 74)
                    ACONST_NULL
                    ACONST_NULL
                    &amp;#304;LOAD_1     // boolean includeDeleted
                    &amp;#304;NVOKESPEC&amp;#304;AL com.ytg.bilette.client.core.providers.DomainContentProvider.getData (Lcom/ytg/bilette/dao/SummaryDAO;Lorg/eclipse/core/runtime/IProgressMonitor;Z)V
                L1: RETURN   (line 75)
  end private void checkInitialized(boolean)

  private boolean checkInput(Object)    org.aspectj.weaver.MethodDeclarationLineNumber: 83:2060
:
                    ALOAD_1     // java.lang.Object input   (line 84)
                    &amp;#304;NSTANCEOF java.lang.Boolean
                    LDC "Input for generic content provider must be Boolean value"   (line 85)
                    &amp;#304;NVOKESTAT&amp;#304;C org.eclipse.jface.util.Assert.isTrue (ZLjava/lang/String;)Z   (line 84)
                    POP
                    ALOAD_1     // java.lang.Object input   (line 86)
                    CHECKCAST java.lang.Boolean
                    &amp;#304;NVOKEV&amp;#304;RTUAL java.lang.Boolean.booleanValue ()Z
                    &amp;#304;STORE_2
                    ALOAD_0     // com.ytg.bilette.client.core.providers.DomainContentProvider this   (line 87)
                    GETF&amp;#304;ELD com.ytg.bilette.client.core.providers.DomainContentProvider.deletable Z
                    &amp;#304;FNE L1
                    ALOAD_0     // com.ytg.bilette.client.core.providers.DomainContentProvider this   (line 88)
                    GETF&amp;#304;ELD com.ytg.bilette.client.core.providers.DomainContentProvider.deletable Z
                    &amp;#304;FNE L0
                    &amp;#304;LOAD_2     // boolean includeDeleted
                    &amp;#304;FEQ L1
                L0: &amp;#304;CONST_0
                    GOTO L2
                L1: &amp;#304;CONST_1
                L2: LDC "Nondeletable object yet deleted flag!"   (line 89)
                    &amp;#304;NVOKESTAT&amp;#304;C org.eclipse.jface.util.Assert.isLegal (ZLjava/lang/String;)Z   (line 87)
                    POP
                    &amp;#304;LOAD_2     // boolean includeDeleted   (line 91)
                    &amp;#304;RETURN
  end private boolean checkInput(Object)

  public void dispose()    org.aspectj.weaver.MethodDeclarationLineNumber: 99:2522
:
                    RETURN   (line 101)
  end public void dispose()

  public void inputChanged(org.eclipse.jface.viewers.Viewer, Object, Object)    org.aspectj.weaver.MethodDeclarationLineNumber: 109:2747
:
                    RETURN   (line 111)
  end public void inputChanged(org.eclipse.jface.viewers.Viewer, Object, Object)

  private void getData(com.ytg.bilette.dao.SummaryDAO, org.eclipse.core.runtime.IProgressMonitor, boolean)    org.aspectj.weaver.MethodDeclarationLineNumber: 115:2954
:
                    ALOAD_1
                    ASTORE 4
                    ALOAD_2
                    ASTORE 5
                    &amp;#304;LOAD_3
                    &amp;#304;STORE 6
    method-execution(void com.ytg.bilette.client.core.providers.DomainContentProvider.getData(com.ytg.bilette.dao.SummaryDAO, org.eclipse.core.runtime.IProgressMonitor, boolean))
    |               ALOAD_0     // com.ytg.bilette.client.core.providers.DomainContentProvider this   (line 117)
    |               ALOAD_1     // com.ytg.bilette.dao.SummaryDAO dao
    |               ALOAD_0     // com.ytg.bilette.client.core.providers.DomainContentProvider this
    |               GETF&amp;#304;ELD com.ytg.bilette.client.core.providers.DomainContentProvider.clazz Ljava/lang/Class;
    |               &amp;#304;LOAD_3     // boolean includeDeleted
    |               &amp;#304;NVOKE&amp;#304;NTERFACE com.ytg.bilette.dao.SummaryDAO.getSummaries (Ljava/lang/Class;Z)Ljava/util/List;
    |               PUTF&amp;#304;ELD com.ytg.bilette.client.core.providers.DomainContentProvider.summaries Ljava/util/List;
    |               &amp;#304;LOAD_3     // boolean includeDeleted   (line 118)
    |               &amp;#304;FEQ L0
    |               ALOAD_0     // com.ytg.bilette.client.core.providers.DomainContentProvider this   (line 119)
    |               GETSTAT&amp;#304;C com.ytg.bilette.client.core.providers.DomainContentProvider$State.FULL_INITIALIZED Lcom/ytg/bilette/client/core/providers/DomainContentProvider$State;
    |               PUTF&amp;#304;ELD com.ytg.bilette.client.core.providers.DomainContentProvider.state Lcom/ytg/bilette/client/core/providers/DomainContentProvider$State;
    |               GOTO L1
    |           L0: ALOAD_0     // com.ytg.bilette.client.core.providers.DomainContentProvider this   (line 121)
    |               GETSTAT&amp;#304;C com.ytg.bilette.client.core.providers.DomainContentProvider$State.LIGHT_INITIALIZED Lcom/ytg/bilette/client/core/providers/DomainContentProvider$State;
    |               PUTF&amp;#304;ELD com.ytg.bilette.client.core.providers.DomainContentProvider.state Lcom/ytg/bilette/client/core/providers/DomainContentProvider$State;
    |           L1: RETURN   (line 122)
    method-execution(void com.ytg.bilette.client.core.providers.DomainContentProvider.getData(com.ytg.bilette.dao.SummaryDAO, org.eclipse.core.runtime.IProgressMonitor, boolean))
  end private void getData(com.ytg.bilette.dao.SummaryDAO, org.eclipse.core.runtime.IProgressMonitor, boolean)

  public java.util.List getSummaries(boolean)    org.aspectj.weaver.MethodDeclarationLineNumber: 128:3308
:
                    ALOAD_0     // com.ytg.bilette.client.core.providers.DomainContentProvider this   (line 129)
                    &amp;#304;LOAD_1     // boolean includeDeleted
                    &amp;#304;NVOKESPEC&amp;#304;AL com.ytg.bilette.client.core.providers.DomainContentProvider.checkInitialized (Z)V
                    &amp;#304;LOAD_1     // boolean includeDeleted   (line 131)
                    &amp;#304;FNE L0
                    GETSTAT&amp;#304;C com.ytg.bilette.client.core.providers.DomainContentProvider$State.LIGHT_INITIALIZED Lcom/ytg/bilette/client/core/providers/DomainContentProvider$State;
                    ALOAD_0     // com.ytg.bilette.client.core.providers.DomainContentProvider this
                    GETF&amp;#304;ELD com.ytg.bilette.client.core.providers.DomainContentProvider.state Lcom/ytg/bilette/client/core/providers/DomainContentProvider$State;
                    &amp;#304;NVOKEV&amp;#304;RTUAL com.ytg.bilette.client.core.providers.DomainContentProvider$State.equals (Ljava/lang/Object;)Z
                    &amp;#304;FEQ L1
                L0: ALOAD_0     // com.ytg.bilette.client.core.providers.DomainContentProvider this   (line 132)
                    GETF&amp;#304;ELD com.ytg.bilette.client.core.providers.DomainContentProvider.summaries Ljava/util/List;
                    ARETURN
                L1: ALOAD_0     // com.ytg.bilette.client.core.providers.DomainContentProvider this   (line 134)
                    GETF&amp;#304;ELD com.ytg.bilette.client.core.providers.DomainContentProvider.summaries Ljava/util/List;
                    &amp;#304;NVOKE&amp;#304;NTERFACE java.util.List.iterator ()Ljava/util/Iterator;
                    ASTORE_2
                    NEW java.util.ArrayList   (line 135)
                    DUP
                    &amp;#304;NVOKESPEC&amp;#304;AL java.util.ArrayList.&lt;init&gt; ()V
                    ASTORE_3
                    GOTO L3   (line 136)
                L2: ALOAD_2     // java.util.Iterator i   (line 137)
                    &amp;#304;NVOKE&amp;#304;NTERFACE java.util.Iterator.next ()Ljava/lang/Object;
                    CHECKCAST com.ytg.bilette.model.Deletable
                    CHECKCAST com.ytg.bilette.model.Deletable
                    ASTORE 4
                    ALOAD 4     // com.ytg.bilette.model.Deletable object   (line 138)
                    &amp;#304;NVOKE&amp;#304;NTERFACE com.ytg.bilette.model.Deletable.isDeleted ()Z
                    &amp;#304;FNE L3
                    ALOAD_3     // java.util.ArrayList list   (line 139)
                    ALOAD 4     // com.ytg.bilette.model.Deletable object
                    CHECKCAST com.ytg.bilette.model.GenericDomainObject
                    &amp;#304;NVOKEV&amp;#304;RTUAL java.util.ArrayList.add (Ljava/lang/Object;)Z
                    POP
                L3: ALOAD_2     // java.util.Iterator i   (line 136)
                    &amp;#304;NVOKE&amp;#304;NTERFACE java.util.Iterator.hasNext ()Z
                    &amp;#304;FNE L2
                    ALOAD_3     // java.util.ArrayList list   (line 142)
                    ARETURN
  end public java.util.List getSummaries(boolean)

  public synchronized void refresh()    org.aspectj.weaver.MethodDeclarationLineNumber: 148:3783
:
                    ALOAD_0     // com.ytg.bilette.client.core.providers.DomainContentProvider this   (line 149)
                    GETSTAT&amp;#304;C com.ytg.bilette.client.core.providers.DomainContentProvider$State.NOT_INITIALIZED Lcom/ytg/bilette/client/core/providers/DomainContentProvider$State;
                    PUTF&amp;#304;ELD com.ytg.bilette.client.core.providers.DomainContentProvider.state Lcom/ytg/bilette/client/core/providers/DomainContentProvider$State;
                    &amp;#304;CONST_0   (line 150)
                    &amp;#304;STORE_1
                    ALOAD_0     // com.ytg.bilette.client.core.providers.DomainContentProvider this   (line 152)
                    GETF&amp;#304;ELD com.ytg.bilette.client.core.providers.DomainContentProvider.deletable Z
                    &amp;#304;FEQ L2
                    ALOAD_0     // com.ytg.bilette.client.core.providers.DomainContentProvider this   (line 153)
                    GETF&amp;#304;ELD com.ytg.bilette.client.core.providers.DomainContentProvider.listeners Ljava/util/HashSet;
                    &amp;#304;NVOKEV&amp;#304;RTUAL java.util.HashSet.iterator ()Ljava/util/Iterator;
                    ASTORE_2
                    GOTO L1   (line 154)
                L0: ALOAD_2     // java.util.Iterator i   (line 155)
                    &amp;#304;NVOKE&amp;#304;NTERFACE java.util.Iterator.next ()Ljava/lang/Object;
                    CHECKCAST com.ytg.bilette.client.core.providers.IDomainObjectChangeListener
                    ASTORE_3
                    ALOAD_3     // com.ytg.bilette.client.core.providers.IDomainObjectChangeListener listener   (line 156)
                    &amp;#304;NVOKE&amp;#304;NTERFACE com.ytg.bilette.client.core.providers.IDomainObjectChangeListener.isIncludeDeleted ()Z
                    &amp;#304;FEQ L1
                    &amp;#304;CONST_1   (line 157)
                    &amp;#304;STORE_1     // boolean includeDeleted
                    GOTO L2   (line 158)
                L1: ALOAD_2     // java.util.Iterator i   (line 154)
                    &amp;#304;NVOKE&amp;#304;NTERFACE java.util.Iterator.hasNext ()Z
                    &amp;#304;FNE L0
                L2: ALOAD_0     // com.ytg.bilette.client.core.providers.DomainContentProvider this   (line 163)
                    ACONST_NULL
                    ACONST_NULL
                    &amp;#304;LOAD_1     // boolean includeDeleted
                    &amp;#304;NVOKESPEC&amp;#304;AL com.ytg.bilette.client.core.providers.DomainContentProvider.getData (Lcom/ytg/bilette/dao/SummaryDAO;Lorg/eclipse/core/runtime/IProgressMonitor;Z)V
                    ALOAD_0     // com.ytg.bilette.client.core.providers.DomainContentProvider this   (line 165)
                    ACONST_NULL
                    ACONST_NULL
                    &amp;#304;NVOKESPEC&amp;#304;AL com.ytg.bilette.client.core.providers.DomainContentProvider.notifyAllListeners (Lcom/ytg/bilette/model/GenericDomainObject;Lcom/ytg/bilette/model/GenericDomainObject;)V
                    RETURN   (line 166)
  end public synchronized void refresh()

  private synchronized void notifyAllListeners(com.ytg.bilette.model.GenericDomainObject, com.ytg.bilette.model.GenericDomainObject)    org.aspectj.weaver.MethodDeclarationLineNumber: 174:4356
:
                    ALOAD_0     // com.ytg.bilette.client.core.providers.DomainContentProvider this   (line 175)
                    GETF&amp;#304;ELD com.ytg.bilette.client.core.providers.DomainContentProvider.listeners Ljava/util/HashSet;
                    &amp;#304;NVOKEV&amp;#304;RTUAL java.util.HashSet.iterator ()Ljava/util/Iterator;
                    ASTORE_3
                    GOTO L2   (line 176)
                L0: ALOAD_3     // java.util.Iterator i   (line 177)
                    &amp;#304;NVOKE&amp;#304;NTERFACE java.util.Iterator.next ()Ljava/lang/Object;
                    CHECKCAST com.ytg.bilette.client.core.providers.IDomainObjectChangeListener
                    ASTORE 4
                    ALOAD_1     // com.ytg.bilette.model.GenericDomainObject oldObj   (line 178)
                    &amp;#304;FNONNULL L1
                    ALOAD_2     // com.ytg.bilette.model.GenericDomainObject newObj
                    &amp;#304;FNONNULL L1
                    ALOAD 4     // com.ytg.bilette.client.core.providers.IDomainObjectChangeListener listener   (line 179)
                    &amp;#304;NVOKE&amp;#304;NTERFACE com.ytg.bilette.client.core.providers.IDomainObjectChangeListener.fullRefresh ()V
                    GOTO L2
                L1: ALOAD 4     // com.ytg.bilette.client.core.providers.IDomainObjectChangeListener listener   (line 181)
                    ALOAD_1     // com.ytg.bilette.model.GenericDomainObject oldObj
                    ALOAD_2     // com.ytg.bilette.model.GenericDomainObject newObj
                    &amp;#304;NVOKE&amp;#304;NTERFACE com.ytg.bilette.client.core.providers.IDomainObjectChangeListener.concessionChanged (Lcom/ytg/bilette/model/GenericDomainObject;Lcom/ytg/bilette/model/GenericDomainObject;)V
                L2: ALOAD_3     // java.util.Iterator i   (line 176)
                    &amp;#304;NVOKE&amp;#304;NTERFACE java.util.Iterator.hasNext ()Z
                    &amp;#304;FNE L0
                    RETURN   (line 183)
  end private synchronized void notifyAllListeners(com.ytg.bilette.model.GenericDomainObject, com.ytg.bilette.model.GenericDomainObject)

  public synchronized void addListener(com.ytg.bilette.client.core.providers.IDomainObjectChangeListener)    org.aspectj.weaver.MethodDeclarationLineNumber: 185:4715
:
                    ALOAD_0     // com.ytg.bilette.client.core.providers.DomainContentProvider this   (line 186)
                    GETF&amp;#304;ELD com.ytg.bilette.client.core.providers.DomainContentProvider.listeners Ljava/util/HashSet;
                    ALOAD_1     // com.ytg.bilette.client.core.providers.IDomainObjectChangeListener listener
                    &amp;#304;NVOKEV&amp;#304;RTUAL java.util.HashSet.add (Ljava/lang/Object;)Z
                    POP
                    RETURN   (line 187)
  end public synchronized void addListener(com.ytg.bilette.client.core.providers.IDomainObjectChangeListener)

  public synchronized void removeListener(com.ytg.bilette.client.core.providers.IDomainObjectChangeListener)    org.aspectj.weaver.MethodDeclarationLineNumber: 189:4831
:
                    ALOAD_0     // com.ytg.bilette.client.core.providers.DomainContentProvider this   (line 190)
                    GETF&amp;#304;ELD com.ytg.bilette.client.core.providers.DomainContentProvider.listeners Ljava/util/HashSet;
                    ALOAD_1     // com.ytg.bilette.client.core.providers.IDomainObjectChangeListener listener
                    &amp;#304;NVOKEV&amp;#304;RTUAL java.util.HashSet.remove (Ljava/lang/Object;)Z
                    POP
                    RETURN   (line 191)
  end public synchronized void removeListener(com.ytg.bilette.client.core.providers.IDomainObjectChangeListener)

end public class com.ytg.bilette.client.core.providers.DomainContentProvider

when implementing on shadow method-execution(void com.ytg.bilette.client.core.providers.DomainContentProvider.getData(com.ytg.bilette.dao.SummaryDAO, org.eclipse.core.runtime.IProgressMonitor, boolean))
when weaving type com.ytg.bilette.client.core.providers.DomainContentProvider
when weaving classes 
when weaving 
when batch building BuildConfig[F:\java\Bilette\.metadata\.plugins\org.eclipse.ajdt.core\com.ytg.bilette.client.core.generated.lst] #Files=22</description><comments/></buginformation><fixedCommits><commit id="3ca976f0ce48a49cdcef98b7f72ce2ce23b9ef4d" author="default" date="2006-05-12 10:41:42"><file name="weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"><method name="initializeKindedAnnotationVars" returnType="void" parameters=""/></file></commit></fixedCommits></bug><bug id="308" opendate="2006-03-24 04:47:00" fixdate="2006-05-12 15:34:39"><buginformation><summary>Lots of warnings with noGuardForLazyTjp</summary><description>When the noGuardForLazyTjp compiler option is set to warning or error and a piece of advice causes this warning to show up, you get one warning for every join point matched by the advice.  I think just one would probably be enough...</description><comments/></buginformation><fixedCommits><commit id="3fa4d24ac16e94ee40b824fe27830fe7a34866a3" author="default" date="2006-05-12 15:34:39"><file name="weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java"><method name="specializeOn" returnType="void" parameters="Shadow"/></file></commit></fixedCommits></bug><bug id="309" opendate="2006-04-05 12:15:00" fixdate="2006-05-16 07:38:53"><buginformation><summary>VerifyError with LTW and @AJ style aspects</summary><description>I get "VerifyError: Incompatible object argument for function call" error when using LTW with @Aspect stype aspects. Interestingly enough, LTW works as expected with equivalent .aj style aspect. Compile time weaving works with both aspect styles. Tested on Linux with AspectJ 1.5.0, 1.5.1 and DEVELOPMENT-20060404163823 and SUN 1.5.0_06 and IBM 1.5.0SR1 JVMs. I will attach example project shortly.</description><comments/></buginformation><fixedCommits><commit id="9ffc63b51aa49fa3bb67a4a1c40dd7d1fe4c97ae" author="default" date="2006-05-16 07:38:53"><file name="weaver/src/org/aspectj/weaver/bcel/AtAjAttributes.java"><method name="readAj5MethodAttributes" returnType="List" parameters="Method BcelMethod"/></file></commit></fixedCommits></bug><bug id="310" opendate="2006-05-16 04:10:00" fixdate="2006-05-16 12:30:08"><buginformation><summary>Compiler issues message concerning aop.xml even when not doing LTW</summary><description>From the mailing list:

=============

I am executing the command as below,
 
COMMAND: ajc -inpath woven_hello1.jar -aspectpath aspect2.jar -outjar woven_hello2.jar
 
I am getting same old error,
woven_hello1.jar [error] aspect 'aspect1' woven into 'Hello' must be declared in an aop.xml file.
(no source information available)
I have placed both aspect1.class and aspect2.class in CLASSPATH system variable.

==============

We shouldn't be putting out messages about aop.xml when we are not doing LTW - this message points the user to a solution that will not work in this case!</description><comments/></buginformation><fixedCommits><commit id="fc7db25dad5d302221669c7cfdb4890f061d2e9e" author="default" date="2006-05-16 12:30:08"><file name="tests/java5/ataspectj/ataspectj/ltwreweavable/MainReweavableLogging.java"><method name="main" returnType="void" parameters="String[]"/></file></commit></fixedCommits></bug><bug id="311" opendate="2006-03-07 05:53:00" fixdate="2006-05-16 15:43:08"><buginformation><summary>poincut references in percflow instantiation model aspects can not be resolved</summary><description>Take these two aspects and this litte class:

// source1
package test1;

import test.Test;
public aspect PointcutProvider {

	public pointcut test(): execution(* Test.*(..));
}


// source2
package test;

import test1.PointcutProvider;

public aspect PointcutConsumer percflow(flow()) {

        // compiler issues the following line with
        // can not find pointcut test on test.PointcutConsumer
	pointcut mytest(): PointcutProvider.test();
        // this also does not work with the same error message
        pointcut mytest(): test1.PointcutProvider.test();
	
	pointcut flow(): mytest();
}
// source3
package test;


public class Test {

	public void foo() {
		
	}
}


Changing the consumer aspect to singleton instantiation model works.</description><comments/></buginformation><fixedCommits><commit id="b166a7e6163889eb951f82655f0f49bfc26a49f0" author="default" date="2006-05-16 15:43:08"><file name="tests/src/org/aspectj/systemtest/ajc152/Ajc152Tests.java"><method name="testReferencePCutInDeclareWarning_pr138215" returnType="void" parameters=""/></file><file name="tests/src/org/aspectj/systemtest/ajc150/GenericITDsDesign.java"><method name="verifyClassSignature" returnType="void" parameters="Ajc String String"/></file><file name="weaver/testsrc/org/aspectj/weaver/bcel/NonstaticWeaveTestCase.java"><method name="testBeforeCflow" returnType="void" parameters=""/><method name="testBeforePerThis" returnType="void" parameters=""/></file><file name="weaver/src/org/aspectj/weaver/ResolvedType.java"><method name="collectCrosscuttingMembers" returnType="CrosscuttingMembers" parameters=""/></file><file name="weaver/testsrc/org/aspectj/weaver/bcel/PointcutResidueTestCase.java"><method name="checkWeave" returnType="void" parameters=""/></file><file name="weaver/testsrc/org/aspectj/weaver/bcel/WeaveOrderTestCase.java"><method name="testDominatesHarder" returnType="void" parameters=""/><method name="testDominates" returnType="void" parameters=""/></file><file name="weaver/src/org/aspectj/weaver/CrosscuttingMembersSet.java"><method name="addOrReplaceAspect" returnType="boolean" parameters="ResolvedType boolean"/><method name="addOrReplaceDescendantsOf" returnType="boolean" parameters="ResolvedType boolean"/></file><file name="weaver/src/org/aspectj/weaver/CrosscuttingMembers.java"><method name="getPerClause" returnType="PerClause" parameters=""/><method name="replaceWith" returnType="boolean" parameters="CrosscuttingMembers boolean"/><method name="setPerClause" returnType="void" parameters="PerClause"/></file></commit></fixedCommits></bug><bug id="312" opendate="2006-05-16 05:12:00" fixdate="2006-05-17 11:38:39"><buginformation><summary>Null Pointer Exception when trying to skip Parent Mungers.</summary><description>I don't know much about the internal workings of aspectJ but this bug keeps popping up so I went through the trouble of checking of trying to debug it so that I could hopefully provide enough information to get it fixed.

This happens while using eclipse AJDT. It never happens if I fully do a clean before rebuild. It only seems to happen when doing incrmental builds (using  the project-&gt;build automatically setting). 

The error happens in the iterator that recursively builds a list of methods
to return for matching. The error is triggered here:


    // we need to know if it is an interface from Parent kind munger
            // as those are used for @AJ ITD and we precisely want to skip those
            boolean shouldSkip = false;
            for (int j = 0; j &lt; rtx.interTypeMungers.size(); j++) {
                ConcreteTypeMunger munger = (ConcreteTypeMunger) rtx.interTypeMungers.get(j);
                if (munger.getMunger().getKind() == ResolvedTypeMunger.Parent) {
                    shouldSkip = true;
                    break;
                }
            }

munger.getMunger() returns null because the munger instance is a BcelPerClauseAspectAdder. My naive fix would be to check munger.getMunger() == null or check munger.getKind(). I'm assuming that BcelPerClausAspectAdder is one that should be skipped since it is related to @AJ ??? 

Again, I don't know very much about the internal architecture of the weaver magic so I hope this is enough information. 

I would appreciate it if someone who knows more of the internals could speculate as to why this bug would never pop up on a clean build but only on incremental builds? Also it's not on all incremental builds and I haven't been able to isolate what kind of changes or compiles it triggers this, although it seems that  once I got the exception once, I keep getting it on every build until I do a clean. 

java.lang.NullPointerException
at org.aspectj.weaver.ResolvedType.addAndRecurse(ResolvedType.java:288)
at org.aspectj.weaver.ResolvedType.getMethodsWithoutIterator(ResolvedType.java:257)
at org.aspectj.weaver.ResolvedType.lookupResolvedMember(ResolvedType.java:378)
at org.aspectj.weaver.JoinPointSignatureIterator.findSignaturesFromSupertypes(JoinPointSignatureIterator.java:178)
at org.aspectj.weaver.JoinPointSignatureIterator.hasNext(JoinPointSignatureIterator.java:69)
at org.aspectj.weaver.patterns.SignaturePattern.matches(SignaturePattern.java:287)
at org.aspectj.weaver.patterns.KindedPointcut.matchInternal(KindedPointcut.java:103)
at org.aspectj.weaver.patterns.Pointcut.match(Pointcut.java:144)
at org.aspectj.weaver.patterns.AndPointcut.matchInternal(AndPointcut.java:51)
at org.aspectj.weaver.patterns.Pointcut.match(Pointcut.java:144)
at org.aspectj.weaver.ShadowMunger.match(ShadowMunger.java:64)
at org.aspectj.weaver.Advice.match(Advice.java:109)
at org.aspectj.weaver.bcel.BcelAdvice.match(BcelAdvice.java:104)
at org.aspectj.weaver.bcel.BcelClassWeaver.match(BcelClassWeaver.java:2210)
at org.aspectj.weaver.bcel.BcelClassWeaver.match(BcelClassWeaver.java:1752)
at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:479)
at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:109)
at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1574)
at org.aspectj.weaver.bcel.BcelWeaver.weaveWithoutDump(BcelWeaver.java:1525)
at org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify(BcelWeaver.java:1305)
at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1127)
at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave(AjCompilerAdapter.java:321)
at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling(AjCompilerAdapter.java:192)
at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$afterReturning$org_aspectj_ajdt_internal_compiler_CompilerAdapter$2$f9cc9ca0(CompilerAdapter.aj:70)
at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:367)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:862)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:269)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.incrementalBuild(AjBuildManager.java:168)
at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:117)
at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)</description><comments/></buginformation><fixedCommits><commit id="5f6a6b12c560f80dd720a943c4c63cf8dc182cc3" author="default" date="2006-05-17 11:38:39"><file name="weaver/src/org/aspectj/weaver/ResolvedType.java"><method name="addAndRecurse" returnType="void" parameters="Set List ResolvedType"/></file><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"><method name="finishTypeMungers" returnType="void" parameters=""/></file><file name="tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java"><method name="testPr115251" returnType="void" parameters=""/></file></commit></fixedCommits></bug><bug id="313" opendate="2006-04-24 13:17:00" fixdate="2006-05-17 15:48:34"><buginformation><summary>Compiler crash on two binding @xxx pcds in one compound expression</summary><description>junit.framework.AssertionFailedError: test "Double at annotation matching (no binding)" failed
test "Double at annotation matching (no binding)" failed
Unexpected warning messages:
	warning at before() : transactionalOperation() {
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/private/tmp/ajcSandbox/ajcTest18924.tmp/DoubleAnnotationMatching.aj:20:0::0 advice defined in DoubleAnnotationMatching has not been applied [Xlint:adviceDidNotMatch]
Unexpected fail messages:
	abort trouble in: 
 class Foo extends java.lang.Object:
  void &lt;init&gt;():
                    ALOAD_0     // LFoo; this   (line 26)
                    INVOKESPECIAL java.lang.Object.&lt;init&gt; ()V
    constructor-execution(void Foo.&lt;init&gt;())
    |               RETURN
    constructor-execution(void Foo.&lt;init&gt;())
  end void &lt;init&gt;()

  public void foo()    org.aspectj.weaver.MethodDeclarationLineNumber: 28:533
:
    method-execution(void Foo.foo())
    |               RETURN   (line 28)
    method-execution(void Foo.foo())
  end public void foo()

  public void bar()    org.aspectj.weaver.MethodDeclarationLineNumber: 30:563
:
    method-execution(void Foo.bar())
    |               RETURN   (line 30)
    method-execution(void Foo.bar())
  end public void bar()

end  class Foo
 -- (BCException) Impossible! annotation=[Tx]  shadow=[method-execution(void Foo.foo()) at /private/tmp/ajcSandbox/ajcTest18924.tmp/DoubleAnnotationMatching.aj:28::533]    pointcut is at [/private/tmp/ajcSandbox/ajcTest18924.tmp/DoubleAnnotationMatching.aj:15::316]
when implementing on shadow method-execution(void Foo.foo())
when weaving type Foo
when weaving classes 
when weaving 
when batch building BuildConfig[null] #Files=1

Impossible! annotation=[Tx]  shadow=[method-execution(void Foo.foo()) at /private/tmp/ajcSandbox/ajcTest18924.tmp/DoubleAnnotationMatching.aj:28::533]    pointcut is at [/private/tmp/ajcSandbox/ajcTest18924.tmp/DoubleAnnotationMatching.aj:15::316]
when implementing on shadow method-execution(void Foo.foo())
when weaving type Foo
when weaving classes 
when weaving 
when batch building BuildConfig[null] #Files=1

org.aspectj.weaver.BCException: Impossible! annotation=[Tx]  shadow=[method-execution(void Foo.foo()) at /private/tmp/ajcSandbox/ajcTest18924.tmp/DoubleAnnotationMatching.aj:28::533]    pointcut is at [/private/tmp/ajcSandbox/ajcTest18924.tmp/DoubleAnnotationMatching.aj:15::316]
when implementing on shadow method-execution(void Foo.foo())
when weaving type Foo
when weaving classes 
when weaving 
when batch building BuildConfig[null] #Files=1

	at org.aspectj.weaver.patterns.AnnotationPointcut.findResidueInternal(AnnotationPointcut.java:201)
	at org.aspectj.weaver.patterns.Pointcut.findResidue(Pointcut.java:267)
	at org.aspectj.weaver.patterns.AndPointcut.findResidueInternal(AndPointcut.java:93)
	at org.aspectj.weaver.patterns.Pointcut.findResidue(Pointcut.java:267)
	at org.aspectj.weaver.patterns.AndPointcut.findResidueInternal(AndPointcut.java:93)
	at org.aspectj.weaver.patterns.Pointcut.findResidue(Pointcut.java:267)
	at org.aspectj.weaver.patterns.IfPointcut.findResidueInternal(IfPointcut.java:173)
	at org.aspectj.weaver.patterns.Pointcut.findResidue(Pointcut.java:267)
	at org.aspectj.weaver.patterns.AndPointcut.findResidueInternal(AndPointcut.java:93)
	at org.aspectj.weaver.patterns.Pointcut.findResidue(Pointcut.java:267)
	at org.aspectj.weaver.patterns.AndPointcut.findResidueInternal(AndPointcut.java:93)
	at org.aspectj.weaver.patterns.Pointcut.findResidue(Pointcut.java:267)
	at org.aspectj.weaver.patterns.OrPointcut.findResidueInternal(OrPointcut.java:96)
	at org.aspectj.weaver.patterns.Pointcut.findResidue(Pointcut.java:267)
	at org.aspectj.weaver.bcel.BcelAdvice.specializeOn(BcelAdvice.java:132)
	at org.aspectj.weaver.bcel.BcelShadow.prepareForMungers(BcelShadow.java:325)
	at org.aspectj.weaver.Shadow.implement(Shadow.java:455)
	at org.aspectj.weaver.bcel.BcelClassWeaver.implement(BcelClassWeaver.java:2236)
	at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:491)
	at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:109)
	at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1560)
	at org.aspectj.weaver.bcel.BcelWeaver.weaveWithoutDump(BcelWeaver.java:1511)
	at org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify(BcelWeaver.java:1291)
	at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1113)
	at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave(AjCompilerAdapter.java:311)
	at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling(AjCompilerAdapter.java:183)
	at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$afterReturning$org_aspectj_ajdt_internal_compiler_CompilerAdapter$2$f9cc9ca0(CompilerAdapter.aj:70)
	at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:367)
	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:862)
	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:242)
	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:161)
	at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:114)
	at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:60)
	at org.aspectj.tools.ajc.Main.run(Main.java:367)
	at org.aspectj.tools.ajc.Main.runMain(Main.java:246)
	at org.aspectj.tools.ajc.Ajc.compile(Ajc.java:199)
	at org.aspectj.tools.ajc.Ajc.compile(Ajc.java:163)
	at org.aspectj.tools.ajc.AjcTestCase.ajc(AjcTestCase.java:510)
	at org.aspectj.testing.CompileSpec.execute(CompileSpec.java:53)
	at org.aspectj.testing.AjcTest.runTest(AjcTest.java:68)
	at org.aspectj.testing.XMLBasedAjcTestCase.runTest(XMLBasedAjcTestCase.java:111)
	at org.aspectj.systemtest.ajc152.Ajc152Tests.testDoubleAnnotationMatching_pr138221(Ajc152Tests.java:37)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:585)
	at junit.framework.TestCase.runTest(TestCase.java:154)
	at junit.framework.TestCase.runBare(TestCase.java:127)
	at junit.framework.TestResult$1.protect(TestResult.java:106)
	at junit.framework.TestResult.runProtected(TestResult.java:124)
	at junit.framework.TestResult.run(TestResult.java:109)
	at junit.framework.TestCase.run(TestCase.java:118)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:478)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:344)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196)


command was: ajc -classpath /Users/adrian/projects/aspectjdev/lib/test/aspectjrt.jar:../testing-client/bin:../runtime/bin:../aspectj5rt/bin:../lib/junit/junit.jar:../bridge/bin:../loadtime/bin:../weaver/bin:../weaver5/bin:../aj-build/jars/bridge.jar:../aj-build/jars/util.jar:../aj-build/jars/loadtime.jar:../aj-build/jars/weaver.jar:../aj-build/jars/weaver5.jar:../aj-build/jars/asm.jar:../lib/test/testing-client.jar:../lib/test/aspectjrt.jar:/tmp/ajcSandbox/ajcTest18924.tmp -1.5 /tmp/ajcSandbox/ajcTest18924.tmp/DoubleAnnotationMatching.aj -d /tmp/ajcSandbox/ajcTest18924.tmp
	at junit.framework.Assert.fail(Assert.java:47)
	at org.aspectj.tools.ajc.AjcTestCase.assertMessages(AjcTestCase.java:452)
	at org.aspectj.testing.CompileSpec.execute(CompileSpec.java:56)
	at org.aspectj.testing.AjcTest.runTest(AjcTest.java:68)
	at org.aspectj.testing.XMLBasedAjcTestCase.runTest(XMLBasedAjcTestCase.java:111)
	at org.aspectj.systemtest.ajc152.Ajc152Tests.testDoubleAnnotationMatching_pr138221(Ajc152Tests.java:37)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:585)
	at junit.framework.TestCase.runTest(TestCase.java:154)
	at junit.framework.TestCase.runBare(TestCase.java:127)
	at junit.framework.TestResult$1.protect(TestResult.java:106)
	at junit.framework.TestResult.runProtected(TestResult.java:124)
	at junit.framework.TestResult.run(TestResult.java:109)
	at junit.framework.TestCase.run(TestCase.java:118)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:478)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:344)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196)</description><comments/></buginformation><fixedCommits><commit id="6b2d9ae90158bd4e5cda5ecea5f3787400bab5af" author="default" date="2006-05-17 15:48:34"><file name="tests/src/org/aspectj/systemtest/ajc152/Ajc152Tests.java"><method name="testReferencePCutInPerClause_pr130722" returnType="void" parameters=""/></file><file name="weaver/src/org/aspectj/weaver/patterns/AnnotationPointcut.java"><method name="findResidueInternal" returnType="Test" parameters="Shadow ExposedState"/></file></commit></fixedCommits></bug><bug id="314" opendate="2006-05-18 07:32:00" fixdate="2006-05-23 07:55:53"><buginformation><summary>[ltw] Fail at runtime if abstract methods are not implemented in a hierarchy that finishes with an XML aspect</summary><description>see pr125480 - copying the test for that will be a good basis for a test for this bug.  We don't check that when defining a concrete aspect there are no unimplemented abstract methods in the aspect we are concretizing.</description><comments/></buginformation><fixedCommits><commit id="69e24e90d4fee7115ecbc8c7786915b1f741471b" author="default" date="2006-05-23 07:55:53"><file name="loadtime/src/org/aspectj/weaver/loadtime/ConcreteAspectCodeGen.java"><method name="validate" returnType="boolean" parameters=""/></file></commit></fixedCommits></bug><bug id="315" opendate="2006-05-26 07:12:00" fixdate="2006-05-30 09:59:53"><buginformation><summary>create constructor ipe in same was as method ipes</summary><description>At the moment the way the constructor ipes are constructed is different to that of methods. For example, for a method which has signature

public void myMethod(String s, int i)

the corresponding ipe is firstly constructed with name "myMethod" and then the arguments are added. Adding the arguments results in an ipe with name "myMethod(java.lang.String,int)".

With a constructor that has signature

public MyClass(String s, int i)

the corresponding ipe is constructed with name "MyClass(String,int)" and no arguments are associated with it. 

Up until now there hasn't been a use case to change this. However, due to enhancement  bug 141730  (updating handles not to rely on source locations) it is necessary for the constructor ipes to have arguments associated with them. Also, if the ipes of methods and constructors had similar properties then the processing for creating the new handles can be the same.</description><comments/></buginformation><fixedCommits><commit id="26a8a862994acefb10a57d561b18c94ffeba41a4" author="default" date="2006-05-30 09:59:53"><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmHierarchyBuilder.java"><method name="visit" returnType="boolean" parameters="ConstructorDeclaration"/></file><file name="ajdoc/testsrc/org/aspectj/tools/ajdoc/CoverageTestCase.java"><method name="testAdvisesRelationshipCoverage" returnType="void" parameters=""/></file><file name="tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java"><method name="testDeclareAnnotationAppearsInStructureModel_pr132130" returnType="void" parameters=""/></file><file name="weaver/src/org/aspectj/weaver/AsmRelationshipProvider.java"><method name="addDeclareAnnotationRelationship" returnType="void" parameters="ISourceLocation"/></file><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmElementFormatter.java"><method name="setParameters" returnType="void" parameters="MethodDeclaration IProgramElement"/></file></commit></fixedCommits></bug><bug id="316" opendate="2006-05-31 12:43:00" fixdate="2006-05-31 17:32:36"><buginformation><summary>org.aspectj.weaver.BCException: Do not call nameToSignature with something that looks like a signature (descriptor): '[Ljava.lang.String;'</summary><description>The exception below is produced when parsing a pointcut that uses an array type in args using the reflection world pointcut parser support.

org.aspectj.weaver.BCException: Do not call nameToSignature with something that looks like a signature (descriptor): '[Ljava.lang.String;'

	at org.aspectj.weaver.UnresolvedType.nameToSignature(UnresolvedType.java:741)
	at org.aspectj.weaver.UnresolvedType.forName(UnresolvedType.java:311)
	at org.aspectj.weaver.reflect.Java15ReflectionBasedReferenceTypeDelegate.getDeclaredPointcuts(Java15ReflectionBasedReferenceTypeDelegate.java:260)
	at org.aspectj.weaver.ReferenceType.getDeclaredPointcuts(ReferenceType.java:526)
	at org.aspectj.weaver.ResolvedType$7.get(ResolvedType.java:468)
	at org.aspectj.weaver.Iterators$6.hasNext(Iterators.java:118)
	at org.aspectj.weaver.Iterators$5.hasNext(Iterators.java:128)
	at org.aspectj.weaver.ResolvedType.findPointcut(ResolvedType.java:479)
	at org.aspectj.weaver.patterns.ReferencePointcut.resolveBindings(ReferencePointcut.java:151)
	at org.aspectj.weaver.patterns.Pointcut.resolve(Pointcut.java:194)
	at org.aspectj.weaver.tools.PointcutParser.resolvePointcutExpression(PointcutParser.java:330)
	at org.aspectj.weaver.tools.PointcutParser.parsePointcutExpression(PointcutParser.java:308)
	at org.aspectj.weaver.tools.Java15PointcutExpressionTest.testArrayTypeInArgs(Java15PointcutExpressionTest.java:304)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:585)
	at junit.framework.TestCase.runTest(TestCase.java:154)
	at junit.framework.TestCase.runBare(TestCase.java:127)
	at junit.framework.TestResult$1.protect(TestResult.java:106)
	at junit.framework.TestResult.runProtected(TestResult.java:124)
	at junit.framework.TestResult.run(TestResult.java:109)
	at junit.framework.TestCase.run(TestCase.java:118)
	at junit.framework.TestSuite.runTest(TestSuite.java:208)
	at junit.framework.TestSuite.run(TestSuite.java:203)
	at junit.framework.TestSuite.runTest(TestSuite.java:208)
	at junit.framework.TestSuite.run(TestSuite.java:203)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:478)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:344)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196)</description><comments/></buginformation><fixedCommits><commit id="97cd71ae811def2ee79d34567f60acb9f76ebf0c" author="default" date="2006-05-31 17:32:36"><file name="weaver/src/org/aspectj/weaver/tools/PointcutParser.java"><method name="buildResolutionScope" returnType="IScope" parameters="Class"/></file><file name="weaver5/java5-src/org/aspectj/weaver/reflect/Java15ReflectionBasedReferenceTypeDelegate.java"><method name="createGenericFieldMember" returnType="ResolvedMember" parameters="Field"/></file><file name="weaver5/java5-testsrc/org/aspectj/weaver/tools/Java15PointcutExpressionTest.java"><method name="d" returnType="void" parameters=""/></file></commit></fixedCommits></bug><bug id="317" opendate="2005-12-13 16:10:00" fixdate="2006-06-01 16:30:21"><buginformation><summary>LTW Optimization: Disable World if it has No Aspects</summary><description>This optimization disables weaving for a ClassLoader where there are no aspects defined. This is actually useful if you have aspect exclusions that exclude all the aspects defined in a parent class loader. It is also helpful in the trivial/rare case where there is an aop.xml definition with no aspect definitions.</description><comments/></buginformation><fixedCommits><commit id="4513e921c89fb3b8f037418a901e49906724e7bd" author="default" date="2006-06-01 16:30:21"><file name="loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"><method name="registerAspects" returnType="void" parameters="BcelWeaver ClassLoader"/><method name="addCrossReference" returnType="void" parameters="ISourceLocation ISourceLocation"/></file></commit></fixedCommits></bug><bug id="318" opendate="2006-03-20 15:51:00" fixdate="2006-06-02 12:47:08"><buginformation><summary>Duplicate exception with aop.xml file on aspectpath</summary><description>See also  bug #57666  which is related (but has to do with manifests):

I have a META-INF/aop.xml file in my aspectpath and another one in the source path. That shouldn't even be a duplicate, because the aspectpath resource should NOT be copied to output at all.

In AspectJ build:  1.5.1.20060309143651

I am now getting:

java.util.zip.ZipException
at java.util.zip.ZipOutputStream.putNextEntry(ZipOutputStream.java:163)
at java.util.jar.JarOutputStream.putNextEntry(JarOutputStream.java:90)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.writeOutxmlFile(AjBuildManager.java:549)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:320)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:163)
at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:122)
at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)

ZipException thrown: duplicate entry: META-INF/aop.xml</description><comments/></buginformation><fixedCommits><commit id="319a0d15703c098b74335ecb9672f58166bf3c5b" author="default" date="2006-06-02 12:47:08"><file name="ajde/testsrc/org/aspectj/ajde/NullIdeProperties.java"><method name="accept" returnType="boolean" parameters="File"/><method name="getSourcePathResources" returnType="Map" parameters=""/></file><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"><method name="accept" returnType="boolean" parameters="File"/><method name="writeResource" returnType="void" parameters="String byte[] File"/><method name="writeOutxmlFile" returnType="void" parameters=""/></file><file name="ajde/testsrc/org/aspectj/ajde/OutxmlTest.java"><method name="testOutxmlfileToOutjar" returnType="void" parameters=""/></file></commit></fixedCommits></bug><bug id="319" opendate="2006-06-02 11:35:00" fixdate="2006-06-03 08:27:06"><buginformation><summary>NPE when weak reference set in signature</summary><description>Simon ran into the same problem in setting the values. I will attach a patch to fix this, with test cases to properly verify it works in both cases.

java.lang.NullPointerException
	at org.aspectj.runtime.reflect.SignatureImpl$CacheImpl.set(SignatureImpl.java:224)
	at org.aspectj.runtime.reflect.SignatureImpl.toString(SignatureImpl.java:57)
	at org.aspectj.runtime.reflect.SignatureImpl.toString(SignatureImpl.java:62)</description><comments/></buginformation><fixedCommits><commit id="f821ca3dae5681758d23a2a0531d0d42f017152e" author="default" date="2006-06-03 08:27:06"><file name="runtime/src/org/aspectj/runtime/reflect/SignatureImpl.java"><method name="set" returnType="void" parameters="int String"/><method name="array" returnType="String[]" parameters=""/><method name="get" returnType="String" parameters="int"/><method name="getUseCache" returnType="boolean" parameters=""/></file></commit></fixedCommits></bug><bug id="320" opendate="2006-06-05 08:12:00" fixdate="2006-06-06 08:40:16"><buginformation><summary>Failure of testCompareSubclassDelegates() on J9 1.5.0 SR1</summary><description>This would appear to be a regression of  bug 120909  which was fixed for 1.5.0. The latest J9 can be obtained here  http://www-128.ibm.com/developerworks/java/jdk/index.html .

TESTROOT
RunTheseBeforeYouCommitTests
AllTests
BcweaverModuleTests15
org.aspectj.weaver.TestJava5ReflectionBasedReferenceTypeDelegate
testCompareSubclassDelegates(org.aspectj.weaver.TestJava5ReflectionBasedReferenceTypeDelegate)
junit.framework.AssertionFailedError: Should be one extra (clinit) in BCEL case, but bcel=41 reflect=41
	at junit.framework.Assert.fail(Assert.java:47)
	at junit.framework.Assert.assertTrue(Assert.java:20)
	at org.aspectj.weaver.reflect.ReflectionBasedReferenceTypeDelegateTest.testCompareSubclassDelegates(ReflectionBasedReferenceTypeDelegateTest.java:286)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:615)
	at junit.framework.TestCase.runTest(TestCase.java:154)
	at junit.framework.TestCase.runBare(TestCase.java:127)
	at junit.framework.TestResult$1.protect(TestResult.java:106)
	at junit.framework.TestResult.runProtected(TestResult.java:124)
	at junit.framework.TestResult.run(TestResult.java:109)
	at junit.framework.TestCase.run(TestCase.java:118)
	at junit.framework.TestSuite.runTest(TestSuite.java:208)
	at junit.framework.TestSuite.run(TestSuite.java:203)
	at junit.framework.TestSuite.runTest(TestSuite.java:208)
	at junit.framework.TestSuite.run(TestSuite.java:203)
	at junit.framework.TestSuite.runTest(TestSuite.java:208)
	at junit.framework.TestSuite.run(TestSuite.java:203)
	at junit.framework.TestSuite.runTest(TestSuite.java:208)
	at junit.framework.TestSuite.run(TestSuite.java:203)
	at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128)
	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196)</description><comments/></buginformation><fixedCommits><commit id="3e0650d8a084248c4eb93f22cd8abfdabe6ba2a8" author="default" date="2006-06-06 08:40:16"><file name="weaver/testsrc/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateTest.java"><method name="testCompareSubclassDelegates" returnType="void" parameters=""/></file></commit></fixedCommits></bug><bug id="321" opendate="2006-01-03 20:19:00" fixdate="2006-06-09 10:56:50"><buginformation><summary>Fix &amp; Bug: Circularity Failure for Verbose Loading on JRockit 1.4.2_08 Agent</summary><description>Here is a stack trace I am getting when I try to use AspectJ 1.5.0 final release's load-time weaving with JRockIt 1.4.2_08 using -Xmanagement:class=org.aspectj.weaver.loadtime.JRockitAgent to load Weblogic Server 8.1 SP2. I debugged the code in Eclipse and discovered that the weaver was being initialized while loading IMessage$Kind, so the JRockIt VM simply hasn't run staticinitialization yet, making IMessage.INFO null.

I was able to fix this stack trace by hoisting the check for loading AspectJ code up BEFORE initializing a weaving adaptor i.e., changing line 55 of Aj.java to be
        if (loader == null || className == null || className.startsWith("org/aspectj/")) {

I then commented out line 251 of WeavingAdaptor to avoid a duplicate check:
	private boolean shouldWeaveName (String name) {
		return !((/*(name.startsWith("org.apache.bcel.")||//FIXME AV why ? bcel is wrapped in org.aspectj.
                name.startsWith("org.aspectj.")||*/ // now checked earlier, to avoid circularity issues in initialization 
                name.startsWith("java.")
                || name.startsWith("javax."))
                //|| name.startsWith("$Proxy")//JDK proxies//FIXME AV is that 1.3 proxy ? fe. ataspect.$Proxy0 is a java5 proxy...
                || name.startsWith("sun.reflect."));//JDK reflect
	}

Note that this bug does NOT occur when using a JRockIt 1.5.0 VM, even with the -Xmanagement command line argument.

Stack Trace:
java.lang.IllegalArgumentException: null kind
	at org.aspectj.bridge.Message.&lt;init&gt;(Ljava/lang/String;Ljava/lang/String;Lorg/aspectj/bridge/IMessage$Kind;Lorg/aspectj/bridge/ISourceLocation;Ljava/lang/Throwable;[Lorg/aspectj/bridge/ISourceLocation;ZIII)V(Message.java:89)
	at org.aspectj.bridge.Message.&lt;init&gt;(Ljava/lang/String;Ljava/lang/String;Lorg/aspectj/bridge/IMessage$Kind;Lorg/aspectj/bridge/ISourceLocation;Ljava/lang/Throwable;[Lorg/aspectj/bridge/ISourceLocation;)V(Message.java:67)
	at org.aspectj.bridge.Message.&lt;init&gt;(Ljava/lang/String;Lorg/aspectj/bridge/IMessage$Kind;Ljava/lang/Throwable;Lorg/aspectj/bridge/ISourceLocation;)V(Message.java:110)
	at org.aspectj.bridge.MessageUtil.info(Ljava/lang/String;)Lorg/aspectj/bridge/IMessage;(MessageUtil.java:211)
	at org.aspectj.bridge.MessageUtil.info(Lorg/aspectj/bridge/IMessageHandler;Ljava/lang/String;)Z(MessageUtil.java:98)
	at org.aspectj.weaver.tools.WeavingAdaptor.info(Ljava/lang/String;)Z(WeavingAdaptor.java:343)
	at org.aspectj.weaver.tools.WeavingAdaptor.createMessageHandler()V(WeavingAdaptor.java:168)
	at org.aspectj.weaver.tools.WeavingAdaptor.&lt;init&gt;()V(WeavingAdaptor.java:80)
	at org.aspectj.weaver.loadtime.ClassLoaderWeavingAdaptor.&lt;init&gt;(Ljava/lang/ClassLoader;Lorg/aspectj/weaver/loadtime/IWeavingContext;)V(ClassLoaderWeavingAdaptor.java:70)
	at org.aspectj.weaver.loadtime.Aj$WeaverContainer.getWeaver(Ljava/lang/ClassLoader;Lorg/aspectj/weaver/loadtime/IWeavingContext;)Lorg/aspectj/weaver/tools/WeavingAdaptor;(Aj.java:94)
	at org.aspectj.weaver.loadtime.Aj.preProcess(Ljava/lang/String;[BLjava/lang/ClassLoader;)[B(Aj.java:61)
	at org.aspectj.weaver.loadtime.JRockitAgent.preProcess(Ljava/lang/ClassLoader;Ljava/lang/String;[B)[B(JRockitAgent.java:74)
	at jrockit.vm.ClassPreProcessorManager.notifyClassPreProcessor(ILjava/lang/String;[B)[B(Unknown Source)
	at jrockit.vm.Classes.defineClass0(ILjava/lang/String;[BII)I(Unknown Source)
	at jrockit.vm.Classes.defineClass(Ljava/lang/ClassLoader;Ljava/lang/String;[BII)Ljava/lang/Class;(Unknown Source)
	at java.lang.ClassLoader.defineClass(Ljava/lang/String;[BIILjava/security/ProtectionDomain;)Ljava/lang/Class;(Unknown Source)
	at java.security.SecureClassLoader.defineClass(Ljava/lang/String;[BIILjava/security/CodeSource;)Ljava/lang/Class;(SecureClassLoader.java:123)
	at java.net.URLClassLoader.defineClass(Ljava/lang/String;Lsun/misc/Resource;)Ljava/lang/Class;(URLClassLoader.java:251)
	at java.net.URLClassLoader.access$100(Ljava/net/URLClassLoader;Ljava/lang/String;Lsun/misc/Resource;)Ljava/lang/Class;(URLClassLoader.java:55)
	at java.net.URLClassLoader$1.run()Ljava/lang/Object;(URLClassLoader.java:194)
	at jrockit.vm.AccessController.do_privileged_exc(Ljava/security/PrivilegedExceptionAction;Ljava/security/AccessControlContext;I)Ljava/lang/Object;(Unknown Source)
	at jrockit.vm.AccessController.doPrivileged(Ljava/security/PrivilegedExceptionAction;Ljava/security/AccessControlContext;)Ljava/lang/Object;(Unknown Source)
	at java.net.URLClassLoader.findClass(Ljava/lang/String;)Ljava/lang/Class;(URLClassLoader.java:187)
	at java.lang.ClassLoader.loadClass(Ljava/lang/String;Z)Ljava/lang/Class;(Unknown Source)
	at sun.misc.Launcher$AppClassLoader.loadClass(Ljava/lang/String;Z)Ljava/lang/Class;(Launcher.java:274)
	at java.lang.ClassLoader.loadClass(Ljava/lang/String;)Ljava/lang/Class;(Unknown Source)
	at java.lang.ClassLoader.loadClassFromNative(II)Ljava/lang/Class;(Unknown Source)
	at jrockit.vm.RNI.getRunnableCode(I)I(Unknown Source)
	at jrockit.vm.RNI.trampoline()V(Unknown Source)
	at org.aspectj.bridge.MessageUtil.info(Ljava/lang/String;)Lorg/aspectj/bridge/IMessage;(MessageUtil.java:???)
	at org.aspectj.bridge.MessageUtil.info(Lorg/aspectj/bridge/IMessageHandler;Ljava/lang/String;)Z(MessageUtil.java:98)
	at org.aspectj.weaver.tools.WeavingAdaptor.info(Ljava/lang/String;)Z(WeavingAdaptor.java:343)
java.lang.IllegalArgumentException: null kind
	at org.aspectj.bridge.Message.&lt;init&gt;(Ljava/lang/String;Ljava/lang/String;Lorg/aspectj/bridge/IMessage$Kind;Lorg/aspectj/bridge/ISourceLocation;Ljava/lang/Throwable;[Lorg/aspectj/bridge/ISourceLocation;ZIII)V(Message.java:89)
	at org.aspectj.bridge.Message.&lt;init&gt;(Ljava/lang/String;Ljava/lang/String;Lorg/aspectj/bridge/IMessage$Kind;Lorg/aspectj/bridge/ISourceLocation;Ljava/lang/Throwable;[Lorg/aspectj/bridge/ISourceLocation;)V(Message.java:67)
	at org.aspectj.bridge.Message.&lt;init&gt;(Ljava/lang/String;Lorg/aspectj/bridge/IMessage$Kind;Ljava/lang/Throwable;Lorg/aspectj/bridge/ISourceLocation;)V(Message.java:110)
	at org.aspectj.bridge.MessageUtil.info(Ljava/lang/String;)Lorg/aspectj/bridge/IMessage;(MessageUtil.java:211)
	at org.aspectj.bridge.MessageUtil.info(Lorg/aspectj/bridge/IMessageHandler;Ljava/lang/String;)Z(MessageUtil.java:98)
	at org.aspectj.weaver.tools.WeavingAdaptor.info(Ljava/lang/String;)Z(WeavingAdaptor.java:343)
	at org.aspectj.weaver.tools.WeavingAdaptor.createMessageHandler()V(WeavingAdaptor.java:168)
	at org.aspectj.weaver.tools.WeavingAdaptor.&lt;init&gt;()V(WeavingAdaptor.java:80)
	at org.aspectj.weaver.loadtime.ClassLoaderWeavingAdaptor.&lt;init&gt;(Ljava/lang/ClassLoader;Lorg/aspectj/weaver/loadtime/IWeavingContext;)V(ClassLoaderWeavingAdaptor.java:70)
	at org.aspectj.weaver.loadtime.Aj$WeaverContainer.getWeaver(Ljava/lang/ClassLoader;Lorg/aspectj/weaver/loadtime/IWeavingContext;)Lorg/aspectj/weaver/tools/WeavingAdaptor;(Aj.java:94)
	at org.aspectj.weaver.loadtime.Aj.preProcess(Ljava/lang/String;[BLjava/lang/ClassLoader;)[B(Aj.java:61)
	at org.aspectj.weaver.loadtime.JRockitAgent.preProcess(Ljava/lang/ClassLoader;Ljava/lang/String;[B)[B(JRockitAgent.java:74)
	at jrockit.vm.ClassPreProcessorManager.notifyClassPreProcessor(ILjava/lang/String;[B)[B(Unknown Source)
	at jrockit.vm.Classes.defineClass0(ILjava/lang/String;[BII)I(Unknown Source)
	at jrockit.vm.Classes.defineClass(Ljava/lang/ClassLoader;Ljava/lang/String;[BII)Ljava/lang/Class;(Unknown Source)
	at java.lang.ClassLoader.defineClass(Ljava/lang/String;[BIILjava/security/ProtectionDomain;)Ljava/lang/Class;(Unknown Source)
	at java.security.SecureClassLoader.defineClass(Ljava/lang/String;[BIILjava/security/CodeSource;)Ljava/lang/Class;(SecureClassLoader.java:123)
	at java.net.URLClassLoader.defineClass(Ljava/lang/String;Lsun/misc/Resource;)Ljava/lang/Class;(URLClassLoader.java:251)
	at java.net.URLClassLoader.access$100(Ljava/net/URLClassLoader;Ljava/lang/String;Lsun/misc/Resource;)Ljava/lang/Class;(URLClassLoader.java:55)
	at java.net.URLClassLoader$1.run()Ljava/lang/Object;(URLClassLoader.java:194)
	at jrockit.vm.AccessController.do_privileged_exc(Ljava/security/PrivilegedExceptionAction;Ljava/security/AccessControlContext;I)Ljava/lang/Object;(Unknown Source)
	at jrockit.vm.AccessController.doPrivileged(Ljava/security/PrivilegedExceptionAction;Ljava/security/AccessControlContext;)Ljava/lang/Object;(Unknown Source)
	at java.net.URLClassLoader.findClass(Ljava/lang/String;)Ljava/lang/Class;(URLClassLoader.java:187)
	at java.lang.ClassLoader.loadClass(Ljava/lang/String;Z)Ljava/lang/Class;(Unknown Source)
	at sun.misc.Launcher$AppClassLoader.loadClass(Ljava/lang/String;Z)Ljava/lang/Class;(Launcher.java:274)
	at java.lang.ClassLoader.loadClass(Ljava/lang/String;)Ljava/lang/Class;(Unknown Source)
	at java.lang.ClassLoader.loadClassFromNative(II)Ljava/lang/Class;(Unknown Source)
	at jrockit.vm.RNI.getRunnableCode(I)I(Unknown Source)
	at jrockit.vm.RNI.trampoline()V(Unknown Source)
	at org.aspectj.bridge.MessageUtil.info(Lorg/aspectj/bridge/IMessageHandler;Ljava/lang/String;)Z(MessageUtil.java:???)
	at org.aspectj.weaver.tools.WeavingAdaptor.info(Ljava/lang/String;)Z(WeavingAdaptor.java:343)
	at org.aspectj.weaver.tools.WeavingAdaptor.createMessageHandler()V(WeavingAdaptor.java:168)</description><comments/></buginformation><fixedCommits><commit id="75afb31e38f75e61de5c15058d3332f3dac0df15" author="default" date="2006-06-09 10:56:50"><file name="loadtime/src/org/aspectj/weaver/loadtime/JRockitAgent.java"><method name="preProcess" returnType="byte[]" parameters="ClassLoader String byte[]"/></file><file name="loadtime/testsrc/LoadtimeModuleTests.java"><method name="suite" returnType="Test" parameters=""/></file><file name="loadtime/src/org/aspectj/weaver/loadtime/Aj.java"><method name="initialize" returnType="void" parameters=""/></file></commit></fixedCommits></bug><bug id="322" opendate="2006-06-12 07:59:00" fixdate="2006-06-12 14:00:02"><buginformation><summary>Remove hard coded dependency on "|" in getFileName(..) methods</summary><description>As part of  bug 141730  we need to remove the hard coded dependency on "|" in methods which use handles to get the filename. These methods are:

AsmManager.getFileName(String)
AspectJElementHierarchy.getFileName(String)</description><comments/></buginformation><fixedCommits><commit id="38cc0dd2f77eaea1778ede835e7da0aa9d871de7" author="default" date="2006-06-12 14:00:02"><file name="asm/src/org/aspectj/asm/AsmManager.java"><method name="dumprelsStderr" returnType="void" parameters="String"/><method name="getFilename" returnType="String" parameters="String"/></file><file name="asm/src/org/aspectj/asm/internal/AspectJElementHierarchy.java"><method name="getFilename" returnType="String" parameters="String"/><method name="updateHandleMap" returnType="void" parameters="Set"/></file></commit></fixedCommits></bug><bug id="323" opendate="2006-04-13 14:23:00" fixdate="2006-06-13 19:45:44"><buginformation><summary>iajc should print summary like javac</summary><description>The iajc ant task should produce a summary of what it is doing, like the javac task does:

[javac] Compiling 189 source files to C:\project\classes</description><comments/></buginformation><fixedCommits><commit id="008efca98bdfe5cda6c32ec75575facf7da2c687" author="default" date="2006-06-13 19:45:44"><file name="taskdefs/testsrc/org/aspectj/tools/ant/taskdefs/AjcTaskTest.java"><method name="testDefaultFileComplete" returnType="void" parameters=""/><method name="check" returnType="void" parameters=""/></file><file name="taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java"><method name="reset" returnType="void" parameters=""/><method name="execute" returnType="void" parameters=""/><method name="toString" returnType="String" parameters=""/></file></commit></fixedCommits></bug><bug id="324" opendate="2006-06-20 06:16:00" fixdate="2006-06-20 11:12:49"><buginformation><summary>Generic abstract aspect hierarchies 3 deep or higher can fail when type parameters have bounds</summary><description>The program below should compile happily, but fails with:

[error] Type B does not meet the specification for type parameter 1 (A extends MyBase) in generic type Base
abstract aspect Middle&lt;B extends MyBase&gt; extends Base&lt;B&gt; {}
                ^^^^^                                      


The test program:
------------------

interface MyBase {};
interface MyMarker extends MyBase {}

abstract aspect Base&lt;A extends MyBase&gt; {}

abstract aspect Middle&lt;B extends MyBase&gt; extends Base&lt;B&gt; {}

aspect Sub extends Middle&lt;MyMarker&gt; {}</description><comments/></buginformation><fixedCommits><commit id="791f8a7c3f37d9b10b8ad1692df998733bbc2f20" author="default" date="2006-06-20 11:12:49"><file name="weaver/src/org/aspectj/weaver/TypeVariable.java"><method name="matchingBounds" returnType="boolean" parameters="TypeVariableReferenceType"/></file></commit></fixedCommits></bug><bug id="325" opendate="2006-06-19 18:07:00" fixdate="2006-06-21 11:33:21"><buginformation><summary>java.lang.ClassFormatError: Repetitive method name/signature</summary><description>I get a ClassFormatError trying to perform runtime-weaving on a DB2 class.
The class being woven is COM.ibm.db2.jdbc.app.DB2PreparedStatement.  
The full message exception is: java.lang.ClassFormatError: Repetitive method name/signature in class file COM/ibm/db2/jdbc/app/DB2PreparedStatement.

In examining the post-weave class file, it looks as if Aspectj is defining
a duplicate method within the class called getParameterMetaData().  

Here are the messages from the weaver:
04:21:13,640 INFO  [STDOUT] info weaving 'COM.ibm.db2.jdbc.app.DB2CallableStatement'
04:21:13,640 INFO  [STDOUT] info weaver operating in reweavable mode.  Need to verify any required types exist.
04:21:13,671 INFO  [STDOUT] info weaving 'COM.ibm.db2.jdbc.app.DB2PreparedStatement'
04:21:13,671 INFO  [STDOUT] info weaver operating in reweavable mode.  Need to verify any required types exist.
04:21:13,703 INFO  [STDOUT] weaveinfo Join point 'method-execution(java.sql.ResultSet COM.ibm.db2.jdbc.app.DB2PreparedStatement.executeQuery())' in Type 'COM.ibm.db2.jdbc.app.DB2PreparedStatement' (DB2PreparedStatement.java:1679) advised by before advice from 'com.ibm.tivoli.itcam.toolkit.ai.aspectj.captureJDBC.CaptureSQLStatement' (CaptureSQLStatement.aj:747) [with runtime test]
04:21:13,703 INFO  [STDOUT] weaveinfo Join point 'method-execution(java.sql.ResultSet COM.ibm.db2.jdbc.app.DB2PreparedStatement.executeQuery())' in Type 'COM.ibm.db2.jdbc.app.DB2PreparedStatement' (DB2PreparedStatement.java:1679) advised by afterReturning advice from 'com.ibm.tivoli.itcam.toolkit.ai.aspectj.captureJDBC.CaptureSQLStatement' (CaptureSQLStatement.aj:946) [with runtime test]
04:21:13,718 INFO  [STDOUT] weaveinfo Join point 'method-execution(java.sql.ResultSet COM.ibm.db2.jdbc.app.DB2PreparedStatement.executeQuery())' in Type 'COM.ibm.db2.jdbc.app.DB2PreparedStatement' (DB2PreparedStatement.java:1679) advised by afterThrowing advice from 'com.ibm.tivoli.itcam.toolkit.ai.aspectj.captureJDBC.CaptureSQLStatement' (CaptureSQLStatement.aj:971) [with runtime test]
04:21:13,718 INFO  [STDOUT] weaveinfo Join point 'method-execution(boolean COM.ibm.db2.jdbc.app.DB2PreparedStatement.execute())' in Type 'COM.ibm.db2.jdbc.app.DB2PreparedStatement' (DB2PreparedStatement.java:3971) advised by before advice from 'com.ibm.tivoli.itcam.toolkit.ai.aspectj.captureJDBC.CaptureSQLStatement' (CaptureSQLStatement.aj:833) [with runtime test]
04:21:13,718 INFO  [STDOUT] weaveinfo Join point 'method-execution(boolean COM.ibm.db2.jdbc.app.DB2PreparedStatement.execute())' in Type 'COM.ibm.db2.jdbc.app.DB2PreparedStatement' (DB2PreparedStatement.java:3971) advised by afterReturning advice from 'com.ibm.tivoli.itcam.toolkit.ai.aspectj.captureJDBC.CaptureSQLStatement' (CaptureSQLStatement.aj:946) [with runtime test]</description><comments/></buginformation><fixedCommits><commit id="13dde4efd453d32bb4f25781a8fa7aafc2cef850" author="default" date="2006-06-21 11:33:21"><file name="weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"><method name="calculateAnyRequiredBridgeMethods" returnType="boolean" parameters="BcelWorld LazyClassGen"/><method name="calculateAnyRequiredBridgeMethods" returnType="boolean" parameters="BcelWorld"/><method name="weave" returnType="boolean" parameters=""/><method name="isOverriding" returnType="ResolvedMember" parameters="ResolvedType"/><method name="checkForOverride" returnType="ResolvedMember" parameters="ResolvedType"/><method name="createBridgeMethod" returnType="void" parameters="BcelWorld"/></file><file name="weaver/src/org/aspectj/weaver/World.java"><method name="ensureAdvancedConfigurationProcessed" returnType="void" parameters=""/></file></commit></fixedCommits></bug><bug id="326" opendate="2006-06-21 05:27:00" fixdate="2006-06-22 04:49:26"><buginformation><summary>boolean methods with after advice return incorrect result on JRockit under WLS</summary><description>n 21/06/06, Stearns, Randy &lt; RStearns@knowledgestorm.com &gt; wrote:

    I've been able to create a reproducible test. My (really pared down) aspect:
     
    public aspect LoggingAspect {
     
     pointcut logPointcut() :
      execution (* *.*(..))
      &amp;&amp; !within(LoggingAspect);
     
     before() : logPointcut() {
       System.out.println("entering");
     }
     
        after() : logPointcut() {
                System.out.println("exiting");
        }
    }
    As it only appears in JRockit *while running in WebLogic*, I created a test servlet (below)
    As long as there is an after advice, tests 2 and 5 in the servlet return incorrect results.
    If I remove it, everything works. Also, if tests 2 and 5 return Boolean objects, it works.
     
    It appears AJ not like after advice on methods returning primitives.
    Is there a way to bypass them?
     
    Randy
     
     
    package test;
     
    import javax.servlet.ServletException;
    import javax.servlet.http.HttpServlet;
    import javax.servlet.http.HttpServletRequest;
    import javax.servlet.http.HttpServletResponse;
    import java.io.IOException;
    import java.io.PrintWriter;
     
    /**
     * Hello world!
     */
    public class TestServlet extends HttpServlet {
     
        protected void service(HttpServletRequest request, HttpServletResponse response)
                throws ServletException, IOException {
            booleanTest(response);
        }
     
        private void booleanTest(HttpServletResponse response) throws ServletException {
            PrintWriter out = null;
            try {
                out = response.getWriter();
            } catch (IOException ioe) {
                throw new ServletException("Could not get writer.");
            }
     
            out.println("Test 1a. Should be false. Was: " + invert1a());
            out.println("Test 1b. Should be true. Was: " + invert1b());
            out.println("Test 2. Should be false. Was: " + invert2());
            out.println("Test 3. Should be true. Was: " + invert3());
            out.println("Test 4. Should be true. Was: " + invert4());
            out.println("Test 5. Should be false. Was: " + invert5());
        }
     
        private boolean invert1a() {
            return ! true;
        }
     
        private boolean invert1b() {
            return ! false;
        }
     
        private boolean invert2() {
            return ! isTrue();
        }
     
        private boolean invert3() {
            return ! isFalse();
        }
     
        private boolean invert4() {
            boolean temp = isFalse();
            return ! temp;
        }
     
        private boolean invert5() {
            boolean temp = isTrue();
            return ! temp;
        }
     
        private boolean isTrue() {
            return true;
        }
     
        private boolean isFalse() {
            return false;
        }
    }</description><comments/></buginformation><fixedCommits><commit id="426cbdccfdf8fcfcda07b86d8e524d1034b2d0b7" author="default" date="2006-06-22 04:49:26"><file name="weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"><method name="weaveAfterReturning" returnType="void" parameters="BcelAdvice"/></file><file name="weaver/src/org/aspectj/weaver/bcel/Utility.java"><method name="replaceInstruction" returnType="void" parameters=""/></file></commit></fixedCommits></bug><bug id="327" opendate="2006-06-19 08:15:00" fixdate="2006-06-24 11:36:59"><buginformation><summary>Add an option to generate aj-synthetics with true synthetic flag</summary><description>In a number of cases tools are getting confused over generated aj members that are  "aj-synthetic" but not marked with the synthetic attribute (because in the past, this has upset other tools). The most recent example was a JAXB posting on the list - by having a perthis() clause in an aspect that matched a type with JAXB 2 annotations the user was no longer able to use JAXB. This is a serious issue, and will prevent the usage of JAXB 2 with any type into which we introduce properties as aj-synthetic members. The JAXB 2 solution to ignore such fields is to annotate them with @XmlTransient, but since the field does not exist in the user program they can't even do this!</description><comments/></buginformation><fixedCommits><commit id="c9f311aeeb11fb1427ec8857c24cfe3ffa6c7c9d" author="default" date="2006-06-24 11:36:59"><file name="weaver/src/org/aspectj/weaver/bcel/LazyClassGen.java"><method name="addField" returnType="void" parameters="Field"/></file><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/PointcutDeclaration.java"><method name="generateCode" returnType="void" parameters="ClassScope ClassFile"/></file><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/DeclareDeclaration.java"><method name="generateCode" returnType="void" parameters="ClassScope ClassFile"/></file><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AdviceDeclaration.java"><method name="resolveStatements" returnType="void" parameters=""/></file><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"><method name="internalMakeFieldBinding" returnType="internalMakeFieldBinding" parameters="ResolvedMember List"/><method name="internalMakeMethodBinding" returnType="internalMakeMethodBinding" parameters="ResolvedMember"/></file></commit></fixedCommits></bug><bug id="328" opendate="2006-06-27 05:42:00" fixdate="2006-06-27 11:34:41"><buginformation><summary>new array construction join point can fail for freaky array constructors</summary><description>Took me a while to discover how to recreate this problem, but this class:

public class A {
  public static void main(String []argv) {
    byte[][] bytes = new byte[][]{{0},{1}};
  }
}

causes this bytecode:

0:   iconst_2
1:   anewarray       #18; //class "[B"

and this causes the newarray joinpoint code to go bang.
(eg. before(): call(*[].new(..)) {})

java.lang.NullPointerException
        at org.aspectj.weaver.bcel.BcelWorld.fromBcel(BcelWorld.java:236)
        at org.aspectj.weaver.bcel.BcelWorld.makeJoinPointSignatureForArrayConstruction(BcelWorld.java:483)
        at org.aspectj.weaver.bcel.BcelShadow.makeArrayConstructorCall(BcelShadow.java:801)
        at org.aspectj.weaver.bcel.BcelClassWeaver.match(BcelClassWeaver.java:2510)
        at org.aspectj.weaver.bcel.BcelClassWeaver.match(BcelClassWeaver.java:2325)
        at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:490)
        at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:115)
        at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1574)
        at org.aspectj.weaver.bcel.BcelWeaver.weaveWithoutDump(BcelWeaver.java:1525)
        at org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify(BcelWeaver.java:1305)
        at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1127)</description><comments/></buginformation><fixedCommits><commit id="792d1dfd50e8b9ca5df70ea84c0b35de9cfba0f3" author="default" date="2006-06-27 11:34:41"><file name="weaver/src/org/aspectj/weaver/bcel/BcelWorld.java"><method name="makeJoinPointSignatureForArrayConstruction" returnType="Member" parameters="LazyClassGen"/></file></commit></fixedCommits></bug><bug id="329" opendate="2006-06-23 09:55:00" fixdate="2006-06-27 18:28:17"><buginformation><summary>LTW weaver produces a debug message at the begining</summary><description>Using the code in  bug #148381  (with any of the working options), LT weaver 
produces what seems a debug message:
"? WeavingClassFileProvider.acceptResult() test.Main-&gt;test.Main$AjcClosure1"

 &gt; java -javaagent:%ASPECTJ_LIB_HOME%\aspectjweaver.jar test.Main 
? WeavingClassFileProvider.acceptResult() test.Main-&gt;test.Main$AjcClosure1
Method Main.foo() took longer than expected
        Max expected = 1000, actual = 65371</description><comments/></buginformation><fixedCommits><commit id="99d1c184fdbaafc772ae290d7af3b3430e33d33b" author="default" date="2006-06-27 18:28:17"><file name="weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java"><method name="acceptResult" returnType="void" parameters="UnwovenClassFile"/></file></commit></fixedCommits></bug><bug id="330" opendate="2006-06-27 19:29:00" fixdate="2006-06-28 07:32:35"><buginformation><summary>NPR compiling Spring</summary><description>The Spring 2.0 RC1 project contains two directories with aspects. Since the eclipse project does not compile cleanly with just the java nature, I decided to try adding the aspectj nature and giving the aspectj builder a shot. 

I don't have any idea what might be the trigger to the problem, but simply checking out Spring 2.0 RC1 and adding the aspectj nature should be able to reproduce. If I learn more I will add to this bug.

----

java.lang.NullPointerException
at org.aspectj.org.eclipse.jdt.internal.compiler.ast.SingleTypeReference.getTypeBinding(SingleTypeReference.java:39)
at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveType(TypeReference.java:132)
at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveType(TypeReference.java:123)
at org.aspectj.ajdt.internal.core.builder.AsmElementFormatter.setParameters(AsmElementFormatter.java:311)
at org.aspectj.ajdt.internal.core.builder.AsmElementFormatter.genLabelAndKind(AsmElementFormatter.java:258)
at org.aspectj.ajdt.internal.core.builder.AsmHierarchyBuilder.visit(AsmHierarchyBuilder.java:392)
at org.aspectj.org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.traverse(MethodDeclaration.java:185)
at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.traverse(TypeDeclaration.java:1250)
at org.aspectj.org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.traverse(QualifiedAllocationExpression.java:392)
at org.aspectj.org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.traverse(LocalDeclaration.java:242)
at org.aspectj.org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.traverse(MethodDeclaration.java:212)
at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.traverse(TypeDeclaration.java:1195)
at org.aspectj.org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.traverse(CompilationUnitDeclaration.java:339)
at org.aspectj.ajdt.internal.core.builder.AsmHierarchyBuilder.internalBuild(AsmHierarchyBuilder.java:145)
at org.aspectj.ajdt.internal.core.builder.AsmHierarchyBuilder.buildStructureForCompilationUnit(AsmHierarchyBuilder.java:87)
at org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.finishedCompilationUnit(EclipseFactory.java:941)
at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterProcessing(AjCompilerAdapter.java:210)
at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$after$org_aspectj_ajdt_internal_compiler_CompilerAdapter$4$6b855184(CompilerAdapter.aj:91)
at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:533)
at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:329)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:887)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:244)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:163)
at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:122)
at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)

NullPointerException thrown: null</description><comments/></buginformation><fixedCommits><commit id="b59b036af89c28616efeda9b4cef1043c34337d6" author="default" date="2006-06-28 07:32:35"><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmElementFormatter.java"><method name="setParameters" returnType="void" parameters="AbstractMethodDeclaration IProgramElement"/></file></commit></fixedCommits></bug><bug id="331" opendate="2006-06-26 16:46:00" fixdate="2006-06-28 09:16:01"><buginformation><summary>Can't call synthetic aspectOf method on aspect in library jar</summary><description>Separate compilation of the following program breaks on 1.5.2rc1 because of the recent change to marking aspect methods as synthetic:

public aspect Asp {
}

public class Client {
    public static void main(String argz[]) {
        System.out.println("Can call aspectOf? "+Asp.aspectOf());
    }
}

C:\devel\scratch\synthetic&gt;ajc -classpath asp.jar;%CLASSPATH% Client.java
C:\devel\scratch\synthetic\Client.java:3 [error] The method aspectOf() is undefi
ned for the type Asp
System.out.println("Can call aspectOf? "+Asp.aspectOf());


1 error

C:\devel\scratch\synthetic&gt;javac -classpath asp.jar;%CLASSPATH% Client.java
Client.java:3: cannot find symbol
symbol  : method aspectOf()
location: class Asp
        System.out.println("Can call aspectOf? "+Asp.aspectOf());
                                                    ^
1 error

Clearly it's vital that external users of a library be able to call API methods like aspectOf on library aspects.

This works:

C:\devel\scratch\synthetic&gt;ajc *.aj Client.java

C:\devel\scratch\synthetic&gt;java Client
Can call aspectOf? Asp@b89838

Patch with test integrated into CVS tree to follow...</description><comments/></buginformation><fixedCommits><commit id="21e06a69892469bab688d2315e7e034047431082" author="default" date="2006-06-28 09:16:01"><file name="tests/src/org/aspectj/systemtest/ajc152/Ajc152Tests.java"><method name="testIncorrectOverridesEvaluation13" returnType="void" parameters=""/></file><file name="weaver/src/org/aspectj/weaver/NameMangler.java"><method name="isSyntheticMethod" returnType="boolean" parameters="String"/></file></commit></fixedCommits></bug><bug id="332" opendate="2006-06-28 07:24:00" fixdate="2006-06-28 11:44:10"><buginformation><summary>problems with binary weaving declare parents in mixed environment.</summary><description>These have been reported to me on a large system doing some intricate weaving where some classes are 1.2, some 1.4, some 1.5 and the VM is 1.5.  Binary weaving declare parents sometimes refuses to allow the modification of the hierarchy because it sees a clash between two methods when there is none.  The two cases I'm fixing are:
  1. sometimes the signatures of the return types differ with the '.' or '/' problem (fix == be consistent)
  2. sometimes the syntheticness of the methods in the relationship isn't determined correctly</description><comments/></buginformation><fixedCommits><commit id="2f2f5683643a0f1e0856ac43fa590c4b39f1be26" author="default" date="2006-06-28 11:44:10"><file name="tests/src/org/aspectj/systemtest/ajc152/Ajc152Tests.java"><method name="testFreakyNewArrayJoinpoint_pr148786" returnType="void" parameters=""/><method name="testIncorrectOverridesEvaluation13" returnType="void" parameters=""/><method name="testItdOnInnerTypeOfGenericType_pr132349_3" returnType="void" parameters=""/><method name="testLTWGeneratedAspectAbstractMethod_pr125480_2" returnType="void" parameters=""/></file><file name="weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java"><method name="enforceDecpRule4_compatibleReturnTypes" returnType="boolean" parameters="BcelClassWeaver"/><method name="mungeNewParent" returnType="boolean" parameters="BcelClassWeaver"/></file></commit></fixedCommits></bug><bug id="333" opendate="2006-06-26 20:09:00" fixdate="2006-07-03 13:49:07"><buginformation><summary>IllegalStateException for non-generic type</summary><description>I believe this is similar to 112880.  The message and stack trace I am getting are

 -- (IllegalStateException) Can't ask to parameterize a member of non-generic type: com...object  kind(raw)
Can't ask to parameterize a member of non-generic type: com...object  kind(raw)
java.lang.IllegalStateException: Can't ask to parameterize a member of non-generic type: com....object  kind(raw)
	at org.aspectj.weaver.ResolvedMemberImpl.parameterizedWith(ResolvedMemberImpl.java:612)
	at org.aspectj.weaver.ResolvedMemberImpl.parameterizedWith(ResolvedMemberImpl.java:597)
	at org.aspectj.weaver.ReferenceType.getDeclaredMethods(ReferenceType.java:508)
	at org.aspectj.weaver.ResolvedType$4.get(ResolvedType.java:225)
	at org.aspectj.weaver.Iterators$3$1.hasNext(Iterators.java:118)
	at org.aspectj.weaver.Iterators$5.hasNext(Iterators.java:171)
	at org.aspectj.weaver.Iterators$3.hasNext(Iterators.java:128)
	at org.aspectj.weaver.ResolvedType.lookupMember(ResolvedType.java:345)
	at org.aspectj.weaver.ResolvedType.lookupMethod(ResolvedType.java:326)
.
.
.

The same code was able to be weaved under 1.5.0.  The reason why this is a major issue is 1.5.0 suffers from a StackOverflowException.</description><comments/></buginformation><fixedCommits><commit id="f6834c7692082a20e94f7d88841e6c7c3f96c26a" author="default" date="2006-07-03 13:49:07"><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java"><method name="parseOption" returnType="void" parameters="String LinkedList"/></file></commit></fixedCommits></bug><bug id="334" opendate="2006-06-26 13:29:00" fixdate="2006-07-05 08:22:55"><buginformation><summary>woven class does not pass org.apache.bcel.verifier.statics.Pass2Verifier</summary><description>Number of LocalVariableTable attributes of Code attribute '&lt;CODE&gt;' (method 'public static mypackage.MyAspect aspectOf() [(Unknown attribute org.aspectj.weaver.AjSynthetic)]') exceeds number of local variable slots '0' ('There may be no more than one LocalVariableTable attribute per local variable in the Code attribute.').'.

=================================================
package mypackage; 

public aspect MyAspect { 

    pointcut executeMethod(): within(TestClass) &amp;&amp; execution(* *(..)); 

    before(): executeMethod() { 
     System.out.println("Enter "+thisJoinPointStaticPart); 
    } 
    after(): executeMethod() { 
     System.out.println("Leave "+thisJoinPointStaticPart); 
    } 
} 

class TestClass { 

public static void main(String[] args) { 
} 

} 

================================================
JustIce by Enver Haase, (C) 2001-2002. 
&lt; http://bcel.sourceforge.net &gt; 
&lt; http://jakarta.apache.org/bcel &gt; 

Now verifying: mypackage.TestClass 

Pass 1: 
VERIFIED_OK 
Passed verification. 

Pass 2: 
VERIFIED_OK 
Passed verification. 

Pass 3a, method number 0 ['public void &lt;init&gt;()']: 
VERIFIED_OK 
Passed verification. 

Pass 3b, method number 0 ['public void &lt;init&gt;()']: 
VERIFIED_OK 
Passed verification. 

Pass 3a, method number 1 ['public static void main(String[] args) [(Unknown 
attribute org.aspectj.weaver.MethodDeclarationLineNumber: 
00 00 00 05 00 00 00 46)]']: 
VERIFIED_REJECTED 
Instruction invokestatic[184](3) 28 constraint violated: Return type 
class/interface could not be verified successfully: 'Number of 
LocalVariableTable attributes of Code attribute '&lt;CODE&gt;' (method 'public 
static mypackage.MyAspect aspectOf() [(Unknown attribute 
org.aspectj.weaver.AjSynthetic)]') exceeds number of local variable slots 
'0' ('There may be no more than one LocalVariableTable attribute per local 
variable in the Code attribute.').'. 

Pass 3b, method number 1 ['public static void main(String[] args) [(Unknown 
attribute org.aspectj.weaver.MethodDeclarationLineNumber: 
00 00 00 05 00 00 00 46)]']: 
VERIFIED_NOTYET 
Not yet verified. 

Pass 3a, method number 2 ['static void &lt;clinit&gt;()']: 
VERIFIED_OK 
Passed verification. 

Pass 3b, method number 2 ['static void &lt;clinit&gt;()']: 
VERIFIED_OK 
Passed verification. 

Warnings: 
Pass 2: Attribute '(Unknown attribute 
org.aspectj.weaver.WeaverVersion: 00 03 00 00 00 00 00 00 
00 00... (truncated))' as an attribute of the ClassFile structure 'public 
class mypackage.TestClass extends java.lang.Object 
filename  mypackage.TestClass 
compiled from  TestClass.java 
compiler version 46.0 
access flags  33 
constant pool  69 entries 
ACC_SUPER flag  true 

Attribute(s): 
SourceFile(TestClass.java) 
(Unknown attribute org.aspectj.weaver.WeaverVersion: 00 03 
00 00 00 00 00 00 00 00... (truncated)) 
(Unknown attribute org.aspectj.weaver.WeaverState: 53 00 00 00 01 00 12 6d 
79 70... (truncated)) 

1 fields: 
private static final org.aspectj.lang.JoinPoint$StaticPart 
ajc$tjp_0 

3 methods: 
public void &lt;init&gt;() 
public static void main(String[] args) [(Unknown attribute 
org.aspectj.weaver.MethodDeclarationLineNumber: 00 00 00 05 
00 00 00 46)] 
static void &lt;clinit&gt;() 
' is unknown and will therefore be ignored. 
Pass 2: Attribute '(Unknown attribute org.aspectj.weaver.WeaverState: 53 00 
00 00 01 00 12 6d 79 70... (truncated))' as an attribute of the ClassFile 
structure 'public class mypackage.TestClass extends java.lang.Object 
filename  mypackage.TestClass 
compiled from  TestClass.java 
compiler version 46.0 
access flags  33 
constant pool  69 entries 
ACC_SUPER flag  true 

Attribute(s): 
SourceFile(TestClass.java) 
(Unknown attribute org.aspectj.weaver.WeaverVersion: 00 03 
00 00 00 00 00 00 00 00... (truncated)) 
(Unknown attribute org.aspectj.weaver.WeaverState: 53 00 00 00 01 00 12 6d 
79 70... (truncated)) 

1 fields: 
private static final org.aspectj.lang.JoinPoint$StaticPart 
ajc$tjp_0 

3 methods: 
public void &lt;init&gt;() 
public static void main(String[] args) [(Unknown attribute 
org.aspectj.weaver.MethodDeclarationLineNumber: 00 00 00 05 
00 00 00 46)] 
static void &lt;clinit&gt;() 
' is unknown and will therefore be ignored. 
Pass 2: Attribute '&lt;LocalVariableTable: LocalVariable(start_pc = 0, length = 
5, index = 0:mypackage.TestClass this)&gt;' as an attribute of Code attribute 
'&lt;CODE&gt;' (method 'public void &lt;init&gt;()') will effectively be ignored and is 
only useful for debuggers and such. 
Pass 2: Attribute '&lt;LineNumberTable: LineNumber(0, 3)&gt;' as an attribute of 
Code attribute '&lt;CODE&gt;' (method 'public void &lt;init&gt;()') will effectively be 
ignored and is only useful for debuggers and such. 
Pass 2: Attribute '(Unknown attribute 
org.aspectj.weaver.MethodDeclarationLineNumber: 00 00 00 05 
00 00 00 46)' as an attribute of Method 'public static void main(String[] 
args) [(Unknown attribute 
org.aspectj.weaver.MethodDeclarationLineNumber: 00 00 00 05 
00 00 00 46)]' is unknown and will therefore be ignored. 
Pass 2: Attribute '(Unknown attribute 
org.aspectj.weaver.MethodDeclarationLineNumber: 00 00 00 05 
00 00 00 46)' as an attribute of Method 'public static void main(String[] 
args) [(Unknown attribute 
org.aspectj.weaver.MethodDeclarationLineNumber: 00 00 00 05 
00 00 00 46)]' is neither Code nor Exceptions and is therefore only of use 
for debuggers and such. 
Pass 2: Unknown attribute '(Unknown attribute 
org.aspectj.weaver.MethodDeclarationLineNumber: 00 00 00 05 
00 00 00 46)'. This attribute is not known in any context! 
Pass 2: Attribute '&lt;LocalVariableTable: LocalVariable(start_pc = 9, length = 
0, index = 0:String[] args)&gt;' as an attribute of Code attribute '&lt;CODE&gt;' 
(method 'public static void main(String[] args) [(Unknown attribute 
org.aspectj.weaver.MethodDeclarationLineNumber: 00 00 00 05 
00 00 00 46)]') will effectively be ignored and is only useful for debuggers 
and such. 
Pass 2: Attribute '&lt;LineNumberTable: LineNumber(9, 6)&gt;' as an attribute of 
Code attribute '&lt;CODE&gt;' (method 'public static void main(String[] args) 
[(Unknown attribute 
org.aspectj.weaver.MethodDeclarationLineNumber: 00 00 00 05 
00 00 00 46)]') will effectively be ignored and is only useful for debuggers 
and such. 
Pass 2: Class or interface initialization method 'static void &lt;clinit&gt;()' 
has superfluous access modifier(s) set: everything but ACC_STRICT is 
ignored. 
Pass 2: Attribute '&lt;LineNumberTable: LineNumber(0, 1)&gt;' as an attribute of 
Code attribute '&lt;CODE&gt;' (method 'static void &lt;clinit&gt;()') will effectively 
be ignored and is only useful for debuggers and such. 
Pass 2: Unknown attribute '(Unknown attribute 
org.aspectj.weaver.WeaverVersion: 00 03 00 00 00 00 00 00 
00 00... (truncated))'. This attribute is not known in any context! 
Pass 2: Unknown attribute '(Unknown attribute 
org.aspectj.weaver.WeaverState: 53 00 00 00 01 00 12 6d 79 70... 
(truncated))'. This attribute is not known in any context!</description><comments/></buginformation><fixedCommits><commit id="82f217fa97084beaa1c4c88ec2e96e4cf83e8aad" author="default" date="2006-07-05 08:22:55"><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectDeclaration.java"><method name="generateMethod" returnType="void" parameters="ClassFile MethodBinding"/></file><file name="tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java"><method name="createRepos" returnType="SyntheticRepository" parameters="String"/><method name="getClassFrom" returnType="JavaClass" parameters="String String"/><method name="verifyClass" returnType="void" parameters="String"/></file></commit></fixedCommits></bug><bug id="335" opendate="2006-06-23 12:29:00" fixdate="2006-07-06 12:12:07"><buginformation><summary>[generics] ClassCastException in UnresolvedType.java:348</summary><description>I am using AspectJ load time weaving with Spring 2.0 RC1 to inject my entities, and I am getting the following exception:

java.lang.ClassCastException: org.aspectj.apache.bcel.classfile.Signature$TypeVariableSignature
	at org.aspectj.weaver.UnresolvedType.forGenericTypeSignature(UnresolvedType.java:348)
	at org.aspectj.weaver.bcel.BcelWorld.addSourceObjectType(BcelWorld.java:385)
	at org.aspectj.weaver.loadtime.ClassLoaderWeavingAdaptor.accept(ClassLoaderWeavingAdaptor.java:492)
	at org.aspectj.weaver.tools.WeavingAdaptor.shouldWeave(WeavingAdaptor.java:230)
	at org.aspectj.weaver.tools.WeavingAdaptor.weaveClass(WeavingAdaptor.java:210)
	at org.aspectj.weaver.loadtime.Aj.preProcess(Aj.java:65)
	at org.aspectj.weaver.loadtime.ClassPreProcessorAgentAdapter.transform(ClassPreProcessorAgentAdapter.java:55)
	at sun.instrument.TransformerManager.transform(TransformerManager.java:122)
	at sun.instrument.InstrumentationImpl.transform(InstrumentationImpl.java:155)
	at java.lang.ClassLoader.defineClass1(Native Method)

.
.
.

Having examined the call stack under the debugger, this seems to happening when the weaver is attempting to determine whether a particular class should be weaved. The exception is thrown in the following method, at the cast highlighted below.


    public static UnresolvedType forGenericTypeSignature(String sig,String declaredGenericSig) {
    	UnresolvedType ret = UnresolvedType.forSignature(sig);
    	ret.typeKind=TypeKind.GENERIC;
    	
    	ClassSignature csig = new GenericSignatureParser().parseAsClassSignature(declaredGenericSig);
    	
    	Signature.FormalTypeParameter[] ftps = csig.formalTypeParameters;
    	ret.typeVariables = new TypeVariable[ftps.length];
    	for (int i = 0; i &lt; ftps.length; i++) {
			Signature.FormalTypeParameter parameter = ftps[i];
			Signature.ClassTypeSignature cts = (Signature.ClassTypeSignature)parameter.classBound; // EXCEPTION HERE!
			ret.typeVariables[i]=new TypeVariable(ftps[i].identifier,UnresolvedType.forSignature(cts.outerType.identifier+";"));
		}
    	ret.signatureErasure = sig;
    	ret.signature = ret.signatureErasure;
    	return ret;
    }


The class in question (which is not one that requires weaving), has the following signature:

public class HibernateEntityDAO&lt;interfaceT extends SecurityEntity, concreteT extends interfaceT&gt; extends HibernateDaoSupport
        implements EntityDAO&lt;interfaceT&gt;
 
The exception is happening because the parameter.classBound member is not of type Signature.ClassTypeSignature, but an instance of Signature.TypeVariableSignature.

The loop variable i is 1, and parameter.identifier is 鈥渃oncreteT鈥, so it looks like it's the signature of the second type parameter (concreteT) that is tripping up the weaver.</description><comments/></buginformation><fixedCommits><commit id="369de870280d4ae4f1e984a7bd8a76affb4ed0a2" author="default" date="2006-07-06 12:12:07"><file name="tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java"><method name="testCpathNoTypeCflowField_pr145693_3" returnType="void" parameters=""/></file><file name="weaver/src/org/aspectj/weaver/UnresolvedType.java"><method name="forGenericTypeSignature" returnType="UnresolvedType" parameters="String"/></file></commit></fixedCommits></bug><bug id="336" opendate="2006-07-14 12:19:00" fixdate="2006-07-25 07:46:13"><buginformation><summary>declare error on set of volatile field does not work</summary><description>When an aspect has a declare error statement involving a pointcut that captures the setting of a volatile field, a compilation error is not produced.  

This bug can be reproduced as follows.  Consider the following class:

class A {
   private volatile int state;

   public void foo() {
      state = 0;
   }
}

Now consider this aspect:

aspect FSM {
   declare error: set(* A.state): "Changing state";
}

The setting of the state field in method foo() does not result in a compilation error as expected.  

I originally noticed this bug when using AJDT 1.4 with Eclipse 3.2.  However this has been reproduced and confirmed with the aspectj 1.5.2 compiler.</description><comments/></buginformation><fixedCommits><commit id="357bbe9eeb34748f7c8c2ff85049230db2adbbf2" author="default" date="2006-07-25 07:46:13"><file name="weaver/src/org/aspectj/weaver/ResolvedMemberImpl.java"><method name="isBridgeMethod" returnType="boolean" parameters=""/></file></commit></fixedCommits></bug><bug id="337" opendate="2006-07-20 02:50:00" fixdate="2006-07-27 09:25:50"><buginformation><summary>NPE in BcelWeaver using LTW</summary><description>Hi,

I created a logging aspect for our application some time ago using 1.5.0 of AspectJ. I enabled this from time to time using Load Time Weaving.

I have recently recompiled the aspect using 1.5.2 and tried to run it also using the 1.5.2 weaver jar, but it fails with a NullPointerException.

This is part of one of the many stacktraces:

20 jul 2006 07:42:49,046 - java.lang.NullPointerException
20 jul 2006 07:42:49,062 - 	at org.aspectj.weaver.bcel.BcelWeaver.weaveParentTypeMungers(BcelWeaver.java:1367)
20 jul 2006 07:42:49,062 - 	at org.aspectj.weaver.bcel.BcelWeaver.weaveParentsFor(BcelWeaver.java:1237)
20 jul 2006 07:42:49,062 - 	at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1072)
20 jul 2006 07:42:49,062 - 	at org.aspectj.weaver.tools.WeavingAdaptor.getWovenBytes(WeavingAdaptor.java:284)
20 jul 2006 07:42:49,062 - 	at org.aspectj.weaver.tools.WeavingAdaptor.weaveClass(WeavingAdaptor.java:212)
20 jul 2006 07:42:49,062 - 	at org.aspectj.weaver.loadtime.Aj.preProcess(Aj.java:65)
20 jul 2006 07:42:49,062 - 	at org.aspectj.weaver.loadtime.ClassPreProcessorAgentAdapter.transform(ClassPreProcessorAgentAdapter.java:55)
20 jul 2006 07:42:49,062 - 	at sun.instrument.TransformerManager.transform(Unknown Source)
20 jul 2006 07:42:49,062 - 	at sun.instrument.InstrumentationImpl.transform(Unknown Source)
20 jul 2006 07:42:49,062 - 	at java.lang.ClassLoader.defineClass1(Native Method)
20 jul 2006 07:42:49,062 - 	at java.lang.ClassLoader.defineClass(Unknown Source)

I then tried with the 1.5.0 weaver jar (although the aspect was compiled using 1.5.2) and this ran without problems.</description><comments/></buginformation><fixedCommits><commit id="397a19d441eaf7fdc67e841232b410358b48ba11" author="default" date="2006-07-27 09:25:50"><file name="loadtime/src/org/aspectj/weaver/loadtime/Aj.java"><method name="initialize" returnType="void" parameters=""/></file></commit></fixedCommits></bug><bug id="338" opendate="2006-07-26 09:44:00" fixdate="2006-07-27 09:27:55"><buginformation><summary>NPE while building</summary><description>Building of a large project fails while weaving. 
NPE in EclipseSourceContext.removeUnnecessaryProblems(..)

The project was just migrated to Eclipse 3.2
Eclipse newly installed with Eclipse SDK and via Update manager with
AJDT, CDT, Web/J2EE tools, SubClipse, SpringIDE.

Same Project workes in Eclipse 3.1.
Simple Test AspectJ-Project workes OK
Building with Ant/AspectJ compiler (as external Tools Launch in Eclipse)
works.

I tried the following, but got the error anyway:
 - Checked out as a new AspectJ Project
 - upgraded to the developement Version of AJDT</description><comments/></buginformation><fixedCommits><commit id="54f7bb4f25792e717eadf21421c81ae1dc8e0718" author="default" date="2006-07-27 09:27:55"><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/EclipseSourceContext.java"><method name="removeUnnecessaryProblems" returnType="void" parameters="Member int"/></file></commit></fixedCommits></bug><bug id="339" opendate="2006-07-25 05:45:00" fixdate="2006-07-27 09:57:26"><buginformation><summary>Incorrect weaving of after returning when 'input' bytecode is of a strange form</summary><description>We have had a user report a problem where after advice being woven into a particular method is producing code that does not verify.  The problem occurs if the bytecode being input to the weaving process includes a subroutine that contains the return from the method.

Here is the problematic snippet produced by some unknown compiler:
   200:	invokespecial	#17; //Method com/MyException."&lt;init&gt;":(Ljava/lang/String;)V
   203:	athrow
   204:	aload_3
   205:	astore	6
   207:	jsr	234
   210:	aload	6
   212:	areturn
   213:	astore	4
   215:	aload	4
   217:	invokevirtual	#79; //Method java/lang/Throwable.printStackTrace:()V
   220:	jsr	234
   223:	goto	238
   226:	astore	7
   228:	jsr	234
   231:	aload	7
   233:	athrow
   234:	astore	8
   236:	aload_3
   237:	areturn
   238:	return
  Exception table:
   from   to  target type
     2   213   213   Class javax/ejb/FinderException

     2   226   226   any

see the jsr's jump to 234, but before the subroutine return at 238 there is an areturn out of the method (this method returns a String).

After weaving we get something like this:

   200:	invokespecial	#17; //Method com/MyException."&lt;init&gt;":(Ljava/lang/String;)V
   203:	athrow
   204:	aload_3
   205:	astore	6
   207:	jsr	238
   210:	aload	6
   212:	astore	9
   214:	goto	248
   217:	astore	4
   219:	aload	4
   221:	invokevirtual	#79; //Method java/lang/Throwable.printStackTrace:()V
   224:	jsr	238
   227:	goto	246
   230:	astore	7
   232:	jsr	238
   235:	aload	7
   237:	athrow
   238:	astore	8
   240:	aload_3
   241:	astore	9
   243:	goto	248
   246:	astore	9
   248:	invokestatic	#299; //Method After.aspectOf:()LAfter;
   251:	invokevirtual	#302; //Method After.ajc$afterReturning$After$1$26d6d4a7:()V
   254:	aload	9
   256:	return

see how the areturn has been lost - this code will blow up with a verify error (the string is on the stack, we just ignore it and 'return' normally)</description><comments/></buginformation><fixedCommits><commit id="e4ab0ae5762be7d9869e0eee350677ac79749150" author="default" date="2006-07-27 09:57:26"><file name="weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"><method name="generateReturnInstructions" returnType="BcelVar" parameters="List InstructionList"/><method name="findReturnInstructions" returnType="List" parameters=""/></file></commit></fixedCommits></bug><bug id="340" opendate="2006-07-27 07:15:00" fixdate="2006-07-28 13:17:57"><buginformation><summary>[3.2compiler] Generics program fails to compile</summary><description>generics problem, reported on newsgroup by Thomas Darimont

//package de.tutorials.aspectj;

public interface IMessage {
  void publish();
}


interface IErrorMessage extends IMessage{
  StackTraceElement[] getStackTrace();
}

interface IObjectFactory&lt;E&gt; {
  public &lt;T extends E&gt; T create(Class&lt;T&gt; theObjectType, Object[] theParameters);
}

class MessageFactory implements IObjectFactory&lt;IMessage&gt;{
  public &lt;T extends IMessage&gt; T create(Class&lt;T&gt; theObjectType, Object[] theParameters) {
    return null;
  }
}

class Main {
  public static void main(String[] args) {
    IErrorMessage message = new MessageFactory().create(IErrorMessage.class, new Object[]{"Foo","Bar"});
  }
}</description><comments/></buginformation><fixedCommits><commit id="68c36e3ac9b5fc031a956800158aee15b0d44301" author="default" date="2006-07-28 13:17:57"><file name="tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java"><method name="testMissingLineNumbersInStacktraceAround_pr145442" returnType="void" parameters=""/><method name="testMissingLineNumbersInStacktraceAfter_pr145442" returnType="void" parameters=""/><method name="testMissingLineNumbersInStacktraceBefore_pr145442" returnType="void" parameters=""/></file></commit></fixedCommits></bug><bug id="341" opendate="2006-07-26 19:33:00" fixdate="2006-08-01 20:41:52"><buginformation><summary>Handle Duplicate -javaagent entries more gracefully</summary><description>If you start a java 5 VM with AspectJ's load-time weaver specified more than once using the -javaagent flag, if there is an aop.xml file defined, it chokes badly: it tries to reweave the woven AspectJ code and emits massive amounts of bytecode. It would be better if AspectJ detected that it was specified more than once and gave a warning then disabled all but one of the agents. Failing that, it would be better to fail and give an error message than emit the bytecode.

This issue came up for our automated installer, which adds a -javaagent flag to VM startup commands. If the script is wrapped twice, it can generate a duplicate. We are making our scripts more intelligent to avoid this issue, but we are probably not the only people who will hit this issue (e.g., if someone manually edits both setclasspath.bat and catalina.bat to add the flag for a Tomcat instance...)</description><comments/></buginformation><fixedCommits><commit id="bebb3640698bf2c465b64d9565123ec699dac45d" author="default" date="2006-08-01 20:41:52"><file name="loadtime5/java5-src/org/aspectj/weaver/loadtime/Agent.java"><method name="premain" returnType="void" parameters="String Instrumentation"/></file></commit></fixedCommits></bug><bug id="342" opendate="2006-07-27 08:58:00" fixdate="2006-08-03 15:51:04"><buginformation><summary>Missing copyright/license in recently added modules</summary><description>BuildModuleTests does not test for licenses in ajdoc, loadtime, loadtime5, weaver5. When I added the necessary logic there were a couple of failures. Could the owners please step forward ...

epl-cpl-ibm|parc|xerox|others   LICENSE FAIL: C:\workspaces\org.aspectj-Restructure\weaver5\java5-src\org\aspectj\weaver\reflect\DeferredResolvedPointcutDefinition.java
epl-cpl-ibm|parc|xerox|others COPYRIGHT FAIL: C:\workspaces\org.aspectj-Restructure\weaver5\java5-src\org\aspectj\weaver\reflect\DeferredResolvedPointcutDefinition.java
epl-cpl-ibm|parc|xerox|others   LICENSE FAIL: C:\workspaces\org.aspectj-Restructure\weaver5\java5-src\org\aspectj\weaver\reflect\InternalUseOnlyPointcutParser.java
epl-cpl-ibm|parc|xerox|others COPYRIGHT FAIL: C:\workspaces\org.aspectj-Restructure\weaver5\java5-src\org\aspectj\weaver\reflect\InternalUseOnlyPointcutParser.java
Total passed: 7 failed: 2


I also noticed the following messages. Does anyone know what they mean?

BuildModuleTest: Define "run.build.tests" as a system property to run tests to build run-all-junit-tests (this is the only warning)
class org.aspectj.internal.build.BuildModuleTest.testNoDuplicates() incomplete
error building module weaver
	at org.aspectj.internal.tools.ant.taskdefs.BuildModule.build(BuildModule.java:145)
	at org.aspectj.internal.tools.ant.taskdefs.BuildModule.execute(BuildModule.java:117)
	at org.aspectj.internal.build.BuildModuleTest.doTask(BuildModuleTest.java:445)
	at org.aspectj.internal.build.BuildModuleTest.testNoDuplicates(BuildModuleTest.java:178)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:585)
	at junit.framework.TestCase.runTest(TestCase.java:154)
	at junit.framework.TestCase.runBare(TestCase.java:127)
	at junit.framework.TestResult$1.protect(TestResult.java:106)
	at junit.framework.TestResult.runProtected(TestResult.java:124)Module 	at junit.framework.TestResult.run(TestResult.java:109)
	at junit.framework.TestCase.run(TestCase.java:118)
	at junit.framework.TestSuite.runTest(TestSuite.java:208)
	at junit.framework.TestSuite.run(TestSuite.java:203)
	at junit.framework.TestSuite.runTest(TestSuite.java:208)
	at junit.framework.TestSuite.run(TestSuite.java:203)
	at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128)
	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196)</description><comments/></buginformation><fixedCommits><commit id="7aa6cfeed1b51b7290a059de6a2f34009274e6f0" author="default" date="2006-08-03 15:51:04"><file name="build/testsrc/org/aspectj/build/BuildModuleTests.java"><method name="testLicense_weaver" returnType="void" parameters=""/><method name="Collections.unmodifiableList" returnType="List" parameters=""/></file></commit></fixedCommits></bug><bug id="343" opendate="2006-08-02 13:26:00" fixdate="2006-08-04 10:29:04"><buginformation><summary>Problem with decp on an aspect using cflow</summary><description>This occurs in the AspectJ build in AJDT from August 1 but not from July 31:

java.lang.NullPointerException
at org.aspectj.weaver.bcel.BcelTypeMunger.enforceDecpRule1_abstractMethodsImplemented(BcelTypeMunger.java:250)
at org.aspectj.weaver.bcel.BcelTypeMunger.mungeNewParent(BcelTypeMunger.java:194)
at org.aspectj.weaver.bcel.BcelTypeMunger.munge(BcelTypeMunger.java:106)
at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:454)
at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:119)
at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1597)
at org.aspectj.weaver.bcel.BcelWeaver.weaveWithoutDump(BcelWeaver.java:1548)
at org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify(BcelWeaver.java:1328)
at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1124)
at org.aspectj.ajdt.internal.compiler.AjPipeliningCompilerAdapter.weaveQueuedEntries(AjPipeliningCompilerAdapter.java:451)
at org.aspectj.ajdt.internal.compiler.AjPipeliningCompilerAdapter.queueForWeaving(AjPipeliningCompilerAdapter.java:389)
at org.aspectj.ajdt.internal.compiler.AjPipeliningCompilerAdapter.afterProcessing(AjPipeliningCompilerAdapter.java:377)
at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$after$org_aspectj_ajdt_internal_compiler_CompilerAdapter$5$6b855184(CompilerAdapter.aj:98)
at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:533)
at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:329)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:891)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:246)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:165)
at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:122)
at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)

trouble in:public class glassbox.agent.ErrorContainmentTest$ErrorMockAspect extends java.lang.Object implements glassbox.agent.api.NotSerializable:
private static Throwable ajc$initFailureCause [Synthetic]
public static final glassbox.agent.ErrorContainmentTest$ErrorMockAspect ajc$perSingletonInstance [Synthetic]
static void &lt;clinit&gt;():
catch java.lang.Throwable -&gt; E0
|               INVOKESTATIC glassbox.agent.ErrorContainmentTest$ErrorMockAspect.ajc$postClinit ()V   (line 60)
catch java.lang.Throwable -&gt; E0
GOTO L0
E0: ASTORE_0
ALOAD_0
PUTSTATIC glassbox.agent.ErrorContainmentTest$ErrorMockAspect.ajc$initFailureCause Ljava/lang/Throwable;
L0: RETURN
end static void &lt;clinit&gt;()
void &lt;init&gt;():
ALOAD_0     // Lglassbox/agent/ErrorContainmentTest$ErrorMockAspect; this   (line 60)
INVOKESPECIAL java.lang.Object.&lt;init&gt; ()V
RETURN
end void &lt;init&gt;()
public void ajc$before$glassbox_agent_ErrorContainmentTest$ErrorMockAspect$1$9589fc()    AdviceAttribute(before, (scope() &amp;&amp; call(* hook1())), 0, 1670)
:
NEW java.lang.RuntimeException   (line 64)
DUP
LDC "rte"
INVOKESPECIAL java.lang.RuntimeException.&lt;init&gt; (Ljava/lang/String;)V
ATHROW
end public void ajc$before$glassbox_agent_ErrorContainmentTest$ErrorMockAspect$1$9589fc()
public void ajc$before$glassbox_agent_ErrorContainmentTest$ErrorMockAspect$2$f75db3e2()    AdviceAttribute(before, execution(* glassbox.agent.ErrorContainmentTest.hook5()), 0, 1764)
:
NEW java.lang.RuntimeException   (line 67)
DUP
LDC "rte"
INVOKESPECIAL java.lang.RuntimeException.&lt;init&gt; (Ljava/lang/String;)V
ATHROW
end public void ajc$before$glassbox_agent_ErrorContainmentTest$ErrorMockAspect$2$f75db3e2()
public void ajc$around$glassbox_agent_ErrorContainmentTest$ErrorMockAspect$3$a3a17d(org.aspectj.runtime.internal.AroundClosure)    AdviceAttribute(around, (scope() &amp;&amp; call(* hook2())), 1, 1913)
:
NEW java.lang.Error   (line 71)
DUP
LDC "foo"
INVOKESPECIAL java.lang.Error.&lt;init&gt; (Ljava/lang/String;)V
ATHROW
end public void ajc$around$glassbox_agent_ErrorContainmentTest$ErrorMockAspect$3$a3a17d(org.aspectj.runtime.internal.AroundClosure)
static void ajc$around$glassbox_agent_ErrorContainmentTest$ErrorMockAspect$3$a3a17dproceed(org.aspectj.runtime.internal.AroundClosure) throws java.lang.Throwable    org.aspectj.weaver.AjAttribute$AjSynthetic@19a01f9
:
ALOAD_0     // Lglassbox/agent/ErrorContainmentTest$ErrorMockAspect; this   (line 1)
ICONST_0
ANEWARRAY java.lang.Object
INVOKEVIRTUAL org.aspectj.runtime.internal.AroundClosure.run ([Ljava/lang/Object;)Ljava/lang/Object;
INVOKESTATIC org.aspectj.runtime.internal.Conversions.voidValue (Ljava/lang/Object;)Ljava/lang/Object;
RETURN
end static void ajc$around$glassbox_agent_ErrorContainmentTest$ErrorMockAspect$3$a3a17dproceed(org.aspectj.runtime.internal.AroundClosure) throws java.lang.Throwable
public void ajc$after$glassbox_agent_ErrorContainmentTest$ErrorMockAspect$4$bfd07f()    AdviceAttribute(after, (scope() &amp;&amp; call(* hook4())), 0, 1991)
:
NEW org.aspectj.lang.SoftException   (line 74)
DUP
ACONST_NULL
INVOKESPECIAL org.aspectj.lang.SoftException.&lt;init&gt; (Ljava/lang/Throwable;)V
ATHROW
end public void ajc$after$glassbox_agent_ErrorContainmentTest$ErrorMockAspect$4$bfd07f()
public void ajc$before$glassbox_agent_ErrorContainmentTest$ErrorMockAspect$5$e5bddfdc()    AdviceAttribute(before, logErrorInTest(), 0, 2446)
:
GETSTATIC glassbox.agent.ErrorContainmentTest.logCount I   (line 84)
ICONST_1
IADD
PUTSTATIC glassbox.agent.ErrorContainmentTest.logCount I
RETURN   (line 85)
end public void ajc$before$glassbox_agent_ErrorContainmentTest$ErrorMockAspect$5$e5bddfdc()
public void ajc$before$glassbox_agent_ErrorContainmentTest$ErrorMockAspect$6$16ecfe62()    AdviceAttribute(before, (adviceexecution(* *) &amp;&amp; (within(glassbox.util.logging.api.LogManagement) &amp;&amp; (cflow(logError()) &amp;&amp; cflow((execution(* testLoggingError(..)) &amp;&amp; within(glassbox.agent.ErrorContainmentTest)))))), 0, 2506)
:
GETSTATIC java.lang.System.err Ljava/io/PrintStream;   (line 87)
LDC "match"
INVOKEVIRTUAL java.io.PrintStream.println (Ljava/lang/String;)V
RETURN   (line 88)
end public void ajc$before$glassbox_agent_ErrorContainmentTest$ErrorMockAspect$6$16ecfe62()
public void ajc$before$glassbox_agent_ErrorContainmentTest$ErrorMockAspect$7$e9ae8482()    AdviceAttribute(before, (adviceexecution(* *) &amp;&amp; (within(glassbox.util.logging.api.LogManagement) &amp;&amp; cflow((execution(* testLoggingError(..)) &amp;&amp; within(glassbox.agent.ErrorContainmentTest))))), 0, 2721)
:
GETSTATIC java.lang.System.err Ljava/io/PrintStream;   (line 90)
LDC "match in test"
INVOKEVIRTUAL java.io.PrintStream.println (Ljava/lang/String;)V
RETURN   (line 91)
end public void ajc$before$glassbox_agent_ErrorContainmentTest$ErrorMockAspect$7$e9ae8482()
public void ajc$before$glassbox_agent_ErrorContainmentTest$ErrorMockAspect$8$c6ac5351()    AdviceAttribute(before, (adviceexecution(* *) &amp;&amp; (within(glassbox.util.logging.api.LogManagement) &amp;&amp; cflow(logError()))), 0, 2923)
:
GETSTATIC java.lang.System.err Ljava/io/PrintStream;   (line 93)
LDC "match in log"
INVOKEVIRTUAL java.io.PrintStream.println (Ljava/lang/String;)V
RETURN   (line 94)
end public void ajc$before$glassbox_agent_ErrorContainmentTest$ErrorMockAspect$8$c6ac5351()
public void ajc$before$glassbox_agent_ErrorContainmentTest$ErrorMockAspect$9$16ecfe62()    AdviceAttribute(before, (adviceexecution(* *) &amp;&amp; (within(glassbox.util.logging.api.LogManagement) &amp;&amp; (cflow(logError()) &amp;&amp; cflow((execution(* testLoggingError(..)) &amp;&amp; within(glassbox.agent.ErrorContainmentTest)))))), 0, 3069)
:
GETSTATIC glassbox.agent.ErrorContainmentTest.recursiveThrows I   (line 96)
ICONST_1
IADD
PUTSTATIC glassbox.agent.ErrorContainmentTest.recursiveThrows I
GETSTATIC glassbox.agent.ErrorContainmentTest.recursiveThrows I   (line 97)
ICONST_2
IF_ICMPGE L0
NEW java.lang.RuntimeException   (line 98)
DUP
LDC "recursive logging failure"
INVOKESPECIAL java.lang.RuntimeException.&lt;init&gt; (Ljava/lang/String;)V
ATHROW
L0: RETURN   (line 100)
end public void ajc$before$glassbox_agent_ErrorContainmentTest$ErrorMockAspect$9$16ecfe62()
public static glassbox.agent.ErrorContainmentTest$ErrorMockAspect aspectOf()    org.aspectj.weaver.AjAttribute$AjSynthetic@3cd8fe
:
GETSTATIC glassbox.agent.ErrorContainmentTest$ErrorMockAspect.ajc$perSingletonInstance Lglassbox/agent/ErrorContainmentTest$ErrorMockAspect;   (line 1)
IFNONNULL L0
NEW org.aspectj.lang.NoAspectBoundException
DUP
LDC "glassbox_agent_ErrorContainmentTest$ErrorMockAspect"
GETSTATIC glassbox.agent.ErrorContainmentTest$ErrorMockAspect.ajc$initFailureCause Ljava/lang/Throwable;
INVOKESPECIAL org.aspectj.lang.NoAspectBoundException.&lt;init&gt; (Ljava/lang/String;Ljava/lang/Throwable;)V
ATHROW
L0: GETSTATIC glassbox.agent.ErrorContainmentTest$ErrorMockAspect.ajc$perSingletonInstance Lglassbox/agent/ErrorContainmentTest$ErrorMockAspect;
ARETURN
end public static glassbox.agent.ErrorContainmentTest$ErrorMockAspect aspectOf()
public static boolean hasAspect()    org.aspectj.weaver.AjAttribute$AjSynthetic@1bd4f6
:
GETSTATIC glassbox.agent.ErrorContainmentTest$ErrorMockAspect.ajc$perSingletonInstance Lglassbox/agent/ErrorContainmentTest$ErrorMockAspect;   (line 1)
IFNULL L0
ICONST_1
IRETURN
L0: ICONST_0
IRETURN
end public static boolean hasAspect()
private static void ajc$postClinit()    org.aspectj.weaver.AjAttribute$AjSynthetic@1febf91
:
NEW glassbox.agent.ErrorContainmentTest$ErrorMockAspect   (line 1)
DUP
INVOKESPECIAL glassbox.agent.ErrorContainmentTest$ErrorMockAspect.&lt;init&gt; ()V
PUTSTATIC glassbox.agent.ErrorContainmentTest$ErrorMockAspect.ajc$perSingletonInstance Lglassbox/agent/ErrorContainmentTest$ErrorMockAspect;
RETURN
end private static void ajc$postClinit()
end public class glassbox.agent.ErrorContainmentTest$ErrorMockAspect
when type munging with (BcelTypeMunger ResolvedTypeMunger(Parent, null))
when weaving aspects
when weaving
when batch building BuildConfig[C:\devel\glassbox\.metadata\.plugins\org.eclipse.ajdt.core\glassboxMonitor.generated.lst] #Files=107

The source is:

public class ErrorContainmentTest extends TestCase {
...
	static aspect ErrorMockAspect implements NotSerializable {
...

I will try to narrow this down if the problem isn't obvious.</description><comments/></buginformation><fixedCommits><commit id="ff2377a7f3b3d2148d107a7c411cf8308d254136" author="default" date="2006-08-04 10:29:04"><file name="weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java"><method name="enforceDecpRule1_abstractMethodsImplemented" returnType="boolean" parameters=""/></file></commit></fixedCommits></bug><bug id="344" opendate="2006-08-04 06:00:00" fixdate="2006-08-04 11:02:38"><buginformation><summary>ArrayIndexOutOfBoundsException in EclipseAdapterUtils.makeLocationContext</summary><description>Got the following exception during startup of Eclipse

java.lang.ArrayIndexOutOfBoundsException
at org.aspectj.ajdt.internal.core.builder.EclipseAdapterUtils.makeLocationContext(EclipseAdapterUtils.java:65)
at org.aspectj.ajdt.internal.core.builder.EclipseAdapterUtils.makeSourceLocation(EclipseAdapterUtils.java:121)
at org.aspectj.ajdt.internal.core.builder.EclipseAdapterUtils.makeMessage(EclipseAdapterUtils.java:130)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager$4.acceptResult(AjBuildManager.java:959)
at org.aspectj.ajdt.internal.compiler.AjPipeliningCompilerAdapter.acceptResult(AjPipeliningCompilerAdapter.java:402)
at org.aspectj.ajdt.internal.compiler.AjPipeliningCompilerAdapter.afterProcessing(AjPipeliningCompilerAdapter.java:375)
at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$after$org_aspectj_ajdt_internal_compiler_CompilerAdapter$5$6b855184(CompilerAdapter.aj:98)
at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:533)
at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:329)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:891)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:246)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:165)
at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:122)
at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)

ArrayIndexOutOfBoundsException thrown: -2</description><comments/></buginformation><fixedCommits><commit id="908b4054bff043f50d8bcf12afb6801e0d2913d4" author="default" date="2006-08-04 11:02:38"><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/EclipseAdapterUtils.java"><method name="makeLocationContext" returnType="String" parameters="ICompilationUnit"/></file></commit></fixedCommits></bug><bug id="345" opendate="2006-08-04 15:21:00" fixdate="2006-08-08 07:59:54"><buginformation><summary>Optimize shouldWeaveAnnotationStyleAspect with Patch</summary><description>The current implementation of shouldWeaveAnnotationStyleAspect is surprising because it weaves annotation aspects without regard as to whether they are registered in an aop.xml file. If an annotation-style aspect is loaded, it is always woven, even if it doesn't match the for what classes should be woven in the aop.xml file, and even if not registered therein. This is both unexpected and it imposes significant overhead on configurations where they aren't used and simple fast match exclusions prevent weaving (see  bug #152871 ).

Is there really a need to weave annotation style aspects like this? Why can't it be done by using the aop.xml configuration mechanism that all other aspects use? In a large system, the CPU overhead of parsing and creating BCEL objects for all loaded classes should be avoided where possible.</description><comments/></buginformation><fixedCommits><commit id="f239f2a2ac6a887fd46e6d95e8fb4ec93e2e159d" author="default" date="2006-08-08 07:59:54"><file name="weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java"><method name="shouldWeaveAnnotationStyleAspect" returnType="boolean" parameters="String byte[]"/><method name="addURL" returnType="void" parameters="URL"/><method name="shouldWeave" returnType="boolean" parameters="String byte[]"/></file></commit></fixedCommits></bug><bug id="346" opendate="2006-08-07 11:04:00" fixdate="2006-08-08 11:26:28"><buginformation><summary>Optimization: Reference Use and URL Caching in ClassLoader Repository</summary><description>I have found that a lot of memory can get pinned by the BCEL ClassLoaderRepository. For example, on a test configuration of Glassbox with WebLogic over 40 megabytes were pinned in memory due to this loader. (*)

I also notice that some of the time spent with loading and parsing redundant classes for shared weaving configuration could be reduced by having a global cache of bytes for URL's instead, i.e., the ClassLoaderRepository is local to a loader, so even if the same class on disk is resolved multiple times in different loaders, it isn't read from cache. This latter issue will be reduced if loading types from a parent loader use reflection delegates instead but BCEL still has to be used for aspects on &lt;1.5 VM's... 

The attached patch has some metrics in it to measure what's happening and it also uses SoftReferences to cache without pinning the reference types and uses a two-step look up process to maintain a global URL cache. When I run this on WebLogic 9.2 with Glassbox and view their admin console and some smaller apps I get this output:

BCEL repository total load time: 7733 ms, in url: 6029 ms for 1427 url cache hits = 1683 missEvicted = 0 missUrlEvicted= 0 all misses = 1427, loader hits = 0

On Tomcat 5.5 with some different sample apps:
BCEL repository total load time: 4945 ms, in url: 4319 ms for 636 url cache hits = 548 missEvicted = 0 missUrlEvicted= 190 all misses= 446, loader hits = 3

So at least in my configuration the URL-based cache is quite effective (with almost a 50% hit rate) whereas the loader-based cache provides little value. From what I've seen, it's worth considering not even using the loader-based BCEL cache at all but others may have configurations where it helps.

(*) This test was on a development build of AspectJ which I had modified so that the LTWWorld evicts classes after loading</description><comments/></buginformation><fixedCommits><commit id="387c3ac6f23a39aebbc4044093c793009dfea8f6" author="default" date="2006-08-08 11:26:28"><file name="bcel-builder/src/org/aspectj/apache/bcel/util/ClassLoaderRepository.java"><method name="clear" returnType="void" parameters=""/><method name="findClass" returnType="JavaClass" parameters="String"/><method name="loadClass" returnType="JavaClass" parameters="String"/><method name="storeClass" returnType="void" parameters="JavaClass"/><method name="removeClass" returnType="void" parameters="JavaClass"/></file><file name="bcel-builder/testsrc/org/aspectj/apache/bcel/classfile/tests/AllTests.java"><method name="suite" returnType="Test" parameters=""/></file></commit></fixedCommits></bug><bug id="347" opendate="2006-07-31 18:31:00" fixdate="2006-08-08 13:48:32"><buginformation><summary>NPE in MessageUtil.addExtraSourceLocations</summary><description>I get this message from an error in a recent dev build of AspectJ with load-time weaving. I don't know how there is a null source location associated with this message, but either it shouldn't be there or MessageUtil line 806 should use this patch:

Index: src/org/aspectj/bridge/MessageUtil.java
===================================================================
RCS file: /home/technology/org.aspectj/modules/bridge/src/org/aspectj/bridge/MessageUtil.java,v
retrieving revision 1.11
diff -u -r1.11 MessageUtil.java
--- src/org/aspectj/bridge/MessageUtil.java	1 Jun 2006 09:36:37 -0000	1.11
+++ src/org/aspectj/bridge/MessageUtil.java	31 Jul 2006 22:32:16 -0000
@@ -803,7 +803,7 @@
 		writer.println(baseMessage);
 		for (Iterator iter = message.getExtraSourceLocations().iterator(); iter.hasNext();) {
 		    ISourceLocation element = (ISourceLocation) iter.next();
-		    writer.print("\tsee also: " + element.toString());
+		    writer.print("\tsee also: " + element);
 		    if (iter.hasNext()) {
 		        writer.println();
 		    }

NPE follows:

java.lang.NullPointerException
	at org.aspectj.bridge.MessageUtil.addExtraSourceLocations(MessageUtil.java:806)
	at org.aspectj.bridge.MessageUtil.renderMessage(MessageUtil.java:793)
	at org.aspectj.bridge.Message.toString(Message.java:177)
	at org.aspectj.bridge.MessageWriter.render(MessageWriter.java:73)
	at org.aspectj.weaver.tools.WeavingAdaptor$WeavingAdaptorMessageHandler.render(WeavingAdaptor.java:471)
	at org.aspectj.bridge.MessageWriter.handleMessage(MessageWriter.java:41)
	at org.aspectj.weaver.tools.WeavingAdaptor$WeavingAdaptorMessageHandler.handleMessage(WeavingAdaptor.java:425)
	at org.aspectj.weaver.bcel.BcelTypeMunger.error(BcelTypeMunger.java:378)
	at org.aspectj.weaver.bcel.BcelTypeMunger.enforceDecpRule1_abstractMethodsImplemented(BcelTypeMunger.java:273)
	at org.aspectj.weaver.bcel.BcelTypeMunger.mungeNewParent(BcelTypeMunger.java:194)
	at org.aspectj.weaver.bcel.BcelTypeMunger.munge(BcelTypeMunger.java:106)
	at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:450)
	at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:115)
	at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1613)
	at org.aspectj.weaver.bcel.BcelWeaver.weaveWithoutDump(BcelWeaver.java:1564)
	at org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify(BcelWeaver.java:1341)
	at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1163)
	at org.aspectj.weaver.tools.WeavingAdaptor.getWovenBytes(WeavingAdaptor.java:288)
	at org.aspectj.weaver.tools.WeavingAdaptor.weaveClass(WeavingAdaptor.java:214)
	at org.aspectj.weaver.loadtime.Aj.preProcess(Aj.java:76)
	at org.aspectj.ext.ltw13.ClassPreProcessorAdapter.preProcess(ClassPreProcessorAdapter.java:65)
	at org.codehaus.aspectwerkz.hook.impl.ClassPreProcessorHelper.defineClass0Pre(ClassPreProcessorHelper.java:107)
	at java.lang.ClassLoader.defineClass(ClassLoader.java:539)
...

NOTE: I'm using Alex Vasseur's adaptor to invoke AspectJ LTW from a 1.4 VM, but with recursion protection added. I don't think that should change the expected behavior of Aj.</description><comments/></buginformation><fixedCommits><commit id="a38edd39a8e998a22b41a0cf1928493aa0755e65" author="default" date="2006-08-08 13:48:32"><file name="bridge/src/org/aspectj/bridge/MessageUtil.java"><method name="addExtraSourceLocations" returnType="String" parameters=""/></file></commit></fixedCommits></bug><bug id="348" opendate="2006-07-28 11:51:00" fixdate="2006-08-08 13:50:57"><buginformation><summary>Contribution: Support -Xset in Load-Time Weaving Configuration</summary><description>I needed this to try out a setting in the pipelined compilation (-Xset:runMinimalMemory=true) ... I was able to verify that it parsed and set an option correctly in the debugger. I also have included a test that sets all the currently available options.</description><comments/></buginformation><fixedCommits><commit id="039be6888f9ec674a0bbb0f5fc37486f8565fece" author="default" date="2006-08-08 13:50:57"><file name="loadtime/src/org/aspectj/weaver/loadtime/Options.java"><method name="parse" returnType="WeaverOption" parameters="String ClassLoader"/></file><file name="loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"><method name="registerOptions" returnType="void" parameters="BcelWeaver ClassLoader"/></file></commit></fixedCommits></bug><bug id="349" opendate="2006-06-22 10:05:00" fixdate="2006-08-08 15:37:36"><buginformation><summary>Wrong warning is reported</summary><description>I used ajdt_1.3.1_for_eclipse_3.1.zip on Eclipse 3.1.2.
Below is my aspectj code.

public aspect MyMessages {
    pointcut getResourceString(String key): args(key, ..) &amp;&amp;
    call (* CommonPlugin.getResourceString(String, ..));

    String around(String key):getResourceString(key) {
    	return key;
    }
}

The warning message is
The parameter key is never read. 
See my screenshot.</description><comments/></buginformation><fixedCommits><commit id="07c2189bdb6d133886056ea1c02a302975f1e724" author="default" date="2006-08-08 15:37:36"><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/problem/AjProblemReporter.java"><method name="unusedArgument" returnType="void" parameters="LocalDeclaration"/></file></commit></fixedCommits></bug><bug id="350" opendate="2006-08-11 03:34:00" fixdate="2006-08-15 11:51:21"><buginformation><summary>Bug in reflection delegate signature for array of object type</summary><description>The following problem is interesting because the advice weaves correctly with Java 1.5 LTW and also using Java 1.4 with build-time weaving. However, the following call pointcut isn't matching the expected call site in Java 1.4 load-time weaving (*).

Pointcut:
    private pointcut inExecQuery() : 
        (within(uk.ltd.getahead.dwr.impl.ExecuteQuery) || within(uk.ltd.getahead.dwr.ExecuteQuery));
    
    public pointcut dwrQuery(Method method, Object receiver, Object[] params) : 
        inExecQuery() &amp;&amp; withincode(* execute(..)) &amp;&amp; 
        call(* Method.invoke(..)) &amp;&amp; args(receiver, params) &amp;&amp; target(method);

    protected pointcut monitorEnd() : dwrQuery(*, *, *);

Matching call site:
                Object reply = method.invoke(object, params);

I've tracked it down to failing to find the method in ResolvedType.matches. On line 405:

"m1.getSignature()"= "(Ljava/lang/Object;[Ljava.lang.Object;)Ljava/lang/Object;"	
"m2.getSignature()"= "(Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;"	

Note the difference between . and /            ^    ^

It looks to me like the signature for array types in the reflection delegate is erroneously using . instead of /. I have attached a patch to the ReflectionBasedReferenceTypeDelegateTest that isolates this unexpected signature return. Hopefully you agree that this is not correct. If not, some more information follows.

Here's the stack trace where the match fails:

ResolvedType.matches(Member, Member) line: 405	
ReferenceType(ResolvedType).lookupMember(Member, Iterator) line: 347	
ReferenceType(ResolvedType).lookupMethod(Member) line: 326	
LTWWorld(World).resolve(Member) line: 504	
MemberImpl.resolve(World) line: 93	
JoinPointSignatureIterator.addSignaturesUpToFirstDefiningMember() line: 109	
JoinPointSignatureIterator.&lt;init&gt;(Member, World) line: 51	
MemberImpl.getJoinPointSignatures(World) line: 943	
SignaturePattern.matches(Member, World, boolean) line: 286	
KindedPointcut.matchInternal(Shadow) line: 106	
KindedPointcut(Pointcut).match(Shadow) line: 146	
AndPointcut.matchInternal(Shadow) line: 53	
AndPointcut(Pointcut).match(Shadow) line: 146	
AndPointcut.matchInternal(Shadow) line: 51	
AndPointcut(Pointcut).match(Shadow) line: 146	
AndPointcut.matchInternal(Shadow) line: 51	
AndPointcut(Pointcut).match(Shadow) line: 146	
AndPointcut.matchInternal(Shadow) line: 51	
AndPointcut(Pointcut).match(Shadow) line: 146	
OrPointcut.matchInternal(Shadow) line: 50	
OrPointcut(Pointcut).match(Shadow) line: 146	
BcelAdvice(ShadowMunger).match(Shadow, World) line: 71	
BcelAdvice(Advice).match(Shadow, World) line: 112	
BcelAdvice.match(Shadow, World) line: 107	
BcelClassWeaver.match(BcelShadow, List) line: 2806	
BcelClassWeaver.matchInvokeInstruction(LazyMethodGen, InstructionHandle, InvokeInstruction, BcelShadow, List) line: 2768	
BcelClassWeaver.match(LazyMethodGen, InstructionHandle, BcelShadow, List) line: 2506	
BcelClassWeaver.match(LazyMethodGen) line: 2332	
BcelClassWeaver.weave() line: 494	
BcelClassWeaver.weave(BcelWorld, LazyClassGen, List, List, List) line: 119	
BcelWeaver.weave(UnwovenClassFile, BcelObjectType, boolean) line: 1613	
BcelWeaver.weaveWithoutDump(UnwovenClassFile, BcelObjectType) line: 1564	
BcelWeaver.weaveAndNotify(UnwovenClassFile, BcelObjectType, IWeaveRequestor) line: 1341	
BcelWeaver.weave(IClassFileProvider) line: 1163	
ClassLoaderWeavingAdaptor(WeavingAdaptor).getWovenBytes(String, byte[]) line: 319	
ClassLoaderWeavingAdaptor(WeavingAdaptor).weaveClass(String, byte[]) line: 225	
Aj.preProcess(String, byte[], ClassLoader) line: 77	
ClassPreProcessorAdapter.preProcess(String, byte[], ClassLoader) line: 67	
ClassPreProcessorHelper.defineClass0Pre(ClassLoader, String, byte[], int, int, ProtectionDomain) line: 107	
WebappClassLoader(ClassLoader).defineClass(String, byte[], int, int, ProtectionDomain) line: 539	
WebappClassLoader(SecureClassLoader).defineClass(String, byte[], int, int, CodeSource) line: 123	
WebappClassLoader.findClassInternal(String) line: 1786	
WebappClassLoader.findClass(String) line: 1048	
WebappClassLoader.loadClass(String, boolean) line: 1506	
WebappClassLoader.loadClass(String) line: 1385	
WebappClassLoader(ClassLoader).loadClassInternal(String) line: 302	
Class.forName0(String, boolean, ClassLoader) line: not available [native method]	
Class.forName(String) line: 141	
InitializeLog.setWarnLogging(String) line: 121	
InitializeLog.initializeLogging() line: 96	
ContextLoaderServlet.init() line: 13	
ContextLoaderServlet(GenericServlet).init(ServletConfig) line: 212	
StandardWrapper.loadServlet() line: 879	
StandardWrapper.load() line: 767	
StandardContext.loadOnStartup(Container[]) line: 3483	
StandardContext.start() line: 3709	
StandardHost(ContainerBase).addChildInternal(Container) line: 776	
StandardHost(ContainerBase).addChild(Container) line: 759	
StandardHost.addChild(Container) line: 537	
StandardHostDeployer.install(String, URL) line: 260	
StandardHost.install(String, URL) line: 730	
HostConfig.deployWARs(File, String[]) line: 558	
HostConfig.deployApps() line: 373	
HostConfig.start() line: 784	
HostConfig.lifecycleEvent(LifecycleEvent) line: 330	
LifecycleSupport.fireLifecycleEvent(String, Object) line: 119	
StandardHost(ContainerBase).start() line: 1155	
StandardHost.start() line: 696	
StandardEngine(ContainerBase).start() line: 1147	
StandardEngine.start() line: 310	
StandardService.start() line: 449	
StandardServer.start() line: 2212	
Catalina.start() line: 458	
Catalina.execute() line: 345	
Catalina.process(String[]) line: 129	
NativeMethodAccessorImpl.invoke0(Method, Object, Object[]) line: not available [native method]	
NativeMethodAccessorImpl.invoke(Object, Object[]) line: 39	
DelegatingMethodAccessorImpl.invoke(Object, Object[]) line: 25	
Method.invoke(Object, Object[]) line: 324	
Bootstrap.main(String[]) line: 150	

I'm using a modified version of Alex Vasseur's LTW plugin for a Java 1.4 VM although I haven't tested on the JRockIt plugin for a 1.4 VM: my guess is that this would fail there too.</description><comments/></buginformation><fixedCommits><commit id="82e3e13c66720ed17399821d478c31151b2d2234" author="default" date="2006-08-15 11:51:21"><file name="weaver/src/org/aspectj/weaver/reflect/ReflectionWorld.java"><method name="resolve" returnType="ResolvedType" parameters="World Class"/></file></commit></fixedCommits></bug><bug id="351" opendate="2006-08-18 03:49:00" fixdate="2006-08-18 08:21:58"><buginformation><summary>[annotations] Incorrect handling of java.lang annotations when matching</summary><description>As raised by Mr Bodkin on the list:
Can anyone tell me why this compiling this program produces warnings for marker but not for deprecated (in a recent dev build of AJDT)? Is this just a bug? Both have runtime retention, so I would expect equivalent behavior.

 

@Deprecated @Marker

public aspect Annot {

 

    pointcut test() : within(@Marker *);// *);

   

    declare warning: staticinitialization(@Deprecated *): "deprecated";   

    declare warning: staticinitialization(@Marker *): "marker";   

   

    public static void main(String argz[]) {

        new Baz().foo();

    }

}

 

@Deprecated @Marker

class Baz {

    public void foo() {}

}

 

@Retention(RetentionPolicy.RUNTIME)

public @interface Marker {

 

}</description><comments/></buginformation><fixedCommits><commit id="59123b0efba484e81625d403ca36768e149bd451" author="default" date="2006-08-18 08:21:58"><file name="weaver/src/org/aspectj/weaver/bcel/BcelObjectType.java"><method name="ensureAnnotationsUnpacked" returnType="void" parameters=""/></file></commit></fixedCommits></bug><bug id="352" opendate="2006-07-04 07:47:00" fixdate="2006-08-22 15:22:06"><buginformation><summary>[@AspectJ] Incorrect weaving of static initialization join point</summary><description>This error occurs if static initialization of one aspect class is woven with an advice from another aspect. It worked fine in version 1.5.0 - see the decompiled code snippet:

    static 
    {
        Object obj = new Factory("ItoMonitoringAspect.java", Class.forName("cz.kb.usermanagement.ito.ItoMonitoringAspect"));
        ajc$tjp_0 = ((Factory) (obj)).makeSJP("staticinitialization", ((Factory) (obj)).makeInitializerSig("8", "cz.kb.usermanagement.ito.ItoMonitoringAspect"), 0);
        obj = Factory.makeJP(ajc$tjp_0, null, null);
        
        
        // the static initialization of this aspect class is deliberately woven using
        // advice from another aspect defined elsewhere.
        
        try
        {
            UserManagementLogAspect.aspectOf().beforeClassInit(((org.aspectj.lang.JoinPoint) (obj)));
        }
        catch(Throwable throwable)
        {
            if(throwable instanceof ExceptionInInitializerError)
            {
                throw (ExceptionInInitializerError)throwable;
            } else
            {
                UserManagementLogAspect.aspectOf().afterClassInit();
                throw throwable;
            }
        }
        UserManagementLogAspect.aspectOf().afterClassInit();
        
        // this line below was there when compiling using AspectJ 1.5.0 
        // but is missing in when using AJC 1.5.2. (Note: the line is, however, present if the static
        // initialization of this aspect class is NOT woven by advice from the other aspect).
        ajc$postClinit();

   }


As a result of the missing call to ajc$postClinit() the aspect instance is not created and it's method .aspectOf() throws org.aspectj.lang.NoAspectBoundException.</description><comments/></buginformation><fixedCommits><commit id="945a257776a5879251ccb1b90cf24fd1d89bcfe6" author="default" date="2006-08-22 15:22:06"><file name="weaver/src/org/aspectj/weaver/patterns/PerSingleton.java"><method name="concretize" returnType="PerClause" parameters="ResolvedType"/></file><file name="tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java"><method name="testIncorrectDeprecatedAnnotationProcessing_pr154332" returnType="void" parameters=""/></file><file name="weaver/src/org/aspectj/weaver/bcel/BcelPerClauseAspectAdder.java"><method name="generatePerSingletonAjcClinitMethod" returnType="void" parameters="LazyClassGen"/></file><file name="tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java"><method name="testPr141956_IncrementallyCompilingAtAj" returnType="void" parameters=""/></file></commit></fixedCommits></bug><bug id="353" opendate="2006-07-11 11:31:00" fixdate="2006-08-23 11:52:22"><buginformation><summary>Allow multiple levels of LTW information</summary><description>It would be nice if basic information about load-time weaving (what version of AspectJ is being used, what loaders are doing weaving and what configuration is being used) was available without all of the -verbose information listing of all classes woven or not woven.

It's also unfortunate that the flags for weaving level are 2 quite different ones:
-Daj.weaving.verbose -Dorg.aspectj.weaver.showWeaveInfo

Why not something like -Dorg.aspectj.weaver.level=[none|summary|info|verbose]

summary: just what configuration is used
info: list affected join points etc. (like showWeaveInfo)
verbose: all (like verbose now)</description><comments/></buginformation><fixedCommits><commit id="8549d861b124c20eba114b658e886bfbaf5d231c" author="default" date="2006-08-23 11:52:22"><file name="tests/java5/ataspectj/ataspectj/TestHelper.java"><method name="handleMessage" returnType="boolean" parameters="IMessage"/></file><file name="loadtime/src/org/aspectj/weaver/loadtime/DefaultMessageHandler.java"><method name="isIgnoring" returnType="boolean" parameters="IMessage.Kind"/></file><file name="weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java"><method name="addURL" returnType="void" parameters="URL"/><method name="info" returnType="boolean" parameters="String"/></file><file name="loadtime/src/org/aspectj/weaver/loadtime/Options.java"><method name="parse" returnType="WeaverOption" parameters="String ClassLoader"/></file><file name="loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"><method name="defineClass" returnType="void" parameters="ClassLoader String byte[]"/></file></commit></fixedCommits></bug><bug id="354" opendate="2006-02-27 03:18:00" fixdate="2006-08-24 17:32:00"><buginformation><summary>Don't Dump Bytecodes to Syserr in LTW</summary><description>The load-time weaving system can produce truly massive quantities of output when there's a weaving error, since the system dumps the bytecode to syserr. It would be much better to produce an ajcore file and just point to it, or use some other log.</description><comments/></buginformation><fixedCommits><commit id="04fa1dcce12934cc5cfe1e5e8b66523c10e93672" author="default" date="2006-08-24 17:32:00"><file name="weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java"><method name="handleMessage" returnType="boolean" parameters="IMessage"/><method name="init" returnType="void" parameters="List List"/><method name="disable" returnType="void" parameters=""/></file><file name="loadtime/src/org/aspectj/weaver/loadtime/WeavingURLClassLoader.java"><method name="defineClass" returnType="Class" parameters="String byte[] CodeSource"/></file><file name="loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"><method name="registerAspects" returnType="void" parameters="BcelWeaver ClassLoader List"/><method name="registerAspects" returnType="void" parameters="BcelWeaver ClassLoader"/></file></commit></fixedCommits></bug><bug id="355" opendate="2006-08-25 08:34:00" fixdate="2006-08-25 12:41:38"><buginformation><summary>[ltw] can get into a state with the Version static initializer</summary><description>The static initializer in Version that parses the time_text string and turns it into a long field seems to sometimes get loadtime weaving into a state - touching DateFormatters early on is always a pain, so I'm moving it to be processed on first reference.  I could take it a step further ... if WeaverStateInfo didn't write out the time (it doesnt read it back in!!) it would never be used at all in normal processing - potentially saving us from loading a bunch of underpinning junk to do the formatting...</description><comments/></buginformation><fixedCommits><commit id="40cf61076994bf2dd6f0397b1bd0287ed546a75b" author="default" date="2006-08-25 12:41:38"><file name="bridge/testsrc/org/aspectj/bridge/VersionTest.java"><method name="testVersion" returnType="void" parameters=""/></file><file name="weaver/src/org/aspectj/weaver/AjAttribute.java"><method name="write" returnType="void" parameters="DataOutputStream"/></file></commit></fixedCommits></bug><bug id="356" opendate="2006-08-24 20:59:00" fixdate="2006-08-25 14:37:34"><buginformation><summary>jdk14 trace deadlock in oc4j</summary><description>I turned on tracing for the Aj class inside of Oracle's OC4J server. In one test (not always) it deadlocked. It looks like the threads are each trying to lock each other's loader. Notice that one of the threads is in the toString method of the Oracle ClassLoader (perhaps another reason to prefer tracing argument class names and system identity hashcodes).

Here's a thread dump from Ctrl+BREAK:

Found one Java-level deadlock:
=============================
"WorkExecutorWorkerThread-1":
  waiting to lock monitor 0x003384ec (object 0x05239e48, a oracle.classloader.Po
licyClassLoader),
  which is held by "OC4J Launcher"
"OC4J Launcher":
  waiting to lock monitor 0x0033848c (object 0x0554f0e8, a oracle.classloader.Po
licyClassLoader),
  which is held by "WorkExecutorWorkerThread-1"

Java stack information for the threads listed above:
===================================================
"WorkExecutorWorkerThread-1":
        at oracle.classloader.SearchPolicy.loadClass(SearchPolicy.java:641)
        - waiting to lock &lt;0x05239e48&gt; (a oracle.classloader.PolicyClassLoader)
        at oracle.classloader.PolicyClassLoader.askParentForClass(PolicyClassLoa
der.java:1284)
        at oracle.classloader.SearchPolicy$AskParent.getClass(SearchPolicy.java:
69)
        at oracle.classloader.SearchSequence.getClass(SearchSequence.java:119)
        at oracle.classloader.SearchPolicy.loadClass(SearchPolicy.java:642)
        - locked &lt;0x0554f0e8&gt; (a oracle.classloader.PolicyClassLoader)
        at oracle.classloader.PolicyClassLoader.askParentForClass(PolicyClassLoa
der.java:1284)
        at oracle.classloader.SearchPolicy$AskParent.getClass(SearchPolicy.java:
69)
        at oracle.classloader.SearchSequence.getClass(SearchSequence.java:119)
        at oracle.classloader.PolicyClassLoader.internalLoadClass(PolicyClassLoa
der.java:1660)
        - locked &lt;0x056a9ed0&gt; (a oracle.classloader.PolicyClassLoader)
        at oracle.classloader.PolicyClassLoader.loadClass(PolicyClassLoader.java
:1621)
        at oracle.classloader.PolicyClassLoader.loadClass(PolicyClassLoader.java
:1606)
        at java.lang.ClassLoader.loadClassInternal(ClassLoader.java:319)
        - locked &lt;0x056a9ed0&gt; (a oracle.classloader.PolicyClassLoader)
        at oracle.j2ee.ra.jms.generic.WorkConsumer.doReceive(WorkConsumer.java:9
87)
        at oracle.j2ee.ra.jms.generic.WorkConsumer.run(WorkConsumer.java:215)
        - locked &lt;0x05de2718&gt; (a oracle.j2ee.ra.jms.generic.WorkConsumer)
        at oracle.j2ee.connector.work.WorkWrapper.runTargetWork(WorkWrapper.java
:242)
        at oracle.j2ee.connector.work.WorkWrapper.doWork(WorkWrapper.java:215)
        at oracle.j2ee.connector.work.WorkWrapper.run(WorkWrapper.java:190)
        at EDU.oswego.cs.dl.util.concurrent.PooledExecutor$Worker.run(PooledExec
utor.java:814)
        at java.lang.Thread.run(Thread.java:595)
"OC4J Launcher":
        at oracle.classloader.PolicyClassLoader.toString(PolicyClassLoader.java:
1846)
        - waiting to lock &lt;0x0554f0e8&gt; (a oracle.classloader.PolicyClassLoader)
        at java.text.MessageFormat.subformat(MessageFormat.java:1237)
        at java.text.MessageFormat.format(MessageFormat.java:828)
        at java.text.Format.format(Format.java:133)
        at java.text.MessageFormat.format(MessageFormat.java:804)
        at java.util.logging.Formatter.formatMessage(Formatter.java:130)
        - locked &lt;0x0514e920&gt; (a java.util.logging.SimpleFormatter)
        at java.util.logging.SimpleFormatter.format(SimpleFormatter.java:63)
        - locked &lt;0x0514e920&gt; (a java.util.logging.SimpleFormatter)
        at java.util.logging.StreamHandler.publish(StreamHandler.java:179)
        - locked &lt;0x0514a0a8&gt; (a java.util.logging.FileHandler)
        at java.util.logging.FileHandler.publish(FileHandler.java:555)
        - locked &lt;0x0514a0a8&gt; (a java.util.logging.FileHandler)
        at java.util.logging.Logger.log(Logger.java:428)
        at java.util.logging.Logger.doLog(Logger.java:450)
        at java.util.logging.Logger.logp(Logger.java:619)
        at java.util.logging.Logger.entering(Logger.java:870)
        at org.aspectj.weaver.tools.Jdk14Trace.enter(Jdk14Trace.java:32)
        at org.aspectj.weaver.loadtime.Aj.preProcess(Aj.java:67)
        at org.aspectj.weaver.loadtime.ClassPreProcessorAgentAdapter.transform(C
lassPreProcessorAgentAdapter.java:55)
        at sun.instrument.TransformerManager.transform(TransformerManager.java:1
22)
        at sun.instrument.InstrumentationImpl.transform(InstrumentationImpl.java
:155)
        at java.lang.ClassLoader.defineClass1(Native Method)
        at java.lang.ClassLoader.defineClass(ClassLoader.java:620)
        at oracle.classloader.PolicyClassLoader.defineClass(PolicyClassLoader.ja
va:2224)
        at oracle.classloader.PolicyClassLoader.findLocalClass(PolicyClassLoader
.java:1457)
        at oracle.classloader.SearchPolicy$FindLocal.getClass(SearchPolicy.java:
167)
        at oracle.classloader.SearchSequence.getClass(SearchSequence.java:119)
        at oracle.classloader.PolicyClassLoader.internalLoadClass(PolicyClassLoa
der.java:1660)
        - locked &lt;0x05239e48&gt; (a oracle.classloader.PolicyClassLoader)
        at oracle.classloader.PolicyClassLoader.loadClass(PolicyClassLoader.java
:1621)
        at oracle.classloader.PolicyClassLoader.loadClass(PolicyClassLoader.java
:1606)
        at java.lang.ClassLoader.loadClassInternal(ClassLoader.java:319)
        - locked &lt;0x05239e48&gt; (a oracle.classloader.PolicyClassLoader)
        at com.evermind.server.http.HttpRequestHandler.&lt;init&gt;(HttpRequestHandler
.java:97)
        at com.evermind.server.http.HttpConnectionListener$HttpNIOAcceptHandler.
getReadHandler(HttpConnectionListener.java:116)
        at oracle.oc4j.network.ReadHandlerPool.getContextFromBackend(ReadHandler
Pool.java:63)
        at com.evermind.util.BBPool.startPool(BBPool.java:42)
        at oracle.oc4j.network.ReadHandlerPool.register(ReadHandlerPool.java:25)

        - locked &lt;0x05ec9290&gt; (a java.util.ArrayList)
        at oracle.oc4j.network.ServerSocketAcceptHandler.setPoolOptions(ServerSo
cketAcceptHandler.java:140)
        at com.evermind.server.http.HttpConnectionListener.setRequestHandlerPool
(HttpConnectionListener.java:232)
        at com.evermind.server.http.HttpConnectionListener.initHandlers(HttpConn
ectionListener.java:226)
        at com.evermind.server.http.HttpConnectionListener.&lt;init&gt;(HttpConnection
Listener.java:174)
        at com.evermind.server.http.HttpServer.getListener(HttpServer.java:481)
        - locked &lt;0x05ec4f88&gt; (a com.evermind.server.http.HttpServer)
        at com.evermind.server.http.HttpServer.setSites(HttpServer.java:267)
        - locked &lt;0x05ec4f88&gt; (a com.evermind.server.http.HttpServer)
        at com.evermind.server.http.HttpServer.setConfig(HttpServer.java:180)
        at com.evermind.server.ApplicationServer.initializeHttp(ApplicationServe
r.java:2296)
        at com.evermind.server.ApplicationServer.setConfig(ApplicationServer.jav
a:944)
        at com.evermind.server.ApplicationServerLauncher.run(ApplicationServerLa
uncher.java:113)
        - locked &lt;0x0530eb20&gt; (a java.lang.Object)
        at java.lang.Thread.run(Thread.java:595)

Found 1 deadlock.</description><comments/></buginformation><fixedCommits><commit id="6be70973a704548a42e396e996c9d49915b92a64" author="default" date="2006-08-25 14:37:34"><file name="weaver/testsrc/org/aspectj/weaver/AbstractTraceTest.java"><method name="toTraceString" returnType="String" parameters=""/><method name="testEnterWithThisAndArray" returnType="void" parameters=""/><method name="testEnterWithThisAndCollection" returnType="void" parameters=""/></file><file name="loadtime/src/org/aspectj/weaver/loadtime/DefaultWeavingContext.java"><method name="getClassLoaderName" returnType="String" parameters=""/></file><file name="weaver5/java5-src/org/aspectj/weaver/tools/Jdk14Trace.java"><method name="enter" returnType="void" parameters="String Object Object[]"/><method name="exit" returnType="void" parameters="String Object"/><method name="event" returnType="void" parameters="String Object Object[]"/></file></commit></fixedCommits></bug><bug id="357" opendate="2006-08-25 11:46:00" fixdate="2006-08-30 09:46:37"><buginformation><summary>Trace should use System.identityHashCode, not hashCode</summary><description>The tracing module uses obj.hashCode() to identify untrusted objects when formatting. I think it would be a little safer and more accurate to use
System.identityHashCode(obj). This way the tracing code wouldn't call any application-defined code, and would give a value that can't change if the loader state changes.</description><comments/></buginformation><fixedCommits><commit id="14e8b7d8f0c94d316665036c3968821f8874678e" author="default" date="2006-08-30 09:46:37"><file name="loadtime/src/org/aspectj/weaver/loadtime/DefaultWeavingContext.java"><method name="getClassLoaderName" returnType="String" parameters=""/></file></commit></fixedCommits></bug><bug id="358" opendate="2006-09-01 08:45:00" fixdate="2006-09-04 14:24:51"><buginformation><summary>NullPointerException in ConstructorSignature.getConstructor()</summary><description>AspectJ version: 1.5.3.200608290814

When advising a constructor, we can do the following to obtain the constructor as a java.lang.reflect.Member:

		Member cons = ((ConstructorSignature) thisJoinPointStaticPart
				.getSignature()).getConstructor();

however that sometimes fails, and returns null.</description><comments/></buginformation><fixedCommits><commit id="090de7e4c5c9618f965259f93de6d490050543da" author="default" date="2006-09-04 14:24:51"><file name="runtime/src/org/aspectj/runtime/reflect/FieldSignatureImpl.java"><method name="getField" returnType="Field" parameters=""/></file><file name="runtime/src/org/aspectj/runtime/reflect/InitializerSignatureImpl.java"><method name="getInitializer" returnType="Constructor" parameters=""/></file><file name="runtime/src/org/aspectj/runtime/reflect/ConstructorSignatureImpl.java"><method name="getConstructor" returnType="Constructor" parameters=""/></file></commit></fixedCommits></bug><bug id="359" opendate="2006-08-14 21:28:00" fixdate="2006-09-14 10:38:50"><buginformation><summary>[generics] Problem with signature for generic type</summary><description>public aspect OuterAspect {

  private pointcut isSetter() : execution(void set*(..));

  public static aspect InnerAspect pertarget(isSetter()) {

  }

}


java.lang.IllegalStateException
at org.aspectj.apache.bcel.classfile.GenericSignatureParser.parseFieldTypeSignature(GenericSignatureParser.java:163)
at org.aspectj.apache.bcel.classfile.GenericSignatureParser.parseTypeArgument(GenericSignatureParser.java:253)
at org.aspectj.apache.bcel.classfile.GenericSignatureParser.maybeParseTypeArguments(GenericSignatureParser.java:261)
at org.aspectj.apache.bcel.classfile.GenericSignatureParser.parseClassTypeSignature(GenericSignatureParser.java:208)
at org.aspectj.apache.bcel.classfile.GenericSignatureParser.parseAsClassSignature(GenericSignatureParser.java:56)
at org.aspectj.apache.bcel.classfile.Signature.asClassSignature(Signature.java:315)
at org.aspectj.apache.bcel.classfile.JavaClass.getGenericClassTypeSignature(JavaClass.java:973)
at org.aspectj.weaver.bcel.BcelObjectType.initializeFromJavaclass(BcelObjectType.java:164)
at org.aspectj.weaver.bcel.BcelObjectType.&lt;init&gt;(BcelObjectType.java:131)
at org.aspectj.weaver.bcel.BcelWorld.buildBcelDelegate(BcelWorld.java:337)
at org.aspectj.weaver.bcel.BcelWorld.addSourceObjectType(BcelWorld.java:395)
at org.aspectj.weaver.bcel.BcelWeaver.addIfAspect(BcelWeaver.java:263)
at org.aspectj.weaver.bcel.BcelWeaver.addAspectsFromDirectory(BcelWeaver.java:255)
at org.aspectj.weaver.bcel.BcelWeaver.addLibraryJarFile(BcelWeaver.java:205)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.initBcelWorld(AjBuildManager.java:698)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:223)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:199)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.incrementalBuild(AjBuildManager.java:170)
at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:117)
at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)

IllegalStateException thrown: Expecting [,L, or T, but found Pjava while unpacking Ljava/util/AbstractSet&lt;Pjava/util/Map$Entry&lt;TK;TV;&gt;;&gt;;</description><comments/></buginformation><fixedCommits><commit id="70ae0f8df6ec8b77ea2940b222e11d6d411ec5d2" author="default" date="2006-09-14 10:38:50"><file name="weaver/src/org/aspectj/weaver/ReferenceType.java"><method name="makeDeclaredSignature" returnType="String" parameters="ResolvedType"/></file></commit></fixedCommits></bug><bug id="360" opendate="2006-09-23 05:11:00" fixdate="2006-09-25 13:51:40"><buginformation><summary>@Pointcut in declare error results in NPE</summary><description>I am trying to use an @AspectJ @Pointcut in a "normal" AspectJ declare error expression. That  results in the following exception.


java.lang.NullPointerException
at org.aspectj.weaver.patterns.ReferencePointcut.concretize1(ReferencePointcut.java:361)
at org.aspectj.weaver.patterns.Pointcut.concretize(Pointcut.java:233)
at org.aspectj.weaver.patterns.NotPointcut.concretize1(NotPointcut.java:100)
at org.aspectj.weaver.patterns.Pointcut.concretize(Pointcut.java:233)
at org.aspectj.weaver.patterns.AndPointcut.concretize1(AndPointcut.java:97)
at org.aspectj.weaver.patterns.Pointcut.concretize(Pointcut.java:233)
at org.aspectj.weaver.patterns.Pointcut.concretize(Pointcut.java:220)
at org.aspectj.weaver.Checker.concretize(Checker.java:45)
at org.aspectj.weaver.CrosscuttingMembers.addShadowMunger(CrosscuttingMembers.java:91)
at org.aspectj.weaver.CrosscuttingMembers.addDeclare(CrosscuttingMembers.java:122)
at org.aspectj.weaver.CrosscuttingMembers.addDeclares(CrosscuttingMembers.java:113)
at org.aspectj.weaver.CrosscuttingMembersSet.addAdviceLikeDeclares(CrosscuttingMembersSet.java:117)
at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.addAdviceLikeDeclares(AjLookupEnvironment.java:382)
at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.completeTypeBindings(AjLookupEnvironment.java:245)
at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.beginToCompile(Compiler.java:301)
at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:315)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:887)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:244)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:199)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.incrementalBuild(AjBuildManager.java:170)
at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:117)
at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)

NullPointerException thrown: null</description><comments/></buginformation><fixedCommits><commit id="e56a69a32149724c51daf0b52958607e5cc46eb4" author="default" date="2006-09-25 13:51:40"><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseSourceType.java"><method name="makeResolvedPointcutDefinition" returnType="ResolvedPointcutDefinition" parameters="AbstractMethodDeclaration"/></file></commit></fixedCommits></bug><bug id="361" opendate="2006-06-27 18:41:00" fixdate="2006-09-26 09:26:33"><buginformation><summary>incorrect source signature for field ipe with qualified allocation expression</summary><description>Ajdoc chokes on interfaces with initializers for final fields (it doesn't preserve the initializer value). See attached AJDT project that fails when you run ajdoc with the default options on it:

 &gt; Calling ajc...
&gt; Building signature files...
&gt; Calling javadoc... 
Loading source file C:\eclipse\3.2\ajdocworkingdir\BadInterface.java...
1 error
 &gt; Decorating html files...
&gt; Removing generated tags (this may take a while)...
&gt; Finished. 
C:\eclipse\3.2\ajdocworkingdir\BadInterface.java:9: = expected
static final Comparator MY_COMPARATOR;
                                     ^</description><comments/></buginformation><fixedCommits><commit id="fc39df195868a601e071f4fec900ab1854c43549" author="default" date="2006-09-26 09:26:33"><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmHierarchyBuilder.java"><method name="generateJavadocComment" returnType="String" parameters="ASTNode"/><method name="genSourceSignature" returnType="String" parameters="FieldDeclaration"/></file><file name="tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java"><method name="testDeclareSoftAndInnerClasses_pr125981" returnType="void" parameters=""/></file></commit></fixedCommits></bug><bug id="362" opendate="2006-09-25 14:18:00" fixdate="2006-09-29 12:20:31"><buginformation><summary>Compiler Error: generics and arrays</summary><description>OK, not sure what to report here or what info you need, but here's the set up, message, and erroreous class.  I don't understand the errors from the compiler enough to parse down the erroneous file to something that contains only the bug, but I could if direction were given.

Here's my set up:
Eclipse SDK
Version: 3.2.0
Build id: M20060629-1905

With AJDT:
Eclipse AspectJ Development Tools
Version: 1.4.1.200608141223
AspectJ version: 1.5.3.200608210848

Here's the bug dump from the compiler inside Eclipse:
java.lang.UnsupportedOperationException
at org.aspectj.weaver.UnresolvedType.parameterize(UnresolvedType.java:221)
at org.aspectj.weaver.ResolvedMemberImpl.parameterize(ResolvedMemberImpl.java:680)
at org.aspectj.weaver.ResolvedMemberImpl.parameterize(ResolvedMemberImpl.java:690)
at org.aspectj.weaver.ResolvedMemberImpl.parameterizedWith(ResolvedMemberImpl.java:643)
at org.aspectj.weaver.ResolvedMemberImpl.parameterizedWith(ResolvedMemberImpl.java:597)
at org.aspectj.weaver.ReferenceType.getDeclaredMethods(ReferenceType.java:508)
at org.aspectj.weaver.ResolvedType$4.get(ResolvedType.java:226)
at org.aspectj.weaver.Iterators$3$1.hasNext(Iterators.java:118)
at org.aspectj.weaver.Iterators$5.hasNext(Iterators.java:171)
at org.aspectj.weaver.Iterators$3.hasNext(Iterators.java:128)
at org.aspectj.weaver.ResolvedType.lookupMember(ResolvedType.java:346)
at org.aspectj.weaver.ResolvedType.lookupMethod(ResolvedType.java:327)
at org.aspectj.weaver.World.resolve(World.java:523)
at org.aspectj.weaver.MemberImpl.resolve(MemberImpl.java:93)
at org.aspectj.weaver.JoinPointSignatureIterator.addSignaturesUpToFirstDefiningMember(JoinPointSignatureIterator.java:109)
at org.aspectj.weaver.JoinPointSignatureIterator.&lt;init&gt;(JoinPointSignatureIterator.java:51)
at org.aspectj.weaver.MemberImpl.getJoinPointSignatures(MemberImpl.java:943)
at org.aspectj.weaver.patterns.SignaturePattern.matches(SignaturePattern.java:286)
at org.aspectj.weaver.patterns.KindedPointcut.matchInternal(KindedPointcut.java:106)
at org.aspectj.weaver.patterns.Pointcut.match(Pointcut.java:146)
at org.aspectj.weaver.patterns.AndPointcut.matchInternal(AndPointcut.java:51)
at org.aspectj.weaver.patterns.Pointcut.match(Pointcut.java:146)
at org.aspectj.weaver.ShadowMunger.match(ShadowMunger.java:75)
at org.aspectj.weaver.Advice.match(Advice.java:112)
at org.aspectj.weaver.bcel.BcelAdvice.match(BcelAdvice.java:117)
at org.aspectj.weaver.bcel.BcelClassWeaver.match(BcelClassWeaver.java:2806)
at org.aspectj.weaver.bcel.BcelClassWeaver.matchInvokeInstruction(BcelClassWeaver.java:2768)
at org.aspectj.weaver.bcel.BcelClassWeaver.match(BcelClassWeaver.java:2506)
at org.aspectj.weaver.bcel.BcelClassWeaver.match(BcelClassWeaver.java:2332)
at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:494)
at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:119)
at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1606)
at org.aspectj.weaver.bcel.BcelWeaver.weaveWithoutDump(BcelWeaver.java:1557)
at org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify(BcelWeaver.java:1335)
at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1155)
at org.aspectj.ajdt.internal.compiler.AjPipeliningCompilerAdapter.weaveQueuedEntries(AjPipeliningCompilerAdapter.java:455)
at org.aspectj.ajdt.internal.compiler.AjPipeliningCompilerAdapter.queueForWeaving(AjPipeliningCompilerAdapter.java:392)
at org.aspectj.ajdt.internal.compiler.AjPipeliningCompilerAdapter.afterProcessing(AjPipeliningCompilerAdapter.java:380)
at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$after$org_aspectj_ajdt_internal_compiler_CompilerAdapter$5$6b855184(CompilerAdapter.aj:98)
at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:533)
at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:329)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:892)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:246)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:165)
at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:122)
at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)

trouble in: 
public class com.wec.lib.util.test.SyncValueTest extends junit.framework.TestCase:
  private com.wec.lib.util.test.SyncValueTest$SyncInteger a
  private com.wec.lib.util.test.SyncValueTest$SyncInteger b
  private com.wec.lib.util.test.SyncValueTest$SyncInteger c
  private com.wec.lib.util.test.SyncValueTest$SyncInteger d
  private com.wec.lib.util.test.SyncValueTest$SyncInteger e
  public void &lt;init&gt;():
                    ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this   (line 17)
                    INVOKESPECIAL junit.framework.TestCase.&lt;init&gt; ()V
    constructor-execution(void com.wec.lib.util.test.SyncValueTest.&lt;init&gt;())
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this   (line 27)
    |               NEW com.wec.lib.util.test.SyncValueTest$SyncInteger
    |               DUP
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this
    |               ICONST_1
    |               INVOKESPECIAL com.wec.lib.util.test.SyncValueTest$SyncInteger.&lt;init&gt; (Lcom/wec/lib/util/test/SyncValueTest;I)V
    |               PUTFIELD com.wec.lib.util.test.SyncValueTest.a Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this   (line 28)
    |               NEW com.wec.lib.util.test.SyncValueTest$SyncInteger
    |               DUP
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this
    |               ICONST_2
    |               INVOKESPECIAL com.wec.lib.util.test.SyncValueTest$SyncInteger.&lt;init&gt; (Lcom/wec/lib/util/test/SyncValueTest;I)V
    |               PUTFIELD com.wec.lib.util.test.SyncValueTest.b Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this   (line 29)
    |               NEW com.wec.lib.util.test.SyncValueTest$SyncInteger
    |               DUP
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this
    |               ICONST_3
    |               INVOKESPECIAL com.wec.lib.util.test.SyncValueTest$SyncInteger.&lt;init&gt; (Lcom/wec/lib/util/test/SyncValueTest;I)V
    |               PUTFIELD com.wec.lib.util.test.SyncValueTest.c Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this   (line 30)
    |               NEW com.wec.lib.util.test.SyncValueTest$SyncInteger
    |               DUP
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this
    |               ICONST_4
    |               INVOKESPECIAL com.wec.lib.util.test.SyncValueTest$SyncInteger.&lt;init&gt; (Lcom/wec/lib/util/test/SyncValueTest;I)V
    |               PUTFIELD com.wec.lib.util.test.SyncValueTest.d Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this   (line 31)
    |               NEW com.wec.lib.util.test.SyncValueTest$SyncInteger
    |               DUP
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this
    |               ICONST_5
    |               INVOKESPECIAL com.wec.lib.util.test.SyncValueTest$SyncInteger.&lt;init&gt; (Lcom/wec/lib/util/test/SyncValueTest;I)V
    |               PUTFIELD com.wec.lib.util.test.SyncValueTest.e Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               RETURN   (line 17)
    constructor-execution(void com.wec.lib.util.test.SyncValueTest.&lt;init&gt;())
  end public void &lt;init&gt;()

  public void testSyncValueGroup()    org.aspectj.weaver.MethodDeclarationLineNumber: 39:1035
:
    method-execution(void com.wec.lib.util.test.SyncValueTest.testSyncValueGroup())
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this   (line 42)
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.a Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               ICONST_1
    |               ANEWARRAY com.wec.lib.util.SyncValueGroup
    |               DUP
    |               ICONST_0
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.b Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               AASTORE
    | method-call(void com.wec.lib.util.test.SyncValueTest$SyncInteger.link(com.wec.lib.util.SyncValueGroup[]))
    | |             INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.link ([Lcom/wec/lib/util/SyncValueGroup;)V
    | method-call(void com.wec.lib.util.test.SyncValueTest$SyncInteger.link(com.wec.lib.util.SyncValueGroup[]))
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this   (line 43)
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.a Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object;
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.b Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object;
    |               IF_ACMPNE L0
    |               ICONST_1
    |               GOTO L1
    |           L0: ICONST_0
    |           L1: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V
    |               ICONST_1   (line 44)
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.b Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object;
    |               CHECKCAST java.lang.Integer
    |               INVOKEVIRTUAL java.lang.Integer.intValue ()I
    |               IF_ICMPNE L2
    |               ICONST_1
    |               GOTO L3
    |           L2: ICONST_0
    |           L3: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this   (line 45)
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.b Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               ICONST_2
    |               INVOKESTATIC java.lang.Integer.valueOf (I)Ljava/lang/Integer;
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.setValue (Ljava/lang/Object;)V
    |               ICONST_2   (line 46)
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.a Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object;
    |               CHECKCAST java.lang.Integer
    |               INVOKEVIRTUAL java.lang.Integer.intValue ()I
    |               IF_ICMPNE L4
    |               ICONST_1
    |               GOTO L5
    |           L4: ICONST_0
    |           L5: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this   (line 47)
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.b Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               ICONST_1
    |               ANEWARRAY com.wec.lib.util.SyncValueGroup
    |               DUP
    |               ICONST_0
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.c Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               AASTORE
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.link ([Lcom/wec/lib/util/SyncValueGroup;)V
    |               ICONST_2   (line 48)
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.c Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object;
    |               CHECKCAST java.lang.Integer
    |               INVOKEVIRTUAL java.lang.Integer.intValue ()I
    |               IF_ICMPNE L6
    |               ICONST_1
    |               GOTO L7
    |           L6: ICONST_0
    |           L7: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this   (line 49)
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.c Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               ICONST_3
    |               INVOKESTATIC java.lang.Integer.valueOf (I)Ljava/lang/Integer;
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.setValue (Ljava/lang/Object;)V
    |               ICONST_3   (line 50)
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.a Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object;
    |               CHECKCAST java.lang.Integer
    |               INVOKEVIRTUAL java.lang.Integer.intValue ()I
    |               IF_ICMPNE L8
    |               ICONST_1
    |               GOTO L9
    |           L8: ICONST_0
    |           L9: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V
    |               ICONST_3   (line 51)
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.b Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object;
    |               CHECKCAST java.lang.Integer
    |               INVOKEVIRTUAL java.lang.Integer.intValue ()I
    |               IF_ICMPNE L10
    |               ICONST_1
    |               GOTO L11
    |          L10: ICONST_0
    |          L11: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this   (line 52)
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.a Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               ICONST_4
    |               INVOKESTATIC java.lang.Integer.valueOf (I)Ljava/lang/Integer;
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.setValue (Ljava/lang/Object;)V
    |               ICONST_4   (line 53)
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.c Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object;
    |               CHECKCAST java.lang.Integer
    |               INVOKEVIRTUAL java.lang.Integer.intValue ()I
    |               IF_ICMPNE L12
    |               ICONST_1
    |               GOTO L13
    |          L12: ICONST_0
    |          L13: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V
    |               ICONST_4   (line 54)
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.b Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object;
    |               CHECKCAST java.lang.Integer
    |               INVOKEVIRTUAL java.lang.Integer.intValue ()I
    |               IF_ICMPNE L14
    |               ICONST_1
    |               GOTO L15
    |          L14: ICONST_0
    |          L15: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this   (line 55)
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.b Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               ICONST_1
    |               INVOKESTATIC java.lang.Integer.valueOf (I)Ljava/lang/Integer;
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.setValue (Ljava/lang/Object;)V
    |               ICONST_1   (line 56)
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.c Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object;
    |               CHECKCAST java.lang.Integer
    |               INVOKEVIRTUAL java.lang.Integer.intValue ()I
    |               IF_ICMPNE L16
    |               ICONST_1
    |               GOTO L17
    |          L16: ICONST_0
    |          L17: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V
    |               ICONST_1   (line 57)
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.a Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object;
    |               CHECKCAST java.lang.Integer
    |               INVOKEVIRTUAL java.lang.Integer.intValue ()I
    |               IF_ICMPNE L18
    |               ICONST_1
    |               GOTO L19
    |          L18: ICONST_0
    |          L19: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this   (line 59)
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.d Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               ICONST_1
    |               ANEWARRAY com.wec.lib.util.SyncValueGroup
    |               DUP
    |               ICONST_0
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.e Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               AASTORE
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.link ([Lcom/wec/lib/util/SyncValueGroup;)V
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this   (line 60)
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.d Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object;
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.e Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object;
    |               IF_ACMPNE L20
    |               ICONST_1
    |               GOTO L21
    |          L20: ICONST_0
    |          L21: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this   (line 63)
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.b Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               ICONST_1
    |               ANEWARRAY com.wec.lib.util.SyncValueGroup
    |               DUP
    |               ICONST_0
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.d Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               AASTORE
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.link ([Lcom/wec/lib/util/SyncValueGroup;)V
    |               ICONST_1   (line 64)
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.d Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object;
    |               CHECKCAST java.lang.Integer
    |               INVOKEVIRTUAL java.lang.Integer.intValue ()I
    |               IF_ICMPNE L22
    |               ICONST_1
    |               GOTO L23
    |          L22: ICONST_0
    |          L23: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V
    |               ICONST_1   (line 65)
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.e Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object;
    |               CHECKCAST java.lang.Integer
    |               INVOKEVIRTUAL java.lang.Integer.intValue ()I
    |               IF_ICMPNE L24
    |               ICONST_1
    |               GOTO L25
    |          L24: ICONST_0
    |          L25: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this   (line 66)
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.d Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               BIPUSH 8
    |               INVOKESTATIC java.lang.Integer.valueOf (I)Ljava/lang/Integer;
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.setValue (Ljava/lang/Object;)V
    |               BIPUSH 8   (line 67)
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.a Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object;
    |               CHECKCAST java.lang.Integer
    |               INVOKEVIRTUAL java.lang.Integer.intValue ()I
    |               IF_ICMPNE L26
    |               ICONST_1
    |               GOTO L27
    |          L26: ICONST_0
    |          L27: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V
    |               BIPUSH 8   (line 68)
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.b Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object;
    |               CHECKCAST java.lang.Integer
    |               INVOKEVIRTUAL java.lang.Integer.intValue ()I
    |               IF_ICMPNE L28
    |               ICONST_1
    |               GOTO L29
    |          L28: ICONST_0
    |          L29: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V
    |               BIPUSH 8   (line 69)
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.c Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object;
    |               CHECKCAST java.lang.Integer
    |               INVOKEVIRTUAL java.lang.Integer.intValue ()I
    |               IF_ICMPNE L30
    |               ICONST_1
    |               GOTO L31
    |          L30: ICONST_0
    |          L31: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V
    |               BIPUSH 8   (line 70)
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.d Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object;
    |               CHECKCAST java.lang.Integer
    |               INVOKEVIRTUAL java.lang.Integer.intValue ()I
    |               IF_ICMPNE L32
    |               ICONST_1
    |               GOTO L33
    |          L32: ICONST_0
    |          L33: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V
    |               BIPUSH 8   (line 71)
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.e Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object;
    |               CHECKCAST java.lang.Integer
    |               INVOKEVIRTUAL java.lang.Integer.intValue ()I
    |               IF_ICMPNE L34
    |               ICONST_1
    |               GOTO L35
    |          L34: ICONST_0
    |          L35: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this   (line 74)
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.c Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.unlink ()V
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this   (line 75)
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.c Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               ICONST_3
    |               INVOKESTATIC java.lang.Integer.valueOf (I)Ljava/lang/Integer;
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.setValue (Ljava/lang/Object;)V
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this   (line 76)
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.b Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               ICONST_2
    |               INVOKESTATIC java.lang.Integer.valueOf (I)Ljava/lang/Integer;
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.setValue (Ljava/lang/Object;)V
    |               ICONST_2   (line 77)
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.a Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object;
    |               CHECKCAST java.lang.Integer
    |               INVOKEVIRTUAL java.lang.Integer.intValue ()I
    |               IF_ICMPNE L36
    |               ICONST_1
    |               GOTO L37
    |          L36: ICONST_0
    |          L37: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V
    |               ICONST_2   (line 78)
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.b Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object;
    |               CHECKCAST java.lang.Integer
    |               INVOKEVIRTUAL java.lang.Integer.intValue ()I
    |               IF_ICMPNE L38
    |               ICONST_1
    |               GOTO L39
    |          L38: ICONST_0
    |          L39: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V
    |               ICONST_3   (line 79)
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.c Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object;
    |               CHECKCAST java.lang.Integer
    |               INVOKEVIRTUAL java.lang.Integer.intValue ()I
    |               IF_ICMPNE L40
    |               ICONST_1
    |               GOTO L41
    |          L40: ICONST_0
    |          L41: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V
    |               ICONST_2   (line 80)
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.d Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object;
    |               CHECKCAST java.lang.Integer
    |               INVOKEVIRTUAL java.lang.Integer.intValue ()I
    |               IF_ICMPNE L42
    |               ICONST_1
    |               GOTO L43
    |          L42: ICONST_0
    |          L43: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V
    |               ICONST_2   (line 81)
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.e Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object;
    |               CHECKCAST java.lang.Integer
    |               INVOKEVIRTUAL java.lang.Integer.intValue ()I
    |               IF_ICMPNE L44
    |               ICONST_1
    |               GOTO L45
    |          L44: ICONST_0
    |          L45: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this   (line 82)
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.d Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.unlink ()V
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this   (line 83)
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.c Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               ICONST_1
    |               ANEWARRAY com.wec.lib.util.SyncValueGroup
    |               DUP
    |               ICONST_0
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.d Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               AASTORE
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.link ([Lcom/wec/lib/util/SyncValueGroup;)V
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this   (line 84)
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.a Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               ICONST_1
    |               INVOKESTATIC java.lang.Integer.valueOf (I)Ljava/lang/Integer;
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.setValue (Ljava/lang/Object;)V
    |               ICONST_1   (line 85)
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.a Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object;
    |               CHECKCAST java.lang.Integer
    |               INVOKEVIRTUAL java.lang.Integer.intValue ()I
    |               IF_ICMPNE L46
    |               ICONST_1
    |               GOTO L47
    |          L46: ICONST_0
    |          L47: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V
    |               ICONST_1   (line 86)
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.b Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object;
    |               CHECKCAST java.lang.Integer
    |               INVOKEVIRTUAL java.lang.Integer.intValue ()I
    |               IF_ICMPNE L48
    |               ICONST_1
    |               GOTO L49
    |          L48: ICONST_0
    |          L49: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V
    |            </description><comments/></buginformation><fixedCommits><commit id="ea4ff8adad2347557c25d6e10e114132b7491870" author="default" date="2006-09-29 12:20:31"><file name="weaver/src/org/aspectj/weaver/ResolvedMemberImpl.java"><method name="parameterizedWith" returnType="ResolvedMemberImpl" parameters="UnresolvedType[]"/><method name="parameterize" returnType="UnresolvedType" parameters="UnresolvedType Map"/></file></commit></fixedCommits></bug><bug id="363" opendate="2006-09-25 11:09:00" fixdate="2006-09-29 14:21:57"><buginformation><summary>changing value of variable in aspect results in adviceDidNotMatch warning</summary><description>Given the following:

public aspect A {
	public static int i = 0;
	before() : execution(* *.*(..)) {}
}

public class C {
	public void m() {}
}

Changing the value of i to be something else and then saving results in an incremental build and an "adviceDidNotMatch" warning. A full build clears the warning.

This is since the JDTLikeHandleProvider ( bug 141730 ) was made the default in AJDT and is down to the call on line 90 of CrosscuttingMembersSet which is the fix for  bug 134541 ). The reason we now hit this is that the JDTLikeHandleProvider doesn't depend on location.</description><comments/></buginformation><fixedCommits><commit id="cd9fd1147b63c7a0df0c93307feae4dce7b19d4d" author="default" date="2006-09-29 14:21:57"><file name="weaver/src/org/aspectj/weaver/CrosscuttingMembers.java"><method name="replaceWith" returnType="boolean" parameters="CrosscuttingMembers"/></file></commit></fixedCommits></bug><bug id="364" opendate="2006-07-31 14:44:00" fixdate="2006-10-03 14:30:21"><buginformation><summary>LTW Within Patterns Should Accept AND For Consistency</summary><description>The load-time weaving definition system accepts AND in addition to &amp;amp;&amp;amp; for pointcuts, but it silently accepts and then fails to work with type patterns that use AND. Such type patterns are important when creating exceptions (e.g., excluding weblogic..* &amp;amp;&amp;amp; !weblogic.jdbc..*) and using AND is also helpful here.

I've attached a patch to support this and tests to show it's working.</description><comments/></buginformation><fixedCommits><commit id="7b831ff7356725b9872a9635d1e0eeb035f2790b" author="default" date="2006-10-03 14:30:21"><file name="loadtime/src/org/aspectj/weaver/loadtime/definition/DocumentParser.java"><method name="startElement" returnType="void" parameters="String String String"/></file></commit></fixedCommits></bug><bug id="365" opendate="2006-09-11 13:39:00" fixdate="2006-10-03 15:00:34"><buginformation><summary>Incorrect warning when advising a private method of a private inner class</summary><description>The Eclipse AJDT give an incorrect warning when you want to advise a private method of a private inner class.


When I want to advise a private method in a private inner class, like this

public class Outer
{
   private class Inner
   {
      private void myMethod()
   }
}

Using the following poincut:

poincut innerpointcut():execution( * Outer.Inner.myMethod() );

and advice:

before():innerpointcut()
{
   System.out.println( "executing!" );
}

I get a warning "invalidAbsoluteTypeName" next to my pointcut, but next to the advice, there is a marker that points to the private method.</description><comments/></buginformation><fixedCommits><commit id="782ade25e6d68caf361f51a1e040edbd6855842b" author="default" date="2006-10-03 15:00:34"><file name="weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java"><method name="lookupTypeInScope" returnType="UnresolvedType" parameters="IScope String"/><method name="resolveBindingsFromFullyQualifiedTypeName" returnType="TypePattern" parameters=""/></file><file name="tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java"><method name="testNPEWithCustomAgent_pr158005" returnType="void" parameters=""/></file></commit></fixedCommits></bug><bug id="366" opendate="2006-10-05 11:44:00" fixdate="2006-10-06 16:29:03"><buginformation><summary>advice from injars do not have unique handles with the JDTLikeHandleProvider</summary><description>Advice of the same kind contained in the same aspect currently do not have unique handles if the aspect is on the aspectpath.</description><comments/></buginformation><fixedCommits><commit id="d532892d89865511ea39286e4ebd34fc20b96a5d" author="default" date="2006-10-06 16:29:03"><file name="weaver/src/org/aspectj/weaver/ShadowMunger.java"><method name="addChildNodes" returnType="void" parameters="IProgramElement Collection"/></file><file name="weaver/src/org/aspectj/weaver/patterns/DeclareErrorOrWarning.java"><method name="getNameSuffix" returnType="String" parameters=""/></file></commit></fixedCommits></bug><bug id="367" opendate="2006-10-08 18:51:00" fixdate="2006-10-09 12:28:29"><buginformation><summary>NPE when using crossrefs option for iajc ant task</summary><description>The ant task is shown below.  I ommited the full paths to the values of inpath, outJar, and argfiles, because they are somewhat long (hence the "..." before the file names):

&lt;iajc  
crossrefs="true" argfiles="...\weave-jars.txt" inpath="...\org.eclipse.core.runtime_3.2.0.v20060603.jar" outJar="...\org.eclipse.core.runtime_3.2.0.v20060603_woven.jar"&gt;
  &lt;classpath&gt;
    &lt;pathelement location="C:\aspectj1.5\lib\aspectjrt.jar"/&gt;
      &lt;fileset dir="${plugins.dir}"&gt;
        &lt;include name="**/*.jar"/&gt;
      &lt;/fileset&gt;
  &lt;/classpath&gt;
&lt;/iajc&gt;

My argfile only contains the absolute path of a single .aj file, which contains one aspect.  The aspect is shown below.  It is very basic - advice bodies simply toggle a boolean variable.  

public aspect FFDC {
  public static boolean bit = false;
  protected pointcut ffdcScope(): within(org.eclipse..*);	
  protected pointcut excluded():  within(org.eclipse.ffdc.FFDC+)
	|| within(org.eclipse.core.internal.runtime.PlatformActivator);
	
  before(CoreException c): ffdcScope() &amp;&amp; !excluded() 
      &amp;&amp; handler(CoreException+) &amp;&amp; args(c) {
    bit = !bit;
  }
	
  after() throwing(CoreException c): ffdcScope() &amp;&amp; !excluded() &amp;&amp; !handler(*) {
    bit = !bit;
  }
	
  after(Plugin activator): execution(void PlatformActivator.start(..)) 
      &amp;&amp; this(activator) {
    bit = !bit;
  }
}

This task worked properly before I added "crossrefs=true".  After adding this option, I get the following error:

weave-C:\eclipse\sdk-aspect-package\eclipse\plugins\org.eclipse.core.runtime_3.2.0.v20060603.jar:
     [iajc] abort ABORT -- (NullPointerException) null
     [iajc] null
     [iajc] java.lang.NullPointerException
     [iajc]     at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:313)
     [iajc]     at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:163)
     [iajc]     at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:112)
     [iajc]     at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:60)
     [iajc]     at org.aspectj.tools.ajc.Main.run(Main.java:367)
     [iajc]     at org.aspectj.tools.ajc.Main.runMain(Main.java:246)
     [iajc]     at org.aspectj.tools.ant.taskdefs.AjcTask.executeInSameVM(AjcTask.java:1282)
     [iajc]     at org.aspectj.tools.ant.taskdefs.AjcTask.execute(AjcTask.java:1080)
     [iajc]     at org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:275)
     [iajc]     at org.apache.tools.ant.Task.perform(Task.java:364)
     [iajc]     at org.apache.tools.ant.Target.execute(Target.java:341)
     [iajc]     at org.apache.tools.ant.Target.performTasks(Target.java:369)
     [iajc]     at org.apache.tools.ant.Project.executeSortedTargets(Project.java:1216)
     [iajc]     at org.apache.tools.ant.helper.SingleCheckExecutor.executeTargets(SingleCheckExecutor.java:37)
     [iajc]     at org.apache.tools.ant.Project.executeTargets(Project.java:1068)
     [iajc]     at org.apache.tools.ant.taskdefs.Ant.execute(Ant.java:382)
     [iajc]     at org.apache.tools.ant.taskdefs.CallTarget.execute(CallTarget.java:107)
     [iajc]     at org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:275)
     [iajc]     at org.apache.tools.ant.Task.perform(Task.java:364)
     [iajc]     at org.apache.tools.ant.Target.execute(Target.java:341)
     [iajc]     at org.apache.tools.ant.Target.performTasks(Target.java:369)
     [iajc]     at org.apache.tools.ant.Project.executeSortedTargets(Project.java:1216)
     [iajc]     at org.apache.tools.ant.Project.executeTarget(Project.java:1185)
     [iajc]     at org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:40)
     [iajc]     at org.apache.tools.ant.Project.executeTargets(Project.java:1068)
     [iajc]     at org.apache.tools.ant.Main.runBuild(Main.java:668)
     [iajc]     at org.apache.tools.ant.Main.startAnt(Main.java:187)
     [iajc]     at org.apache.tools.ant.launch.Launcher.run(Launcher.java:246)
     [iajc]     at org.apache.tools.ant.launch.Launcher.main(Launcher.java:67)</description><comments/></buginformation><fixedCommits><commit id="f7508cf38732781a467aa3eb95a03cee157e2730" author="default" date="2006-10-09 12:28:29"><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"><method name="doBuild" returnType="boolean" parameters=""/></file></commit></fixedCommits></bug><bug id="368" opendate="2006-06-30 08:20:00" fixdate="2006-10-17 08:08:12"><buginformation><summary>declare annotation problem: AIOOBE at ProblemReporter.java:2992</summary><description>This has been happening a lot, but I'm having trouble figuring out why it's happening.  It's always "5".  It happens both in Eclipse and from the command line.

java.lang.ArrayIndexOutOfBoundsException
at org.aspectj.org.eclipse.jdt.internal.compiler.problem.ProblemReporter.invalidType(ProblemReporter.java:2992)
at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeReference.reportInvalidType(TypeReference.java:170)
at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveType(TypeReference.java:136)
at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveType(TypeReference.java:123)
at org.aspectj.org.eclipse.jdt.internal.compiler.ast.Annotation.resolveType(Annotation.java:214)
at org.aspectj.org.eclipse.jdt.internal.compiler.ast.ASTNode.resolveAnnotations(ASTNode.java:436)
at org.aspectj.ajdt.internal.compiler.lookup.EclipseSourceType.getAnnotationTypes(EclipseSourceType.java:443)
at org.aspectj.ajdt.internal.compiler.lookup.EclipseSourceType.isAnnotationStyleAspect(EclipseSourceType.java:123)
at org.aspectj.ajdt.internal.compiler.lookup.EclipseSourceType.isAspect(EclipseSourceType.java:108)
at org.aspectj.weaver.ReferenceType.isAspect(ReferenceType.java:159)
at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.verifyAnyTypeParametersMeetBounds(AjLookupEnvironment.java:269)
at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.completeTypeBindings(AjLookupEnvironment.java:228)
at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.beginToCompile(Compiler.java:301)
at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:315)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:887)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:244)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:163)
at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:122)
at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)

ArrayIndexOutOfBoundsException thrown: 5</description><comments/></buginformation><fixedCommits><commit id="bc2f36fdbf0e0a8d59e9613b69a3b4639b1dd668" author="default" date="2006-10-17 08:08:12"><file name="tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java"><method name="testBuildingTwoProjectsInTurns" returnType="void" parameters=""/></file></commit></fixedCommits></bug><bug id="369" opendate="2006-10-17 08:19:00" fixdate="2006-10-19 14:05:02"><buginformation><summary>NPE in BcelAdvice</summary><description>I've been playing with some aspect deployment models and got into this error during project rebuild from AJDT:

java.lang.NullPointerException
at org.aspectj.weaver.bcel.BcelAdvice.implementOn(BcelAdvice.java:199)
at org.aspectj.weaver.Shadow.implementMungers(Shadow.java:699)
at org.aspectj.weaver.Shadow.implement(Shadow.java:471)
at org.aspectj.weaver.bcel.BcelClassWeaver.implement(BcelClassWeaver.java:2832)
at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:506)
at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeave ... lasses 
when weaving 
when batch building BuildConfig[...] #Files=6

Here is the aspect and classes it is applied to:

-----
@Aspect("percflow(execution(* InstrumentedBean.getProperty2()))")
public class GetFieldAtAspect {

  @Around("execution(* ConfigurableBean.getProperty2())")
  public Object onGet(ProceedingJoinPoint jp) throws Throwable {
    return jp.proceed();
  }
}
------
import org.springframework.beans.factory.InitializingBean;


public class InstrumentedBean implements InitializingBean, IInstrumentedBean {

  private ConfigurableBean configurableBean;

  private String value;

  private transient String transientValue = "aaa";

  
  public void afterPropertiesSet() throws Exception {
    this.configurableBean = new ConfigurableBean();
  }
  
  public String getProperty1() {
    synchronized(this) {
      return this.configurableBean.getProperty1();
    }
  }

  public String getProperty2() {
    synchronized(this) {
      return this.configurableBean.getProperty2();
    }
  }
  
  public void setValue(String value) {
    synchronized(this) {
      this.value = value;
    }
  }

  public Object getValue() {
    synchronized(this) {
      return value;
    }
  }

  public Object getTransientValue() {
    return transientValue;
  }
  
  public void setTransientValue(String transientValue) {
    this.transientValue = transientValue;
  }

}

------

import java.io.Serializable;

import org.springframework.beans.factory.annotation.Configurable;


@Configurable
public class ConfigurableBean implements Serializable {
  private static final long serialVersionUID = 1L;
  
  private String property1;
  private String property2;
  
  public ConfigurableBean() {
  }
  
  public String getProperty1() {
    return this.property1;
  }
  
  public String getProperty2() {
    return this.property2;
  }
  
  public void setProperty1(String property1) {
    this.property1 = property1;
  }
  
  public void setProperty2(String property2) {
    this.property2 = property2;
  }
  
}</description><comments/></buginformation><fixedCommits><commit id="044542c6d5996806ce29156e83e1725823f5f8fe" author="default" date="2006-10-19 14:05:02"><file name="weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java"><method name="implementOn" returnType="void" parameters="Shadow"/></file></commit></fixedCommits></bug><bug id="370" opendate="2006-10-11 11:41:00" fixdate="2006-10-23 10:39:38"><buginformation><summary>ajdoc Main class needs refactoring for ease of use</summary><description>Whilst looking at other ajdoc bugs it was slightly confusing to read the main ajdoc method. I didn't want to include the refactoring of this within patches for the other bugs as this is mearly for ease of use. Therefore, raising this enhancement to cover it.</description><comments/></buginformation><fixedCommits><commit id="efe6cc79c4c19ebc8f7109f10220b13dc4efffad" author="default" date="2006-10-23 10:39:38"><file name="ajdoc/src/org/aspectj/tools/ajdoc/Main.java"><method name="parseArgs" returnType="void" parameters="List File"/><method name="accept" returnType="boolean" parameters="File"/><method name="main" returnType="void" parameters="String[]"/></file></commit></fixedCommits></bug><bug id="371" opendate="2006-07-06 17:24:00" fixdate="2006-10-23 11:55:54"><buginformation><summary>NPE in org.aspectj.weaver.MemberImpl.getModifiers(MemberImpl.java:526)</summary><description>java.lang.NullPointerException
	at org.aspectj.weaver.MemberImpl.getModifiers(MemberImpl.java:526)
	at org.aspectj.weaver.MemberImpl.getMethodSignatureString(MemberImpl.java:824)
	at org.aspectj.weaver.MemberImpl.getSignatureString(MemberImpl.java:753)
	at org.aspectj.weaver.bcel.LazyClassGen.initializeTjp(LazyClassGen.java:1039)
	at org.aspectj.weaver.bcel.LazyClassGen.initializeAllTjps(LazyClassGen.java:1016)
	at org.aspectj.weaver.bcel.LazyClassGen.addAjcInitializers(LazyClassGen.java:964)
	at org.aspectj.weaver.bcel.LazyClassGen.writeBack(LazyClassGen.java:502)
	at org.aspectj.weaver.bcel.LazyClassGen.getJavaClassBytesIncludingReweavable(LazyClassGen.java:652)
	at org.aspectj.weaver.bcel.BcelWeaver.getClassFilesFor(BcelWeaver.java:1337)
	at org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify(BcelWeaver.java:1309)
	at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1127)
	at org.aspectj.weaver.tools.WeavingAdaptor.getWovenBytes(WeavingAdaptor.java:284)
	at org.aspectj.weaver.tools.WeavingAdaptor.weaveClass(WeavingAdaptor.java:212)
	at org.aspectj.weaver.loadtime.WeavingURLClassLoader.defineClass(WeavingURLClassLoader.java:125)
	at org.aspectj.weaver.ExtensibleURLClassLoader.defineClass(ExtensibleURLClassLoader.java:80)
	at org.aspectj.weaver.ExtensibleURLClassLoader.findClass(ExtensibleURLClassLoader.java:46)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:306)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:251)
	at java.lang.ClassLoader.loadClassInternal(ClassLoader.java:319)
Exception in thread "main" 

public aspect JoinPointTraceAspect {
	
	private int _callDepth = -1;
	
	pointcut tracePoints() : !within(JoinPointTraceAspect);
	
	before() : tracePoints() {
		_callDepth++; print("Before", thisJoinPoint);
	}
	
	after() : tracePoints() {
		print("After", thisJoinPoint);
		_callDepth--;
	}
	
	private void print(String prefix, Object message) {
		for(int i = 0, spaces = _callDepth * 2; i &lt; spaces; i++) {
			System.out.print(" ");
		}
		
		System.out.println(prefix + ": " + message);
	}
}

aspect EdtRuleChecker {
    private boolean isStressChecking = true;
    
    public pointcut anySwingMethods(JComponent c):
         target(c) &amp;&amp; call(* *(..));

    public pointcut threadSafeMethods():         
         call(* repaint(..)) || 
         call(* revalidate()) ||
         call(* invalidate()) ||
         call(* getListeners(..)) ||
         call(* add*Listener(..)) ||
         call(* remove*Listener(..));

    //calls of any JComponent method, including subclasses
    before(JComponent c): anySwingMethods(c) &amp;&amp; 
                          !threadSafeMethods() &amp;&amp;
                          !within(EdtRuleChecker) {
     if(!SwingUtilities.isEventDispatchThread() &amp;&amp;
         (isStressChecking || c.isShowing())) 
     {
             System.err.println(thisJoinPoint.getSourceLocation());
             System.err.println(thisJoinPoint.getSignature());
             System.err.println();
      }
    }

    //calls of any JComponent constructor, including subclasses
    before(): call(JComponent+.new(..)) {
      if (isStressChecking &amp;&amp; !SwingUtilities.isEventDispatchThread()) {
          System.err.println(thisJoinPoint.getSourceLocation());
          System.err.println(thisJoinPoint.getSignature() +
                                " *constructor*");
          System.err.println();
      }
    }
}

Running with SwingSet2.</description><comments/></buginformation><fixedCommits><commit id="757004ca6702a97369aac2ba62532f13ac5ced36" author="default" date="2006-10-23 11:55:54"><file name="weaver/src/org/aspectj/weaver/MemberImpl.java"><method name="getJoinPointSignatures" returnType="Iterator" parameters="World"/><method name="getParameterNames" returnType="String[]" parameters="World"/><method name="getExceptions" returnType="UnresolvedType[]" parameters="World"/><method name="getModifiers" returnType="int" parameters="World"/></file></commit></fixedCommits></bug><bug id="372" opendate="2006-10-18 22:23:00" fixdate="2006-10-24 12:42:57"><buginformation><summary>UnsupportedOperationException thrown: unable to parameterize unresolved type: Pjava/util/List&lt;+Ljava/lang/Object; &gt;;</summary><description>Generic parameters (like List&lt;? extends T&gt;) in pointcuts throw UnsupportedOperationException.

java.lang.UnsupportedOperationException
at org.aspectj.weaver.UnresolvedType.parameterize(UnresolvedType.java: 220)
at org.aspectj.weaver.patterns.ExactTypePattern.parameterizeWith (ExactTypePattern.java:244)
at org.aspectj.weaver.patterns.SignaturePattern.parameterizeWith (SignaturePattern.java:265)
at org.aspectj.weaver.patterns.KindedPointcut.parameterizeWith (KindedPointcut.java:381)
at org.aspectj.weaver.bcel.BcelAdvice.parameterizeWith (BcelAdvice.java:93)
at org.aspectj.weaver.ResolvedType.getDeclaredAdvice (ResolvedType.java:710)
at org.aspectj.weaver.ResolvedType.getDeclaredShadowMungers (ResolvedType.java:739)
at org.aspectj.weaver.ResolvedType.collectShadowMungers (ResolvedType.java:575)
at org.aspectj.weaver.ResolvedType.collectCrosscuttingMembers (ResolvedType.java:504)
at org.aspectj.weaver.CrosscuttingMembersSet.addOrReplaceAspect (CrosscuttingMembersSet.java:68)
at org.aspectj.weaver.CrosscuttingMembersSet.addOrReplaceAspect (CrosscuttingMembersSet.java:57)
at org.aspectj.weaver.bcel.BcelWeaver.prepareForWeave(BcelWeaver.java: 450)
at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave (AjCompilerAdapter.java:299)
at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling (AjCompilerAdapter.java:192)
at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc $afterReturning$org_aspectj_ajdt_internal_compiler_CompilerAdapter$2 $f9cc9ca0(CompilerAdapter.aj:70)
at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile (Compiler.java:367)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation (AjBuildManager.java:887)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild (AjBuildManager.java:244)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild (AjBuildManager.java:163)
at org.aspectj.ajde.internal.CompilerAdapter.compile (CompilerAdapter.java:122)
at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run (AspectJBuildManager.java:191)

UnsupportedOperationException thrown: unable to parameterize unresolved type: Pjava/util/List&lt;+Ljava/lang/Object;&gt;;

To reproduce this exception compile the following code snippet.

import java.util.ArrayList;
import java.util.List;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;

public class Main {

  public List&lt;? extends Element&gt; getElements() {
    return new ArrayList&lt;Element&gt;();
  }

  class Element {};

  @Aspect
  static abstract class Base&lt;T&gt; {
    @Around("call(List&lt;? extends T&gt; *.*(..))")
    public List&lt;? extends T&gt; elementList(ProceedingJoinPoint thisJoinPoint) {
      try {
        return (List&lt;? extends T&gt;)thisJoinPoint.proceed();
      } catch (Throwable e) {
        throw new RuntimeException(e);
      }
    }
  }

  @Aspect
  static class Concrete extends Base&lt;Element&gt; {}

  public static void main(String[] args) {
    new Main().getElements();
  }
	
}</description><comments/></buginformation><fixedCommits><commit id="7b40e7e3e4b68d6b0334f5643931e00f06881cdd" author="default" date="2006-10-24 12:42:57"><file name="weaver/src/org/aspectj/weaver/ReferenceType.java"><method name="getDeclares" returnType="Collection" parameters=""/><method name="getPerClause" returnType="PerClause" parameters=""/></file><file name="weaver/src/org/aspectj/weaver/Checker.java"><method name="parameterizeWith" returnType="ShadowMunger" parameters="ResolvedType Map"/></file><file name="weaver/src/org/aspectj/weaver/ResolvedPointcutDefinition.java"><method name="parameterizedWith" returnType="ResolvedMemberImpl" parameters="UnresolvedType[]"/></file></commit></fixedCommits></bug><bug id="373" opendate="2006-11-13 04:04:00" fixdate="2006-11-17 13:45:52"><buginformation><summary>Can no longer compile JDK 1.5 projects with apsectj for JDeveloper</summary><description>I am working with AspectJ 1.5.2 in JDeveloper and have found that it is 
not possible to convince the compiler to use JDK 5 constructs.
 
It appears that there is a method on AjcBuildOptions called 
getJavaOptionsMap() which is currently implemented to return null in all 
cases. In CompilerAdapter.configureBuildOptions areound line 358 the 
code tried to access this object to access whether to use JDK 5 
constructs or not. Since the return value is always null the project is 
never properly configured. 
 
I notice that the only other implementation of the root interface is 
CoreBuildOption which appears to directly return a structure from the 
eclipse class JavaProject. It would appear that this interface is 
breaking the rules on abstraction, is this the correct read on the 
situation? 

If so the solution would either be to implement a CoreBuildOption class 
to correctly work with the ADJE project adapter class or alter the code in
Compiler adapter to correct use the properties in project adapter. I think
that the latter is probably the best as BuildOption assumes a depedency on
Eclipse which shouldn't be there.

We do currently have customer, one in nato, who are currently having to 
work around this issue so it would be good to get it resolve for 1.5.3 if possible
But I know I am a bit late for that now do to a lost email.</description><comments/></buginformation><fixedCommits><commit id="c54fa62036a1fce21c2f50d0dbeafc025ca16bc0" author="default" date="2006-11-17 13:45:52"><file name="ajde/src/org/aspectj/ajde/internal/CompilerAdapter.java"><method name="configureBuildOptions" returnType="boolean" parameters="AjBuildConfig"/></file><file name="ajde/src/org/aspectj/ajde/BuildOptionsAdapter.java"><method name="getComplianceLevel" returnType="String" parameters=""/></file><file name="ajde/testsrc/org/aspectj/ajde/BuildConfigurationTests.java"><method name="testComplianceLevel" returnType="void" parameters=""/></file></commit></fixedCommits></bug><bug id="374" opendate="2006-11-20 08:26:00" fixdate="2006-11-20 13:20:41"><buginformation><summary>[ltw] Unnecessary exceptions during concretization of aspects in aop.xml</summary><description>Due to the mechanism used in ConcreteAspectCodeGen I see a lot of unnecessary exceptions created.  The problem is rather than looking up a type to confirm it doesn't exist before defining it, the code uses a resolve() to check if it exists and resolve attempts to build it if it isnt there.  Because the classloader will never find an aop.xml defined type (the class doesn't exist anywhere on the classpath), a spurious exception is created and sometimes traced (if collecting a trace).  I'm going to change the code to do a lookup, that is all that is really necessary.</description><comments/></buginformation><fixedCommits><commit id="e8d2556d9448375fcf578695c082f81aa604fddb" author="default" date="2006-11-20 13:20:41"><file name="loadtime/src/org/aspectj/weaver/loadtime/ConcreteAspectCodeGen.java"><method name="getClassName" returnType="String" parameters=""/><method name="validate" returnType="boolean" parameters=""/></file></commit></fixedCommits></bug><bug id="375" opendate="2007-01-10 12:16:00" fixdate="2007-01-11 08:43:18"><buginformation><summary>iajc Ant task doesn't support all warn options</summary><description>The iajc Ant task currently supports only a few of the options provided by the ajc compiler.

It would be nice if it could support them all so that builds done using the Ant task generate the same errors/warnings as the ones done within the Eclipse IDE.</description><comments/></buginformation><fixedCommits><commit id="53366032c9158823a2d7527df96046f34b773c9c" author="default" date="2007-01-11 08:43:18"><file name="taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java"><method name="toString" returnType="String" parameters=""/></file></commit></fixedCommits></bug><bug id="376" opendate="2007-01-25 09:24:00" fixdate="2007-02-16 10:02:27"><buginformation><summary>When ordering a Clean with Build Automatico I receive the error below.</summary><description>When executing an Clean Project in Eclipse with Automatic Building I receive the error below.

line from the top stack, e.g. "SomeFile.jara:243"

java.lang.NullPointerException
at org.aspectj.ajdt.internal.compiler.problem.AjProblemReporter.methodMustOverride(AjProblemReporter.java:380)
at org.aspectj.org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:153)
at org.aspectj.org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:400)
at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDe ... pter.java:107)
at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)

NullPointerException thrown: null</description><comments/></buginformation><fixedCommits><commit id="4177bedfe6e1fe4240fddb7de6b9eaed38b9f0cf" author="default" date="2007-02-16 10:02:27"><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/problem/AjProblemReporter.java"><method name="methodMustOverride" returnType="void" parameters="AbstractMethodDeclaration"/></file></commit></fixedCommits></bug><bug id="377" opendate="2007-02-21 16:02:00" fixdate="2007-03-06 09:59:56"><buginformation><summary>ArrayIndexOutOfBoundException Bug with Nested Type in TypeParameters</summary><description>I debugged this stack trace from load-time weaving (ajcore files are also available). I found that the signature argument to TypeFactory.createTypeFromSignature(String) is Pjava/lang/Enum&lt;Ljavax/jws/soap/SOAPBinding$ParameterStyle;&gt;; but the method is erroneously using an empty array of parameters, because it thinks the $ relates to the generic type, not the parameter. It should be fairly easy to reproduce with a test case and to fix with a patch - I'll look at it some more tonight or this week.

java.lang.ArrayIndexOutOfBoundsException
	at org.aspectj.weaver.ResolvedType.getMemberParameterizationMap(ResolvedType.java:698)
	at org.aspectj.weaver.ReferenceType.getDeclaredInterfaces(ReferenceType.java:406)
	at org.aspectj.weaver.ResolvedType.getDirectSupertypes(ResolvedType.java:65)
	at org.aspectj.weaver.patterns.TypePattern.matchesSubtypes(TypePattern.java:182)
	at org.aspectj.weaver.patterns.TypePattern.matchesSubtypes(TypePattern.java:169)
	at org.aspectj.weaver.patterns.TypePattern.matchesStatically(TypePattern.java:119)
	at org.aspectj.weaver.loadtime.ClassLoaderWeavingAdaptor.accept(ClassLoaderWeavingAdaptor.java:621)
	at org.aspectj.weaver.tools.WeavingAdaptor.weaveClass(WeavingAdaptor.java:253)
	at org.aspectj.weaver.loadtime.Aj.preProcess(Aj.java:78)
	at org.aspectj.weaver.loadtime.ClassPreProcessorAgentAdapter.transform(ClassPreProcessorAgentAdapter.java:52)
	at sun.instrument.TransformerManager.transform(TransformerManager.java:122)
	at sun.instrument.InstrumentationImpl.transform(InstrumentationImpl.java:155)
	at java.lang.ClassLoader.defineClass(Ljava.lang.String;[BIILjava.security.ProtectionDomain;)Ljava.lang.Class;(Unknown Source)
	at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:124)
	at java.net.URLClassLoader.defineClass(URLClassLoader.java:260)
	at java.net.URLClassLoader.access$100(URLClassLoader.java:56)
	at java.net.URLClassLoader$1.run(URLClassLoader.java:195)
	at java.net.URLClassLoader.findClass(URLClassLoader.java:188)
	at java.lang.ClassLoader.loadClass(Ljava.lang.String;Z)Ljava.lang.Class;(Unknown Source)
	at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:268)
	at java.lang.ClassLoader.loadClass(Ljava.lang.String;)Ljava.lang.Class;(Unknown Source)
	at java.lang.ClassLoader.loadClassFromNative(Ljava.lang.String;)Ljava.lang.Class;(Unknown Source)
	at java.lang.Class.forName(Ljava.lang.String;ZLjava.lang.ClassLoader;)Ljava.lang.Class;(Unknown Source)
	at jrockit.reflect.MemberAccess.getClassFromFieldDesc(Ljava.lang.String;ILjava.lang.ClassLoader;)Ljava.lang.Class;(Unknown Source)
	at jrockit.reflect.MemberAccess.getReturnClassFromMethodDesc(Ljava.lang.String;Ljava.lang.ClassLoader;)Ljava.lang.Class;(Unknown Source)</description><comments/></buginformation><fixedCommits><commit id="579ec14c9e86cdbaac656872e26f3e954e8f8946" author="default" date="2007-03-06 09:59:56"><file name="weaver/src/org/aspectj/weaver/TypeFactory.java"><method name="createTypeFromSignature" returnType="UnresolvedType" parameters="String"/></file></commit></fixedCommits></bug><bug id="378" opendate="2007-10-18 05:54:00" fixdate="2007-10-18 11:03:05"><buginformation><summary>[itds] Problem with ITDs appearing to be applied twice (and clashing) for binary types</summary><description>As reported by Josh on the mailing list:

I have the following 2 files:

 

Advised.aj:

 

package bugs;

 

public class Advised {}

aspect ITD {

          public void Advised.f() {}

}

 

Ref.aj:

 

package notbugs;

 

import bugs.Advised;

 

public class Ref {

          public void g() {

                   new Advised().f();

          }

}

 

I am attempting to build Advised.aj into a jar, and refer to it from Ref.aj, using the following ant build.xml:

 

&lt;?xml version="1.0"?&gt;

 

&lt;project name="Bugs" basedir="C:\workplace\imds\Bugs"

          xmlns:aj="antlib:org.aspectj"&gt;

          &lt;taskdef uri="antlib:org.aspectj" resource="org/aspectj/antlib.xml" classpath="./aspectjtools.jar"/&gt;

          &lt;target name="clean"&gt;

                   &lt;delete dir="bugs" includes="**/*.class"/&gt;

                   &lt;delete dir="notbugs" includes="**/*.class"/&gt;

          &lt;/target&gt;

          &lt;target name="task1"&gt;

                   &lt;aj:iajc srcdir="." destdir="." source="1.5" target="1.5"&gt;

                             &lt;classpath location=".\aspectjrt.jar"/&gt;

                             &lt;include name="bugs/Advised.aj"/&gt;

                   &lt;/aj:iajc&gt;

          &lt;/target&gt;

          &lt;target name="task2"&gt;

                   &lt;aj:iajc source="1.5" target="1.5" srcdir="."&gt;

                             &lt;classpath location=".\aspectjrt.jar"/&gt;

                             &lt;aspectpath location="."/&gt;

                             &lt;include name="notbugs/Ref.aj"/&gt;

                   &lt;/aj:iajc&gt;

          &lt;/target&gt;

&lt;/project&gt;

 

From within Eclipse, there are no build errors because this is all one project.  On the command line, however, once I execute 鈥渁nt task2鈥, I get the following marvelous error message which suggests that ajc is trying to ITD f into a class it already ITDd f into before:

 

  [aj:iajc] error at C:\workplace\imds\Bugs\bugs\Advised.aj:5::77 inter-type declaration from bugs.ITD conflicts with existing member: void bugs.Advised.f()

  [aj:iajc] MessageHolder:  (8 info)  (1 error)

  [aj:iajc] [error   0]: error at C:\workplace\imds\Bugs\bugs\Advised.aj:5::77 inter-type declaration from bugs.ITD conflicts with existing member: void bugs.Advised.f()

 

Let me also say that in my real use-case, the jar produced by task1 will contain aspects that should apply to clients thereof, and as such, that jar should indeed be in the aspectpath (not the classpath) for task2 (unless I am seriously misunderstanding something).

 

How to stop this duplicate attempt to ITD?

 

Josh

---

Josh is correct that using aspectpath will pull in the aspects for application to other types, the problem is that when pulling in type Advised, we reapply known ITDs and it clashes with the one added in the original build of the type.

Two possible fixes that I am looking at:
- don't reapply the ITDs (they are added to ensure type system is consistent) to binary types pulled in from the aspectpath
- recognize the ITD is clashing with a member previously applied through the same ITD

I am not sure we can determine it came from the aspectpath at the point the clash is detected.  I have option (2) already implemented, but I'll try a little more with option 1 before giving up ;)</description><comments/></buginformation><fixedCommits><commit id="797ec4d2ade426e40ada04881fdc83f799fd4cc9" author="default" date="2007-10-18 11:03:05"><file name="weaver/src/org/aspectj/weaver/ResolvedType.java"><method name="compareToExistingMembers" returnType="boolean" parameters="ConcreteTypeMunger"/></file></commit></fixedCommits></bug><bug id="379" opendate="2007-09-13 19:22:00" fixdate="2008-01-22 18:48:29"><buginformation><summary>AST: Type information not exposed on itmd, itfd...</summary><description>The Types:

org/aspectj/org/eclipse/jdt/core/dom/InterTypeFieldDeclaration.java
org/aspectj/org/eclipse/jdt/core/dom/InterTypeMethodDeclaration.java

Which can be returned by visiting the AjAST tree do not expose the name of the type on which the method or field is added. I require this information in the project I'm currently working on, and would appreciate if it was added.</description><comments/></buginformation><fixedCommits><commit id="114db350a407be5b0aa00d1b8b3baa60aa6911e2" author="default" date="2008-01-22 18:48:29"><file name="org.aspectj.ajdt.core/src/org/aspectj/org/eclipse/jdt/core/dom/AjASTConverter.java"><method name="convert" returnType="ASTNode" parameters="InterTypeFieldDeclaration"/><method name="convert" returnType="ASTNode" parameters=""/></file></commit></fixedCommits></bug><bug id="380" opendate="2008-02-25 06:34:00" fixdate="2008-02-25 21:39:45"><buginformation><summary>[compiler] NullpointerException during compile</summary><description>Created  attachment 90626   [details] 
example code producing the error

The attached code produces a NullpointerException when compiling it with aspectj.
I checked it with the following compiler versions: (using sun java 1.6.0.04)
ajc 1.5.3
AJDT 1.5.2.200802061816 (ajc 1.6.0.20080206212408)

Exception:
java.lang.NullPointerException
        at org.aspectj.weaver.Shadow.toResolvedString(Shadow.java:735)
        at org.aspectj.weaver.patterns.ArgsPointcut.findResidueNoEllipsis(ArgsPointcut.java:237)
        at org.aspectj.weaver.patterns.ArgsPointcut.findResidueInternal(ArgsPointcut.java:273)
        at org.aspectj.weaver.patterns.Pointcut.findResidue(Pointcut.java:269)
        at org.aspectj.weaver.patterns.AndPointcut.findResidueInternal(AndPointcut.java:94)
        at org.aspectj.weaver.patterns.Pointcut.findResidue(Pointcut.java:269)
        at org.aspectj.weaver.patterns.AndPointcut.findResidueInternal(AndPointcut.java:94)
        at org.aspectj.weaver.patterns.Pointcut.findResidue(Pointcut.java:269)
        at org.aspectj.weaver.bcel.BcelAdvice.specializeOn(BcelAdvice.java:146)
        at org.aspectj.weaver.bcel.BcelShadow.prepareForMungers(BcelShadow.java:327)
        at org.aspectj.weaver.Shadow.implement(Shadow.java:470)
        at org.aspectj.weaver.bcel.BcelClassWeaver.implement(BcelClassWeaver.java:2832)
        at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:506)
        at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:119)
        at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1612)
        at org.aspectj.weaver.bcel.BcelWeaver.weaveWithoutDump(BcelWeaver.java:1563)
        at org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify(BcelWeaver.java:1341)
        at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1135)
        at org.aspectj.ajdt.internal.compiler.AjPipeliningCompilerAdapter.weaveQueuedEntries(AjPipeliningCompilerAdapter.java:455)
        at org.aspectj.ajdt.internal.compiler.AjPipeliningCompilerAdapter.queueForWeaving(AjPipeliningCompilerAdapter.java:392)
        at org.aspectj.ajdt.internal.compiler.AjPipeliningCompilerAdapter.afterProcessing(AjPipeliningCompilerAdapter.java:380)
        at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$after$org_aspectj_ajdt_internal_compiler_CompilerAdapter$5$6b855184(CompilerAdapter.aj:98)
        at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:533)
        at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:329)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:906)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:260)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:176)
        at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:112)
        at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:60)
        at org.aspectj.tools.ajc.Main.run(Main.java:378)
        at org.aspectj.tools.ajc.Main.runMain(Main.java:253)
        at org.aspectj.tools.ajc.Main.main(Main.java:88)</description><comments/></buginformation><fixedCommits><commit id="5beab0ec09f8ccc7cea9778ea3d77e5d03486f0c" author="default" date="2008-02-25 21:39:45"><file name="weaver/src/org/aspectj/weaver/Shadow.java"><method name="toResolvedString" returnType="String" parameters="World"/></file></commit></fixedCommits></bug><bug id="381" opendate="2008-02-26 13:41:00" fixdate="2008-02-26 21:03:19"><buginformation><summary>mixup in retrieving the right class in Java15AnnotationFinder</summary><description>See  http://jira.springframework.org/browse/SPR-4390 

The problem is:

The method getAnnotations is called in the Java15AnnotationFinder - and the member that is passed is a method that is defined on some class C.  The bcelRepository is then used to load that class.  In the buggy situation there are two versions of the class around - one on the regular classpath and one in the core JVM classes (in this case JAXBContext on Java6).  

The member passed in is from the variant defined as a standard extension or core class.  For some reason the bcelRepository loads the Java5 version and then cannot find the member.  This is worse than a ClassNotFoundException which would case the AnnotationFinder to fall back on reflection.  I think the right thing to do now is recognize this situation and fall back on reflection - which will recover the annotations a different way.</description><comments/></buginformation><fixedCommits><commit id="9bbdb4128761575adb6e1c81e51b9c0bb1edb02a" author="default" date="2008-02-26 21:03:19"><file name="weaver5/java5-src/org/aspectj/weaver/reflect/Java15AnnotationFinder.java"><method name="getAnnotations" returnType="Set" parameters="Member"/><method name="getAnnotationDefaultValue" returnType="String" parameters="Member"/><method name="getAnnotationOfType" returnType="AnnotationX" parameters="UnresolvedType Member"/></file></commit></fixedCommits></bug><bug id="382" opendate="2008-02-21 12:47:00" fixdate="2008-02-26 23:54:38"><buginformation><summary>java.lang.NullPointerException in Java15AnnotationFinder when using SWT</summary><description>I receive the following Exception when running SWT with AspjectJ load time weaving through the Spring Framework.  The lines around org.aspectj.weaver.reflect.Java15AnnotationFinder.getAnnotations(Java15AnnotationFinder.java:123) are as follows:

for (int i = 0; i &lt; anns.length; i++) {
     annSet.add(world.resolve(UnresolvedType.forSignature(anns[i].getTypeSignature())));
}

When using the debugger, I see "world" as a null value.

Attached is a stripped down Eclipse project that generates the error during startup.  My runtime arguments are as follows:

-javaagent:${resource_loc:/AspectJBug/lib/spring-agent.jar}

--------------------------------------------

[AppClassLoader@19d819d8] abort trouble in: 
final class org.eclipse.swt.awt.SWT_AWT$10 extends java.lang.Object implements java.lang.Runnable:
  private final java.awt.Frame val$frame [Synthetic]
  void &lt;init&gt;(java.awt.Frame):
                    ALOAD_0     // Lorg/eclipse/swt/awt/SWT_AWT$10; this   (line 274)
                    INVOKESPECIAL java.lang.Object.&lt;init&gt; ()V
    constructor-execution(void org.eclipse.swt.awt.SWT_AWT$10.&lt;init&gt;(java.awt.Frame))
    |               ALOAD_0     // Lorg/eclipse/swt/awt/SWT_AWT$10; this   (line 1)
    |               ALOAD_1
    |               PUTFIELD org.eclipse.swt.awt.SWT_AWT$10.val$frame Ljava/awt/Frame;
    |               RETURN
    constructor-execution(void org.eclipse.swt.awt.SWT_AWT$10.&lt;init&gt;(java.awt.Frame))
  end void &lt;init&gt;(java.awt.Frame)

  public void run():
    method-execution(void org.eclipse.swt.awt.SWT_AWT$10.run())
    | catch java.lang.Throwable -&gt; E0
    | |             LDC "sun.awt.windows.WComponentPeer"   (line 277)
    | | method-call(java.lang.Class java.lang.Class.forName(java.lang.String))
    | | |           INVOKESTATIC java.lang.Class.forName (Ljava/lang/String;)Ljava/lang/Class;
    | | method-call(java.lang.Class java.lang.Class.forName(java.lang.String))
    | |             ASTORE_1
    | |             ALOAD_1     // Ljava/lang/Class; clazz   (line 278)
    | |             LDC "winGraphicsConfig"
    | | method-call(java.lang.reflect.Field java.lang.Class.getDeclaredField(java.lang.String))
    | | |           INVOKEVIRTUAL java.lang.Class.getDeclaredField (Ljava/lang/String;)Ljava/lang/reflect/Field;
    | | method-call(java.lang.reflect.Field java.lang.Class.getDeclaredField(java.lang.String))
    | |             ASTORE_2
    | |             ALOAD_2     // Ljava/lang/reflect/Field; field   (line 279)
    | |             ICONST_1
    | | method-call(void java.lang.reflect.Field.setAccessible(boolean))
    | | |           INVOKEVIRTUAL java.lang.reflect.Field.setAccessible (Z)V
    | | method-call(void java.lang.reflect.Field.setAccessible(boolean))
    | |             ALOAD_2     // Ljava/lang/reflect/Field; field   (line 280)
    | |             ALOAD_0     // Lorg/eclipse/swt/awt/SWT_AWT$10; this
    | |             GETFIELD org.eclipse.swt.awt.SWT_AWT$10.val$frame Ljava/awt/Frame;
    | | method-call(java.awt.peer.ComponentPeer java.awt.Frame.getPeer())
    | | |           INVOKEVIRTUAL java.awt.Frame.getPeer ()Ljava/awt/peer/ComponentPeer;
    | | method-call(java.awt.peer.ComponentPeer java.awt.Frame.getPeer())
    | |             ALOAD_0     // Lorg/eclipse/swt/awt/SWT_AWT$10; this
    | |             GETFIELD org.eclipse.swt.awt.SWT_AWT$10.val$frame Ljava/awt/Frame;
    | |             INVOKEVIRTUAL java.awt.Frame.getGraphicsConfiguration ()Ljava/awt/GraphicsConfiguration;
    | |             INVOKEVIRTUAL java.lang.reflect.Field.set (Ljava/lang/Object;Ljava/lang/Object;)V
    | catch java.lang.Throwable -&gt; E0
    |               GOTO L0
    |           E0: POP   (line 281)
    |           L0: RETURN   (line 282)
    method-execution(void org.eclipse.swt.awt.SWT_AWT$10.run())
  end public void run()

end final class org.eclipse.swt.awt.SWT_AWT$10
 -- (NullPointerException) null
null
java.lang.NullPointerException
	at org.aspectj.weaver.reflect.Java15AnnotationFinder.getAnnotations(Java15AnnotationFinder.java:123)
	at org.aspectj.weaver.reflect.ReflectionBasedResolvedMemberImpl.unpackAnnotations(ReflectionBasedResolvedMemberImpl.java:174)
	at org.aspectj.weaver.reflect.ReflectionBasedResolvedMemberImpl.hasAnnotation(ReflectionBasedResolvedMemberImpl.java:158)
	at org.aspectj.weaver.patterns.ExactAnnotationTypePattern.matches(ExactAnnotationTypePattern.java:82)
	at org.aspectj.weaver.patterns.AnnotationPointcut.matchInternal(AnnotationPointcut.java:151)
	at org.aspectj.weaver.patterns.Pointcut.match(Pointcut.java:146)
	at org.aspectj.weaver.patterns.AndPointcut.matchInternal(AndPointcut.java:52)
	at org.aspectj.weaver.patterns.Pointcut.match(Pointcut.java:146)
	at org.aspectj.weaver.ShadowMunger.match(ShadowMunger.java:75)
	at org.aspectj.weaver.Advice.match(Advice.java:112)
	at org.aspectj.weaver.bcel.BcelAdvice.match(BcelAdvice.java:118)
	at org.aspectj.weaver.bcel.BcelClassWeaver.match(BcelClassWeaver.java:2811)
	at org.aspectj.weaver.bcel.BcelClassWeaver.matchInvokeInstruction(BcelClassWeaver.java:2773)
	at org.aspectj.weaver.bcel.BcelClassWeaver.match(BcelClassWeaver.java:2506)
	at org.aspectj.weaver.bcel.BcelClassWeaver.match(BcelClassWeaver.java:2332)
	at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:494)
	at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:119)
	at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1651)
	at org.aspectj.weaver.bcel.BcelWeaver.weaveWithoutDump(BcelWeaver.java:1602)
	at org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify(BcelWeaver.java:1380)
	at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1200)
	at org.aspectj.weaver.tools.WeavingAdaptor.getWovenBytes(WeavingAdaptor.java:360)
	at org.aspectj.weaver.tools.WeavingAdaptor.weaveClass(WeavingAdaptor.java:262)
	at org.aspectj.weaver.loadtime.Aj.preProcess(Aj.java:78)
	at org.aspectj.weaver.loadtime.ClassPreProcessorAgentAdapter.transform(ClassPreProcessorAgentAdapter.java:52)
	at org.springframework.context.weaving.AspectJWeavingEnabler$AspectJClassBypassingClassFileTransformerDecorator.transform(AspectJWeavingEnabler.java:84)
	at sun.instrument.TransformerManager.transform(TransformerManager.java:141)
	at sun.instrument.InstrumentationImpl.transform(InstrumentationImpl.java:174)
	at java.lang.ClassLoader.defineClassImpl(Native Method)
	at java.lang.ClassLoader.defineClass(ClassLoader.java:228)
	at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:148)
	at java.net.URLClassLoader.defineClass(URLClassLoader.java:557)
	at java.net.URLClassLoader.access$400(URLClassLoader.java:120)
	at java.net.URLClassLoader$ClassFinder.run(URLClassLoader.java:962)
	at java.security.AccessController.doPrivileged(AccessController.java:275)
	at java.net.URLClassLoader.findClass(URLClassLoader.java:488)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:607)
	at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:327)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:573)
	at org.eclipse.swt.awt.SWT_AWT.new_Frame(SWT_AWT.java:274)

Feb 21, 2008 12:09:23 PM org.aspectj.weaver.tools.Jdk14Trace error
SEVERE: org/eclipse/swt/awt/SWT_AWT$10
java.lang.NullPointerException
	at org.aspectj.weaver.reflect.Java15AnnotationFinder.getAnnotations(Java15AnnotationFinder.java:123)
	at org.aspectj.weaver.reflect.ReflectionBasedResolvedMemberImpl.unpackAnnotations(ReflectionBasedResolvedMemberImpl.java:174)
	at org.aspectj.weaver.reflect.ReflectionBasedResolvedMemberImpl.hasAnnotation(ReflectionBasedResolvedMemberImpl.java:158)
	at org.aspectj.weaver.patterns.ExactAnnotationTypePattern.matches(ExactAnnotationTypePattern.java:82)
	at org.aspectj.weaver.patterns.AnnotationPointcut.matchInternal(AnnotationPointcut.java:151)
	at org.aspectj.weaver.patterns.Pointcut.match(Pointcut.java:146)
	at org.aspectj.weaver.patterns.AndPointcut.matchInternal(AndPointcut.java:52)
	at org.aspectj.weaver.patterns.Pointcut.match(Pointcut.java:146)
	at org.aspectj.weaver.ShadowMunger.match(ShadowMunger.java:75)
	at org.aspectj.weaver.Advice.match(Advice.java:112)
	at org.aspectj.weaver.bcel.BcelAdvice.match(BcelAdvice.java:118)
	at org.aspectj.weaver.bcel.BcelClassWeaver.match(BcelClassWeaver.java:2811)
	at org.aspectj.weaver.bcel.BcelClassWeaver.matchInvokeInstruction(BcelClassWeaver.java:2773)
	at org.aspectj.weaver.bcel.BcelClassWeaver.match(BcelClassWeaver.java:2506)
	at org.aspectj.weaver.bcel.BcelClassWeaver.match(BcelClassWeaver.java:2332)
	at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:494)
	at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:119)
	at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1651)
	at org.aspectj.weaver.bcel.BcelWeaver.weaveWithoutDump(BcelWeaver.java:1602)
	at org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify(BcelWeaver.java:1380)
	at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1200)
	at org.aspectj.weaver.tools.WeavingAdaptor.getWovenBytes(WeavingAdaptor.java:360)
	at org.aspectj.weaver.tools.WeavingAdaptor.weaveClass(WeavingAdaptor.java:262)
	at org.aspectj.weaver.loadtime.Aj.preProcess(Aj.java:78)
	at org.aspectj.weaver.loadtime.ClassPreProcessorAgentAdapter.transform(ClassPreProcessorAgentAdapter.java:52)
	at org.springframework.context.weaving.AspectJWeavingEnabler$AspectJClassBypassingClassFileTransformerDecorator.transform(AspectJWeavingEnabler.java:84)
	at sun.instrument.TransformerManager.transform(TransformerManager.java:141)
	at sun.instrument.InstrumentationImpl.transform(InstrumentationImpl.java:174)
	at java.lang.ClassLoader.defineClassImpl(Native Method)
	at java.lang.ClassLoader.defineClass(ClassLoader.java:228)
	at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:148)
	at java.net.URLClassLoader.defineClass(URLClassLoader.java:557)
	at java.net.URLClassLoader.access$400(URLClassLoader.java:120)
	at java.net.URLClassLoader$ClassFinder.run(URLClassLoader.java:962)
	at java.security.AccessController.doPrivileged(AccessController.java:275)
	at java.net.URLClassLoader.findClass(URLClassLoader.java:488)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:607)
	at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:327)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:573)
	at org.eclipse.swt.awt.SWT_AWT.new_Frame(SWT_AWT.java:274)</description><comments/></buginformation><fixedCommits><commit id="1bbe6f988d26d08b3482d0875d588ea1d1eb039f" author="default" date="2008-02-26 23:54:38"><file name="weaver5/java5-src/org/aspectj/weaver/reflect/Java15ReflectionBasedReferenceTypeDelegate.java"><method name="initialize" returnType="void" parameters="ReferenceType Class"/></file></commit></fixedCommits></bug><bug id="383" opendate="2008-02-27 21:16:00" fixdate="2008-02-28 20:50:38"><buginformation><summary>unsynchronized access to WeakHashMap</summary><description>Created  attachment 90955   [details] 
patch to World.java

Build ID: M20071023-1652

Steps To Reproduce:
1. org.aspectj.weaver.World.expendableMap is defined as a java.util.WeakHashMap
2. java.util.WeakHashMap is not thread safe
3. we have observed that expendableMap can be updated concurrently by multiple threads under load which will corrupt the internal hashmap structure resulting in infinite loops when get() is called


More information:</description><comments/></buginformation><fixedCommits><commit id="caf8960e2b98d6bbd4e5ade65f05e128c240ddc3" author="default" date="2008-02-28 20:50:38"><file name="weaver/src/org/aspectj/weaver/World.java"><method name="isTargettingAspectJRuntime12" returnType="boolean" parameters=""/></file></commit></fixedCommits></bug><bug id="384" opendate="2007-06-19 12:01:00" fixdate="2008-03-10 18:09:16"><buginformation><summary>NPE on attempt to compile</summary><description>I can't really pinpoint any code that trigger this. It happens on for an incremental, and only some of the time. If I do a full build of the project then I do not get the error and all seems to work.

----

java.lang.NullPointerException
at org.aspectj.weaver.bcel.BcelWeaver.raiseUnboundFormalError(BcelWeaver.java:833)
at org.aspectj.weaver.bcel.BcelWeaver.validateSingleBranch(BcelWeaver.java:688)
at org.aspectj.weaver.bcel.BcelWeaver.validateBindings(BcelWeaver.java:627)
at org.aspectj.weaver.bcel.BcelWeaver.rewritePointcuts(BcelWeaver.java:556)
at org.aspectj.weaver.bcel.BcelWeaver.prepareForWeave(BcelWeaver.java:484)
at org.aspectj.ajd ... oBuildJob.run(AutoBuildJob.java:235)
at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

Compile error: NullPointerException thrown: null</description><comments/></buginformation><fixedCommits><commit id="a31b3dea01cbf925e6b22ef8789b3a3d86fd9160" author="default" date="2008-03-10 18:09:16"><file name="weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java"><method name="raiseUnboundFormalError" returnType="void" parameters="String Pointcut"/></file></commit></fixedCommits></bug><bug id="385" opendate="2008-03-12 12:45:00" fixdate="2008-03-12 17:51:13"><buginformation><summary>MANIFEST.MF copying is not always reliable</summary><description>Sometimes an AJDT project gets into a state where it has a meta-inf/manifest.mf - and this file fails to make it out to the destination folder.</description><comments/></buginformation><fixedCommits><commit id="906c84944b2e740a1bd781e936d48b31ce09b9ac" author="default" date="2008-03-12 17:51:13"><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"><method name="copyResourcesFromFile" returnType="void" parameters="File String File"/><method name="copyResourcesFromJarFile" returnType="void" parameters="File"/><method name="acceptResource" returnType="boolean" parameters="String"/></file></commit></fixedCommits></bug><bug id="386" opendate="2008-03-17 13:57:00" fixdate="2008-03-20 15:48:59"><buginformation><summary>More NPEs in Java15AnnotationFinder</summary><description>Reported on the list by Chris Wall and on spring bug  http://jira.springframework.org/browse/SPR-4390 

---
When my plugin is initiated and during Spring context beans loading,
we're getting the following:

Caused by: java.lang.NullPointerException
       at org.aspectj.weaver.reflect.Java15AnnotationFinder.getParameterNamesFromLVT(Java15AnnotationFinder.java:196)
       at org.aspectj.weaver.reflect.Java15AnnotationFinder.getParameterNames(Java15AnnotationFinder.java:187)
       at org.aspectj.weaver.reflect.Java15ReflectionBasedReferenceTypeDelegate.tryToDiscoverParameterNames(Java15ReflectionBasedReferenceTypeDelegate.java:297)
       at org.aspectj.weaver.reflect.Java15ReflectionBasedReferenceTypeDelegate.getDeclaredPointcuts(Java15ReflectionBasedReferenceTypeDelegate.java:270)
       at org.aspectj.weaver.ReferenceType.getDeclaredPointcuts(ReferenceType.java:535)
       at org.aspectj.weaver.ResolvedType$7.get(ResolvedType.java:477)
       at org.aspectj.weaver.Iterators$3$1.hasNext(Iterators.java:118)
       at org.aspectj.weaver.Iterators$3.hasNext(Iterators.java:128)
       at org.aspectj.weaver.ResolvedType.findPointcut(ResolvedType.java:488)
       at org.aspectj.weaver.patterns.ReferencePointcut.resolveBindings(ReferencePointcut.java:152)
       at org.aspectj.weaver.patterns.Pointcut.resolve(Pointcut.java:196)
       at org.aspectj.weaver.tools.PointcutParser.resolvePointcutExpression(PointcutParser.java:330)
       at org.aspectj.weaver.tools.PointcutParser.parsePointcutExpression(PointcutParser.java:308)
       at org.springframework.aop.aspectj.AspectJExpressionPointcut.buildPointcutExpression(AspectJExpressionPointcut.java:197)
       at org.springframework.aop.aspectj.AspectJExpressionPointcut.checkReadyToMatch(AspectJExpressionPointcut.java:184)
       at org.springframework.aop.aspectj.AspectJExpressionPointcut.getClassFilter(AspectJExpressionPointcut.java:165)
       at org.springframework.aop.support.AopUtils.canApply(AopUtils.java:198)
       at org.springframework.aop.support.AopUtils.canApply(AopUtils.java:253)
       at org.springframework.aop.support.AopUtils.findAdvisorsThatCanApply(AopUtils.java:287)
       at org.springframework.aop.framework.autoproxy.AbstractAdvisorAutoProxyCreator.findAdvisorsThatCanApply(AbstractAdvisorAutoProxyCreator.java:113)
       at org.springframework.aop.framework.autoproxy.AbstractAdvisorAutoProxyCreator.findEligibleAdvisors(AbstractAdvisorAutoProxyCreator.java:85)
       at org.springframework.aop.framework.autoproxy.AbstractAdvisorAutoProxyCreator.getAdvicesAndAdvisorsForBean(AbstractAdvisorAutoProxyCreator.java:66)
       at org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator.wrapIfNecessary(AbstractAutoProxyCreator.java:345)
       at org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator.postProcessAfterInitialization(AbstractAutoProxyCreator.java:309)
       at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsAfterInitialization(AbstractAutowireCapableBeanFactory.java:360)
       at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1343)
       at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:470)

I've tried with with Spring 2.5.2 and 2.5.3 with JDK 1.5. We're using
"@AspectJ" so &lt;aop:aspectj-autoproxy/&gt; is set, and aspectjweaver.jar
and aspectjrt.jar are included. The Spring IDE shows that AOP advise
is applied to expected pointcuts. When compiled and run outside of the
Spring IDE, the application encounters the NPE.

Ideas?</description><comments/></buginformation><fixedCommits><commit id="6c54db924759b08effc806a93f633515c3e3a5d2" author="default" date="2008-03-20 15:48:59"><file name="weaver5/java5-src/org/aspectj/weaver/reflect/Java15AnnotationFinder.java"><method name="getParameterNamesFromLVT" returnType="String[]" parameters="LocalVariableTable int"/></file></commit></fixedCommits></bug><bug id="387" opendate="2006-11-08 08:48:00" fixdate="2008-03-21 01:43:30"><buginformation><summary>Compilation error</summary><description>Hello,

I had several times aspectj compiler errors when compiling some normal java class file (not refering any aspect nor concerned by an aspect) but in a aspectJ project. Bug goes away after cleaning project. 

Here is the error reported for my class
java.lang.NullPointerException
at org.aspectj.weaver.ResolvedType.collectInterTypeMungers(ResolvedType.java:1158)
at org.aspectj.weaver.ResolvedType.collectInterTypeMungers(ResolvedType.java:1158)
at org.aspectj.weaver.ResolvedType.getInterTypeMungersIncludingSupers(ResolvedType.java:1135)
at org.aspectj.weaver.ResolvedType.checkInterTypeMungers(ResolvedType.java:1202)
at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.weaveInt ... Adapter.java:102)
at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)

NullPointerException thrown: null


It occurs with plugin configuration:
com.ibm.icu (3.4.5) "International Components for Unicode for Java (ICU4J)" [Active]
com.ibm.icu.source (3.4.5) "International Components for Unicode for Java (ICU4J) source plug-in" [Resolved]
com.jcraft.jsch (0.1.28) "JSch" [Resolved]
net.sf.fjep.fatjar (0.0.24) "Fat Jar Plug-in" [Resolved]
org.apache.ant (1.6.5) "Apache Ant" [Resolved]
org.apache.lucene (1.4.103.v20060601) "Apache Lucene" [Resolved]
org.aspectj.ajde (1.5.3.200610201049) "AspectJ" [Active]
org.aspectj.runtime (1.5.3.200610201049) "AspectJ Runtime" [Resolved]
org.aspectj.weaver (1.5.3.200610201049) "AspectJ Weaver" [Resolved]
org.eclipse.ajdt.core (1.4.1.200611071030) "AspectJ Development Tools Core" [Active]
org.eclipse.ajdt.examples (1.4.1.200611071030) "AspectJ Examples" [Resolved]
org.eclipse.ajdt.pde.build (1.4.1.200611071030) "AspectJ Plug-in Development Environment Build Support" [Resolved]
org.eclipse.ajdt.source (1.4.1.200611071030) "pluginName" [Resolved]
org.eclipse.ajdt.ui (1.4.1.200611071030) "AspectJ Development Tools UI" [Active]
org.eclipse.ant.core (3.1.100.v20060531) "Ant Build Tool Core" [Resolved]
org.eclipse.ant.ui (3.2.1.r321_v20060828) "Ant UI" [Resolved]
org.eclipse.aspectj (1.4.1.200611071030) "AspectJ Development Tools" [Resolved]
org.eclipse.compare (3.2.1.M20060711) "Compare Support" [Active]
org.eclipse.contribution.visualiser (2.2.0.200611071030) "Visualiser Plug-in" [Resolved]
org.eclipse.contribution.xref.core (1.4.1.200611071030) "Cross Reference Core Plugin" [Active]
org.eclipse.contribution.xref.ui (1.4.1.200611071030) "Cross Reference UI Plugin" [Active]
org.eclipse.core.boot (3.1.100.v20060603) "Core Boot" [Resolved]
org.eclipse.core.commands (3.2.0.I20060605-1400) "Commands" [Resolved]
org.eclipse.core.contenttype (3.2.0.v20060603) "Eclipse Content Mechanism" [Active]
org.eclipse.core.expressions (3.2.1.r321_v20060721) "Expression Language" [Active]
org.eclipse.core.filebuffers (3.2.1.r321_v20060721) "File Buffers" [Active]
org.eclipse.core.filesystem (1.0.0.v20060603) "Core File Systems" [Resolved]
org.eclipse.core.filesystem.macosx (1.0.0.v20060603) "Core File System for Macintosh" [Resolved]
org.eclipse.core.jobs (3.2.0.v20060603) "Eclipse Jobs Mechanism" [Active]
org.eclipse.core.resources (3.2.1.R32x_v20060914) "Core Resource Management" [Active]
org.eclipse.core.resources.compatibility (3.2.0.v20060603) "Core Resource Management Compatibility Fragment" [Resolved]
org.eclipse.core.runtime (3.2.0.v20060603) "Core Runtime" [Active]
org.eclipse.core.runtime.compatibility (3.1.100.v20060603) "Core Runtime Plug-in Compatibility" [Active]
org.eclipse.core.runtime.compatibility.auth (3.2.0.v20060601) "Authorization Compatibility Plug-in" [Active]
org.eclipse.core.runtime.compatibility.registry (3.2.1.R32x_v20060907) "Eclipse Registry Compatibility Fragment" [Resolved]
org.eclipse.core.variables (3.1.100.v20060605) "Core Variables" [Active]
org.eclipse.debug.core (3.2.1.v20060823) "Debug Core" [Active]
org.eclipse.debug.ui (3.2.1.v20060823) "Debug UI" [Active]
org.eclipse.equinox.common (3.2.0.v20060603) "Common Eclipse Runtime" [Active]
org.eclipse.equinox.preferences (3.2.1.R32x_v20060717) "Eclipse Preferences Mechanism" [Active]
org.eclipse.equinox.registry (3.2.1.R32x_v20060814) "Extension Registry Support" [Active]
org.eclipse.help (3.2.1.R321_v20060920) "Help System Core" [Active]
org.eclipse.help.appserver (3.1.100.v20060602) "Help Application Server" [Resolved]
org.eclipse.help.base (3.2.1.R321_v20060822) "Help System Base" [Resolved]
org.eclipse.help.ui (3.2.0.v20060602) "Help System UI" [Resolved]
org.eclipse.help.webapp (3.2.1.R321_v20060803) "Help System Webapp" [Resolved]
org.eclipse.jdt (3.2.1.r321_v20060823) "Eclipse Java Development Tools" [Resolved]
org.eclipse.jdt.apt.core (3.2.1.R32x_v20060822-2100) "Java Annotation Processing Core" [Active]
org.eclipse.jdt.apt.ui (3.2.1.R32x_v20060822-2100) "Java Annotation Processing UI" [Resolved]
org.eclipse.jdt.core (3.2.1.v_677_R32x) "Java Development Tools Core" [Active]
org.eclipse.jdt.core.manipulation (1.0.1.r321_v20060721) "Java Code Manipulation Functionality" [Resolved]
org.eclipse.jdt.debug (3.2.1.r321_v20060731) "JDI Debug Model" [Active]
org.eclipse.jdt.debug.ui (3.2.1.r321_v20060918) "JDI Debug UI" [Active]
org.eclipse.jdt.doc.isv (3.2.1.r321_v20060907) "Eclipse JDT Plug-in Developer Guide" [Resolved]
org.eclipse.jdt.doc.user (3.2.0.v20060605-1400) "Eclipse Java Development User Guide" [Resolved]
org.eclipse.jdt.junit (3.2.1.r321_v20060810) "Java Development Tools JUnit support" [Active]
org.eclipse.jdt.junit.runtime (3.2.1.r321_v20060721) "Java Development Tools JUnit runtime support" [Resolved]
org.eclipse.jdt.junit4.runtime (1.0.1.r321_v20060905) "Java Development Tools JUnit4 runtime support" [Resolved]
org.eclipse.jdt.launching (3.2.1.r321_v20060731) "Java Development Tools Launching Support" [Active]
org.eclipse.jdt.launching.macosx (3.1.100.v20060605) "Mac OS X Launcher" [Active]
org.eclipse.jdt.source (3.2.1.r321_v20060905-R4CM1Znkvre9wC-) "Eclipse Java Development Tools SDK" [Resolved]
org.eclipse.jdt.source.macosx.carbon.ppc (3.2.1.r321_v20060905-R4CM1Znkvre9wC-) "Eclipse Java Development Tools SDK" [Resolved]
org.eclipse.jdt.ui (3.2.1.r321_v20060907) "Java Development Tools UI" [Active]
org.eclipse.jface (3.2.1.M20060908-1000) "JFace" [Resolved]
org.eclipse.jface.databinding (1.0.0.I20060605-1400) "JFace Data Binding" [Resolved]
org.eclipse.jface.text (3.2.1.r321_v20060810) "JFace Text" [Resolved]
org.eclipse.ltk.core.refactoring (3.2.1.r321_v20060823) "Refactoring Core" [Active]
org.eclipse.ltk.ui.refactoring (3.2.1.r321_v20060726) "Refactoring UI" [Active]
org.eclipse.osgi.services (3.1.100.v20060601) "OSGi Release 3 Services" [Resolved]
org.eclipse.osgi.util (3.1.100.v20060601) "OSGi R3 Utility Classes" [Resolved]
org.eclipse.pde (3.2.1.v20060810-0800) "Eclipse Plug-in Development Environment" [Resolved]
org.eclipse.pde.build (3.2.1.r321_v20060823) "Plug-in Development Environment Build Support" [Resolved]
org.eclipse.pde.core (3.2.1.v20060915-0800) "Plug-in Development Core" [Resolved]
org.eclipse.pde.doc.user (3.2.1.v20060816-0800) "Eclipse Plug-in Development User Guide" [Resolved]
org.eclipse.pde.junit.runtime (3.2.0.v20060605) "PDE JUnit Plug-in Test" [Resolved]
org.eclipse.pde.runtime (3.2.0.v20060605) "Plug-in Development Environment Runtime" [Resolved]
org.eclipse.pde.source (3.2.1.r321_v20060823-6vYLLdQ3Nk8DrFG) "Eclipse Plug-in Development Environment Developer Resources" [Resolved]
org.eclipse.pde.ui (3.2.1.v20060816-0800) "Plug-in Development UI" [Resolved]
org.eclipse.platform (3.2.0.v20060601) "Eclipse Platform" [Resolved]
org.eclipse.platform.doc.isv (3.2.1.r321_v2006030) "Eclipse Platform Plug-in Developer Guide" [Resolved]
org.eclipse.platform.doc.user (3.2.1.R32x_v200608101155) "Eclipse Workbench User Guide" [Resolved]
org.eclipse.platform.source (3.2.1.r321_v20060921-b_XVA-INSQSyMtx) "Eclipse Platform Plug-in Developer Resources" [Resolved]
org.eclipse.platform.source.macosx.carbon.ppc (3.2.1.r321_v20060921-b_XVA-INSQSyMtx) "Eclipse Platform Plug-in Developer Resources" [Resolved]
org.eclipse.rcp (3.2.0.v20060605) "Eclipse RCP" [Resolved]
org.eclipse.rcp.source (3.2.1.r321_v20060801-2ekW2BxmcpPUOoq) "Eclipse RCP Plug-in Developer Resources" [Resolved]
org.eclipse.rcp.source.macosx.carbon.ppc (3.2.1.r321_v20060801-2ekW2BxmcpPUOoq) "Eclipse RCP Plug-in Developer Resources" [Resolved]
org.eclipse.sdk (3.2.1.r321_v20060705) "Eclipse Project SDK" [Resolved]
org.eclipse.search (3.2.1.r321_v20060726) "Search Support" [Resolved]
org.eclipse.swt (3.2.1.v3235e) "Standard Widget Toolkit" [Resolved]
org.eclipse.swt.carbon.macosx (3.2.1.v3235) "Standard Widget Toolkit for Mac OS X (Carbon)" [Resolved]
org.eclipse.team.core (3.2.1.M20060711) "Team Support Core" [Active]
org.eclipse.team.cvs.core (3.2.1.M200608161750) "CVS Team Provider Core" [Active]
org.eclipse.team.cvs.ssh (3.2.0.I200606011710) "CVS SSH Core" [Resolved]
org.eclipse.team.cvs.ssh2 (3.2.0.I200606051140) "CVS SSH2" [Active]
org.eclipse.team.cvs.ui (3.2.1.M20060831) "CVS Team Provider UI" [Active]
org.eclipse.team.ui (3.2.1.M200608151725) "Team Support UI" [Active]
org.eclipse.text (3.2.0.v20060605-1400) "Text" [Resolved]
org.eclipse.tomcat (4.1.130.v20060601) "Tomcat Wrapper" [Resolved]
org.eclipse.ui (3.2.1.M20060913-0800) "Eclipse UI" [Active]
org.eclipse.ui.browser (3.2.0.v20060602) "Browser Support" [Active]
org.eclipse.ui.carbon (3.2.0.I20060605-1400) "Eclipse UI MacOS X Enhancements" [Resolved]
org.eclipse.ui.cheatsheets (3.2.1.R321_v20060720) "Cheat Sheets" [Resolved]
org.eclipse.ui.console (3.1.100.v20060605) "Console" [Active]
org.eclipse.ui.editors (3.2.1.r321_v20060721) "Default Text Editor" [Active]
org.eclipse.ui.externaltools (3.1.101.r321_v20060802) "External Tools" [Active]
org.eclipse.ui.forms (3.2.0.v20060602) "Eclipse Forms" [Active]
org.eclipse.ui.ide (3.2.1.M20060915-1030) "Eclipse IDE UI" [Active]
org.eclipse.ui.intro (3.2.1.R321_v20060810) "Welcome Framework" [Resolved]
org.eclipse.ui.intro.universal (3.2.1.R321_v20060905) "Universal Welcome" [Resolved]
org.eclipse.ui.navigator (3.2.1.M20060913-0800) "Common Navigator View" [Resolved]
org.eclipse.ui.navigator.resources (3.2.1.M20060906-0800b) "Navigator Workbench Components" [Resolved]
org.eclipse.ui.presentations.r21 (3.2.0.I20060605-1400) "R21 Presentation Plug-in" [Resolved]
org.eclipse.ui.views (3.2.1.M20060906-0800) "Views" [Active]
org.eclipse.ui.views.properties.tabbed (3.2.1.M20060830-0800) "Tabbed Properties View" [Resolved]
org.eclipse.ui.workbench (3.2.1.M20060906-0800) "Workbench" [Active]
org.eclipse.ui.workbench.compatibility (3.2.0.I20060605-1400) "Workbench Compatibility" [Resolved]
org.eclipse.ui.workbench.texteditor (3.2.0.v20060605-1400) "Text Editor Framework" [Active]
org.eclipse.update.configurator (3.2.1.v20092006) "Install/Update Configurator" [Active]
org.eclipse.update.core (3.2.1.v20092006) "Install/Update Core" [Active]
org.eclipse.update.scheduler (3.2.1.v20092006) "Automatic Updates Scheduler" [Active]
org.eclipse.update.ui (3.2.1.v20092006) "Install/Update UI" [Resolved]
org.junit (3.8.1) "JUnit Testing Framework" [Resolved]
org.junit4 (4.1.0.1) "JUnit Testing Framework Version 4" [Resolved]
sf.eclipse.javacc (1.5.5) "JavaCC Plug-in" [Active]
system.bundle (3.2.1.R32x_v20060919) "OSGi System Bundle" [Active]</description><comments/></buginformation><fixedCommits><commit id="fe99e6bfec2689b03ffcfd7da960e3cd3bd78a54" author="default" date="2008-03-21 01:43:30"><file name="weaver/src/org/aspectj/weaver/ResolvedType.java"><method name="collectInterTypeMungers" returnType="void" parameters="List"/></file></commit></fixedCommits></bug><bug id="388" opendate="2007-04-27 11:00:00" fixdate="2008-03-21 18:14:28"><buginformation><summary>AjLookupEnvironment.java:519</summary><description>Build ID: Eclipse SDK

Version: 3.2.2
M20070212-1330

Steps To Reproduce:
This occured repeatedly when I saved a .aj file or a .java file that was boing advised.  A restart of eclipse made it go away and it has not happen again so I don't know how reproduce it. Sorry.

AJDT version 1.4.2.200703020612

More information:
java.lang.NullPointerException
at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.doDeclareAnnotations(AjLookupEnvironment.java:803)
at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.weaveInterTypeDeclarations(AjLookupEnvironment.java:592)
at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.weaveInterTypeDeclarations(AjLookupEnvironment.java:519)
at org.aspectj.ajdt.internal.compiler.lookup.AjLookupE ... AutoBuildJob.run(AutoBuildJob.java:217)
at org.eclipse.core.internal.jobs.Worker.run(Worker.java:58)

Compile error: NullPointerException thrown: null</description><comments/></buginformation><fixedCommits><commit id="8ce9dcfa94ad3c702fa0bbc8529d6e4b169661a6" author="default" date="2008-03-21 18:14:28"><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java"><method name="doDeclareAnnotations" returnType="boolean" parameters="DeclareAnnotation"/></file></commit></fixedCommits></bug><bug id="389" opendate="2008-03-31 14:11:00" fixdate="2008-04-01 04:48:31"><buginformation><summary>AjcTask doesn't work with Java6</summary><description>Although support for Java6 has been added in the last milestone, you can't use it from ant because AjcTask doesn't recognize the "source=1.6" and "target=1.6" parameters.

It's easy to fix by modifying AjcTask.java and adding the missing constants:

     static final String[] TARGET_INPUTS = new String [] 
    { "1.1", "1.2", "1.3", "1.4", "1.5", "1.6" };
    static final String[] SOURCE_INPUTS = new String [] 
    { "1.3", "1.4", "1.5", "1.6" };
    static final String[] COMPLIANCE_INPUTS = new String [] 
    { "-1.3", "-1.4", "-1.5", "-1.6" };

Thanks.</description><comments/></buginformation><fixedCommits><commit id="6bdb87d7462fd4fee4ec474937d4ad18b59b0852" author="default" date="2008-04-01 04:48:31"><file name="taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java"><method name="toString" returnType="String" parameters=""/></file></commit></fixedCommits></bug><bug id="390" opendate="2008-04-24 05:32:00" fixdate="2008-04-24 16:45:17"><buginformation><summary>AST Support for PointcutDesignators</summary><description>I would like an enhancement to be able to match two PointcutDesignators (called 'pointcut definitions' in the AJ5 quick reference). Currently, the following test fails:

---------------AjASTMatcherTest.java---------------
public void testMatchDefaultPointcut() {
  AjAST ast = AjAST.newAjAST(AST.JLS3);
  DefaultPointcut dp1 = ast.newDefaultPointcut();
  DefaultPointcut dp2 = ast.newDefaultPointcut();
  dp1.setDetail("call(* *.foo(..)");
  dp2.setDetail("call(* *.bar(..)");
  assertFalse(dp1.subtreeMatch(new AjASTMatcher(), dp2));
}
---------------------------------------------------

The reason is that there are no implementations for the many different kinds of pointcut definitions of AspectJ. Instead, DefaultPointcut simply contains the pointcut definition in a String-field "detail" as shown in the test case. The same is true for DefaultTypePattern and SignaturePattern. Additionally, in the current implementation a DefaultPointcut, DefaultTypePattern, and SignaturePattern node will always match another AST node if that node is of the same type (instanceof).

From what I see, it is necessary to 
1) add types for every possible pointcut definition,
2) extend the current implementation of type name patterns and 
3) signature patterns,
4) extend the parser (internal and external?) to create nodes for the pointcut definitions,
5) extend the converter to convert the new node types, and finally
6) extend the matcher to be able to match two pointcut definitions.

Implementation is already done for combinations of poincuts using and (&amp;&amp;), or (||), not (!), cflow, and reference pointcuts (without parameters).

Please comment on the task list as it is just an initial overview resulting from my limited knowledge on this field.</description><comments/></buginformation><fixedCommits><commit id="bed3f4e45a663bc7c366bea3c66e17b27d3410e2" author="default" date="2008-04-24 16:45:17"><file name="org.aspectj.ajdt.core/src/org/aspectj/org/eclipse/jdt/core/dom/AjASTMatcher.java"><method name="match" returnType="boolean" parameters="SignaturePattern Object"/><method name="match" returnType="boolean" parameters="DefaultPointcut Object"/><method name="match" returnType="boolean" parameters="DefaultTypePattern Object"/></file></commit></fixedCommits></bug><bug id="391" opendate="2008-05-06 22:43:00" fixdate="2008-05-07 15:31:18"><buginformation><summary>LazyMethodGen.remap() NullPointerException</summary><description>This has been reported a few times by different users, but has always proved tough to diagnose.  The typical stack trace is something like:

java.lang.NullPointerException
org.aspectj.weaver.bcel.LazyMethodGen.remap(LazyMethodGen.java:1237)
org.aspectj.weaver.bcel.LazyMethodGen.addExceptionHandlers(LazyMethodGen.java:1132)
org.aspectj.weaver.bcel.LazyMethodGen.packBody(LazyMethodGen.java:1078)
org.aspectj.weaver.bcel.LazyMethodGen.pack(LazyMethodGen.java:977)
org.aspectj.weaver.bcel.LazyMethodGen.getMethod(LazyMethodGen.java:484)
org.aspectj.weaver.bcel.LazyClassGen.writeBack(LazyClassGen.java:512)
org.aspectj.weaver.bcel.LazyClassGen.getJavaClassBytesIncludingReweavable(LazyClassGen.java:652)
org.aspectj.weaver.bcel.BcelWeaver.getClassFilesFor(BcelWeaver.java:1420)
org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify(BcelWeaver.java:1390)

And that is an exception on this line in remap()

ih = ih.getNext();

called from the addExceptionHandlers() line:

 gen.addExceptionHandler(
                remap(r.getRealStart(), map), 
                remap(r.getRealEnd(), map),
                remap(r.getHandler(), map),
                (r.getCatchType() == null)
                ? null 
                : (ObjectType) BcelWorld.makeBcelType(r.getCatchType()));

During weaving, an instruction list is augmented with extra entries representing where shadows start and end (method-call, method-execution, handler, etc).  When weaving is complete we want to remove these temporary elements and use the remaining instructions to produce the method bytecode.  Now sometimes these temporary entries are targeted by other elements (line number tags, local variable tags and exception handlers usually).  During packing we use remap() to reposition the locations so they move off of temporary placeholders and onto real instructions that will make it out into the bytecode.  What the above exception tells us is that we started walking over temporary placeholder entries, but before we came to a real instruction, we ran out of instructions!  This cannot happen, and indicates something went seriously wrong, we should always encounter an instruction when remapping off a temporary element.

After some digging it is actually the remap() call for the handler (not the start or end) that leads to the problem.  The handler represents where to jump to in the code when an exception of the specified type occurs between the instructions pointed at by start and end.

I sent a debug build to a user encountering this problem (I could not recreate it) and in that I was looking at where in fact the handler was pointing before we called remap().  I learned that when this problem occurs, the handler is not pointing to anywhere in the method currently being processed (not good).

In a second debug build I tried to ascertain who was setting these handlers to point to nowhere.  This debug never triggered, no-one was setting them to point to nowhere...

I happened to notice whilst going through the instructions in the debug output that cobertura was being used, a coverage toolkit that works by doing bytecode manipulation to insert calls out to a library.  AspectJ was being called after cobertura and I asked the user to try the steps the other way round - it worked fine.  Indicating cobertura was doing something to the bytecode that gave us problems.  After much messing about, I recreated it by applying around advice to within(*) to all the classes in rt.jar (I just used that as a very large standalone jar file I could weave into).

I learned that Cobertura creates catch blocks that look a little different to what javac and other compilers create.  The typical bytecode sequence a compiler produces for a catch block starts with a STORE instruction, to store the exception being caught (whether the body of the catch block uses it or not).  But the cobertura catch blocks started with an INVOKESTATIC instruction, a call out to another method.  What does this mean?  It means the same instruction has two shadows, a 'handler' shadow and a 'method-call' shadow - and it turns out this is what causes our problem.  If around advice is applied to the call join point and it cannot be inlined then the body of the call shadow (the call itself) is pulled out into a new method.  Because the handler was the same instruction, this meant the handler *was also being pulled out* into the new method, leaving behind an exception handler that jumped to an invalid location (in fact it 'jumped' to an instruction in a different method!).  So the reason I never saw the handler location being set incorrectly is that it was set correctly up front, but then dragged out with the method-call shadow into the wrong place.  In bytecode terms it looks like this:

   method-execution()
    |               ICONST_0
    |               ISTORE_2
    |               SIPUSH -1
    |               ISTORE_3
    | catch java.lang.Exception (1806389629) -&gt; E0
    | | method-call(ProjectData ProjectData.getGlobalProjectData())
    | | |           INVOKESTATIC ProjectData.getGlobalProjectData ()
    | | method-call(ProjectData getGlobalProjectData())
    | |             LDC "SomeString"
    | | method-call(ClassData getOrCreateClassData(java.lang.String))
    | | |           INVOKEVIRTUAL  ProjectData.getOrCreateClassData (LString;)
    | | method-call(ClassData ProjectData.getOrCreateClassData(String))
    | |             SIPUSH 106
    | | method-call(void ClassData.touch(int))
    | | |           INVOKEVIRTUAL ClassData.touch (I)V
    | | method-call(void ClassData.touch(int))
    | |             ALOAD_1
    | | method-call(Object Expression.getValue())
    | | |           INVOKEVIRTUAL Expression.getValue ()
    | | method-call(Object Expression.getValue())
    | catch java.lang.Exception (1806389629) -&gt; E0
    |               ARETURN
    | method-call(nProjectData ProjectData.getGlobalProjectData())
    | |         E0: INVOKESTATIC ProjectData.getGlobalProjectData ()
    | method-call(ProjectData ProjectData.getGlobalProjectData())
    |               LDC "Object"

We can see the problem in that final method-call.  The target for the exception handler seen earlier (E0) is within the method-call shadow.

What to do?</description><comments/></buginformation><fixedCommits><commit id="5f97d461c819a42c52aa772499f0046db8fa1dda" author="default" date="2008-05-07 15:31:18"><file name="weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"><method name="addExceptionHandlers" returnType="void" parameters="MethodGen Map LinkedList"/><method name="assertGoodHandle" returnType="void" parameters="InstructionHandle Set Stack String"/><method name="assertGoodRange" returnType="void" parameters="Range Set String"/><method name="assertInBody" returnType="void" parameters="Object Set String"/><method name="assertGoodRangeHandle" returnType="void" parameters="InstructionHandle Set Stack String"/><method name="assertGoodBody" returnType="void" parameters="InstructionList String"/></file><file name="weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"><method name="matchInvokeInstruction" returnType="void" parameters="LazyMethodGen"/><method name="match" returnType="void" parameters=""/></file></commit></fixedCommits></bug><bug id="392" opendate="2007-11-09 14:27:00" fixdate="2008-05-07 22:08:01"><buginformation><summary>Compile error: IllegalArgumentException thrown: negative line: -1</summary><description>If line numbers have not been added to the generated class files the following exception is thrown:

java.lang.IllegalArgumentException
at org.aspectj.bridge.SourceLocation.validLine(SourceLocation.java:41)
at org.aspectj.bridge.SourceLocation.&lt;init&gt;(SourceLocation.java:96)
at org.aspectj.bridge.SourceLocation.&lt;init&gt;(SourceLocation.java:85)
at org.aspectj.bridge.SourceLocation.&lt;init&gt;(SourceLocation.java:70)
at org.aspectj.ajdt.internal.core.builder.EclipseSourceContext.makeSourceLocation(EclipseSourceContext.java:57)
at org.aspectj.we ... reUtility.java:155)
at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

Compile error: IllegalArgumentException thrown: negative line: -1



An easy way to reproduce the problem is to uncheck the corresponding checkbox in the Classfile Generation section of the Java Compiler options in Eclipse.  A full build is performed during which an AspectJ Internal Compiler Error is thrown.

My Eclipse feature version is org.eclipse.ajdt_1.5.0.200706070619.</description><comments/></buginformation><fixedCommits><commit id="d3c3e32b533cbfa15120ad0414d07c5dbeec4296" author="default" date="2008-05-07 22:08:01"><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/EclipseAdapterUtils.java"><method name="makeMessage" returnType="IMessage" parameters="ICompilationUnit IProblem World"/></file></commit></fixedCommits></bug><bug id="393" opendate="2008-05-11 12:48:00" fixdate="2008-05-13 19:54:27"><buginformation><summary>Cant Compile new Statement for the Generic Class</summary><description>[aspectj:iajc] error at (no source information available)
[aspectj:iajc] C:\Development\PI\JavaSrc\com\centricsoftware\pi\service\expression\FuncNewMatrix.java:0::0 Internal compiler error
[aspectj:iajc] java.lang.ArrayIndexOutOfBoundsException: 1
[aspectj:iajc] 	at org.aspectj.weaver.ResolvedType.getMemberParameterizationMap(ResolvedType.java:744)
[aspectj:iajc] 	at org.aspectj.weaver.ReferenceType.getDeclaredInterfaces(ReferenceType.java:411)
[aspectj:iajc] 	at org.aspectj.weaver.ResolvedType.getDirectSupertypes(ResolvedType.java:68)
[aspectj:iajc] 	at org.aspectj.weaver.ResolvedType.collectInterTypeMungers(ResolvedType.java:1206)
[aspectj:iajc] 	at org.aspectj.weaver.ResolvedType.collectInterTypeMungers(ResolvedType.java:1211)
[aspectj:iajc] 	at org.aspectj.weaver.ResolvedType.collectInterTypeMungers(ResolvedType.java:1211)
[aspectj:iajc] 	at org.aspectj.weaver.ResolvedType.getInterTypeMungersIncludingSupers(ResolvedType.java:1185)
[aspectj:iajc] 	at org.aspectj.weaver.ResolvedType.checkInterTypeMungers(ResolvedType.java:1255)
[aspectj:iajc] 	at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.weaveInterTypeDeclarations(AjLookupEnvironment.java:646)
[aspectj:iajc] 	at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.weaveInterTypeDeclarations(AjLookupEnvironment.java:522)
[aspectj:iajc] 	at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.createBinaryTypeFrom(AjLookupEnvironment.java:1105)
[aspectj:iajc] 	at org.aspectj.org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.createBinaryTypeFrom(LookupEnvironment.java:599)
[aspectj:iajc] 	at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.accept(Compiler.java:276)
[aspectj:iajc] 	at org.aspectj.org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.askForType(LookupEnvironment.java:113)
[aspectj:iajc] 	at org.aspectj.org.eclipse.jdt.internal.compiler.lookup.UnresolvedReferenceBinding.resolve(UnresolvedReferenceBinding.java:49)
[aspectj:iajc] 	at org.aspectj.org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.resolveType(BinaryTypeBinding.java:99)
[aspectj:iajc] 	at org.aspectj.org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.getMemberType(BinaryTypeBinding.java:755)
[aspectj:iajc] 	at org.aspectj.org.eclipse.jdt.internal.compiler.lookup.Scope.findMemberType(Scope.java:986)
[aspectj:iajc] 	at org.aspectj.org.eclipse.jdt.internal.compiler.lookup.Scope.getMemberType(Scope.java:2116)
[aspectj:iajc] 	at org.aspectj.org.eclipse.jdt.internal.compiler.ast.QualifiedTypeReference.findNextTypeBinding(QualifiedTypeReference.java:43)
[aspectj:iajc] 	at org.aspectj.org.eclipse.jdt.internal.compiler.ast.QualifiedTypeReference.getTypeBinding(QualifiedTypeReference.java:77)
[aspectj:iajc] 	at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveType(TypeReference.java:142)
[aspectj:iajc] 	at org.aspectj.org.eclipse.jdt.internal.compiler.ast.AllocationExpression.resolveType(AllocationExpression.java:258)
[aspectj:iajc] 	at org.aspectj.org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.resolve(LocalDeclaration.java:196)
[aspectj:iajc] 	at org.aspectj.org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:433)
[aspectj:iajc] 	at org.aspectj.org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:196)
[aspectj:iajc] 	at org.aspectj.org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:404)
[aspectj:iajc] 	at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1109)
[aspectj:iajc] 	at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1188)
[aspectj:iajc] 	at org.aspectj.org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:366)
[aspectj:iajc] 	at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:625)
[aspectj:iajc] 	at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:392)
[aspectj:iajc] 	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:990)
[aspectj:iajc] 	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:264)
[aspectj:iajc] 	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:180)
[aspectj:iajc] 	at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:112)
[aspectj:iajc] 	at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:60)
[aspectj:iajc] 	at org.aspectj.tools.ajc.Main.run(Main.java:378)
[aspectj:iajc] 	at org.aspectj.tools.ajc.Main.runMain(Main.java:253)
[aspectj:iajc] 	at org.aspectj.tools.ant.taskdefs.AjcTask.executeInSameVM(AjcTask.java:1303)
[aspectj:iajc] 	at org.aspectj.tools.ant.taskdefs.AjcTask.execute(AjcTask.java:1101)
[aspectj:iajc] 	at org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:288)
[aspectj:iajc] 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
[aspectj:iajc] 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
[aspectj:iajc] 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
[aspectj:iajc] 	at java.lang.reflect.Method.invoke(Method.java:585)
[aspectj:iajc] 	at org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:105)
[aspectj:iajc] 	at org.apache.tools.ant.Task.perform(Task.java:348)
[aspectj:iajc] 	at org.apache.tools.ant.Target.execute(Target.java:357)
[aspectj:iajc] 	at org.apache.tools.ant.Target.performTasks(Target.java:385)
[aspectj:iajc] 	at org.apache.tools.ant.Project.executeSortedTargets(Project.java:1329)
[aspectj:iajc] 	at org.apache.tools.ant.Project.executeTarget(Project.java:1298)
[aspectj:iajc] 	at org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)
[aspectj:iajc] 	at org.eclipse.ant.internal.ui.antsupport.EclipseDefaultExecutor.executeTargets(EclipseDefaultExecutor.java:32)
[aspectj:iajc] 	at org.apache.tools.ant.Project.executeTargets(Project.java:1181)
[aspectj:iajc] 	at org.eclipse.ant.internal.ui.antsupport.InternalAntRunner.run(InternalAntRunner.java:423)
[aspectj:iajc] 	at org.eclipse.ant.internal.ui.antsupport.InternalAntRunner.main(InternalAntRunner.java:137)
[aspectj:iajc] abort ABORT -- (ArrayIndexOutOfBoundsException) 1
[aspectj:iajc] 1
[aspectj:iajc] java.lang.ArrayIndexOutOfBoundsException: 1
[aspectj:iajc] 	at org.aspectj.weaver.ResolvedType.getMemberParameterizationMap(ResolvedType.java:744)
[aspectj:iajc] 	at org.aspectj.weaver.ReferenceType.getDeclaredInterfaces(ReferenceType.java:411)
[aspectj:iajc] 	at org.aspectj.weaver.ResolvedType.getDirectSupertypes(ResolvedType.java:68)
[aspectj:iajc] 	at org.aspectj.weaver.ResolvedType.collectInterTypeMungers(ResolvedType.java:1206)
[aspectj:iajc] 	at org.aspectj.weaver.ResolvedType.collectInterTypeMungers(ResolvedType.java:1211)
[aspectj:iajc] 	at org.aspectj.weaver.ResolvedType.collectInterTypeMungers(ResolvedType.java:1211)
[aspectj:iajc] 	at org.aspectj.weaver.ResolvedType.getInterTypeMungersIncludingSupers(ResolvedType.java:1185)
[aspectj:iajc] 	at org.aspectj.weaver.ResolvedType.checkInterTypeMungers(ResolvedType.java:1255)
[aspectj:iajc] 	at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.weaveInterTypeDeclarations(AjLookupEnvironment.java:646)
[aspectj:iajc] 	at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.weaveInterTypeDeclarations(AjLookupEnvironment.java:522)
[aspectj:iajc] 	at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.createBinaryTypeFrom(AjLookupEnvironment.java:1105)
[aspectj:iajc] 	at org.aspectj.org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.createBinaryTypeFrom(LookupEnvironment.java:599)
[aspectj:iajc] 	at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.accept(Compiler.java:276)
[aspectj:iajc] 	at org.aspectj.org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.askForType(LookupEnvironment.java:113)
[aspectj:iajc] 	at org.aspectj.org.eclipse.jdt.internal.compiler.lookup.UnresolvedReferenceBinding.resolve(UnresolvedReferenceBinding.java:49)
[aspectj:iajc] 	at org.aspectj.org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.resolveType(BinaryTypeBinding.java:99)
[aspectj:iajc] 	at org.aspectj.org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.getMemberType(BinaryTypeBinding.java:755)
[aspectj:iajc] 	at org.aspectj.org.eclipse.jdt.internal.compiler.lookup.Scope.findMemberType(Scope.java:986)
[aspectj:iajc] 	at org.aspectj.org.eclipse.jdt.internal.compiler.lookup.Scope.getMemberType(Scope.java:2116)
[aspectj:iajc] 	at org.aspectj.org.eclipse.jdt.internal.compiler.ast.QualifiedTypeReference.findNextTypeBinding(QualifiedTypeReference.java:43)
[aspectj:iajc] 	at org.aspectj.org.eclipse.jdt.internal.compiler.ast.QualifiedTypeReference.getTypeBinding(QualifiedTypeReference.java:77)
[aspectj:iajc] 	at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveType(TypeReference.java:142)
[aspectj:iajc] 	at org.aspectj.org.eclipse.jdt.internal.compiler.ast.AllocationExpression.resolveType(AllocationExpression.java:258)
[aspectj:iajc] 	at org.aspectj.org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.resolve(LocalDeclaration.java:196)
[aspectj:iajc] 	at org.aspectj.org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:433)
[aspectj:iajc] 	at org.aspectj.org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:196)
[aspectj:iajc] 	at org.aspectj.org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:404)
[aspectj:iajc] 	at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1109)
[aspectj:iajc] 	at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1188)
[aspectj:iajc] 	at org.aspectj.org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:366)
[aspectj:iajc] 	at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:625)
[aspectj:iajc] 	at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:392)
[aspectj:iajc] 	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:990)
[aspectj:iajc] 	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:264)
[aspectj:iajc] 	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:180)
[aspectj:iajc] 	at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:112)
[aspectj:iajc] 	at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:60)
[aspectj:iajc] 	at org.aspectj.tools.ajc.Main.run(Main.java:378)
[aspectj:iajc] 	at org.aspectj.tools.ajc.Main.runMain(Main.java:253)
[aspectj:iajc] 	at org.aspectj.tools.ant.taskdefs.AjcTask.executeInSameVM(AjcTask.java:1303)
[aspectj:iajc] 	at org.aspectj.tools.ant.taskdefs.AjcTask.execute(AjcTask.java:1101)
[aspectj:iajc] 	at org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:288)
[aspectj:iajc] 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
[aspectj:iajc] 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
[aspectj:iajc] 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
[aspectj:iajc] 	at java.lang.reflect.Method.invoke(Method.java:585)
[aspectj:iajc] 	at org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:105)
[aspectj:iajc] 	at org.apache.tools.ant.Task.perform(Task.java:348)
[aspectj:iajc] 	at org.apache.tools.ant.Target.execute(Target.java:357)
[aspectj:iajc] 	at org.apache.tools.ant.Target.performTasks(Target.java:385)
[aspectj:iajc] 	at org.apache.tools.ant.Project.executeSortedTargets(Project.java:1329)
[aspectj:iajc] 	at org.apache.tools.ant.Project.executeTarget(Project.java:1298)
[aspectj:iajc] 	at org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)
[aspectj:iajc] 	at org.eclipse.ant.internal.ui.antsupport.EclipseDefaultExecutor.executeTargets(EclipseDefaultExecutor.java:32)
[aspectj:iajc] 	at org.apache.tools.ant.Project.executeTargets(Project.java:1181)
[aspectj:iajc] 	at org.eclipse.ant.internal.ui.antsupport.InternalAntRunner.run(InternalAntRunner.java:423)
[aspectj:iajc] 	at org.eclipse.ant.internal.ui.antsupport.InternalAntRunner.main(InternalAntRunner.java:137)
[aspectj:iajc] May 11, 2008 9:35:06 AM org.aspectj.weaver.tools.Jdk14Trace info
[aspectj:iajc] INFO: Dumping to C:\Development\PI\Projects\PI-ServiceCommon\.\ajcore.20080511.093506.214.txt
[aspectj:iajc] MessageHolder:  (92 info)  (1 error)  (1 abort) 
[aspectj:iajc] [error   0]: error at (no source information available)
[aspectj:iajc] C:\Development\PI\JavaSrc\com\centricsoftware\pi\service\expression\FuncNewMatrix.java:0::0 Internal compiler error
[aspectj:iajc] java.lang.ArrayIndexOutOfBoundsException: 1
[aspectj:iajc] 	at org.aspectj.weaver.ResolvedType.getMemberParameterizationMap(ResolvedType.java:744)
[aspectj:iajc] 	at org.aspectj.weaver.ReferenceType.getDeclaredInterfaces(ReferenceType.java:411)
[aspectj:iajc] 	at org.aspectj.weaver.ResolvedType.getDirectSupertypes(ResolvedType.java:68)
[aspectj:iajc] 	at org.aspectj.weaver.ResolvedType.collectInterTypeMungers(ResolvedType.java:1206)
[aspectj:iajc] 	at org.aspectj.weaver.ResolvedType.collectInterTypeMungers(ResolvedType.java:1211)
[aspectj:iajc] 	at org.aspectj.weaver.ResolvedType.collectInterTypeMungers(ResolvedType.java:1211)
[aspectj:iajc] 	at org.aspectj.weaver.ResolvedType.getInterTypeMungersIncludingSupers(ResolvedType.java:1185)
[aspectj:iajc] 	at org.aspectj.weaver.ResolvedType.checkInterTypeMungers(ResolvedType.java:1255)
[aspectj:iajc] 	at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.weaveInterTypeDeclarations(AjLookupEnvironment.java:646)
[aspectj:iajc] 	at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.weaveInterTypeDeclarations(AjLookupEnvironment.java:522)
[aspectj:iajc] 	at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.createBinaryTypeFrom(AjLookupEnvironment.java:1105)
[aspectj:iajc] 	at org.aspectj.org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.createBinaryTypeFrom(LookupEnvironment.java:599)
[aspectj:iajc] 	at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.accept(Compiler.java:276)
[aspectj:iajc] 	at org.aspectj.org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.askForType(LookupEnvironment.java:113)
[aspectj:iajc] 	at org.aspectj.org.eclipse.jdt.internal.compiler.lookup.UnresolvedReferenceBinding.resolve(UnresolvedReferenceBinding.java:49)
[aspectj:iajc] 	at org.aspectj.org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.resolveType(BinaryTypeBinding.java:99)
[aspectj:iajc] 	at org.aspectj.org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.getMemberType(BinaryTypeBinding.java:755)
[aspectj:iajc] 	at org.aspectj.org.eclipse.jdt.internal.compiler.lookup.Scope.findMemberType(Scope.java:986)
[aspectj:iajc] 	at org.aspectj.org.eclipse.jdt.internal.compiler.lookup.Scope.getMemberType(Scope.java:2116)
[aspectj:iajc] 	at org.aspectj.org.eclipse.jdt.internal.compiler.ast.QualifiedTypeReference.findNextTypeBinding(QualifiedTypeReference.java:43)
[aspectj:iajc] 	at org.aspectj.org.eclipse.jdt.internal.compiler.ast.QualifiedTypeReference.getTypeBinding(QualifiedTypeReference.java:77)
[aspectj:iajc] 	at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveType(TypeReference.java:142)
[aspectj:iajc] 	at org.aspectj.org.eclipse.jdt.internal.compiler.ast.AllocationExpression.resolveType(AllocationExpression.java:258)
[aspectj:iajc] 	at org.aspectj.org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.resolve(LocalDeclaration.java:196)
[aspectj:iajc] 	at org.aspectj.org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:433)
[aspectj:iajc] 	at org.aspectj.org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:196)
[aspectj:iajc] 	at org.aspectj.org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:404)
[aspectj:iajc] 	at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1109)
[aspectj:iajc] 	at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1188)
[aspectj:iajc] 	at org.aspectj.org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:366)
[aspectj:iajc] 	at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:625)
[aspectj:iajc] 	at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:392)
[aspectj:iajc] 	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:990)
[aspectj:iajc] 	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:264)
[aspectj:iajc] 	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:180)
[aspectj:iajc] 	at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:112)
[aspectj:iajc] 	at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:60)
[aspectj:iajc] 	at org.aspectj.tools.ajc.Main.run(Main.java:378)
[aspectj:iajc] 	at org.aspectj.tools.ajc.Main.runMain(Main.java:253)
[aspectj:iajc] 	at org.aspectj.tools.ant.taskdefs.AjcTask.executeInSameVM(AjcTask.java:1303)
[aspectj:iajc] 	at org.aspectj.tools.ant.taskdefs.AjcTask.execute(AjcTask.java:1101)
[aspectj:iajc] 	at org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:288)
[aspectj:iajc] 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
[aspectj:iajc] 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
[aspectj:iajc] 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
[aspectj:iajc] 	at java.lang.reflect.Method.invoke(Method.java:585)
[aspectj:iajc] 	at org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:105)
[aspectj:iajc] 	at org.apache.tools.ant.Task.perform(Task.java:348)
[aspectj:iajc] 	at org.apache.tools.ant.Target.execute(Target.java:357)
[aspectj:iajc] 	at org.apache.tools.ant.Target.performTasks(Target.java:385)
[aspectj:iajc] 	at org.apache.tools.ant.Project.executeSortedTargets(Project.java:1329)
[aspectj:iajc] 	at org.apache.tools.ant.Project.executeTarget(Project.java:1298)
[aspectj:iajc] 	at org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)
[aspectj:iajc] 	at org.eclipse.ant.internal.ui.antsupport.EclipseDefaultExecutor.executeTargets(EclipseDefaultExecutor.java:32)
[aspectj:iajc] 	at org.apache.tools.ant.Project.executeTargets(Project.java:1181)
[aspectj:iajc] 	at org.eclipse.ant.internal.ui.antsupport.InternalAntRunner.run(InternalAntRunner.java:423)
[aspectj:iajc] 	at org.eclipse.ant.internal.ui.antsupport.InternalAntRunner.main(InternalAntRunner.java:137)</description><comments/></buginformation><fixedCommits><commit id="a8739e3359b0da1fdb60e2201f8fe37265aa9d04" author="default" date="2008-05-13 19:54:27"><file name="weaver/src/org/aspectj/weaver/TypeFactory.java"><method name="locateFirstBracket" returnType="int" parameters="StringBuffer"/></file></commit></fixedCommits></bug><bug id="394" opendate="2008-05-18 17:23:00" fixdate="2008-05-20 18:30:38"><buginformation><summary>ClassFormatError during LTW using annotation approach</summary><description>The following exception is obtained when using the annotation approach and load-time weaving:

[AppClassLoader@1f12c4e] info AspectJ Weaver Version 1.5.4 built on Thursday Dec 20, 2007 at 13:44:10 GMT
[AppClassLoader@1f12c4e] info register classloader sun.misc.Launcher$AppClassLoader@1f12c4e
[AppClassLoader@1f12c4e] info using configuration /H:/temp/aspectj_bug/scratch/classes/scratch/aop/annotationbug/aspect/aop-bug.xml
[AppClassLoader@1f12c4e] info register aspect scratch.aop.annotationbug.aspect.BugAspect
doSomething()
Exception in thread "main" java.lang.ClassFormatError: Code attribute in native or abstract methods in class file scratch/aop/annotationbug/extra/SubClass
	at java.lang.ClassLoader.defineClass1(Native Method)
	at java.lang.ClassLoader.defineClass(ClassLoader.java:620)
	at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:124)
	at java.net.URLClassLoader.defineClass(URLClassLoader.java:260)
	at java.net.URLClassLoader.access$000(URLClassLoader.java:56)
	at java.net.URLClassLoader$1.run(URLClassLoader.java:195)
	at java.security.AccessController.doPrivileged(Native Method)
	at java.net.URLClassLoader.findClass(URLClassLoader.java:188)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:306)
	at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:276)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:251)
	at java.lang.ClassLoader.loadClassInternal(ClassLoader.java:319)
	at scratch.aop.annotationbug.extra.BugOther.getSubClass(BugOther.java:22)
	at scratch.aop.annotationbug.main.BugMain.somethingElse(BugMain.java:36)
	at scratch.aop.annotationbug.main.BugMain.doSomething(BugMain.java:30)
	at scratch.aop.annotationbug.main.BugMain.execute(BugMain.java:24)
	at scratch.aop.annotationbug.main.BugDriver.doExecute(BugDriver.java:27)
	at scratch.aop.annotationbug.main.BugDriver.main(BugDriver.java:21)

The same advice logic does not result in a ClassFormatError when using the Aspect approach, it only appears using the annotation approach.

Unfortunately we have not been able to track down exactly why the above Error occurs but have attached a test case that manifests it.

To run simply use the runtime configuration on the BugDriver main():

-Dorg.aspectj.weaver.loadtime.configuration="scratch/aop/annotationbug/aspect/aop-bug.xml"

Along with the AspectJ Load-Time Weaver Agent.

The above occurs with both AspectJ 1.5.4 and AspectJ 1.6.0. Interestingly when using the aspectj 1.6.0 weaver, the AppClassLoader log still indicates "1.5.4".</description><comments/></buginformation><fixedCommits><commit id="f0142758d0b83904bd648dddf270199777d5ec6c" author="default" date="2008-05-20 18:30:38"><file name="weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"><method name="createBridgeMethod" returnType="void" parameters="BcelWorld"/></file></commit></fixedCommits></bug><bug id="395" opendate="2008-05-22 13:12:00" fixdate="2008-05-22 18:26:18"><buginformation><summary>StringIndexOutOfBoundsException thrown in BcelWeaver</summary><description>Created  attachment 101560   [details] 
Core dump

A StringIndexOutOfBoundsException is thrown during weaving with the following stack trace:

java.lang.StringIndexOutOfBoundsException: String index out of range: -2
	at java.lang.String.substring(String.java:1938)
	at org.aspectj.weaver.bcel.BcelWeaver.addIfAspect(BcelWeaver.java:294)
	at org.aspectj.weaver.bcel.BcelWeaver.addAspectsFromDirectory(BcelWeaver.java:282)
	at org.aspectj.weaver.bcel.BcelWeaver.addLibraryJarFile(BcelWeaver.java:231)
	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.initBcelWorld(AjBuildManager.java:803)
	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:243)
	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:180)
	at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:112)
	at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:60)
	at org.aspectj.tools.ajc.Main.run(Main.java:382)
	at org.aspectj.tools.ajc.Main.runMain(Main.java:254)
	at org.aspectj.tools.ant.taskdefs.AjcTask.executeInSameVM(AjcTask.java:1303)
	at org.aspectj.tools.ant.taskdefs.AjcTask.execute(AjcTask.java:1101)
	at org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:288)
	at sun.reflect.GeneratedMethodAccessor2.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:105)
	at org.apache.tools.ant.Task.perform(Task.java:348)
	at org.apache.tools.ant.Target.execute(Target.java:357)
	at org.apache.tools.ant.Target.performTasks(Target.java:385)
	at org.apache.tools.ant.Project.executeSortedTargets(Project.java:1329)
	at org.apache.tools.ant.helper.SingleCheckExecutor.executeTargets(SingleCheckExecutor.java:38)
	at org.apache.tools.ant.Project.executeTargets(Project.java:1181)
	at org.apache.tools.ant.taskdefs.Ant.execute(Ant.java:416)
	at org.apache.tools.ant.taskdefs.CallTarget.execute(CallTarget.java:105)
	at org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:288)
	at sun.reflect.GeneratedMethodAccessor2.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:105)
	at org.apache.tools.ant.Task.perform(Task.java:348)
	at org.apache.tools.ant.taskdefs.Sequential.execute(Sequential.java:62)
	at com.cdmtech.tools.ant.task.conditional.IfSet.execute(IfSet.java:48)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:105)
	at org.apache.tools.ant.TaskAdapter.execute(TaskAdapter.java:134)
	at org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:288)
	at sun.reflect.GeneratedMethodAccessor2.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:105)
	at org.apache.tools.ant.Task.perform(Task.java:348)
	at org.apache.tools.ant.Target.execute(Target.java:357)
	at org.apache.tools.ant.Target.performTasks(Target.java:385)
	at org.apache.tools.ant.Project.executeSortedTargets(Project.java:1329)
	at org.apache.tools.ant.Project.executeTarget(Project.java:1298)
	at org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)
	at org.apache.tools.ant.Project.executeTargets(Project.java:1181)
	at org.apache.tools.ant.Main.runBuild(Main.java:698)
	at org.apache.tools.ant.Main.startAnt(Main.java:199)
	at org.apache.tools.ant.launch.Launcher.run(Launcher.java:257)
	at org.apache.tools.ant.launch.Launcher.main(Launcher.java:104)

The core dump is attached. It appears like the calculation of the binary path is failing in addIfAspect. This is due to "name" not containing "typeName" whereby causing the substring method to be called with -2. 

This exception appears most frequently when weaving with iajc, but does occur (oddly enough) less frequently in Eclipse/AJDT. My build is the 12 May 2008 development build.</description><comments/></buginformation><fixedCommits><commit id="93b7bedd6e367f07cf74782b6d367b9f6f418698" author="default" date="2008-05-22 18:26:18"><file name="weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java"><method name="addIfAspect" returnType="void" parameters="byte[] String List"/><method name="accept" returnType="boolean" parameters="File"/></file></commit></fixedCommits></bug><bug id="396" opendate="2008-04-16 06:24:00" fixdate="2008-06-06 20:38:14"><buginformation><summary>AJC error, somehow connected with generics</summary><description>Build ID: 1.5.0.20070607

Steps To Reproduce:
I cannot find a way to reproduce it, it's somehow "randomic", for example it happened to me now while creating a new class in an aspectj project, but when i then saved the .java it compiled properly. That's why I'm filing it in AJDT and not in AspectJ directly.

Based on the exception, IIUC, there is a narrowing in a generic (UnresolvedType should be something like Converter&lt;?&gt;, while BoundedReferenceType should be somethinf like Converter&lt;? extends Number&gt;), and the weaver is not handling it properly, but simply casting from one to the other .. but this are just silly assumptions.

More information:
java.lang.ClassCastException
at org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.makeTypeBinding1(EclipseFactory.java:656)
at org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.makeTypeBinding(EclipseFactory.java:579)
at org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.makeTypeBinding1(EclipseFactory.java:640)
at org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.makeTypeBinding(EclipseFactory.java:579)
at org.asp ... Worker.java:55)

Compile error: ClassCastException thrown: org.aspectj.weaver.UnresolvedType cannot be cast to org.aspectj.weaver.BoundedReferenceType</description><comments/></buginformation><fixedCommits><commit id="3b2109ac656e354034713b090f7d70a2d9898486" author="default" date="2008-06-06 20:38:14"><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"><method name="makeTypeBinding1" returnType="TypeBinding" parameters="UnresolvedType"/></file></commit></fixedCommits></bug><bug id="397" opendate="2006-08-27 18:46:00" fixdate="2008-06-10 20:48:36"><buginformation><summary>NPE during compilation of class file with pointcuts</summary><description>I commented out a static nested aspect inside a class to let me do a rename refactoring in Eclipse. This results in the following exception, which even a full rebuild won't fix. The class does have pointcut definitions inside of it. Commenting those out avoids the problem (though it caused other syntax errors...)

java.lang.ArrayIndexOutOfBoundsException
at org.aspectj.weaver.patterns.IfPointcut.findResidueInternal(IfPointcut.java:186)
at org.aspectj.weaver.patterns.Pointcut.findResidue(Pointcut.java:269)
at org.aspectj.weaver.patterns.AndPointcut.findResidueInternal(AndPointcut.java:93)
at org.aspectj.weaver.patterns.Pointcut.findResidue(Pointcut.java:269)
at org.aspectj.weaver.patterns.AndPointcut.findResidueInternal(AndPointcut.java:93)
at or ... ses 
when weaving 
when batch building BuildConfig[C:\devel\glassbox\.metadata\.plugins\org.eclipse.ajdt.core\glassboxAgent.generated.lst] #Files=210</description><comments/></buginformation><fixedCommits><commit id="248962b92ffa409d11122d2504e84567c7c34354" author="default" date="2008-06-10 20:48:36"><file name="weaver/src/org/aspectj/weaver/patterns/IfPointcut.java"><method name="findResidueInternal" returnType="Test" parameters="Shadow ExposedState"/></file></commit></fixedCommits></bug><bug id="398" opendate="2008-06-20 13:07:00" fixdate="2008-06-20 17:15:52"><buginformation><summary>[migration] Unexpected problem loading an aspect built with 1.5.4</summary><description>We always support processing of old aspects.  It doesn't matter what level of AspectJ was used to build an aspect, as long as you use that version or a later version of the weaver, we can unpack it and don't require it to be rebuilt from source.  However, I've just encountered a .class apparently built with 1.5.4 that 1.6.1 cannot load.  It crashes deserializing a PointcutDeclaration.

In the data stream we have just read the numbers 1 and 3 indicating 'kinded pointcut' and then 'method-execution' and the next digit is a 0 when it should be 1-9.  We crash with a:

org.aspectj.weaver.BCException: weird kind 0
when batch building BuildConfig[null] #Files=43
	at org.aspectj.weaver.MemberKind.read(MemberKind.java:35)
	at org.aspectj.weaver.patterns.SignaturePattern.read(SignaturePattern.java:682)

The memberkind is a typesafeenum and so can never be other than 1-9.  It is the first part of a signaturepattern so hard to see how it got written out 'wrong' right now.

I've been told 1.5.4 can load this, so about to try that. Wow....1.5.4 did load it back in, how the hell.

I suspect we aren't consuming enough in 1.6.1 which then leaves us some extra that we interpret as a rogue pointcut.

Ok, in a comparison we consume one extra byte from the stream when reading it with 1.6.1 that we do not consume with 1.6.0 - at position 260.

As I got closer to it, I knew what it would be - especially when I knew it was just one byte difference.  The version check for whether the byte for 'annotation pattern relates to a parameter match' was wrong (urgh).</description><comments/></buginformation><fixedCommits><commit id="be0316737b255f5e9d05bd76ea1e7bf973c347e1" author="default" date="2008-06-20 17:15:52"><file name="weaver/src/org/aspectj/weaver/patterns/WildAnnotationTypePattern.java"><method name="read" returnType="AnnotationTypePattern" parameters="VersionedDataInputStream"/></file><file name="weaver/src/org/aspectj/weaver/patterns/AndAnnotationTypePattern.java"><method name="read" returnType="AnnotationTypePattern" parameters="VersionedDataInputStream"/></file><file name="weaver/src/org/aspectj/weaver/patterns/OrAnnotationTypePattern.java"><method name="read" returnType="AnnotationTypePattern" parameters="VersionedDataInputStream"/></file><file name="weaver/src/org/aspectj/weaver/patterns/NotAnnotationTypePattern.java"><method name="read" returnType="AnnotationTypePattern" parameters="VersionedDataInputStream ISourceContext"/></file></commit></fixedCommits></bug><bug id="399" opendate="2008-05-01 14:00:00" fixdate="2008-07-29 16:55:49"><buginformation><summary>SourceTypeBinding.sourceStart() NPE</summary><description>java.lang.NullPointerException
at org.aspectj.org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.sourceStart(SourceTypeBinding.java:1514)
at org.aspectj.org.eclipse.jdt.internal.compiler.lookup.MethodBinding.sourceStart(MethodBinding.java:988)
at org.aspectj.ajdt.internal.compiler.lookup.EclipseSourceType.fillDeclaredMembers(EclipseSourceType.java:243)
at org.aspectj.ajdt.internal.compiler.lookup.EclipseSourceType.getDeclaredFiel ...                     IRETURN
  end public boolean isTracingModifications()

end public class com.centricsoftware.pi.core.data.reflection.Attribute</description><comments/></buginformation><fixedCommits><commit id="e9823aa074ffa69352ffcab1ef6be2b00d5accf1" author="default" date="2008-07-29 16:55:49"><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseSourceType.java"><method name="fillDeclaredMembers" returnType="void" parameters=""/></file></commit></fixedCommits></bug><bug id="400" opendate="2008-06-26 15:05:00" fixdate="2008-08-06 18:10:47"><buginformation><summary>Allow the ltw configuration to be directly specified rather than discovered on the classpath</summary><description>Currently the property:

org.aspectj.weaver.loadtime.configuration

can be set to name the ltw configuration file that the loadtime weaver searches for.  The default value is:

META-INF/aop.xml;META-INF/aop-ajc.xml;org/aspectj/aop.xml

and the weaver searches the classpath for .xml files matching any of those three possibilities.

A typical override might therefore be:

-Dorg.aspectj.weaver.loadtime.configuration=META-INF/overhere.xml

however the weaver will still only look for it on the classpath.

In some environments the ltw user may just want to name the aop config file to use, and not be forced to include it on the classpath.

We have had the suggestion to make it protocol based, which i like, but for now I would just allow support for 'file:'.  If file: is the prefix, it will be treated as direct reference to the file to use, otherwise it will be searched for.

This change would mean all existing uses of the override will be fine, but new users will be all to exploit the flexibility of naming their configuration directly.</description><comments/></buginformation><fixedCommits><commit id="df49b5c64ad56dcb67424bbcdbe27976c5b77477" author="default" date="2008-08-06 18:10:47"><file name="loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"><method name="parseDefinitions" returnType="List" parameters="ClassLoader"/></file></commit></fixedCommits></bug><bug id="401" opendate="2008-01-21 21:05:00" fixdate="2008-08-20 19:31:42"><buginformation><summary>Typo in point example</summary><description>Build ID: 3.3.1.1

Steps To Reproduce:
1. Install AspectJ
2. Navigate to the examples/introduction directory
3. Method in Point.java


More information:
protected void makeRectangular(){
      if (!rectangular) {
	 x = rho * Math.sin(theta);
	 y = rho * Math.cos(theta);
	 rectangular = true;
      }
   }

x and y should be interchanged in the method above, mathetimatical definition. For reference:  http://en.wikipedia.org/wiki/Trigonometric_function  .. please look at Right Triangle Definitions.</description><comments/></buginformation><fixedCommits><commit id="6d906dc563e78f9a4a21bc61f27ca406b065a6b8" author="default" date="2008-08-20 19:31:42"><file name="docs/dist/doc/examples/introduction/Point.java"><method name="makeRectangular" returnType="void" parameters=""/></file></commit></fixedCommits></bug><bug id="402" opendate="2008-08-15 13:54:00" fixdate="2008-08-29 20:08:59"><buginformation><summary>I cannot aspect code written in SJPP-based encoding</summary><description>Created  attachment 110112   [details] 
sjpp.jar to parse encoding

I cannot aspect code written in SJPP-based encoding

However, I *can* compile the code fine:
-  if I remove Aspect nature from my project, or
-  using command line ajc (of slightly newer version of AspectJ). i.e.,
      ajc.bat -J-Dpp.charset=%USERPROFILE%\pp.charset.properties -encoding MY_ENCODING -d out ...

Adding "-encoding MY_ENCODING" to AspectJ non-standard compiler options did *not* help.


source code: 
------------

public class Foo {
   public static void main(String [] args) {
#ifdef A_MACRO
      System.out.println("ok!");
#endif
   }
}

errors reported by "Problems" view:
-----------------------------------

	Severity and Description	Path	Resource	Location	Creation Time	Id
	A_MACRO cannot be resolved to a type	encoded/src	Foo.java	line 3	1218821924326	474099
	out cannot be resolved	encoded/src	Foo.java	line 4	1218821924326	474101
	Syntax error on token ".", ; expected	encoded/src	Foo.java	line 4	1218821924326	474100
	Syntax error on token "Invalid Character", @ expected	encoded/src	Foo.java	line 3	1218821924326	474098
	Syntax error, insert ";" to complete Statement	encoded/src	Foo.java	line 4	1218821924326	474102


project encoding:
-----------------

	Set to: MY_ENCODING

%USERPROFILE%/pp.charset.properties:
------------------------------------

	charset = MY_ENCODING

	MY_ENCODING.defines = A_MACRO

My Eclipse environment is:
--------------------------

*	Eclipse AspectJ Development Tools
	Version: 1.5.2.200804241330
	AspectJ version [for Eclipse]: 1.6.0.20080423100000

*	AspectJ version [for ajc]: AspectJ Compiler 1.6.1 (1.6.1 - Built: Thursday Jul 3, 2008 at 18:35:41 GMT) - Eclipse Compiler 0.785_R33x, 3.3

*	Eclipse v3.3.2 M20080221-1800

*	C:\jdk1.5\jre\lib\ext\sjpp.jar (see attached)</description><comments/></buginformation><fixedCommits><commit id="d5c2eadfa5e873ae300b52c0ecd86a3a8dedd088" author="default" date="2008-08-29 20:08:59"><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.java"><method name="installGlobals" returnType="void" parameters="AjBuildConfig"/></file></commit></fixedCommits></bug><bug id="403" opendate="2008-09-02 18:22:00" fixdate="2008-09-03 00:28:44"><buginformation><summary>FindBugs reporting another optimization</summary><description>Ben Hale reported that FindBugs was producing a warning about a dead store to a local variable (a variable that is never then read within the method).  This bug is to investigate and hopefully remove the dead store.</description><comments/></buginformation><fixedCommits><commit id="78a483d0aed48c974a4a2408f9e1adb2822d1242" author="default" date="2008-09-03 00:28:44"><file name="weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"><method name="weaveAroundInline" returnType="void" parameters="BcelAdvice boolean"/><method name="getArgVar" returnType="Var" parameters="int"/><method name="initializeArgVars" returnType="void" parameters=""/><method name="makeMethodExecution" returnType="BcelShadow" parameters="BcelWorld LazyMethodGen"/><method name="arg0HoldsThis" returnType="boolean" parameters=""/><method name="ensureTargetTypeIsCorrect" returnType="UnresolvedType" parameters="UnresolvedType"/><method name="initializeTargetAnnotationVars" returnType="void" parameters=""/></file></commit></fixedCommits></bug><bug id="404" opendate="2007-06-15 09:57:00" fixdate="2008-09-30 20:51:53"><buginformation><summary>[ataspectj] @AspectJ style inter-type declaration causes false compiler error during incremental build</summary><description>Build ID: M20070212-1330

Steps To Reproduce:
Use @DeclareParents to introduce a default interface implementation to an existing type.  

A full build compiles cleanly and works as expected.  An incremental build causes the following type of compile error: "The type FooImpl must implement the inherited abstract method Test.methodA()".  

In this example FooImpl is the class we are introducing a default implementation of the Test interface which defines the method "methodA".


More information:
See attached zip for a complete set of files to reproduce.

I can repoduce this bug with AJDT 1.4.2.200705221209 for Eclipse 3.2.2 as well as AJDT 1.5RC1 for Eclipse 3.3RC1</description><comments/></buginformation><fixedCommits><commit id="9b68a31302174ba06218e5e1182653297f722110" author="default" date="2008-09-30 20:51:53"><file name="tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java"><method name="testAspectPath_pr247742_c16" returnType="void" parameters=""/><method name="testBrokenCodeCompilation" returnType="void" parameters=""/></file></commit></fixedCommits></bug><bug id="405" opendate="2007-05-14 17:02:00" fixdate="2008-09-30 22:55:35"><buginformation><summary>Unhandled Kind of New Exception when have advice for Pointcut call(Throwable+.new(..))</summary><description>I get this error when weaving a LifeRay jar (compression-filter.jar). 

Unhandled kind of new   -1: impdep1[254](1)
when implementing on shadow constructor-call(void java.lang.NoClassDefFoundError.&lt;init&gt;()) when weaving classes ..

To reproduce: 

1)extract TestCase.zip. 
2) Go to the expanded TestCase/ directory.

3)do: ajc ThrowablesAspect.aj -log "test.log" -cp "&lt;path to aspectjrt.jar&gt;;lib\commons-logging-1.0.4.jar;lib\servlet-api.jar;lib\util-java.jar;lib\portal-kernel.jar" -injars compression-filter.jar -outjar compression-filter.jar.new

4) ajc will say there are 2 fail|aborts

NOTE: No advice or doing "around()" doesn't produce the error. The error happens when having at least "before()" or "after()" advice. I tried empty advice and it still fails. 



Full Stack Trace:
--------
trouble in: 
public class com.liferay.filters.compression.CompressionFilter extends java.lang.Object implements javax.servlet.Filter:
  static boolean useCompressionFilter
  public static final String ENCODING
  private static final String _ALREADY_FILTERED
  private static final String _COMPRESS = "compress"
  private static final String _INCLUDE = "javax.servlet.include.request_uri"
  private static org.apache.commons.logging.Log _log
  static Class class$com$liferay$filters$compression$CompressionFilter [Synthetic]
  public void init(javax.servlet.FilterConfig):
    method-execution(void com.liferay.filters.compression.CompressionFilter.init(javax.servlet.FilterConfig))
    |               RETURN   (line 80)
    method-execution(void com.liferay.filters.compression.CompressionFilter.init(javax.servlet.FilterConfig))
  end public void init(javax.servlet.FilterConfig)

  public void doFilter(javax.servlet.ServletRequest, javax.servlet.ServletResponse, javax.servlet.FilterChain) throws java.io.IOException, javax.servlet.ServletException:
    method-execution(void com.liferay.filters.compression.CompressionFilter.doFilter(javax.servlet.ServletRequest, javax.servlet.ServletResponse, javax.servlet.FilterChain))
    |               GETSTATIC com.liferay.filters.compression.CompressionFilter._log Lorg/apache/commons/logging/Log;   (line 86)
    | method-call(boolean org.apache.commons.logging.Log.isDebugEnabled())
    | |             INVOKEINTERFACE org.apache.commons.logging.Log.isDebugEnabled ()Z
    | method-call(boolean org.apache.commons.logging.Log.isDebugEnabled())
    |               IFEQ L1
    |               GETSTATIC com.liferay.filters.compression.CompressionFilter.useCompressionFilter Z   (line 87)
    |               IFEQ L0
    |               GETSTATIC com.liferay.filters.compression.CompressionFilter._log Lorg/apache/commons/logging/Log;   (line 88)
    |               LDC "Compression is enabled"
    | method-call(void org.apache.commons.logging.Log.debug(java.lang.Object))
    | |             INVOKEINTERFACE org.apache.commons.logging.Log.debug (Ljava/lang/Object;)V
    | method-call(void org.apache.commons.logging.Log.debug(java.lang.Object))
    |               GOTO L1
    |           L0: GETSTATIC com.liferay.filters.compression.CompressionFilter._log Lorg/apache/commons/logging/Log;   (line 91)
    |               LDC "Compression is disabled"
    | method-call(void org.apache.commons.logging.Log.debug(java.lang.Object))
    | |             INVOKEINTERFACE org.apache.commons.logging.Log.debug (Ljava/lang/Object;)V
    | method-call(void org.apache.commons.logging.Log.debug(java.lang.Object))
    |           L1: ALOAD_1     // Ljavax/servlet/ServletRequest; req   (line 95)
    |               CHECKCAST javax.servlet.http.HttpServletRequest
    |               ASTORE 4     // Ljavax/servlet/http/HttpServletRequest; httpReq
    |               ALOAD_2     // Ljavax/servlet/ServletResponse; res   (line 96)
    |               CHECKCAST javax.servlet.http.HttpServletResponse
    |               ASTORE 5     // Ljavax/servlet/http/HttpServletResponse; httpRes
    |               ALOAD 4     // Ljavax/servlet/http/HttpServletRequest; httpReq   (line 98)
    |               GETSTATIC com.liferay.filters.compression.CompressionFilter.ENCODING Ljava/lang/String;
    | method-call(void javax.servlet.http.HttpServletRequest.setCharacterEncoding(java.lang.String))
    | |             INVOKEINTERFACE javax.servlet.http.HttpServletRequest.setCharacterEncoding (Ljava/lang/String;)V
    | method-call(void javax.servlet.http.HttpServletRequest.setCharacterEncoding(java.lang.String))
    |               ALOAD 4     // Ljavax/servlet/http/HttpServletRequest; httpReq   (line 100)
    | method-call(java.lang.String com.liferay.util.Http.getCompleteURL(javax.servlet.http.HttpServletRequest))
    | |             INVOKESTATIC com.liferay.util.Http.getCompleteURL (Ljavax/servlet/http/HttpServletRequest;)Ljava/lang/String;
    | method-call(java.lang.String com.liferay.util.Http.getCompleteURL(javax.servlet.http.HttpServletRequest))
    |               ASTORE 6     // Ljava/lang/String; completeURL
    |               GETSTATIC com.liferay.filters.compression.CompressionFilter.useCompressionFilter Z   (line 102)
    |               IFEQ L3
    |               ALOAD_0     // Lcom/liferay/filters/compression/CompressionFilter; this
    |               ALOAD 4     // Ljavax/servlet/http/HttpServletRequest; httpReq
    | method-call(boolean com.liferay.filters.compression.CompressionFilter.isCompress(javax.servlet.http.HttpServletRequest))
    | |             INVOKEVIRTUAL com.liferay.filters.compression.CompressionFilter.isCompress (Ljavax/servlet/http/HttpServletRequest;)Z
    | method-call(boolean com.liferay.filters.compression.CompressionFilter.isCompress(javax.servlet.http.HttpServletRequest))
    |               IFEQ L3
    |               ALOAD_0     // Lcom/liferay/filters/compression/CompressionFilter; this
    |               ALOAD 4     // Ljavax/servlet/http/HttpServletRequest; httpReq
    | method-call(boolean com.liferay.filters.compression.CompressionFilter.isInclude(javax.servlet.http.HttpServletRequest))
    | |             INVOKEVIRTUAL com.liferay.filters.compression.CompressionFilter.isInclude (Ljavax/servlet/http/HttpServletRequest;)Z
    | method-call(boolean com.liferay.filters.compression.CompressionFilter.isInclude(javax.servlet.http.HttpServletRequest))
    |               IFNE L3
    |               ALOAD 4     // Ljavax/servlet/http/HttpServletRequest; httpReq
    | method-call(boolean com.liferay.util.BrowserSniffer.acceptsGzip(javax.servlet.http.HttpServletRequest))
    | |             INVOKESTATIC com.liferay.util.BrowserSniffer.acceptsGzip (Ljavax/servlet/http/HttpServletRequest;)Z
    | method-call(boolean com.liferay.util.BrowserSniffer.acceptsGzip(javax.servlet.http.HttpServletRequest))
    |               IFEQ L3
    |               ALOAD_0     // Lcom/liferay/filters/compression/CompressionFilter; this
    |               ALOAD 4     // Ljavax/servlet/http/HttpServletRequest; httpReq
    | method-call(boolean com.liferay.filters.compression.CompressionFilter.isAlreadyFiltered(javax.servlet.http.HttpServletRequest))
    | |             INVOKEVIRTUAL com.liferay.filters.compression.CompressionFilter.isAlreadyFiltered (Ljavax/servlet/http/HttpServletRequest;)Z
    | method-call(boolean com.liferay.filters.compression.CompressionFilter.isAlreadyFiltered(javax.servlet.http.HttpServletRequest))
    |               IFNE L3
    |               GETSTATIC com.liferay.filters.compression.CompressionFilter._log Lorg/apache/commons/logging/Log;   (line 106)
    | method-call(boolean org.apache.commons.logging.Log.isDebugEnabled())
    | |             INVOKEINTERFACE org.apache.commons.logging.Log.isDebugEnabled ()Z
    | method-call(boolean org.apache.commons.logging.Log.isDebugEnabled())
    |               IFEQ L2
    |               GETSTATIC com.liferay.filters.compression.CompressionFilter._log Lorg/apache/commons/logging/Log;   (line 107)
    |               NEW java.lang.StringBuffer
    |               DUP
    |               LDC "Compressing "
    | constructor-call(void java.lang.StringBuffer.&lt;init&gt;(java.lang.String))
    | |             INVOKESPECIAL java.lang.StringBuffer.&lt;init&gt; (Ljava/lang/String;)V
    | constructor-call(void java.lang.StringBuffer.&lt;init&gt;(java.lang.String))
    |               ALOAD 6     // Ljava/lang/String; completeURL
    | method-call(java.lang.StringBuffer java.lang.StringBuffer.append(java.lang.String))
    | |             INVOKEVIRTUAL java.lang.StringBuffer.append (Ljava/lang/String;)Ljava/lang/StringBuffer;
    | method-call(java.lang.StringBuffer java.lang.StringBuffer.append(java.lang.String))
    | method-call(java.lang.String java.lang.StringBuffer.toString())
    | |             INVOKEVIRTUAL java.lang.StringBuffer.toString ()Ljava/lang/String;
    | method-call(java.lang.String java.lang.StringBuffer.toString())
    | method-call(void org.apache.commons.logging.Log.debug(java.lang.Object))
    | |             INVOKEINTERFACE org.apache.commons.logging.Log.debug (Ljava/lang/Object;)V
    | method-call(void org.apache.commons.logging.Log.debug(java.lang.Object))
    |           L2: ALOAD 4     // Ljavax/servlet/http/HttpServletRequest; httpReq   (line 110)
    |               GETSTATIC com.liferay.filters.compression.CompressionFilter._ALREADY_FILTERED Ljava/lang/String;
    |               GETSTATIC java.lang.Boolean.TRUE Ljava/lang/Boolean;
    | method-call(void javax.servlet.http.HttpServletRequest.setAttribute(java.lang.String, java.lang.Object))
    | |             INVOKEINTERFACE javax.servlet.http.HttpServletRequest.setAttribute (Ljava/lang/String;Ljava/lang/Object;)V
    | method-call(void javax.servlet.http.HttpServletRequest.setAttribute(java.lang.String, java.lang.Object))
    |               NEW com.liferay.filters.compression.CompressionResponse   (line 112)
    |               DUP
    |               ALOAD 5     // Ljavax/servlet/http/HttpServletResponse; httpRes
    | constructor-call(void com.liferay.filters.compression.CompressionResponse.&lt;init&gt;(javax.servlet.http.HttpServletResponse))
    | |             INVOKESPECIAL com.liferay.filters.compression.CompressionResponse.&lt;init&gt; (Ljavax/servlet/http/HttpServletResponse;)V
    | constructor-call(void com.liferay.filters.compression.CompressionResponse.&lt;init&gt;(javax.servlet.http.HttpServletResponse))
    |               ASTORE 7     // Lcom/liferay/filters/compression/CompressionResponse; compressionResponse
    |               ALOAD_3     // Ljavax/servlet/FilterChain; chain   (line 115)
    |               ALOAD_1     // Ljavax/servlet/ServletRequest; req
    |               ALOAD 7     // Lcom/liferay/filters/compression/CompressionResponse; compressionResponse
    | method-call(void javax.servlet.FilterChain.doFilter(javax.servlet.ServletRequest, javax.servlet.ServletResponse))
    | |             INVOKEINTERFACE javax.servlet.FilterChain.doFilter (Ljavax/servlet/ServletRequest;Ljavax/servlet/ServletResponse;)V
    | method-call(void javax.servlet.FilterChain.doFilter(javax.servlet.ServletRequest, javax.servlet.ServletResponse))
    |               ALOAD 7     // Lcom/liferay/filters/compression/CompressionResponse; compressionResponse   (line 117)
    | method-call(void com.liferay.filters.compression.CompressionResponse.finishResponse())
    | |             INVOKEVIRTUAL com.liferay.filters.compression.CompressionResponse.finishResponse ()V
    | method-call(void com.liferay.filters.compression.CompressionResponse.finishResponse())
    |               GOTO L5
    |           L3: GETSTATIC com.liferay.filters.compression.CompressionFilter._log Lorg/apache/commons/logging/Log;   (line 120)
    | method-call(boolean org.apache.commons.logging.Log.isDebugEnabled())
    | |             INVOKEINTERFACE org.apache.commons.logging.Log.isDebugEnabled ()Z
    | method-call(boolean org.apache.commons.logging.Log.isDebugEnabled())
    |               IFEQ L4
    |               GETSTATIC com.liferay.filters.compression.CompressionFilter._log Lorg/apache/commons/logging/Log;   (line 121)
    |               NEW java.lang.StringBuffer
    |               DUP
    |               LDC "Not compressing "
    | constructor-call(void java.lang.StringBuffer.&lt;init&gt;(java.lang.String))
    | |             INVOKESPECIAL java.lang.StringBuffer.&lt;init&gt; (Ljava/lang/String;)V
    | constructor-call(void java.lang.StringBuffer.&lt;init&gt;(java.lang.String))
    |               ALOAD 6     // Ljava/lang/String; completeURL
    | method-call(java.lang.StringBuffer java.lang.StringBuffer.append(java.lang.String))
    | |             INVOKEVIRTUAL java.lang.StringBuffer.append (Ljava/lang/String;)Ljava/lang/StringBuffer;
    | method-call(java.lang.StringBuffer java.lang.StringBuffer.append(java.lang.String))
    | method-call(java.lang.String java.lang.StringBuffer.toString())
    | |             INVOKEVIRTUAL java.lang.StringBuffer.toString ()Ljava/lang/String;
    | method-call(java.lang.String java.lang.StringBuffer.toString())
    | method-call(void org.apache.commons.logging.Log.debug(java.lang.Object))
    | |             INVOKEINTERFACE org.apache.commons.logging.Log.debug (Ljava/lang/Object;)V
    | method-call(void org.apache.commons.logging.Log.debug(java.lang.Object))
    |           L4: ALOAD_3     // Ljavax/servlet/FilterChain; chain   (line 124)
    |               ALOAD_1     // Ljavax/servlet/ServletRequest; req
    |               ALOAD_2     // Ljavax/servlet/ServletResponse; res
    | method-call(void javax.servlet.FilterChain.doFilter(javax.servlet.ServletRequest, javax.servlet.ServletResponse))
    | |             INVOKEINTERFACE javax.servlet.FilterChain.doFilter (Ljavax/servlet/ServletRequest;Ljavax/servlet/ServletResponse;)V
    | method-call(void javax.servlet.FilterChain.doFilter(javax.servlet.ServletRequest, javax.servlet.ServletResponse))
    |           L5: RETURN   (line 126)
    method-execution(void com.liferay.filters.compression.CompressionFilter.doFilter(javax.servlet.ServletRequest, javax.servlet.ServletResponse, javax.servlet.FilterChain))
  end public void doFilter(javax.servlet.ServletRequest, javax.servlet.ServletResponse, javax.servlet.FilterChain) throws java.io.IOException, javax.servlet.ServletException

  public void destroy():
    method-execution(void com.liferay.filters.compression.CompressionFilter.destroy())
    |               RETURN   (line 129)
    method-execution(void com.liferay.filters.compression.CompressionFilter.destroy())
  end public void destroy()

  protected boolean isAlreadyFiltered(javax.servlet.http.HttpServletRequest):
    method-execution(boolean com.liferay.filters.compression.CompressionFilter.isAlreadyFiltered(javax.servlet.http.HttpServletRequest))
    |               ALOAD_1     // Ljavax/servlet/http/HttpServletRequest; req   (line 132)
    |               GETSTATIC com.liferay.filters.compression.CompressionFilter._ALREADY_FILTERED Ljava/lang/String;
    | method-call(java.lang.Object javax.servlet.http.HttpServletRequest.getAttribute(java.lang.String))
    | |             INVOKEINTERFACE javax.servlet.http.HttpServletRequest.getAttribute (Ljava/lang/String;)Ljava/lang/Object;
    | method-call(java.lang.Object javax.servlet.http.HttpServletRequest.getAttribute(java.lang.String))
    |               IFNULL L0
    |               ICONST_1   (line 133)
    |               IRETURN
    |           L0: ICONST_0   (line 136)
    |               IRETURN
    method-execution(boolean com.liferay.filters.compression.CompressionFilter.isAlreadyFiltered(javax.servlet.http.HttpServletRequest))
  end protected boolean isAlreadyFiltered(javax.servlet.http.HttpServletRequest)

  protected boolean isCompress(javax.servlet.http.HttpServletRequest):
    method-execution(boolean com.liferay.filters.compression.CompressionFilter.isCompress(javax.servlet.http.HttpServletRequest))
    |               ALOAD_1     // Ljavax/servlet/http/HttpServletRequest; req   (line 141)
    |               LDC "compress"
    |               ICONST_1
    | method-call(boolean com.liferay.util.ParamUtil.get(javax.servlet.ServletRequest, java.lang.String, boolean))
    | |             INVOKESTATIC com.liferay.util.ParamUtil.get (Ljavax/servlet/ServletRequest;Ljava/lang/String;Z)Z
    | method-call(boolean com.liferay.util.ParamUtil.get(javax.servlet.ServletRequest, java.lang.String, boolean))
    |               IFNE L0
    |               ICONST_0   (line 142)
    |               IRETURN
    |           L0: ALOAD_1     // Ljavax/servlet/http/HttpServletRequest; req   (line 151)
    |               LDC "p_p_state"
    | method-call(java.lang.String com.liferay.util.ParamUtil.getString(javax.servlet.ServletRequest, java.lang.String))
    | |             INVOKESTATIC com.liferay.util.ParamUtil.getString (Ljavax/servlet/ServletRequest;Ljava/lang/String;)Ljava/lang/String;
    | method-call(java.lang.String com.liferay.util.ParamUtil.getString(javax.servlet.ServletRequest, java.lang.String))
    |               ASTORE_2     // Ljava/lang/String; windowState
    |               ALOAD_2     // Ljava/lang/String; windowState   (line 153)
    |               LDC "exclusive"
    | method-call(boolean java.lang.String.equals(java.lang.Object))
    | |             INVOKEVIRTUAL java.lang.String.equals (Ljava/lang/Object;)Z
    | method-call(boolean java.lang.String.equals(java.lang.Object))
    |               IFEQ L1
    |               ICONST_0   (line 154)
    |               IRETURN
    |           L1: ICONST_1   (line 157)
    |               IRETURN
    method-execution(boolean com.liferay.filters.compression.CompressionFilter.isCompress(javax.servlet.http.HttpServletRequest))
  end protected boolean isCompress(javax.servlet.http.HttpServletRequest)

  protected boolean isInclude(javax.servlet.http.HttpServletRequest):
    method-execution(boolean com.liferay.filters.compression.CompressionFilter.isInclude(javax.servlet.http.HttpServletRequest))
    |               ALOAD_1     // Ljavax/servlet/http/HttpServletRequest; req   (line 163)
    |               LDC "javax.servlet.include.request_uri"
    | method-call(java.lang.Object javax.servlet.http.HttpServletRequest.getAttribute(java.lang.String))
    | |             INVOKEINTERFACE javax.servlet.http.HttpServletRequest.getAttribute (Ljava/lang/String;)Ljava/lang/Object;
    | method-call(java.lang.Object javax.servlet.http.HttpServletRequest.getAttribute(java.lang.String))
    |               CHECKCAST java.lang.String
    |               ASTORE_2     // Ljava/lang/String; uri
    |               ALOAD_2     // Ljava/lang/String; uri   (line 165)
    |               IFNONNULL L0
    |               ICONST_0   (line 166)
    |               IRETURN
    |           L0: ICONST_1   (line 169)
    |               IRETURN
    method-execution(boolean com.liferay.filters.compression.CompressionFilter.isInclude(javax.servlet.http.HttpServletRequest))
  end protected boolean isInclude(javax.servlet.http.HttpServletRequest)

  static Class class(String, boolean):
    method-execution(java.lang.Class com.liferay.filters.compression.CompressionFilter.class(java.lang.String, boolean))
    | catch java.lang.ClassNotFoundException -&gt; E0
    | |             ALOAD_0   (line 0)
    | | method-call(java.lang.Class java.lang.Class.forName(java.lang.String))
    | | |           INVOKESTATIC java.lang.Class.forName (Ljava/lang/String;)Ljava/lang/Class;
    | | method-call(java.lang.Class java.lang.Class.forName(java.lang.String))
    | |             ILOAD_1
    | |             IFNE L0
    | | method-call(java.lang.Class java.lang.Class.getComponentType())
    | | |           INVOKEVIRTUAL java.lang.Class.getComponentType ()Ljava/lang/Class;
    | | method-call(java.lang.Class java.lang.Class.getComponentType())
    | |         L0: ARETURN
    | catch java.lang.ClassNotFoundException -&gt; E0
    |           E0: NEW java.lang.NoClassDefFoundError
    |               DUP_X1
    | constructor-call(void java.lang.NoClassDefFoundError.&lt;init&gt;())
    | |             INVOKESPECIAL java.lang.NoClassDefFoundError.&lt;init&gt; ()V
    | constructor-call(void java.lang.NoClassDefFoundError.&lt;init&gt;())
    | method-call(java.lang.Throwable java.lang.Throwable.initCause(java.lang.Throwable))
    | |             INVOKEVIRTUAL java.lang.Throwable.initCause (Ljava/lang/Throwable;)Ljava/lang/Throwable;
    | method-call(java.lang.Throwable java.lang.Throwable.initCause(java.lang.Throwable))
    |               ATHROW
    method-execution(java.lang.Class com.liferay.filters.compression.CompressionFilter.class(java.lang.String, boolean))
  end static Class class(String, boolean)

  public void &lt;init&gt;():
                    ALOAD_0     // Lcom/liferay/filters/compression/CompressionFilter; this   (line 52)
                    INVOKESPECIAL java.lang.Object.&lt;init&gt; ()V
    constructor-execution(void com.liferay.filters.compression.CompressionFilter.&lt;init&gt;())
    |               RETURN
    constructor-execution(void com.liferay.filters.compression.CompressionFilter.&lt;init&gt;())
  end public void &lt;init&gt;()

  private static final void &lt;clinit&gt;():
    staticinitialization(void com.liferay.filters.compression.CompressionFilter.&lt;clinit&gt;())
    |               GETSTATIC com.liferay.filters.compression.CompressionFilter.class$com$liferay$filters$compression$CompressionFilter Ljava/lang/Class;   (line 54)
    |               DUP
    |               IFNONNULL L0
    |               POP
    |               LDC "[Lcom.liferay.filters.compression.CompressionFilter;"
    |               ICONST_0
    | method-call(java.lang.Class com.liferay.filters.compression.CompressionFilter.class(java.lang.String, boolean))
    | |             INVOKESTATIC com.liferay.filters.compression.CompressionFilter.class (Ljava/lang/String;Z)Ljava/lang/Class;
    | method-call(java.lang.Class com.liferay.filters.compression.CompressionFilter.class(java.lang.String, boolean))
    |               DUP
    |               PUTSTATIC com.liferay.filters.compression.CompressionFilter.class$com$liferay$filters$compression$CompressionFilter Ljava/lang/Class;
    | method-call(java.lang.String java.lang.Class.getName())
    | |         L0: INVOKEVIRTUAL java.lang.Class.getName ()Ljava/lang/String;
    | method-call(java.lang.String java.lang.Class.getName())
    | method-call(java.lang.String com.liferay.util.SystemProperties.get(java.lang.String))
    | |             INVOKESTATIC com.liferay.util.SystemProperties.get (Ljava/lang/String;)Ljava/lang/String;
    | method-call(java.lang.String com.liferay.util.SystemProperties.get(java.lang.String))
    |               ICONST_1
    | method-call(boolean com.liferay.util.GetterUtil.getBoolean(java.lang.String, boolean))
    | |             INVOKESTATIC com.liferay.util.GetterUtil.getBoolean (Ljava/lang/String;Z)Z
    | method-call(boolean com.liferay.util.GetterUtil.getBoolean(java.lang.String, boolean))
    |               PUTSTATIC com.liferay.filters.compression.CompressionFilter.useCompressionFilter Z
    |               GETSTATIC com.liferay.filters.compression.CompressionFilter.useCompressionFilter Z   (line 62)
    |               IFEQ L3
    | method-call(boolean com.liferay.portal.kernel.util.ServerDetector.isJBoss())
    | |             INVOKESTATIC com.liferay.portal.kernel.util.ServerDetector.isJBoss ()Z   (line 63)
    | method-call(boolean com.liferay.portal.kernel.util.ServerDetector.isJBoss())
    |               IFNE L1
    | method-call(boolean com.liferay.portal.kernel.util.ServerDetector.isJetty())
    | |             INVOKESTATIC com.liferay.portal.kernel.util.ServerDetector.isJetty ()Z
    | method-call(boolean com.liferay.portal.kernel.util.ServerDetector.isJetty())
    |               IFNE L1
    | method-call(boolean com.liferay.portal.kernel.util.ServerDetector.isJOnAS())
    | |             INVOKESTATIC com.liferay.portal.kernel.util.ServerDetector.isJOnAS ()Z
    | method-call(boolean com.liferay.portal.kernel.util.ServerDetector.isJOnAS())
    |               IFNE L1
    | method-call(boolean com.liferay.portal.kernel.util.ServerDetector.isOC4J())
    | |             INVOKESTATIC com.liferay.portal.kernel.util.ServerDetector.isOC4J ()Z
    | method-call(boolean com.liferay.portal.kernel.util.ServerDetector.isOC4J())
    |               IFNE L1
    | method-call(boolean com.liferay.portal.kernel.util.ServerDetector.isOrion())
    | |             INVOKESTATIC com.liferay.portal.kernel.util.ServerDetector.isOrion ()Z
    | method-call(boolean com.liferay.portal.kernel.util.ServerDetector.isOrion())
    |               IFNE L1
    | method-call(boolean com.liferay.portal.kernel.util.ServerDetector.isTomcat())
    | |             INVOKESTATIC com.liferay.portal.kernel.util.ServerDetector.isTomcat ()Z
    | method-call(boolean com.liferay.portal.kernel.util.ServerDetector.isTomcat())
    |               IFEQ L2
    |           L1: ICONST_1   (line 67)
    |               PUTSTATIC com.liferay.filters.compression.CompressionFilter.useCompressionFilter Z
    |               GOTO L3
    |           L2: ICONST_0   (line 70)
    |               PUTSTATIC com.liferay.filters.compression.CompressionFilter.useCompressionFilter Z
    |           L3: NEW java.lang.StringBuffer   (line 75)
    |               DUP
    | constructor-call(void java.lang.StringBuffer.&lt;init&gt;())
    | |             INVOKESPECIAL java.lang.StringBuffer.&lt;init&gt; ()V
    | constructor-call(void java.lang.StringBuffer.&lt;init&gt;())
    |               GETSTATIC com.liferay.filters.compression.CompressionFilter.class$com$liferay$filters$compression$CompressionFilter Ljava/lang/Class;
    |               DUP
    |               IFNONNULL L4
    |               POP
    |               LDC "[Lcom.liferay.filters.compression.CompressionFilter;"
    |               ICONST_0
    | method-call(java.lang.Class com.liferay.filters.compression.CompressionFilter.class(java.lang.String, boolean))
    | |             INVOKESTATIC com.liferay.filters.compression.CompressionFilter.class (Ljava/lang/String;Z)Ljava/lang/Class;
    | method-call(java.lang.Class com.liferay.filters.compression.CompressionFilter.class(java.lang.String, boolean))
    |               DUP
    |               PUTSTATIC com.liferay.filters.compression.CompressionFilter.class$com$liferay$filters$compression$CompressionFilter Ljava/lang/Class;
    | method-call(java.lang.String java.lang.Class.getName())
    | |         L4: INVOKEVIRTUAL java.lang.Class.getName ()Ljava/lang/String;
    | method-call(java.lang.String java.lang.Class.getName())
    | method-call(java.lang.StringBuffer java.lang.StringBuffer.append(java.lang.String))
    | |             INVOKEVIRTUAL java.lang.StringBuffer.append (Ljava/lang/String;)Ljava/lang/StringBuffer;
    | method-call(java.lang.StringBuffer java.lang.StringBuffer.append(java.lang.String))
    |               LDC ".encoding"
    | method-call(java.lang.StringBuffer java.lang.StringBuffer.append(java.lang.String))
    | |             INVOKEVIRTUAL java.lang.StringBuffer.append (Ljava/lang/String;)Ljava/lang/StringBuffer;
    | method-call(java.lang.StringBuffer java.lang.StringBuffer.append(java.lang.String))
    | method-call(java.lang.String java.lang.StringBuffer.toString())
    | |             INVOKEVIRTUAL java.lang.StringBuffer.toString ()Ljava/lang/String;
    | method-call(java.lang.String java.lang.StringBuffer.toString())
    | method-call(java.lang.String com.liferay.util.SystemProperties.get(java.lang.String))
    | |             INVOKESTATIC com.liferay.util.SystemProperties.get (Ljava/lang/String;)Ljava/lang/String;
    | method-call(java.lang.String com.liferay.util.SystemProperties.get(java.lang.String))
    |               LDC "UTF-8"
    | method-call(java.lang.String com.liferay.util.GetterUtil.getString(java.lang.String, java.lang.String))
    | |             INVOKESTATIC com.liferay.util.GetterUtil.getString (Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;
    | method-call(java.lang.String com.liferay.util.GetterUtil.getString(java.lang.String, java.lang.String))
    |               PUTSTATIC com.liferay.filters.compression.CompressionFilter.ENCODING Ljava/lang/String;
    |               NEW java.lang.StringBuffer   (line 173)
    |               DUP
    | constructor-call(void java.lang.StringBuffer.&lt;init&gt;())
    | |             INVOKESPECIAL java.lang.StringBuffer.&lt;init&gt; ()V
    | constructor-call(void java.lang.StringBuffer.&lt;init&gt;())
    |               GETSTATIC com.liferay.filters.compression.CompressionFilter.class$com$liferay$filters$compression$CompressionFilter Ljava/lang/Class;
    |               DUP
    |               IFNONNULL L5
    |               POP
    |               LDC "[Lcom.liferay.filters.compression.CompressionFilter;"
    |               ICONST_0
    | method-call(java.lang.Class com.liferay.filters.compression.CompressionFilter.class(java.lang.String, boolean))
    | |             INVOKESTATIC com.liferay.filters.compression.CompressionFilter.class (Ljava/lang/String;Z)Ljava/lang/Class;
    | method-call(java.lang.Class com.liferay.filters.compression.CompressionFilter.class(java.lang.String, boolean))
    |               DUP
    |               PUTSTATIC com.liferay.filters.compression.CompressionFilter.class$com$liferay$filters$compression$CompressionFilter Ljava/lang/Class;
    | method-call(java.lang.StringBuffer java.lang.StringBuffer.append(java.lang.Object))
    | |         L5: INVOKEVIRTUAL java.lang.StringBuffer.append (Ljava/lang/Object;)Ljava/lang/StringBuffer;
    | method-call(java.lang.StringBuffer java.lang.StringBuffer.append(java.lang.Object))
    |               LDC "_ALREADY_FILTERED"
    | method-call(java.lang.StringBuffer java.lang.StringBuffer.append(java.lang.String))
    | |             INVOKEVIRTUAL java.lang.StringBuffer.append (Ljava/lang/String;)Ljava/lang/StringBuffer;
    | method-call(java.lang.StringBuffer java.lang.StringBuffer.append(java.lang.String))
    | method-call(java.lang.String java.lang.StringBuffer.toString())
    | |             INVOKEVIRTUAL java.lang.StringBuffer.toString ()Ljava/lang/String;
    | method-call(java.lang.String java.lang.StringBuffer.toString())
    |               PUTSTATIC com.liferay.filters.compression.CompressionFilter._ALREADY_FILTERED Ljava/lang/String;
    |               GETSTATIC com.liferay.filters.compression.CompressionFilter.class$com$liferay$filters$compression$CompressionFilter Ljava/lang/Class;   (line 180)
    |               DUP
    |               IFNONNULL L6
    |               POP
    |               LDC "[Lcom.liferay.filters.compression.CompressionFilter;"
    |               ICONST_0
    | method-call(java.lang.Class com.liferay.filters.compression.CompressionFilter.class(java.lang.String, boolean))
    | |             INVOKESTATIC com.liferay.filters.compression.CompressionFilter.class (Ljava/lang/String;Z)Ljava/lang/Class;
    | method-call(java.lang.Class com.liferay.filters.compression.CompressionFilter.class(java.lang.String, boolean))
    |               DUP
    |               PUTSTATIC com.liferay.filters.compression.CompressionFilter.class$com$liferay$filters$compression$CompressionFilter Ljava/lang/Class;
    | method-call(org.apache.commons.logging.Log org.apache.commons.logging.LogFactory.getLog(java.lang.Class))
    | |         L6: INVOKESTATIC org.apache.commons.logging.LogFactory.getLog (Ljava/lang/Class;)Lorg/apache/commons/logging/Log;
    | method-call(org.apache.commons.logging.Log org.apache.commons.logging.LogFactory.getLog(java.lang.Class))
    |               PUTSTATIC com.liferay.filters.compression.CompressionFilter._log Lorg/apache/commons/logging/Log;
    |               RETURN
    staticinitialization(void com.liferay.filters.compression.CompressionFilter.&lt;clinit&gt;())
  end private static final void &lt;clinit&gt;()
end public class com.liferay.filters.compression.CompressionFilter

	
Exception thrown from AspectJ 1.5.2

This might be logged as a bug already -- find current bugs at
   http://bugs.eclipse.org/bugs/buglist.cgi?product=AspectJ&amp;component=Compiler 

Bugs for exceptions thrown have titles File:line from the top stack, 
e.g., "SomeFile.java:243"

If you don't find the exception below in a bug, please add a new bug
at  http://bugs.eclipse.org/bugs/enter_bug.cgi?product=AspectJ 
To make the bug a priority, please include a test program
that can reproduce this exception.
Unhandled kind of new   -1: impdep1[254](1)

when implementing on shadow constructor-call(void java.lang.NoClassDefFoundError.&lt;init&gt;())
when weaving classes 
when weaving 
when batch building BuildConfig[null] #Files=1
Unhandled kind of new   -1: impdep1[254](1)
java.lang.RuntimeException: Unhandled kind of new   -1: impdep1[254](1)
	at org.aspectj.weaver.bcel.BcelShadow.deleteNewAndDup(BcelShadow.java:226)
	at org.aspectj.wea</description><comments/></buginformation><fixedCommits><commit id="7a398a2d4cfe14c36662ac6b984303f8ba920362" author="default" date="2008-09-30 22:55:35"><file name="weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"><method name="deleteNewAndDup" returnType="void" parameters=""/><method name="retargetFrom" returnType="void" parameters="InstructionHandle InstructionHandle"/></file></commit></fixedCommits></bug><bug id="406" opendate="2008-10-05 18:24:00" fixdate="2008-10-29 19:08:05"><buginformation><summary>[compiling] Problem with -XterminateAfterCompilation</summary><description>Reported on the mailing list by Simone:

I tried disabling pipelining as described in  bug 146781 , that is using
-Xset:pipelineCompilation=false, but unfortunately I get this error
while compiling with -XterminateAfterCompilation :

java.lang.NullPointerException
       at org.aspectj.weaver.ReferenceType.isAspect(ReferenceType.java:160)
       at
org.aspectj.ajdt.internal.core.builder.AjBuildManager$4.addAspectName(AjBuildManager.java:1108)
       at
org.aspectj.ajdt.internal.core.builder.AjBuildManager$4.acceptResult(AjBuildManager.java:1047)
       at</description><comments/></buginformation><fixedCommits><commit id="cffe291340c69186f6a5c986adbecf02038ba590" author="default" date="2008-10-29 19:08:05"><file name="tests/src/org/aspectj/systemtest/ajc163/Ajc163Tests.java"><method name="testItdCCE_pr250091" returnType="void" parameters=""/></file></commit></fixedCommits></bug><bug id="407" opendate="2008-11-25 04:51:00" fixdate="2008-11-27 17:59:09"><buginformation><summary>An internal error occurred during: "Delete and update AspectJ markers for CoreSource".</summary><description>this occured during a clean and build of the project i'm working on. The following was inthe details.

An internal error occurred during: "Delete and update AspectJ markers for CoreSource".
java.lang.NullPointerException</description><comments/></buginformation><fixedCommits><commit id="155a888d39e73a70fd4fe47de2c37ed593bb5459" author="default" date="2008-11-27 17:59:09"><file name="asm/src/org/aspectj/asm/internal/JDTLikeHandleProvider.java"><method name="getParameters" returnType="String" parameters="IProgramElement"/></file></commit></fixedCommits></bug><bug id="408" opendate="2007-05-03 17:18:00" fixdate="2008-12-01 21:00:43"><buginformation><summary>[plan] [ataspectj] Abstract @Aspect causing problems</summary><description>Trying to use an abstract @Aspect from a library jar file is causing problems.

In the (soon to be) attached zip of eclipse projects:
* logging-library: defines two abstract trivial logging aspects, one in code-style and one in @AspectJ style.

* sample-system: uses the code-style abstract aspect successfully
* sample-system2: uses the @AspectJ style abstract aspect and won't compile in Eclipse

Exception:
java.lang.NullPointerException
at org.aspectj.weaver.bcel.AtAjAttributes$LazyResolvedPointcutDefinition.getPointcut(AtAjAttributes.java:1632)
at org.aspectj.weaver.ShadowMunger.addChildNodes(ShadowMunger.java:258)
at org.aspectj.weaver.ShadowMunger.createHierarchy(ShadowMunger.java:247)
at org.aspectj.weaver.AsmRelationshipProvider.adviceMunger(AsmRelationshipProvider.java:180)
at org.aspectj.weaver.Shadow.implementMungers(Shadow.java:717)
a ... int;)Ljava/lang/String;
                    ARETURN
  end public Object run(Object[])</description><comments/></buginformation><fixedCommits><commit id="120b47fd215b25f2c3cd7e977a93c206e8a2281a" author="default" date="2008-12-01 21:00:43"><file name="weaver/src/org/aspectj/weaver/bcel/AtAjAttributes.java"><method name="getPointcut" returnType="Pointcut" parameters=""/></file><file name="weaver/src/org/aspectj/weaver/model/AsmRelationshipProvider.java"><method name="addChildNodes" returnType="void" parameters="AsmManager ShadowMunger"/></file></commit></fixedCommits></bug><bug id="409" opendate="2009-01-12 12:43:00" fixdate="2009-01-12 21:35:16"><buginformation><summary>java.lang.StringIndexOutOfBoundsException</summary><description>ava.lang.StringIndexOutOfBoundsException
at java.lang.String.substring(String.java:1938)
at org.aspectj.ajdt.ajc.ConfigParser.stripWhitespaceAndComments(ConfigParser.java:103)
at org.aspectj.ajdt.ajc.ConfigParser.parseConfigFileHelper(ConfigParser.java:69)
at org.aspectj.ajdt.ajc.ConfigParser.parseImportedConfigFile(ConfigParser.java:224)
at org.aspectj.ajdt.ajc.ConfigParser.parseOneArg(ConfigParser.java:213)
at org.aspectj.ajdt.ajc.ConfigP ... 82)
at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)</description><comments/></buginformation><fixedCommits><commit id="d9bd46d462bc3742bfcc72d7baf493c49d96cb4b" author="default" date="2009-01-12 21:35:16"><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/ConfigParser.java"><method name="stripWhitespaceAndComments" returnType="String" parameters="String"/></file></commit></fixedCommits></bug><bug id="410" opendate="2009-02-05 13:25:00" fixdate="2009-02-06 00:15:57"><buginformation><summary>Error during Delete AJ Markers</summary><description>Error sent through the AJDT mailing list.  I believe this is an LTW weaving error, so not raising it against AJDT.</description><comments/></buginformation><fixedCommits><commit id="1b54b4b7555176c8548dbbffded063191ad0b46a" author="default" date="2009-02-06 00:15:57"><file name="weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"><method name="getReweavableMode" returnType="boolean" parameters=""/><method name="weave" returnType="boolean" parameters="BcelWorld LazyClassGen List List List"/><method name="setReweavableMode" returnType="void" parameters="boolean"/></file><file name="weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java"><method name="munge" returnType="boolean" parameters="BcelClassWeaver"/></file><file name="weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java"><method name="setReweavableMode" returnType="void" parameters="boolean"/><method name="weave" returnType="LazyClassGen" parameters="UnwovenClassFile BcelObjectType"/></file></commit></fixedCommits></bug><bug id="411" opendate="2009-02-11 13:19:00" fixdate="2009-02-12 17:50:17"><buginformation><summary>[handles] Remove trailing '/' from source path handles</summary><description>In  bug 262953 , we noticed that when the .classpath has an entry like:

  	&lt;classpathentry kind="src" path="src/"/&gt;
Instead of something like:
		&lt;classpathentry kind="src" path="src"/&gt;

AspectJ handles will include the extra '/', but JDT handles will not.  On the AJDT side, I fixed things in  Bug 262953  so that this kind of classpath entry will not be created by AJDT.  However, for consistency, it is probably a good idea for AspectJ to handle these kinds of paths the same as JDT.

For example, the AspectJ handle for the source folder in Spacewar when the .classpath entry contains and extra '/' looks like:
=Spacewar Example/src\/

but the JDT handle looks like:
=Spacewar Example/src</description><comments/></buginformation><fixedCommits><commit id="0af658e1b117aee704b5e6e836ce7e84199ae548" author="default" date="2009-02-12 17:50:17"><file name="asm/src/org/aspectj/asm/internal/JDTLikeHandleProvider.java"><method name="createHandleIdentifier" returnType="String" parameters="IProgramElement"/></file></commit></fixedCommits></bug><bug id="412" opendate="2009-02-13 11:54:00" fixdate="2009-02-17 16:20:49"><buginformation><summary>AspectJ depends on Class files having a dot in their source file name attribute</summary><description>The following code in ShadowMunger$getBinaryFile() (line 169 ff) fails if a class file does not contain a proper source file name:

		if (binaryFile == null) {
			String s = getDeclaringType().getBinaryPath();
			File f = getDeclaringType().getSourceLocation().getSourceFile();
			int i = f.getPath().lastIndexOf('.');
			String path = f.getPath().substring(0, i) + ".class";
			binaryFile = new File(s + "!" + path);
		}

(there is no '.' in the file name, thus this gives a string index out of bounds error).</description><comments/></buginformation><fixedCommits><commit id="9f80317172e217cf2cbee6d212ccfc2d94c0ecfb" author="default" date="2009-02-17 16:20:49"><file name="org.aspectj.matcher/src/org/aspectj/weaver/ShadowMunger.java"><method name="getBinaryFile" returnType="File" parameters=""/></file></commit></fixedCommits></bug><bug id="413" opendate="2009-02-28 16:09:00" fixdate="2009-03-02 04:00:31"><buginformation><summary>Problem with incremental itd compilation</summary><description>Reproduceable from Roo code - commenting out a field after a successful build results in this exception. The underlying cause may also apply to ITD methods (and maybe constructors).

org.aspectj.weaver.BCException: Couldn't find ITD init member 'void com.springsource.petclinic.domain.Visit_Roo_Entity_Itd.ajc$interFieldInit$com_springsource_petclinic_domain_Visit_Roo_Entity_Itd$com_springsource_petclinic_domain_Visit$id(com.springsource.petclinic.domain.Visit)' on aspect com.springsource.petclinic.domain.Visit_Roo_Entity_Itd
when type munging with (BcelTypeMunger ResolvedTypeMunger(Field, java.lang.Long com.springsource.petclinic.domain.Visit.id))
when weaving type com.springsource.petclinic.domain.Visit
when weaving classes 
when weaving 
when incrementally building with classpath: C:\temp\petclinic\target\classes;E:/jvms/jdk1.6.0_06/jre/lib/resources.jar;E:/jvms/jdk1.6.0_06/jre/lib/rt.jar;E:/jvms/jdk1.6.0_06/jre/lib/jsse.jar;E:/jvms/jdk1.6.0_06/jre/lib/jce.jar;E:/jvms/jdk1.6.0_06/jre/lib/charsets.jar;E:/jvms/jdk1.6.0_06/jre/lib/ext/dnsns.jar;E:/jvms/jdk1.6.0_06/jre/lib/ext/localedata.jar;E:/jvms/jdk1.6.0_06/jre/lib/ext/sunjce_provider.jar;E:/jvms/jdk1.6.0_06/jre/lib/ext/sunmscapi.jar;E:/jvms/jdk1.6.0_06/jre/lib/ext/sunpkcs11.jar;C:/Users/Andy/.m2/repository/org/antlr/com.springsource.antlr/2.7.6/com.springsource.antlr-2.7.6.jar;C:/Users/Andy/.m2/repository/com/thoughtworks/xstream/com.springsource.com.thoughtworks.xstream/1.3.0/com.springsource.com.thoughtworks.xstream-1.3.0.jar;C:/Users/Andy/.m2/repository/edu/emory/mathcs/backport/com.springsource.edu.emory.mathcs.backport/3.1.0/com.springsource.edu.emory.mathcs.backport-3.1.0.jar;C:/Users/Andy/.m2/repository/edu/oswego/cs/concurrent/com.springsource.edu.oswego.cs.dl.util.concurrent/1.3.4/com.springsource.edu.oswego.cs.dl.util.concurrent-1.3.4.jar;C:/Users/Andy/.m2/repository/org/jboss/javassist/com.springsource.javassist/3.3.0.ga/com.springsource.javassist-3.3.0.ga.jar;C:/Users/Andy/.m2/repository/javax/annotation/com.springsource.javax.annotation/1.0.0/com.springsource.javax.annotation-1.0.0.jar;C:/Users/Andy/.m2/repository/javax/persistence/com.springsource.javax.persistence/1.0.0/com.springsource.javax.persistence-1.0.0.jar;C:/Users/Andy/.m2/repository/javax/servlet/com.springsource.javax.servlet/2.4.0/com.springsource.javax.servlet-2.4.0.jar;C:/Users/Andy/.m2/repository/javax/servlet/com.springsource.javax.servlet.jsp.jstl/1.2.0/com.springsource.javax.servlet.jsp.jstl-1.2.0.jar;C:/Users/Andy/.m2/repository/javax/transaction/com.springsource.javax.transaction/1.1.0/com.springsource.javax.transaction-1.1.0.jar;C:/Users/Andy/.m2/repository/net/sourceforge/cglib/com.springsource.net.sf.cglib/2.1.3/com.springsource.net.sf.cglib-2.1.3.jar;C:/Users/Andy/.m2/repository/net/sourceforge/ehcache/com.springsource.net.sf.ehcache/1.4.1/com.springsource.net.sf.ehcache-1.4.1.jar;C:/Users/Andy/.m2/repository/net/sourceforge/jsr107cache/com.springsource.net.sf.jsr107cache/1.0.0/com.springsource.net.sf.jsr107cache-1.0.0.jar;C:/Users/Andy/.m2/repository/org/antlr/com.springsource.org.antlr/3.0.1/com.springsource.org.antlr-3.0.1.jar;C:/Users/Andy/.m2/repository/org/aopalliance/com.springsource.org.aopalliance/1.0.0/com.springsource.org.aopalliance-1.0.0.jar;C:/Users/Andy/.m2/repository/org/apache/commons/com.springsource.org.apache.commons.collections/3.2.0/com.springsource.org.apache.commons.collections-3.2.0.jar;C:/Users/Andy/.m2/repository/org/apache/commons/com.springsource.org.apache.commons.dbcp/1.2.2.osgi/com.springsource.org.apache.commons.dbcp-1.2.2.osgi.jar;C:/Users/Andy/.m2/repository/org/apache/commons/com.springsource.org.apache.commons.logging/1.1.1/com.springsource.org.apache.commons.logging-1.1.1.jar;C:/Users/Andy/.m2/repository/org/apache/commons/com.springsource.org.apache.commons.pool/1.3.0/com.springsource.org.apache.commons.pool-1.3.0.jar;C:/Users/Andy/.m2/repository/org/apache/log4j/com.springsource.org.apache.log4j/1.2.15/com.springsource.org.apache.log4j-1.2.15.jar;C:/Users/Andy/.m2/repository/org/apache/taglibs/com.springsource.org.apache.taglibs.standard/1.1.2/com.springsource.org.apache.taglibs.standard-1.1.2.jar;C:/Users/Andy/.m2/repository/org/aspectj/com.springsource.org.aspectj.runtime/1.6.2.RELEASE/com.springsource.org.aspectj.runtime-1.6.2.RELEASE.jar;C:/Users/Andy/.m2/repository/org/aspectj/com.springsource.org.aspectj.tools/1.6.2.RELEASE/com.springsource.org.aspectj.tools-1.6.2.RELEASE.jar;C:/Users/Andy/.m2/repository/org/aspectj/com.springsource.org.aspectj.weaver/1.6.2.RELEASE/com.springsource.org.aspectj.weaver-1.6.2.RELEASE.jar;C:/Users/Andy/.m2/repository/org/dom4j/com.springsource.org.dom4j/1.6.1/com.springsource.org.dom4j-1.6.1.jar;C:/Users/Andy/.m2/repository/org/hibernate/com.springsource.org.hibernate/3.2.6.ga/com.springsource.org.hibernate-3.2.6.ga.jar;C:/Users/Andy/.m2/repository/org/hibernate/com.springsource.org.hibernate.annotations/3.3.1.ga/com.springsource.org.hibernate.annotations-3.3.1.ga.jar;C:/Users/Andy/.m2/repository/org/hibernate/com.springsource.org.hibernate.annotations.common/3.3.0.ga/com.springsource.org.hibernate.annotations.common-3.3.0.ga.jar;C:/Users/Andy/.m2/repository/org/hibernate/com.springsource.org.hibernate.ejb/3.3.2.GA/com.springsource.org.hibernate.ejb-3.3.2.GA.jar;C:/Users/Andy/.m2/repository/org/hibernate/com.springsource.org.hibernate.validator/3.0.0.GA/com.springsource.org.hibernate.validator-3.0.0.GA.jar;C:/Users/Andy/.m2/repository/org/hsqldb/com.springsource.org.hsqldb/1.8.0.9/com.springsource.org.hsqldb-1.8.0.9.jar;C:/Users/Andy/.m2/repository/org/jboss/util/com.springsource.org.jboss.util/2.0.4.GA/com.springsource.org.jboss.util-2.0.4.GA.jar;C:/Users/Andy/.m2/repository/org/junit/com.springsource.org.junit/4.4.0/com.springsource.org.junit-4.4.0.jar;C:/Users/Andy/.m2/repository/org/objectweb/asm/com.springsource.org.objectweb.asm/2.2.3/com.springsource.org.objectweb.asm-2.2.3.jar;C:/Users/Andy/.m2/repository/org/objectweb/asm/com.springsource.org.objectweb.asm.attrs/1.5.3/com.springsource.org.objectweb.asm.attrs-1.5.3.jar;C:/Users/Andy/.m2/repository/org/objectweb/asm/com.springsource.org.objectweb.asm.commons/2.2.3/com.springsource.org.objectweb.asm.commons-2.2.3.jar;C:/Users/Andy/.m2/repository/org/xmlpull/com.springsource.org.xmlpull/1.1.3.4-O/com.springsource.org.xmlpull-1.1.3.4-O.jar;C:/Users/Andy/.m2/repository/org/springframework/org.springframework.aop/3.0.0.M1/org.springframework.aop-3.0.0.M1.jar;C:/Users/Andy/.m2/repository/org/springframework/org.springframework.aspects/3.0.0.M1/org.springframework.aspects-3.0.0.M1.jar;C:/Users/Andy/.m2/repository/org/springframework/org.springframework.beans/3.0.0.M1/org.springframework.beans-3.0.0.M1.jar;C:/Users/Andy/.m2/repository/org/springframework/org.springframework.context/3.0.0.M1/org.springframework.context-3.0.0.M1.jar;C:/Users/Andy/.m2/repository/org/springframework/org.springframework.core/3.0.0.M1/org.springframework.core-3.0.0.M1.jar;C:/Users/Andy/.m2/repository/org/springframework/org.springframework.expression/3.0.0.M1/org.springframework.expression-3.0.0.M1.jar;C:/Users/Andy/.m2/repository/org/springframework/org.springframework.jdbc/3.0.0.M1/org.springframework.jdbc-3.0.0.M1.jar;C:/Users/Andy/.m2/repository/org/springframework/org.springframework.orm/3.0.0.M1/org.springframework.orm-3.0.0.M1.jar;C:/Users/Andy/.m2/repository/org/springframework/org.springframework.test/3.0.0.M1/org.springframework.test-3.0.0.M1.jar;C:/Users/Andy/.m2/repository/org/springframework/org.springframework.transaction/3.0.0.M1/org.springframework.transaction-3.0.0.M1.jar;C:/Users/Andy/.m2/repository/org/springframework/org.springframework.web/3.0.0.M1/org.springframework.web-3.0.0.M1.jar;C:/Users/Andy/.m2/repository/org/springframework/org.springframework.web.servlet/3.0.0.M1/org.springframework.web.servlet-3.0.0.M1.jar;C:/Users/Andy/.m2/repository/org/springframework/roo/roo-core/0.2.0-SNAPSHOT/roo-core-0.2.0-SNAPSHOT.jar;F:/eclipse/e342/eclipse/plugins/org.aspectj.runtime_1.6.4.20090205161900/aspectjrt.jar;f:\jvms\jdk1.6.0_06\jre\lib\ext\dnsns.jar;f:\jvms\jdk1.6.0_06\jre\lib\ext\localedata.jar;f:\jvms\jdk1.6.0_06\jre\lib\ext\sunjce_provider.jar;f:\jvms\jdk1.6.0_06\jre\lib\ext\sunmscapi.jar;f:\jvms\jdk1.6.0_06\jre\lib\ext\sunpkcs11.jar;f:\eclipse\e342\eclipse\\plugins\org.eclipse.equinox.launcher_1.0.101.R34x_v20081125.jar;


	at org.aspectj.weaver.bcel.BcelTypeMunger.mungeNewField(BcelTypeMunger.java:1638)

	at org.aspectj.weaver.bcel.BcelTypeMunger.munge(BcelTypeMunger.java:90)

	at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:441)

	at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:103)

	at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1732)

	at org.aspectj.weaver.bcel.BcelWeaver.weaveWithoutDump(BcelWeaver.java:1693)

	at org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify(BcelWeaver.java:1458)

	at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1272)

	at org.aspectj.ajdt.internal.compiler.AjPipeliningCompilerAdapter.weaveQueuedEntries(AjPipeliningCompilerAdapter.java:435)

	at org.aspectj.ajdt.internal.compiler.AjPipeliningCompilerAdapter.queueForWeaving(AjPipeliningCompilerAdapter.java:371)

	at org.aspectj.ajdt.internal.compiler.AjPipeliningCompilerAdapter.afterProcessing(AjPipeliningCompilerAdapter.java:358)

	at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$after$org_aspectj_ajdt_internal_compiler_CompilerAdapter$5$6b855184(CompilerAdapter.aj:98)

	at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:652)

	at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:392)

	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:977)

	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performBuild(AjBuildManager.java:301)

	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.incrementalBuild(AjBuildManager.java:183)

	at org.aspectj.ajde.core.internal.AjdeCoreBuildManager.performBuild(AjdeCoreBuildManager.java:127)

	at org.aspectj.ajde.core.AjCompiler.build(AjCompiler.java:88)

	at org.eclipse.ajdt.core.builder.AJBuilder.build(AJBuilder.java:223)

	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:633)

	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:37)

	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:170)

	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:201)

	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:253)

	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:37)

	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:256)

	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:309)

	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:341)

	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:140)

	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:238)

	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)</description><comments/></buginformation><fixedCommits><commit id="2f36e7f0a7cbf99fbb49e5de268918d4ea57256c" author="default" date="2009-03-02 04:00:31"><file name="weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java"><method name="mungeNewConstructor" returnType="boolean" parameters="BcelClassWeaver"/><method name="mungeNewMethod" returnType="boolean" parameters="BcelClassWeaver"/><method name="mungeNewField" returnType="boolean" parameters="BcelClassWeaver NewFieldTypeMunger"/></file></commit></fixedCommits></bug><bug id="414" opendate="2009-03-04 05:49:00" fixdate="2009-03-04 17:12:43"><buginformation><summary>AspectJElementHierarchy.java:427 NullPointerException</summary><description>Since an recent update to eclipse I get errors when using ajdt compile time weaving. Single used aspect is @Configurable from spring 2.5.6. I call this critical because my application wont run without that aspect compiled in.

When doing a build two popups "AspectJ Internal Compiler Error" are showing up with instructions to look for and post bugreports.


1st popup:
--------------------------------
java.lang.NullPointerException
at org.aspectj.asm.internal.AspectJElementHierarchy.findCloserMatchForLineNumber(AspectJElementHierarchy.java:427)
at org.aspectj.weaver.model.AsmRelationshipProvider.addRelationship(AsmRelationshipProvider.java:130)
at org.aspectj.weaver.bcel.BcelTypeMunger.munge(BcelTypeMunger.java:124)
at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:441)
at org.aspectj.weaver.bcel.BcelClassWeaver.weave( ... 
end abstract interface org.springframework.beans.factory.aspectj.AbstractInterfaceDrivenDependencyInjectionAspect$ConfigurableDeserializationSupport
--------------------------------


2nd popup
--------------------------------
java.lang.NullPointerException
at org.aspectj.asm.internal.AspectJElementHierarchy.findCloserMatchForLineNumber(AspectJElementHierarchy.java:427)
at org.aspectj.weaver.model.AsmRelationshipProvider.addRelationship(AsmRelationshipProvider.java:130)
at org.aspectj.weaver.bcel.BcelTypeMunger.munge(BcelTypeMunger.java:124)
at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:441)
at org.aspectj.weaver.bcel.BcelClassWeaver.weave( ... ibatis/domain/Banf;)I
                    IRETURN
  end public volatile int compareTo(Object)
end public class de.synaix.k070_Banf.ibatis.domain.Banf
--------------------------------


Output of AJDT Event trace window:
--------------------------------
11:21:34 Removed problems and tasks for project SOME_webapp
11:21:34 Builder: Tidied output folder(s), removed class files and derived resources
11:21:35 Timer event: 1ms: Delete markers: SOME_webapp (Finished deleting markers for SOME_webapp
11:21:38 Compiler configuration for project SOME_webapp doesn't know previous state, so assuming EVERYTHING has changed.
11:21:38 ===========================================================================================
11:21:38 Build kind = FULLBUILD
11:21:38 Project=SOME_webapp, kind of build requested=Full AspectJ compilation
11:21:38 Builder: Tidied output folder(s), removed class files and derived resources
11:21:38 Timer event: 442ms: Pre compile
11:21:38 Compiler configuration for project SOME_webapp has been read by compiler.  Resetting.
11:21:38      Configuration was [PROJECTSOURCEFILES_CHANGED, JAVAOPTIONS_CHANGED, ASPECTPATH_CHANGED, CLASSPATH_CHANGED, INPATH_CHANGED, NONSTANDARDOPTIONS_CHANGED, OUTJAR_CHANGED, PROJECTSOURCERESOURCES_CHANGED, OUTPUTDESTINATIONS_CHANGED, INJARS_CHANGED]
11:21:38 Resetting list of modified source files.  Was null
11:21:38 Preparing for build: not going to be incremental because no successful previous full build
11:21:40 Timer event: 1252ms: Time to first compiled message
11:21:40 Timer event: 1276ms: Time to first woven message
11:21:45 AspectJ reports build successful, build was: FULL
11:21:45 AJDE Callback: finish. Was full build: true
11:21:45 Timer event: 6456ms: Total time spent in AJDE
11:21:45 Timer event: 157ms: Refresh after build
11:21:45 Types affected during build = 308
11:21:45 Crosscutting model sanity checked with no problems
11:21:45 Timer event: 0ms: Post compile
11:21:45 Timer event: 7248ms: Total time spent in AJBuilder.build()
11:21:45 Timer event: 2ms: Delete markers: SOME_webapp (Finished deleting markers for SOME_webapp)
11:21:45 Timer event: 179ms: Create markers: SOME_webapp (Finished creating markers for SOME_webapp)
--------------------------------</description><comments/></buginformation><fixedCommits><commit id="2309f7b8eba592fd5521952e04ec8f0093daab62" author="default" date="2009-03-04 17:12:43"><file name="asm/src/org/aspectj/asm/internal/AspectJElementHierarchy.java"><method name="findCloserMatchForLineNumber" returnType="IProgramElement" parameters="IProgramElement int"/></file></commit></fixedCommits></bug><bug id="415" opendate="2009-03-20 17:01:00" fixdate="2009-03-21 01:38:50"><buginformation><summary>Resource deletion in source folder on full build when source and output folders are the same.</summary><description>On the clean before a full aspectj build resources are removed from the output folder.  This is true even when the output and the source folder are the same.  In this case, the resources are deleted from the source folder!

When the source and output folders are the same, resources should never be deleted.</description><comments/></buginformation><fixedCommits><commit id="5c49c0b67a0e88722bf9ea7a8c9e80dce518f067" author="default" date="2009-03-21 01:38:50"><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java"><method name="hasResource" returnType="boolean" parameters="String"/><method name="recordResource" returnType="void" parameters="String"/></file><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"><method name="writeDirectory" returnType="void" parameters="String File"/><method name="writeResource" returnType="void" parameters="String byte[] File"/></file></commit></fixedCommits></bug><bug id="416" opendate="2009-03-24 12:07:00" fixdate="2009-03-24 16:43:38"><buginformation><summary>[model] package search fails in binary aspect in same package as a source type</summary><description>If type a.b.c.C is advised by an aspect a.b.c.X from the aspectpath the model search logic breaks for finding 'X' because it hits the package node for a.b.c and stops looking</description><comments/></buginformation><fixedCommits><commit id="7a7d6f0f1e81e6639bdaa4f278b4778b984ad175" author="default" date="2009-03-24 16:43:38"><file name="asm/src/org/aspectj/asm/internal/AspectJElementHierarchy.java"><method name="findElementForType" returnType="IProgramElement" parameters="String String"/></file></commit></fixedCommits></bug><bug id="417" opendate="2009-03-24 14:16:00" fixdate="2009-03-24 22:04:41"><buginformation><summary>Non synchronized access to WeakHashMap causes infinite loop</summary><description>The non synchronized access from AjTypeSystem.getAjType(clazz) to a static instance of WeakHashMap may cause an infinite loop at start up in a multi threaded system. The thread dump shows that 32 of 33 threads of the application stuck in WeakHashMap.get(Object) line 355:

"BundleStarterThreadQcCtrl24" prio=3 tid=0x00957c00 nid=0x39 runnable [0xd42fb000..0xd42ffa70]
   java.lang.Thread.State: RUNNABLE
	at java.util.WeakHashMap.get(WeakHashMap.java:355)
	at org.aspectj.lang.reflect.AjTypeSystem.getAjType(AjTypeSystem.java:37)
	at org.aspectj.weaver.reflect.Java15ReflectionBasedReferenceTypeDelegate.initialize(Java15ReflectionBasedReferenceTypeDelegate.java:66)
	at org.aspectj.weaver.reflect.ReflectionBasedReferenceTypeDelegateFactory.create15Delegate(ReflectionBasedReferenceTypeDelegateFactory.java:56)
	at org.aspectj.weaver.reflect.ReflectionBasedReferenceTypeDelegateFactory.createDelegate(ReflectionBasedReferenceTypeDelegateFactory.java:42)
	at org.aspectj.weaver.reflect.ReflectionWorld.resolveDelegate(ReflectionWorld.java:111)
	at org.aspectj.weaver.World.resolveToReferenceType(World.java:388)
	at org.aspectj.weaver.World.resolve(World.java:279)
	at org.aspectj.weaver.World.resolve(World.java:199)
	at org.aspectj.weaver.World.resolve(World.java:348)
	at org.aspectj.weaver.reflect.ReflectionWorld.resolve(ReflectionWorld.java:103)
	at org.aspectj.weaver.reflect.ReflectionWorld.resolve(ReflectionWorld.java:93)
	at org.aspectj.weaver.reflect.ReflectionBasedReferenceTypeDelegateFactory.toResolvedTypeArray(ReflectionBasedReferenceTypeDelegateFactory.java:214)
	at org.aspectj.weaver.reflect.ReflectionBasedReferenceTypeDelegateFactory.createResolvedMethod(ReflectionBasedReferenceTypeDelegateFactory.java:107)
	at org.aspectj.weaver.reflect.ReflectionBasedReferenceTypeDelegateFactory.createResolvedMember(ReflectionBasedReferenceTypeDelegateFactory.java:98)
	at org.aspectj.weaver.reflect.ReflectionShadow.makeExecutionShadow(ReflectionShadow.java:53)
	at org.aspectj.weaver.internal.tools.PointcutExpressionImpl.matchesExecution(PointcutExpressionImpl.java:100)
	at org.aspectj.weaver.internal.tools.PointcutExpressionImpl.matchesMethodExecution(PointcutExpressionImpl.java:92)
	at org.springframework.aop.aspectj.AspectJExpressionPointcut.getShadowMatch(AspectJExpressionPointcut.java:370)</description><comments/></buginformation><fixedCommits><commit id="752f895d260e3c61c8140a90812df52425ca3692" author="default" date="2009-03-24 22:04:41"><file name="aspectj5rt/java5-src/org/aspectj/lang/reflect/AjTypeSystem.java"><method name="WeakHashMap&lt;Class,WeakReference&lt;AjType&gt;&gt;" returnType="Map&lt;Class," parameters=""/></file></commit></fixedCommits></bug><bug id="418" opendate="2009-03-24 19:25:00" fixdate="2009-03-25 16:19:48"><buginformation><summary>wasted time building message context when it is only used for command line builds</summary><description>The context for a message is created even when AspectJ is used inside AJDT - but the context only ever gets used when printing messages to System.out.  Under AJDT we ought to be able to 'switch it off'</description><comments/></buginformation><fixedCommits><commit id="c732808dbf2daf655dc1c9ce4cddb20b8c27ab1a" author="default" date="2009-03-25 16:19:48"><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"><method name="acceptResult" returnType="void" parameters="CompilationResult"/></file><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/EclipseAdapterUtils.java"><method name="makeSourceLocation" returnType="ISourceLocation" parameters="ICompilationUnit IProblem"/><method name="makeMessage" returnType="IMessage" parameters="ICompilationUnit IProblem World"/></file></commit></fixedCommits></bug><bug id="419" opendate="2009-03-24 18:39:00" fixdate="2009-03-26 02:25:32"><buginformation><summary>NPE in AsmRelationshipProvider.addRelationship</summary><description>When doing a clean build of my project, seeing dozens, upwards of 100 of NPEs similar to the following:

java.lang.NullPointerException
at org.aspectj.weaver.model.AsmRelationshipProvider.addRelationship(AsmRelationshipProvider.java:168)
at org.aspectj.weaver.bcel.BcelTypeMunger.munge(BcelTypeMunger.java:124)
at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:441)
at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:103)
at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1732)
at org.aspectj.weaver.b ...  

FWIW, this is seen for Spring-managed auto-injection of beans with the @Configurable annotation.

Official AJDT version is: 1.6.4.20090304172355
Version: 3.4.2
Build id: M20090211-17</description><comments/></buginformation><fixedCommits><commit id="d5e900d42c32d32d87173c82d8a5dc51beb87300" author="default" date="2009-03-26 02:25:32"><file name="weaver/src/org/aspectj/weaver/model/AsmRelationshipProvider.java"><method name="addRelationship" returnType="void" parameters="AsmManager ResolvedType"/></file></commit></fixedCommits></bug><bug id="420" opendate="2009-03-25 17:20:00" fixdate="2009-03-26 03:15:47"><buginformation><summary>[incremental] Incremental compilation with aspects on an incoming classpath/aspectpath</summary><description>This is something it might now be time to address.  I encountered it in  bug 267794  and it was rather annoying.  With all the improvements to incremental it is annoying to just throw our hands in the air and do a full build if we hit an aspect on the defined classpath/aspectpath for a project.  I'm not looking into inpath here, if that benefits from some of these changes - that's great - but it is not something I'm trying to fix here.</description><comments/></buginformation><fixedCommits><commit id="b23cc1a113ffabc87c2efefdfa919d643562b20e" author="default" date="2009-03-26 03:15:47"><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java"><method name="classFileChangedInDirSinceLastBuildRequiringFullBuild" returnType="int" parameters="File"/><method name="changedAndNeedsFullBuild" returnType="boolean" parameters="List List"/><method name="changedAndNeedsFullBuild" returnType="boolean" parameters="List List boolean List"/><method name="classpathChangedAndNeedsFullBuild" returnType="boolean" parameters="List List"/></file></commit></fixedCommits></bug><bug id="421" opendate="2009-03-20 10:24:00" fixdate="2009-03-26 18:52:57"><buginformation><summary>[handles] Cross reference view and markers mix up joinpoints assigned to advice</summary><description>Build ID: M20090211-1700

Steps To Reproduce:
I have two pieces of after advice in my aspect.  

In the cross reference view I see all of the joinpoints for both after advice selecting one of the after advice statements.  When I select the other after advice statement I see no joinpoints.

When I select the marker for either piece of after advice, I see all the joinpoints for both pieces of advice.

1. open and perform a clean compile on the attached project
2. open the xref view
3. select line 22 an note that you see 5 joinpoints (should only be 3)
4. select line 68 and note that you see zero joinpoints (should be 2 here)
5. right click the marker at line 68 and choose "advises" - note you see all 5 joinpoints
6. right click the marker at line 22 and choose "advises" - note you see all 5 joinpoints


More information:</description><comments/></buginformation><fixedCommits><commit id="6dbb5f308c198963486550cb614204bc5bf8fd7a" author="default" date="2009-03-26 18:52:57"><file name="asm/src/org/aspectj/asm/internal/JDTLikeHandleProvider.java"><method name="getParameters" returnType="String" parameters="IProgramElement"/></file></commit></fixedCommits></bug><bug id="422" opendate="2009-04-16 18:32:00" fixdate="2009-04-30 20:44:56"><buginformation><summary>[WARNING] couldn't find aspectjrt.jar on classpath</summary><description>I am using the aspectj runtime jar that is in the spring source bundle repository.  The have renamed their jar to match their naming conventions and it is causing the warning to occur.  Their bundle is named com.springsource.org.aspectj.runtime-1.6.3.RELEASE.jar.  It would be nice if this warning was not printed out in this case.</description><comments/></buginformation><fixedCommits><commit id="1b663a986bf7d2a0b62988c08d31753ace94072e" author="default" date="2009-04-30 20:44:56"><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"><method name="checkRtJar" returnType="String" parameters="AjBuildConfig"/><method name="acceptResult" returnType="void" parameters="CompilationResult"/><method name="getWorld" returnType="World" parameters=""/><method name="setupModel" returnType="void" parameters="AjBuildConfig"/></file></commit></fixedCommits></bug><bug id="423" opendate="2009-05-05 09:50:00" fixdate="2009-05-05 23:45:14"><buginformation><summary>DocumentParser incorrectly caches DTD InputStream</summary><description>Build ID: 1.6.3

Steps To Reproduce:
Attempt to parse two aop.xml files using two DocumentParsers that are loaded by the same class loader. If the DTD is loaded from a JAR file you'll get an NPE at  java.util.zip.Inflater.inflateBytes(Native Method).

More information:
DocumentParser caches the DTD InputStream in a static final field. Many InputStreams are unusable after being closed so the same instance should not be used here. 

For InflaterInputStreams there seems to be a bug in the JRE that prevents the stream from reporting itself as closed when you use it again.</description><comments/></buginformation><fixedCommits><commit id="66235e846cc472a5e7c15ab3c1c37513d2e4ed0b" author="default" date="2009-05-05 23:45:14"><file name="weaver/src/org/aspectj/weaver/loadtime/definition/DocumentParser.java"><method name="DocumentParser.class.getResourceAsStream" returnType="InputStream" parameters=""/><method name="resolveEntity" returnType="InputSource" parameters="String String"/></file></commit></fixedCommits></bug><bug id="424" opendate="2009-06-04 11:10:00" fixdate="2009-06-04 15:43:11"><buginformation><summary>NPE determining annotation target kind during weaving</summary><description>reported on the list:

Hi,

 

I am using aspectj LTW (aspectjweaver-1.6.1) for weaving an aspect available in another jar within my web application code.

 

While building the jar which contains the aspect, using maven, I have JUnits which run without any problems using LTW.

 

My aspect code looks as below

      @Around("execution (@com.arisglobal.aglite.annotations.OperationTrail public * *(..)) &amp;&amp; this(executor)")

      public Object auditOperation(ProceedingJoinPoint thisJoinPoint,

                  Object executor) {

            鈥

鈥 aspect code

鈥

            }

 

However when I deploy the application in tomcat (with javaagent:aspectjweaver-1.6.1.jar option), I get a NPE which I have pasted below.

 

Jun 4, 2009 12:06:18 PM org.aspectj.weaver.tools.Jdk14Trace error

SEVERE: com/arisglobal/aglite/services/actiontrail/ActionTrailAspect

java.lang.NullPointerException

        at org.aspectj.weaver.bcel.BcelObjectType.getAnnotationTargetKinds(BcelO

bjectType.java:612)

        at org.aspectj.weaver.ReferenceType.getAnnotationTargetKinds(ReferenceTy

pe.java:265)

        at org.aspectj.weaver.patterns.SignaturePattern.checkForIncorrectTargetK

ind(SignaturePattern.java:112)

        at org.aspectj.weaver.patterns.SignaturePattern.checkForIncorrectTargetK

ind(SignaturePattern.java:94)

        at org.aspectj.weaver.patterns.SignaturePattern.resolveBindings(Signatur

ePattern.java:87)

        at org.aspectj.weaver.patterns.KindedPointcut.resolveBindings(KindedPoin

tcut.java:262)

        at org.aspectj.weaver.patterns.AndPointcut.resolveBindings(AndPointcut.j

ava:75)

        at org.aspectj.weaver.patterns.Pointcut.resolve(Pointcut.java:196)

        at org.aspectj.weaver.bcel.AtAjAttributes.handleAroundAnnotation(AtAjAtt

ributes.java:1308)

        at org.aspectj.weaver.bcel.AtAjAttributes.readAj5MethodAttributes(AtAjAt

tributes.java:403)

        at org.aspectj.weaver.bcel.BcelMethod.unpackAjAttributes(BcelMethod.java

:189)

        at org.aspectj.weaver.bcel.BcelMethod.&lt;init&gt;(BcelMethod.java:96)

        at org.aspectj.weaver.bcel.BcelObjectType.getDeclaredMethods(BcelObjectT

ype.java:264)

        at org.aspectj.weaver.bcel.LazyClassGen.&lt;init&gt;(LazyClassGen.java:303)

        at org.aspectj.weaver.bcel.BcelObjectType.getLazyClassGen(BcelObjectType

.java:524)

        at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1728)

        at org.aspectj.weaver.bcel.BcelWeaver.weaveWithoutDump(BcelWeaver.java:1

696)

        at org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify(BcelWeaver.java:145

8)

        at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1244)

        at org.aspectj.weaver.tools.WeavingAdaptor.getWovenBytes(WeavingAdaptor.

java:423)

        at org.aspectj.weaver.tools.WeavingAdaptor.weaveClass(WeavingAdaptor.jav

a:286)

        at org.aspectj.weaver.loadtime.Aj.preProcess(Aj.java:95)

        at org.aspectj.weaver.loadtime.ClassPreProcessorAgentAdapter.transform(C

lassPreProcessorAgentAdapter.java:52)

        at sun.instrument.TransformerManager.transform(TransformerManager.java:1

22)

        at sun.instrument.InstrumentationImpl.transform(InstrumentationImpl.java

:155)

        at java.lang.ClassLoader.defineClass1(Native Method)

        at java.lang.ClassLoader.defineClass(ClassLoader.java:620)

 

I also tried using aspectjweaver-1.6.4 version however got the same error.</description><comments/></buginformation><fixedCommits><commit id="3417cbe70eb77243767e59f9fd181b989c8cefb6" author="default" date="2009-06-04 15:43:11"><file name="weaver/src/org/aspectj/weaver/bcel/BcelObjectType.java"><method name="canAnnotationTargetType" returnType="boolean" parameters=""/></file></commit></fixedCommits></bug><bug id="425" opendate="2009-06-18 10:48:00" fixdate="2009-06-18 18:37:30"><buginformation><summary>JavaDocRunner fails on System.setSecurityManager in Netbeans</summary><description>Attempting to use the ajdoc ant task in Netbeans 6.7.  The JavaDocRunner attempts to set the SecurityManager and this is prevented by Netbeans.  Below is the ant stacktrace printed to the Netbeans output window.  I can run the ant task from the command line with no errors.  Only in the context of Netbeans does it fail.

I think the JavaDocRunner should run with whatever SecurityManager is in place and allow errors from executing javadoc to occur.  Attached is a patch file removing the anonymous SecurityManager and calls to System.setSecurityManager(). 

init:
 &gt; Calling ajc...
&gt; Building signature files...
&gt; Calling javadoc... 
An internal error occured in ajdoc
                                                                  
If this has not already been logged as a bug raised please raise  
a new AspectJ bug at  https://bugs.eclipse.org/bugs  including the  
text below. To make the bug a priority, please also include a test
program that can reproduce this problem.
 
java.lang.SecurityException
java.lang.SecurityException
        at org.netbeans.TopSecurityManager.checkSetSecurityManager(TopSecurityManager.java:431)
        at org.netbeans.TopSecurityManager.checkPermission(TopSecurityManager.java:365)
        at java.lang.System.setSecurityManager0(System.java:273)
        at java.lang.System.setSecurityManager(System.java:264)
        at org.aspectj.tools.ajdoc.JavadocRunner.callJavadoc(JavadocRunner.java:43)
        at org.aspectj.tools.ajdoc.Main.callJavadoc(Main.java:277)
        at org.aspectj.tools.ajdoc.Main.main(Main.java:156)
        at org.aspectj.tools.ant.taskdefs.Ajdoc.compile(Ajdoc.java:710)
        at org.aspectj.tools.ant.taskdefs.Ajdoc.execute(Ajdoc.java:697)
        at org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:288)
        at sun.reflect.GeneratedMethodAccessor131.invoke(Unknown Source)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
        at java.lang.reflect.Method.invoke(Method.java:597)
        at org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)
        at org.apache.tools.ant.Task.perform(Task.java:348)
        at org.apache.tools.ant.Target.execute(Target.java:357)
        at org.apache.tools.ant.Target.performTasks(Target.java:385)
        at org.apache.tools.ant.Project.executeSortedTargets(Project.java:1337)
        at org.apache.tools.ant.Project.executeTarget(Project.java:1306)
        at org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)
        at org.apache.tools.ant.Project.executeTargets(Project.java:1189)
        at org.apache.tools.ant.module.bridge.impl.BridgeImpl.run(BridgeImpl.java:278)
        at org.apache.tools.ant.module.run.TargetExecutor.run(TargetExecutor.java:497)
        at org.netbeans.core.execution.RunClassThread.run(RunClassThread.java:151)

org.netbeans.core.execution.ExitSecurityException: Exit from within execution engine, normal
        at org.netbeans.core.execution.SecMan.checkExitImpl(SecMan.java:85)
        at org.netbeans.core.execution.SecMan$PrivilegedCheck.run(SecMan.java:160)
        at java.security.AccessController.doPrivileged(Native Method)
        at org.netbeans.core.execution.SecMan$PrivilegedCheck.check(SecMan.java:175)
        at org.netbeans.core.execution.SecMan$PrivilegedCheck.checkExit(SecMan.java:170)
        at org.netbeans.core.execution.SecMan.checkExit(SecMan.java:69)
        at org.netbeans.TopSecurityManager.checkExit(TopSecurityManager.java:149)
        at java.lang.Runtime.exit(Runtime.java:88)
        at java.lang.System.exit(System.java:906)
        at org.aspectj.tools.ajdoc.Main.exit(Main.java:765)
        at org.aspectj.tools.ajdoc.Main.main(Main.java:163)
        at org.aspectj.tools.ant.taskdefs.Ajdoc.compile(Ajdoc.java:710)
        at org.aspectj.tools.ant.taskdefs.Ajdoc.execute(Ajdoc.java:697)
        at org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:288)
        at sun.reflect.GeneratedMethodAccessor131.invoke(Unknown Source)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
        at java.lang.reflect.Method.invoke(Method.java:597)
        at org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)
        at org.apache.tools.ant.Task.perform(Task.java:348)
        at org.apache.tools.ant.Target.execute(Target.java:357)
        at org.apache.tools.ant.Target.performTasks(Target.java:385)
        at org.apache.tools.ant.Project.executeSortedTargets(Project.java:1337)
        at org.apache.tools.ant.Project.executeTarget(Project.java:1306)
        at org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)
        at org.apache.tools.ant.Project.executeTargets(Project.java:1189)
        at org.apache.tools.ant.module.bridge.impl.BridgeImpl.run(BridgeImpl.java:278)
        at org.apache.tools.ant.module.run.TargetExecutor.run(TargetExecutor.java:497)
        at org.netbeans.core.execution.RunClassThread.run(RunClassThread.java:151)
BUILD FAILED (total time: 3 seconds)</description><comments/></buginformation><fixedCommits><commit id="59d5c3bcd7c045c55826f1b62576ffa05321626f" author="default" date="2009-06-18 18:37:30"><file name="ajdoc/src/org/aspectj/tools/ajdoc/JavadocRunner.java"><method name="checkPermission" returnType="void" parameters="java.security.Permission"/><method name="callJavadoc" returnType="void" parameters="String[]"/><method name="has14ToolsAvailable" returnType="boolean" parameters=""/><method name="checkExit" returnType="void" parameters="int"/></file></commit></fixedCommits></bug><bug id="426" opendate="2009-07-30 11:00:00" fixdate="2009-07-30 15:29:40"><buginformation><summary>Sometimes when load-time weaving there will be two ReferenceType objects for the same type</summary><description>Seen by Ramnivas.

A pointcut uses an exact type name for an annotation

execution(* (@Controller *..*).*(..))

Resolving this pointcut causes us to construct a ReferenceType for 'Controller'.  Then we attempt to populate it by loading the class implementation.  This recurses back into the weaver as Controller is loaded and an attempt is made to weave it.  This takes a second route through the weaver to build a referencetype again and this second referencetype is cached in the world.  When we unwind, we continue building the original referencetype and are left with one in the cache and the one resolved for the pointcut.  Due to the use of == for comparison, we fail to match on join points later because they will use the ReferenceType from the cache.</description><comments/></buginformation><fixedCommits><commit id="dd7d87923f6f8e6ccdc3e387679ba5a3c70550ac" author="default" date="2009-07-30 15:29:40"><file name="org.aspectj.matcher/src/org/aspectj/weaver/World.java"><method name="resolve" returnType="ResolvedType" parameters="UnresolvedType boolean"/></file></commit></fixedCommits></bug><bug id="427" opendate="2009-08-21 11:30:00" fixdate="2009-08-24 18:07:09"><buginformation><summary>NPE using declare @type</summary><description>reported by Ramnivas:

java.lang.NullPointerException
        at 
org.aspectj.weaver.bcel.BcelObjectType.hasAnnotation(BcelObjectType.java:558)
        at 
org.aspectj.weaver.ReferenceType.hasAnnotation(ReferenceType.java:161)
        at 
org.aspectj.weaver.patterns.ExactAnnotationTypePattern.matches(ExactAnnotationTypePattern.java:101)
        at 
org.aspectj.weaver.patterns.ExactAnnotationTypePattern.matches(ExactAnnotationTypePattern.java:94)
        at 
org.aspectj.weaver.patterns.AnyWithAnnotationTypePattern.matchesExactly(TypePattern.java:513)
        at 
org.aspectj.weaver.patterns.TypePattern.matchesStatically(TypePattern.java:129)
        at 
org.aspectj.weaver.patterns.DeclareAnnotation.matches(DeclareAnnotation.java:269)
        at 
org.aspectj.weaver.bcel.BcelWeaver.applyDeclareAtType(BcelWeaver.java:1590)</description><comments/></buginformation><fixedCommits><commit id="b6649690748b44544a361e39510a10e0bf83ca46" author="default" date="2009-08-24 18:07:09"><file name="weaver/src/org/aspectj/weaver/bcel/BcelObjectType.java"><method name="hasAnnotation" returnType="boolean" parameters="UnresolvedType"/><method name="ensureAnnotationsUnpacked" returnType="void" parameters=""/></file></commit></fixedCommits></bug><bug id="428" opendate="2009-09-03 12:17:00" fixdate="2009-09-03 16:21:37"><buginformation><summary>failure to close inputstream</summary><description>default</description><comments/></buginformation><fixedCommits><commit id="3d3d03b2898a16658e281583d3912b24db1c0ac1" author="default" date="2009-09-03 16:21:37"><file name="org.aspectj.matcher/src/org/aspectj/weaver/Lint.java"><method name="loadDefaultProperties" returnType="void" parameters=""/></file></commit></fixedCommits></bug><bug id="429" opendate="2009-09-18 04:23:00" fixdate="2009-09-18 23:05:59"><buginformation><summary>Potentially unclosed stream in org.aspectj.weaver.bcel.BcelWorld</summary><description>Created  attachment 147526   [details] 
Eclipse workspace patch that closes the stream correctly

In method lookupJavaClass(), one has to close a stream used by ClassParser.
This should be done in a finally block, since parse() may fail and throw an
IOException. Right now, the stream is left open in that case.

A path to correctly close the stream is attached.</description><comments/></buginformation><fixedCommits><commit id="67ffda8e2f53058f6e41336f5204541e912ca9e2" author="default" date="2009-09-18 23:05:59"><file name="weaver/src/org/aspectj/weaver/bcel/BcelWorld.java"><method name="lookupJavaClass" returnType="JavaClass" parameters="ClassPathManager String"/></file></commit></fixedCommits></bug><bug id="430" opendate="2009-09-18 04:31:00" fixdate="2009-09-18 23:07:29"><buginformation><summary>Unclosed stream in org.aspectj.weaver.bcel.ExtensibleURLClassLoader</summary><description>Created  attachment 147527   [details] 
Eclipse workspace patch that closes the stream

The method getBytes() gets a fresh stream from ClassFile and should close it
after using it. Right now, the stream is left open.

A patch is attached that closes the stream.</description><comments/></buginformation><fixedCommits><commit id="4d200d1ffd09f64825f908979a3d7af0f3cb63a9" author="default" date="2009-09-18 23:07:29"><file name="weaver/src/org/aspectj/weaver/bcel/ExtensibleURLClassLoader.java"><method name="defineClass" returnType="Class" parameters="String byte[] CodeSource"/></file></commit></fixedCommits></bug><bug id="431" opendate="2009-06-05 14:02:00" fixdate="2009-10-22 23:26:14"><buginformation><summary>AspectJ LTW with Cobertura</summary><description>We are using AspectJ LTW along with Cobertura for code coverage. Class files are
weaved just fine if they are not instrumented with Cobertura, but when
AspectJ attempts to weave the same aspects into Cobertura-instrumented
copies of the same class files, weaving fails with the following error:

 &gt;&gt; error at com\mycompany\MyAspect.java::0 Cannot read debug info for 
@Aspect to handle formal binding in pointcuts (please compile with 'javac
-g' or '&lt;javac debug='true'.../&gt;' in Ant)

The attached project demonstrates the problem. It contains one simple aspect, a target class, and a unit test for the aspect. To see the problem, run the "unittest" target in the included Ant build file. This will run the single unit test twice. In the first pass, the test is run with javac-generated (i.e. uninstrumented) class files. The aspect is correctly woven and the test passes. In the second pass, the test is run with Cobertura-instrumented class files. There is an error during LTW, and the test fails.</description><comments/></buginformation><fixedCommits><commit id="35a964971d99283b22510f73b5e7e826b57c619a" author="default" date="2009-10-22 23:26:14"><file name="weaver/src/org/aspectj/weaver/bcel/AtAjAttributes.java"><method name="lastbit" returnType="String" parameters="String"/></file></commit></fixedCommits></bug><bug id="432" opendate="2009-10-26 14:19:00" fixdate="2009-10-27 14:04:12"><buginformation><summary>RuntimeException weaving roo app with advice based on execution pointcut</summary><description>java.lang.RuntimeException
at org.aspectj.weaver.ResolvedType.getAnnotations(ResolvedType.java:718)
at org.aspectj.weaver.AbstractAnnotationAJ.retrieveAnnotationOnAnnotation(AbstractAnnotationAJ.java:123)
at org.aspectj.weaver.AbstractAnnotationAJ.ensureAtTargetInitialized(AbstractAnnotationAJ.java:85)
at org.aspectj.weaver.AbstractAnnotationAJ.specifiesTarget(AbstractAnnotationAJ.java:115)
at org.aspectj.weaver.bcel.BcelWeaver.verifyTa ... .eclipse.core.internal.jobs.Worker.run(Worker.java:55)

Compile error: RuntimeException thrown: ResolvedType.getAnnotations() should never be called</description><comments/></buginformation><fixedCommits><commit id="a23c7e40904d0c5cd572d6f49a461ae474a0d303" author="default" date="2009-10-27 14:04:12"><file name="org.aspectj.matcher/src/org/aspectj/weaver/MissingResolvedTypeWithKnownSignature.java"><method name="getInterTypeParentMungers" returnType="List" parameters=""/><method name="getInterTypeParentMungersIncludingSupers" returnType="List" parameters=""/><method name="hasAnnotation" returnType="boolean" parameters="UnresolvedType"/><method name="raiseCantFindType" returnType="void" parameters="String String"/><method name="getDeclaredInterfaces" returnType="ResolvedType[]" parameters=""/><method name="raiseWarningOnMissingInterfaceWhilstFindingMethods" returnType="void" parameters=""/><method name="getModifiers" returnType="int" parameters=""/><method name="tidy" returnType="void" parameters=""/><method name="isAssignableFrom" returnType="boolean" parameters="ResolvedType boolean"/><method name="getInterTypeMungersIncludingSupers" returnType="List" parameters=""/><method name="raiseWarningOnJoinPointSignature" returnType="void" parameters="String"/><method name="getDeclaredPointcuts" returnType="ResolvedMember[]" parameters=""/><method name="getInterTypeMungers" returnType="List" parameters=""/><method name="getSuperclass" returnType="ResolvedType" parameters=""/><method name="isAssignableFrom" returnType="boolean" parameters="ResolvedType"/><method name="getDeclaredMethods" returnType="ResolvedMember[]" parameters=""/><method name="isMissing" returnType="boolean" parameters=""/><method name="getDeclaredFields" returnType="ResolvedMember[]" parameters=""/><method name="raiseCantFindType" returnType="void" parameters="String"/></file></commit></fixedCommits></bug><bug id="433" opendate="2005-12-12 10:43:00" fixdate="2009-11-19 18:33:01"><buginformation><summary>Support Load-Time Weaving and HotSwap</summary><description>LTW can be used in a development environment when the JVM is run under the debugger. If a class is modified it may be recompiled, submitted to the JVM being debugged and "HotSwapped" (see  bug 117854 ). The AspectJ 5 javaagent used for LTW is made aware of this through the JVMTI ( http://java.sun.com/j2se/1.5.0/docs/api/java/lang/instrument/ClassFileTransformer.html ) but current implementation throws an exception. There may be a limited number of transformations we could safely perfrom especially if the aspects involved only implement dynamic cross-cutting.</description><comments/></buginformation><fixedCommits><commit id="19355dd4021dae5388a4a6178f08d57595b59b1d" author="default" date="2009-11-19 18:33:01"><file name="loadtime5/java5-src/org/aspectj/weaver/loadtime/ClassPreProcessorAgentAdapter.java"><method name="transform" returnType="byte[]" parameters="ClassLoader String"/></file></commit></fixedCommits></bug><bug id="434" opendate="2010-01-04 13:27:00" fixdate="2010-01-05 00:44:36"><buginformation><summary>suspected problem with handling of multiple aop.xml files</summary><description>default</description><comments/></buginformation><fixedCommits><commit id="a9688904c8041bd2bbb28817fbb82833522340c2" author="default" date="2010-01-05 00:44:36"><file name="loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"><method name="accept" returnType="boolean" parameters="String byte[]"/></file></commit></fixedCommits></bug><bug id="435" opendate="2010-03-13 20:52:00" fixdate="2010-03-23 14:26:02"><buginformation><summary>Exception was thrown when I saved a file in Eclipse</summary><description>Build Identifier: SpringSource STS 2.3.1

java.util.ConcurrentModificationException
at java.util.HashMap$HashIterator.nextEntry(HashMap.java:793)
at java.util.HashMap$KeyIterator.next(HashMap.java:828)
at org.aspectj.asm.internal.AspectJElementHierarchy.updateHandleMap(AspectJElementHierarchy.java:594)
at org.aspectj.asm.AsmManager.removeStructureModelForFiles(AsmManager.java:564)
at org.aspectj.asm.AsmManager.processDelta(AsmManager.java:639)
at org.aspectj.ajdt.internal.core ... un(AutoBuildJob.java:238)
at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

Compile error: ConcurrentModificationException thrown: null

Reproducible: Always

Steps to Reproduce:
1.Generate an abstract class using Spring roo
2. Edit that file within Eclipse/STS to add JPA annotations
3.Click on the save icon to save the file - Exceptions box pops up</description><comments/></buginformation><fixedCommits><commit id="749078d83c99b0f19f4a3060460a17730faa97f9" author="default" date="2010-03-23 14:26:02"><file name="asm/src/org/aspectj/asm/internal/AspectJElementHierarchy.java"><method name="findElementForLabel" returnType="IProgramElement" parameters="IProgramElement"/><method name="findElementForType" returnType="IProgramElement" parameters="String String"/><method name="findClassInNodes" returnType="IProgramElement" parameters="Collection String"/><method name="findElementForHandleOrCreate" returnType="IProgramElement" parameters="String boolean"/><method name="findElementForHandle" returnType="IProgramElement" parameters="IProgramElement"/><method name="hasMoreSpecificChild" returnType="boolean" parameters="IProgramElement String int int"/><method name="updateHandleMap" returnType="void" parameters="Set"/><method name="findElementForSignature" returnType="IProgramElement" parameters="IProgramElement"/></file></commit></fixedCommits></bug><bug id="436" opendate="2010-04-05 14:16:00" fixdate="2010-04-05 18:25:10"><buginformation><summary>incremental build problem when mixing up ITDs and declare parents</summary><description>reported by Rod Johnson.  He had a sophisticated aspect doing a mix of ITDs and declare parents.  On doing an incremental build he was receiving errors that looked like the declare parents hadn't applied on the secondary build.

What was actually happening is that when a class file was brought in as a BinaryTypeBinding, the existing World representation wasn't being cleaned up properly.  Without the cleanup the declare parents thought it was still in effect, but it was not.  With proper cleanup the declare parents applies on the secondary build and all is well. Change is in AjLookupEnviroment.weaveInterTypeDeclarations where the onType.clearInterTypeMungers() must be paired with an onType.ensureConsistent() call.</description><comments/></buginformation><fixedCommits><commit id="4b43dc63d14ad8b2bc82129bc27bdc3abfdfd7b4" author="default" date="2010-04-05 18:25:10"><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java"><method name="weaveInterTypeDeclarations" returnType="void" parameters="SourceTypeBinding"/></file></commit></fixedCommits></bug><bug id="437" opendate="2010-04-15 19:09:00" fixdate="2010-04-16 15:18:11"><buginformation><summary>Changes to Main.java</summary><description>In order to get the AJDT ant integration working, we need a small change to Main.java.

We need to be able to pass in a custom org.aspectj.bridge.ICommand object.  Currently, the ICommand object is created via reflection.

Here is my suggestion:

1. augment the ICommand local variable to being a field
2. add a setter for this field
3. change this:
ICommand command = ReflectionFactory.makeCommand(commandName, holder);
to this:
if (command != null)
  command = ReflectionFactory.makeCommand(commandName, holder);</description><comments/></buginformation><fixedCommits><commit id="b21eb05a252a83b5a920430d733bed1b4dc97d52" author="default" date="2010-04-16 15:18:11"><file name="org.aspectj.ajdt.core/src/org/aspectj/tools/ajc/Main.java"><method name="appendNLabel" returnType="void" parameters="StringBuffer String int"/></file></commit></fixedCommits></bug><bug id="438" opendate="2010-04-27 15:59:00" fixdate="2010-04-28 01:05:35"><buginformation><summary>Bug in ProgramElement.getCorrespondingType()</summary><description>Here is the code for the method:

	public String getCorrespondingType(boolean getFullyQualifiedType) {
		String returnType = (String) kvpairs.get("returnType");
		if (returnType == null)
			returnType = "";
		if (getFullyQualifiedType) {
			return returnType;
		}
		int index = returnType.lastIndexOf(".");
		if (index != -1) {
			return returnType.substring(index);
		}
		return returnType;
	}

the line:
return returnType.substring(index);
should be using 'index+1'</description><comments/></buginformation><fixedCommits><commit id="a502da8b5a1b2fefa0d57ffbcc950ebf88ae497d" author="default" date="2010-04-28 01:05:35"><file name="asm/src/org/aspectj/asm/internal/ProgramElement.java"><method name="setFormalComment" returnType="void" parameters="String"/><method name="genAccessibility" returnType="IProgramElement.Accessibility" parameters="int"/><method name="addChild" returnType="void" parameters="IProgramElement"/><method name="setSourceSignature" returnType="void" parameters="String"/><method name="getDeclaringType" returnType="String" parameters=""/><method name="addChild" returnType="void" parameters="int IProgramElement"/><method name="setMessage" returnType="void" parameters="IMessage"/><method name="setBytecodeName" returnType="void" parameters="String"/><method name="toSignatureString" returnType="String" parameters="boolean"/><method name="setOverrider" returnType="void" parameters="boolean"/><method name="setExtraInfo" returnType="void" parameters="ExtraInformation"/><method name="getPackageName" returnType="String" parameters=""/><method name="getFormalComment" returnType="String" parameters=""/><method name="setRunnable" returnType="void" parameters="boolean"/><method name="setParentTypes" returnType="void" parameters="List"/><method name="genModifiers" returnType="List" parameters="int"/><method name="setCorrespondingType" returnType="void" parameters="String"/><method name="setImplementor" returnType="void" parameters="boolean"/><method name="setRelations" returnType="void" parameters="List"/><method name="getCorrespondingType" returnType="String" parameters="boolean"/><method name="setDetails" returnType="void" parameters="String"/><method name="setChildren" returnType="void" parameters="List"/><method name="setDeclaringType" returnType="void" parameters="String"/><method name="preProcess" returnType="void" parameters="IProgramElement"/><method name="setParameterNames" returnType="void" parameters="List"/><method name="toLongString" returnType="String" parameters=""/></file></commit></fixedCommits></bug><bug id="439" opendate="2010-04-22 12:18:00" fixdate="2010-04-29 19:54:09"><buginformation><summary>java.lang.RuntimeException at AsmManager.java:1143</summary><description>Build Identifier: Eclipse AspectJ Development Tools  Version: 2.0.3.e35x-20100419-1200 AspectJ version: 1.6.9.20100416110000

java.lang.RuntimeException
at org.aspectj.asm.AsmManager.removeSingleNode(AsmManager.java:1143)
at org.aspectj.asm.AsmManager.removeRelationshipsTargettingThisType(AsmManager.java:798)
at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1173)
at org.aspectj.ajdt.internal.compiler.AjPipeliningCompilerAdapter.weaveQueuedEntries(AjPipeliningCompilerAdapter.java:455)
at org.aspectj.ajdt.internal.compiler.AjPipeliningCompilerAdapter. ...  for handle =xstm/stm&lt;com.argilsoft.xstm.core{TKeyed.java[TKeyed[Visitor?field-set(java.util.ArrayList com.argilsoft.xstm.core.Visitor._continueStack)

Reproducible: Sometimes

Steps to Reproduce:
Random exception popup in Eclipse</description><comments/></buginformation><fixedCommits><commit id="728ecb8806b154c20f7b1248ae994a93a514f7a2" author="default" date="2010-04-29 19:54:09"><file name="asm/src/org/aspectj/asm/AsmManager.java"><method name="removeSingleNode" returnType="void" parameters="IProgramElement"/></file></commit></fixedCommits></bug><bug id="440" opendate="2010-05-06 11:22:00" fixdate="2010-05-06 16:34:47"><buginformation><summary>AspectJ internal Compiler Error</summary><description>Stack Trace:
java.lang.NullPointerException
at org.aspectj.weaver.model.AsmRelationshipProvider.createSourceLocation(AsmRelationshipProvider.java:303)
at org.aspectj.weaver.model.AsmRelationshipProvider.addPointcuts(AsmRelationshipProvider.java:580)
at org.aspectj.weaver.model.AsmRelationshipProvider.createHierarchyForBinaryAspect(AsmRelationshipProvider.java:562)
at org.aspectj.weaver.model.AsmRelationshipProvider.addAdvisedRelationship(AsmRelations ...       ARETURN
  end public Object run(Object[])
end public class com.cerner.isis.biz.services.asclepius.patient.PatientManagerImplTest$AjcClosure3


Happening when weaving a jar with a aspect jar.</description><comments/></buginformation><fixedCommits><commit id="3be69a2d115996e70903880e50c5bb897f53b887" author="default" date="2010-05-06 16:34:47"><file name="weaver/src/org/aspectj/weaver/model/AsmRelationshipProvider.java"><method name="addDeclareAnnotationMethodRelationship" returnType="void" parameters=""/><method name="addPointcuts" returnType="void" parameters="AsmManager String"/></file></commit></fixedCommits></bug><bug id="441" opendate="2010-05-25 17:32:00" fixdate="2010-05-25 23:03:13"><buginformation><summary>pointcut rewriter can have issues for large hashcode values</summary><description>AJDT uses a pointcut like this:

(persingleton(org.eclipse.ajdt.internal.ui.ras.UIFFDC) &amp;&amp; ((handler(java.lang.Throwable+) &amp;&amp; args(arg1)) &amp;&amp; ((within(org.eclipse.ajdt..*) &amp;&amp; (!within(org.eclipse.ajdt.internal.ui.lazystart..*) &amp;&amp; (!within(org.eclipse.ajdt.internal.ui.dialogs.OpenTypeSelectionDialog2) &amp;&amp; !(within(org.eclipse.ajdt.internal.ui.editor.AspectJBreakpointRulerAction) &amp;&amp; handler(org.eclipse.jface.text.BadLocationException))))) &amp;&amp; (!(within(org.eclipse.ajdt.core.ras.FFDC+) || handler(org.eclipse.core.runtime.OperationCanceledException)) &amp;&amp; !this(java.lang.Object)))))

After the pointcut rewriter has chewed on it, it is reduced to a normal form.  This is meant to be a stable form such that further rewrites of it would not change it.  This turned out not to be the case.  The hashcodes for some of the components were quite large and manifested as negative integers.  The arithmetic in the comparator for the elements would have a problem and give unhelpful responses.  For example, if the elements were C,B,A it might rewrite them to A,B,C but on a subsequent rewrite it would realise that C was less than A, giving B,C,A.  Whether it went wrong was dependent on the order in which the elements were collected by the rewriter.

This is now fixed.  It impacts incremental compilation sometimes as two pointcuts that should be identical look different because one has been through the rewritter more times than the other...</description><comments/></buginformation><fixedCommits><commit id="1e28b926584c406e4822ec153f6bac07af47771d" author="default" date="2010-05-25 23:03:13"><file name="org.aspectj.matcher/src/org/aspectj/weaver/patterns/PointcutEvaluationExpenseComparator.java"><method name="compare" returnType="int" parameters="Pointcut Pointcut"/><method name="getScore" returnType="int" parameters="Pointcut"/></file><file name="org.aspectj.matcher/testsrc/org/aspectj/weaver/patterns/PointcutRewriterTest.java"><method name="testOrderingInAnd" returnType="void" parameters=""/></file></commit></fixedCommits></bug><bug id="442" opendate="2010-05-24 11:53:00" fixdate="2010-05-26 22:31:02"><buginformation><summary>[plan] [ltw] [hcr] LTW, Reweaving and Hot Code Replace changes reflected every two saves of files</summary><description>Build Identifier: AspectJ 1.6.9.M2 (Eclipse 3.5.1 Build ID: 20090920-1017)

A full description of the bug is in the AspectJ-Users mail list:
 http://dev.eclipse.org/mhonarc/lists/aspectj-users/msg12114.html 

While debugging if I change the content of a method (ex. the text of a System.out) and save the file, it wouldn't reflected. But if I save the save file again, this time the changes are reflected. And it repeats on cycles of two saves.
The rare is that when I save and the changes are not reflected, in log appears the next two lines and when I save the file and changes are reflected this lines are not showed:

[AppClassLoader@2bbd86] info processing reweavable type test.weaved.Test: test\weaved\Test.java
[AppClassLoader@2bbd86] info successfully verified type test.aspects.TestAspect exists.  Originates from test\aspects\TestAspect.java

This lines comes from the method processReweavableStateIfPresent(String, BcelObjectType) on the class org.aspectj.weaver.bcel.BcelWeaver

Setting -Xset:overWeaving=true was worst because every time that I save the file that is aspected I get this message from Eclipse in a popup: "Hot code replace failed - Scheme change not implemented" and the changes are never reflected, neither in the first save nor in the second save.

My environment is:
Windows XP SP3 32 bits
Sun Java 1.6.0 Update 19 JDK
Eclipse 3.5.1 Build ID: 20090920-1017
AspectJ 1.6.9 M2 (the same occurs with 1.6.8)
Project: A clean new basis java project that only has this test and AspectJ
Weaver options: -Xreweavable -verbose -showWeaveInfo -debug (and also -Xset:overWeaving=true in some tests)
Using: -javaagent:aspectjweaver-1.6.9.M2.jar

I will attach the test project that I used to isolate and reproduce this bug.

Reproducible: Always

Steps to Reproduce:
1. Import the attached project into Eclipse
2. Run the project with the Main.launch that is in the project root.
3. Modify the method print() in the class test.weaved.Test (ex. uncomment a line)
4. See the console log. The changes are not reflected in the behavior.
5. Modify again the method print() in the class test.weaved.Test (ex. uncomment another line)
6. See the console log. Now the changes are reflected in the behavior.
7. The same occurs whatever you change (obviously with the limits of the Hot Code Replace imposed by the JDK)</description><comments/></buginformation><fixedCommits><commit id="cf0ee0c1ee5af17d91fe81e68b059665fe824bcd" author="default" date="2010-05-26 22:31:02"><file name="weaver/src/org/aspectj/weaver/bcel/BcelWorld.java"><method name="addSourceObjectType" returnType="BcelObjectType" parameters="String byte[]"/></file><file name="weaver/src/org/aspectj/weaver/bcel/BcelObjectType.java"><method name="ensureAspectJAttributesUnpacked" returnType="void" parameters=""/></file><file name="weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java"><method name="weaveClass" returnType="byte[]" parameters="String byte[] boolean"/></file></commit></fixedCommits></bug><bug id="443" opendate="2010-05-27 15:47:00" fixdate="2010-05-27 20:11:51"><buginformation><summary>NPE when using aop.xml for compile time config</summary><description>Reported on the list:

java.lang.NullPointerException
at org.aspectj.weaver.bcel.BcelWorld.isAspectIncluded(BcelWorld.java:942)
at org.aspectj.weaver.ShadowMunger.match(ShadowMunger.java:80)
at org.aspectj.weaver.Advice.match(Advice.java:106)
at org.aspectj.weaver.bcel.BcelAdvice.match(BcelAdvice.java:149)
at org.aspectj.weaver.bcel.BcelClassWeaver.match(BcelClassWeaver.java:3108)
at org.aspectj.weaver.bcel.BcelClassWeaver.match(BcelClassWeaver.java:2562)</description><comments/></buginformation><fixedCommits><commit id="0e5ecd3dcd9e4fb7a4e82f1f96b9439c4c613a16" author="default" date="2010-05-27 20:11:51"><file name="org.aspectj.matcher/src/org/aspectj/weaver/Advice.java"><method name="makeCflowEntry" returnType="Advice" parameters="World Pointcut"/></file></commit></fixedCommits></bug><bug id="444" opendate="2010-06-17 01:50:00" fixdate="2010-06-29 00:07:59"><buginformation><summary>NullPointerException during weaving</summary><description>Created  attachment 172090   [details] 
AspectJ compile log

Using the Maven plugin to compile aspects into my code I get the following exception:

鈥
---- Exception Information ---
java.lang.NullPointerException
        at org.aspectj.weaver.bcel.BcelObjectType.ensureGenericSignatureUnpacked(BcelObjectType.java:823)
        at org.aspectj.weaver.bcel.BcelObjectType.getSuperclass(BcelObjectType.java:228)
        at org.aspectj.weaver.ReferenceType.getSuperclass(ReferenceType.java:905)
        at org.aspectj.weaver.bcel.AtAjAttributes.handleAspectAnnotation(AtAjAttributes.java:490)
        at org.aspectj.weaver.bcel.AtAjAttributes.readAj5ClassAttributes(AtAjAttributes.java:234)
鈥

I have attached the complete log as attachment.</description><comments/></buginformation><fixedCommits><commit id="92a52a21be71734cfe05dc6a8fdbc8a14beba467" author="default" date="2010-06-29 00:07:59"><file name="weaver/src/org/aspectj/weaver/bcel/BcelObjectType.java"><method name="ensureGenericSignatureUnpacked" returnType="void" parameters=""/></file></commit></fixedCommits></bug><bug id="445" opendate="2010-06-23 15:28:00" fixdate="2010-06-29 00:12:05"><buginformation><summary>import handling and type lookup issues</summary><description>Raised by Peter Melnikov on the mailing list.

Two problems: 
1) the binding scope being used for annotation style aspects accumulates lots of duplicate import prefixes in the SimpleScope object.
2) SimpleScope.lookupType tries the prefixes even if the type is already fully qualified. 

The combination of these issues causes a terrible mess.  Lots of class lookup failures.  Since the type cannot be 'partially qualified' it is silly to use the prefixes if the type is fully qualified.</description><comments/></buginformation><fixedCommits><commit id="767bb859f169094181618e45651ed04697e735b4" author="default" date="2010-06-29 00:12:05"><file name="org.aspectj.matcher/testsrc/org/aspectj/weaver/patterns/PatternsTests.java"><method name="suite" returnType="Test" parameters=""/></file><file name="org.aspectj.matcher/src/org/aspectj/weaver/patterns/WildTypePattern.java"><method name="splitNames" returnType="char[][]" parameters="String boolean"/><method name="couldEverMatchSameTypesAs" returnType="boolean" parameters="TypePattern"/><method name="preMatch" returnType="String[]" parameters="String[]"/><method name="isNamePatternStar" returnType="boolean" parameters=""/></file><file name="org.aspectj.matcher/src/org/aspectj/weaver/BindingScope.java"><method name="getEnclosingType" returnType="ResolvedType" parameters=""/><method name="lookupType" returnType="UnresolvedType" parameters="String IHasPosition"/><method name="makeSourceLocation" returnType="ISourceLocation" parameters="IHasPosition"/></file><file name="org.aspectj.matcher/src/org/aspectj/weaver/patterns/IScope.java"><method name="lookupFormal" returnType="FormalBinding" parameters="String"/><method name="message" returnType="void" parameters="IMessage"/><method name="getEnclosingType" returnType="ResolvedType" parameters=""/><method name="lookupType" returnType="UnresolvedType" parameters="String IHasPosition"/></file><file name="org.aspectj.matcher/src/org/aspectj/weaver/patterns/SimpleScope.java"><method name="lookupType" returnType="UnresolvedType" parameters="String IHasPosition"/><method name="setImportedPrefixes" returnType="void" parameters="String[]"/><method name="lookupFormal" returnType="FormalBinding" parameters="String"/></file></commit></fixedCommits></bug><bug id="446" opendate="2010-06-29 20:15:00" fixdate="2010-06-30 00:20:30"><buginformation><summary>Caching in EclipseSourceType is too aggressive</summary><description>In fixing a recent Roo related issue (where annotations are resolved too early, before declare parents are done) a cache was introduced into EclipseSourceType (see ensureAnnotationTypesResolved()).  The cache needs to be cleared if the set of annotation declarations changes - this can occur even after parsing because declare annotation can change them.</description><comments/></buginformation><fixedCommits><commit id="fe049eacaf0c2befba6e617aac2d7387548f5f24" author="default" date="2010-06-30 00:20:30"><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseSourceType.java"><method name="ensureAnnotationTypesResolved" returnType="void" parameters=""/></file></commit></fixedCommits></bug><bug id="447" opendate="2010-08-03 14:05:00" fixdate="2010-08-10 15:11:54"><buginformation><summary>No way to exclude Proxool classes although excluded from AOP. Causing Veryfy error.</summary><description>Build Identifier: 20100218-1602

For aspectJ 1.6.7 the setup works, however exactly the same setup but changing the aspectJ version to 1.6.8 or 1.6.9 derive to the same error: a piece of code excluded from the aop.xml is woven causing a Verify Error.

We are using Proxool, proxy setup which in fact uses CGLIB to create a EnhancerProxy class. In order to avoid VerifyError exceptions the Proxool classes are excluded from aop.xml exactly in the same way the CGLIB workarround is commented in the aspectJ FAQ:

		&lt;exclude within="*..*Proxool*"/&gt;


This is the error we got when we upgrade our 1.6.7 aspejctweaver.jar to 1.6.8. The same is got when using 1.6.9:

jvm 3    | 2010/08/03 16:42:53 | java.lang.VerifyError: (class: oracle/jdbc/internal/OracleConnection$$EnhancerByProxool$$7f6320a8, method: getTdoCState signature: (Ljava/lang/String;Ljava/lang/String;)J) Inconsistent stack height 1 != 0
jvm 3    | 2010/08/03 16:42:53 | 	at java.lang.Class.getDeclaredMethods0(Native Method)
jvm 3    | 2010/08/03 16:42:53 | 	at java.lang.Class.privateGetDeclaredMethods(Class.java:2427)
jvm 3    | 2010/08/03 16:42:53 | 	at java.lang.Class.getDeclaredMethod(Class.java:1935)
jvm 3    | 2010/08/03 16:42:53 | 	at org.logicalcobwebs.cglib.proxy.Enhancer.getCallbacksSetter(Enhancer.java:627)
jvm 3    | 2010/08/03 16:42:53 | 	at org.logicalcobwebs.cglib.proxy.Enhancer.setCallbacksHelper(Enhancer.java:615)
jvm 3    | 2010/08/03 16:42:53 | 	at org.logicalcobwebs.cglib.proxy.Enhancer.setThreadCallbacks(Enhancer.java:609)
jvm 3    | 2010/08/03 16:42:53 | 	at org.logicalcobwebs.cglib.proxy.Enhancer.createUsingReflection(Enhancer.java:631)
jvm 3    | 2010/08/03 16:42:53 | 	at org.logicalcobwebs.cglib.proxy.Enhancer.firstInstance(Enhancer.java:538)
jvm 3    | 2010/08/03 16:42:53 | 	at org.logicalcobwebs.cglib.core.AbstractClassGenerator.create(AbstractClassGenerator.java:225)
jvm 3    | 2010/08/03 16:42:53 | 	at org.logicalcobwebs.cglib.proxy.Enhancer.createHelper(Enhancer.java:377)
jvm 3    | 2010/08/03 16:42:53 | 	at org.logicalcobwebs.cglib.proxy.Enhancer.create(Enhancer.java:285)
....

As far as the Verify Error is got while deploying one of the applications that run on the serve we are no able to use the new versions of aspectJ because the application is not properly started up.

Thank you very much in advance,

Best regards.

Reproducible: Always

Steps to Reproduce:
1.Exclude Proxool classes from aop.xml using aspectj 1.6.7. It works
2.Upgrade to 1.6.8: it does not work.
3.Upgrade to 1.6.9: it does not work.</description><comments/></buginformation><fixedCommits><commit id="85fd25dc91475e6b9926b5c740f73b994eb84a49" author="default" date="2010-08-10 15:11:54"><file name="loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"><method name="accept" returnType="boolean" parameters="String byte[]"/></file><file name="loadtime/testsrc/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptorTest.java"><method name="printExpendableMap" returnType="void" parameters="Map"/><method name="printMainMap" returnType="void" parameters="Map"/><method name="getDefinitions" returnType="List" parameters="ClassLoader WeavingAdaptor"/><method name="getAdaptor" returnType="TestClassLoaderWeavingAdaptor" parameters="String[]"/><method name="testAcceptanceSpeedStarDotDotStar" returnType="void" parameters=""/></file></commit></fixedCommits></bug><bug id="448" opendate="2010-08-16 15:33:00" fixdate="2010-08-16 19:52:25"><buginformation><summary>early field resolution leading to problems for ITDs when declare parents in use</summary><description>I have a type that is being used where a generic is being expected.  That generic specifies an upper bound.  The type only obeys the upper bound once a declare parents has applied to it.

I have an intertype declaration (a field).  When the ITD is applied we do some work to see if it clashes with existing fields.  This causes existing fields to be resolved.  If this resolution triggers a bounds check for the declare parents affected type before the declare parents has applied, a problem will be raised.

Basically if the target of the declare is processed before the intertype then we are ok, but that is luck based.

We should do the declare parents first (and declare annotation) and then do intertype declarations (since they may trigger this extra resolution).</description><comments/></buginformation><fixedCommits><commit id="16adee6b2928350a3c469de0d051c6d9c10dc5a3" author="default" date="2010-08-16 19:52:25"><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java"><method name="weaveInterTypeDeclarations" returnType="void" parameters="CompilationUnitScope List&lt;ConcreteTypeMunger&gt;"/><method name="weaveIntertypes" returnType="void" parameters="List&lt;SourceTypeBinding&gt; SourceTypeBinding"/><method name="weaveInterTypeDeclarations" returnType="void" parameters="SourceTypeBinding"/><method name="completeTypeBindings" returnType="void" parameters=""/><method name="weaveInterTypeDeclarations" returnType="void" parameters="SourceTypeBinding List&lt;ConcreteTypeMunger&gt;"/><method name="collectAllITDsAndDeclares" returnType="void" parameters="SourceTypeBinding"/><method name="weaveIntertypes" returnType="void" parameters="List&lt;SourceTypeBinding&gt;"/></file></commit></fixedCommits></bug><bug id="449" opendate="2010-08-06 19:47:00" fixdate="2010-08-18 17:29:04"><buginformation><summary>Fully qualified ITD has incorrect handle identifier</summary><description>In the following aspect:

public aspect Aspect {
	public void q2.ThisClass.something2() {}
}

In aspectJ, the ITD has the following handle identifier (notice that the ITD name is not fully qualified):

=AspectJ Project/src2&lt;p*Aspect.aj'Aspect)ThisClass.something2

However, it should be (with fully qualified name):

=AspectJ Project/src2&lt;p*Aspect.aj'Aspect)q2.ThisClass.something2

This means that fully qualified ITDs cannot be navigated to or searched.  I'm a little surprised that this doesn't work because I thought I had tests for it...</description><comments/></buginformation><fixedCommits><commit id="6b35ea418d5523a05eb591eec4cb30742b6649b6" author="default" date="2010-08-18 17:29:04"><file name="tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java"><method name="testIncrementalCtorItdHandle_280383" returnType="void" parameters=""/></file></commit></fixedCommits></bug><bug id="450" opendate="2010-08-23 13:44:00" fixdate="2010-08-25 01:46:42"><buginformation><summary>Sometimes StackOverflow is got while weaving</summary><description>Build Identifier: 1.6.10

While weaving LifeRay 6.0.5 over tomcat 6.0.26 sometimes the next exceptions appear:

java.lang.StackOverflowError
        at java.lang.String.indexOf(String.java:1521)
        at org.aspectj.weaver.TypeFactory.createTypeFromSignature(TypeFactory.java:199)
        at org.aspectj.weaver.UnresolvedType.forSignature(UnresolvedType.java:375)
        at org.aspectj.weaver.UnresolvedType.getRawType(UnresolvedType.java:533)
        at org.aspectj.weaver.ResolvedType.getRawType(ResolvedType.java:2400)
        at org.aspectj.weaver.ReferenceType.isAssignableFrom(ReferenceType.java:430)
        at org.aspectj.weaver.ReferenceType.isAssignableFrom(ReferenceType.java:399)
        at org.aspectj.weaver.ReferenceType.isAssignableFrom(ReferenceType.java:430)
        at org.aspectj.weaver.ReferenceType.isAssignableFrom(ReferenceType.java:399)
        at org.aspectj.weaver.ReferenceType.isAssignableFrom(ReferenceType.java:430)
        at org.aspectj.weaver.ReferenceType.isAssignableFrom(ReferenceType.java:399)
        at org.aspectj.weaver.ReferenceType.isAssignableFrom(ReferenceType.java:430)
        at org.aspectj.weaver.ReferenceType.isAssignableFrom(ReferenceType.java:399)
        at org.aspectj.weaver.ReferenceType.isAssignableFrom(ReferenceType.java:430)
        at org.aspectj.weaver.ReferenceType.isAssignableFrom(ReferenceType.java:399)
        at org.aspectj.weaver.ReferenceType.isAssignableFrom(ReferenceType.java:430)
        at org.aspectj.weaver.ReferenceType.isAssignableFrom(ReferenceType.java:399)
        at org.aspectj.weaver.ReferenceType.isAssignableFrom(ReferenceType.java:430)
        at org.aspectj.weaver.ReferenceType.isAssignableFrom(ReferenceType.java:399)
        at org.aspectj.weaver.ReferenceType.isAssignableFrom(ReferenceType.java:430)
        at org.aspectj.weaver.ReferenceType.isAssignableFrom(ReferenceType.java:399)
...




Reproducible: Sometimes</description><comments/></buginformation><fixedCommits><commit id="f631ad6e4e37f43bfae556fc966e6ab0d7ee38bf" author="default" date="2010-08-25 01:46:42"><file name="org.aspectj.matcher/src/org/aspectj/weaver/World.java"><method name="demote" returnType="int" parameters="boolean"/></file></commit></fixedCommits></bug><bug id="451" opendate="2010-08-25 12:40:00" fixdate="2010-08-25 16:41:33"><buginformation><summary>NPE parameterizing perclause</summary><description>java.lang.NullPointerException
at org.aspectj.weaver.ReferenceType.getPerClause(ReferenceType.java:823)
at org.aspectj.weaver.patterns.PerFromSuper.lookupConcretePerClause(PerFromSuper.java:82)
at org.aspectj.weaver.patterns.PerFromSuper.concretize(PerFromSuper.java:61)
at org.aspectj.weaver.CrosscuttingMembers.setPerClause(CrosscuttingMembers.java:512)
at org.aspectj.weaver.ResolvedType.collectCrosscuttingMembers(ResolvedType.java:748) ... oBuildJob.run(AutoBuildJob.java:242)
at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)</description><comments/></buginformation><fixedCommits><commit id="ce16a06749d562fd123e4ecb984ec3a5a8cf5a94" author="default" date="2010-08-25 16:41:33"><file name="org.aspectj.matcher/src/org/aspectj/weaver/ReferenceType.java"><method name="getPerClause" returnType="PerClause" parameters=""/></file></commit></fixedCommits></bug><bug id="452" opendate="2010-07-21 04:22:00" fixdate="2010-08-26 15:20:03"><buginformation><summary>ModifiersPattern.getModifierFlag() is not thread safe</summary><description>Build Identifier: org.aspectj.weaver_1.6.0.20080423100000.jar

ModifiersPattern.getModifierFlag() is a non-synchronized static method using the static Map modifierFlags. This can lead to a ConcurrentModificationException when this code is executed in a multi-threaded environment. A stack trace showing the erroneous behavior is appended at the end of this bug report.

In our case multithreading is introduced by using Spring DM. This leads to many application contexts being initialized in parallel. Each of them can contain pointcut expression, which are processed in independent threads. Spring AOP enters the "AspectJ world" calling PointcutParser.parsePointcutExpression().

Since there is no guarantee that a ConcurrentModificationException is thrown it is also possible that concurrent read/write accesses to the modifierFlags map are not recognized and incorrect values are used.


org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'sessionFactoryProxy': Post-processing of the FactoryBean's object failed; nested exception is java.util.ConcurrentModificationException: concurrent access to HashMap attempted by Thread[SpringOsgiExtenderThread-43,5,spring-osgi-extender[6dee6dee]-threads]
	at org.springframework.beans.factory.support.FactoryBeanRegistrySupport$1.run(FactoryBeanRegistrySupport.java:142)
	at java.security.AccessController.doPrivileged(AccessController.java:219)
	at org.springframework.beans.factory.support.FactoryBeanRegistrySupport.doGetObjectFromFactoryBean(FactoryBeanRegistrySupport.java:116)
	at org.springframework.beans.factory.support.FactoryBeanRegistrySupport.getObjectFromFactoryBean(FactoryBeanRegistrySupport.java:91)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getObjectForBeanInstance(AbstractBeanFactory.java:1288)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:217)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:185)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:164)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:425)
	at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:728)
	at org.springframework.osgi.context.support.AbstractDelegatedExecutionApplicationContext.access$1600(AbstractDelegatedExecutionApplicationContext.java:69)
	at org.springframework.osgi.context.support.AbstractDelegatedExecutionApplicationContext$4.run(AbstractDelegatedExecutionApplicationContext.java:355)
	at org.springframework.osgi.util.internal.PrivilegedUtils.executeWithCustomTCCL(PrivilegedUtils.java:85)
	at org.springframework.osgi.context.support.AbstractDelegatedExecutionApplicationContext.completeRefresh(AbstractDelegatedExecutionApplicationContext.java:320)
	at org.springframework.osgi.extender.internal.dependencies.startup.DependencyWaiterApplicationContextExecutor$CompleteRefreshTask.run(DependencyWaiterApplicationContextExecutor.java:136)
	at java.lang.Thread.run(Thread.java:811)
Caused by: java.util.ConcurrentModificationException: concurrent access to HashMap attempted by Thread[SpringOsgiExtenderThread-43,5,spring-osgi-extender[6dee6dee]-threads]
	at java.util.HashMap.onEntry(HashMap.java:214)
	at java.util.HashMap.transfer(HashMap.java:686)
	at java.util.HashMap.resize(HashMap.java:676)
	at java.util.HashMap.addEntry(HashMap.java:1049)
	at java.util.HashMap.put(HashMap.java:561)
	at org.aspectj.weaver.patterns.ModifiersPattern.getModifierFlag(ModifiersPattern.java:87)
	at org.aspectj.weaver.patterns.PatternParser.parseModifiersPattern(PatternParser.java:1169)
	at org.aspectj.weaver.patterns.PatternParser.parseMethodOrConstructorSignaturePattern(PatternParser.java:1248)
	at org.aspectj.weaver.patterns.PatternParser.parseKindedPointcut(PatternParser.java:603)
	at org.aspectj.weaver.patterns.PatternParser.parseSinglePointcut(PatternParser.java:317)
	at org.aspectj.weaver.patterns.PatternParser.parseAtomicPointcut(PatternParser.java:295)
	at org.aspectj.weaver.patterns.PatternParser.parsePointcut(PatternParser.java:256)
	at org.aspectj.weaver.tools.PointcutParser.resolvePointcutExpression(PointcutParser.java:328)
	at org.aspectj.weaver.tools.PointcutParser.parsePointcutExpression(PointcutParser.java:309)
	at org.springframework.aop.aspectj.AspectJExpressionPointcut.buildPointcutExpression(AspectJExpressionPointcut.java:206)
	at org.springframework.aop.aspectj.AspectJExpressionPointcut.checkReadyToMatch(AspectJExpressionPointcut.java:193)
	at org.springframework.aop.aspectj.AspectJExpressionPointcut.getClassFilter(AspectJExpressionPointcut.java:174)
	at org.springframework.aop.support.AopUtils.canApply(AopUtils.java:195)
	at org.springframework.aop.support.AopUtils.canApply(AopUtils.java:250)
	at org.springframework.aop.support.AopUtils.findAdvisorsThatCanApply(AopUtils.java:284)
	at org.springframework.aop.framework.autoproxy.AbstractAdvisorAutoProxyCreator.findAdvisorsThatCanApply(AbstractAdvisorAutoProxyCreator.java:113)
	at org.springframework.aop.framework.autoproxy.AbstractAdvisorAutoProxyCreator.findEligibleAdvisors(AbstractAdvisorAutoProxyCreator.java:85)
	at org.springframework.aop.framework.autoproxy.AbstractAdvisorAutoProxyCreator.getAdvicesAndAdvisorsForBean(AbstractAdvisorAutoProxyCreator.java:66)
	at org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator.wrapIfNecessary(AbstractAutoProxyCreator.java:362)
	at org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator.postProcessAfterInitialization(AbstractAutoProxyCreator.java:325)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsAfterInitialization(AbstractAutowireCapableBeanFactory.java:361)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.postProcessObjectFromFactoryBean(AbstractAutowireCapableBeanFactory.java:1429)
	at org.springframework.beans.factory.support.FactoryBeanRegistrySupport$1.run(FactoryBeanRegistrySupport.java:139)
	... 15 more

Reproducible: Sometimes</description><comments/></buginformation><fixedCommits><commit id="e0e1330c6e01a878d365bff112f1c6505c7e6ebd" author="default" date="2010-08-26 15:20:03"><file name="org.aspectj.matcher/src/org/aspectj/weaver/patterns/ModifiersPattern.java"><method name="ModifiersPattern" returnType="ModifiersPattern" parameters=""/><method name="getModifierFlag" returnType="int" parameters="String"/></file></commit></fixedCommits></bug><bug id="453" opendate="2010-08-31 16:50:00" fixdate="2010-09-01 00:29:30"><buginformation><summary>ArrayIndexOutOfBoundsException at AjState.java:1767</summary><description>Build Identifier: 20100617-1415

Using AspectJ version: 1.6.10.20100817163700

I hit the blow exception after saving a edited java file.

java.lang.ArrayIndexOutOfBoundsException
at org.aspectj.ajdt.internal.core.builder.AjState.hasStructuralChanges(AjState.java:1767)
at org.aspectj.ajdt.internal.core.builder.AjState.recordClassFile(AjState.java:1510)
at org.aspectj.ajdt.internal.core.builder.AjState.noteResult(AjState.java:1322)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager$3.acceptResult(AjBuildManager.java:1049)
at org.aspectj.ajdt.internal.compiler.AjPipeli ... b.run(AutoBuildJob.java:242)
at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

Compile error: ArrayIndexOutOfBoundsException thrown: 14

Reproducible: Didn't try</description><comments/></buginformation><fixedCommits><commit id="88fab6ad42f17bce86217d0b0fd6525dd5953bc4" author="default" date="2010-09-01 00:29:30"><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java"><method name="hasStructuralChanges" returnType="boolean" parameters="ClassFileReader"/><method name="getDelegate" returnType="ReferenceTypeDelegate" parameters="ReferenceType"/></file></commit></fixedCommits></bug><bug id="454" opendate="2010-07-05 10:24:00" fixdate="2010-09-01 04:19:01"><buginformation><summary>NPE with @args matching Argument by Type</summary><description>Build Identifier: 

This bug is related to  Bug 257833 . I'm wondering why nobody has faced and reported that bug before?!?!

This is the top of the stacktrace i get:
java.lang.NullPointerException
	at org.aspectj.weaver.reflect.ShadowMatchImpl$RuntimeTestEvaluator.visit(ShadowMatchImpl.java:140)
	at org.aspectj.weaver.ast.Instanceof.accept(Instanceof.java:29)
	at org.aspectj.weaver.reflect.ShadowMatchImpl$RuntimeTestEvaluator.matches(ShadowMatchImpl.java:121)
	at org.aspectj.weaver.reflect.ShadowMatchImpl.matchesJoinPoint(ShadowMatchImpl.java:78)

This bug occurs in aspectJ 1.6.1 and 1.6.8 so i think all versions in between are affected as well. I'm using aspectJ together with Spring 2.5.6 but i think that does not matter.

Expected behavior:
When using @Before("args(myId,..)") to match all methods that have an argument of type MyInterface as first argument (see steps to reproduce), the methods declared argument types should be used to determine if the method matches when null is passed as first argument.

Actual Behavior:
NullPointerException is thrown from org.aspectj.weaver.reflect.ShadowMatchImpl$RuntimeTestEvaluator.visit(ShadowMatchImpl.java:140).


Note: Everything works fine if null is not used as first argument. That means if your first argument is never null you'll get no exception and everything works as expected. But if there is one method you don't want to match/intercept that gets null as it's first argument the runtime exception occurs.

Reproducible: Always

Steps to Reproduce:
1. define an interface MyInterface
2. define a pointcut / empty advice using "@args(myId)", e.g.
@Before("args(myId,..)")
public void startsMyIdArgument(final JoinPoint jp, final MyInterface myId) { };
3. call a method of an intercepted class with the first argument being null and you'll get a NullPointerException</description><comments/></buginformation><fixedCommits><commit id="2a8d684a678b1761acbe081bc1ddad3d3c9c405e" author="default" date="2010-09-01 04:19:01"><file name="org.aspectj.matcher/src/org/aspectj/weaver/reflect/ShadowMatchImpl.java"><method name="visit" returnType="void" parameters="Instanceof"/></file><file name="org.aspectj.matcher/testsrc/org/aspectj/weaver/patterns/ThisOrTargetTestCase.java"><method name="needToSkipPointcutParserTests" returnType="boolean" parameters=""/><method name="checkNoMatch" returnType="void" parameters="ShadowMatch Object Object"/><method name="testMatchJP" returnType="void" parameters=""/><method name="testBinding" returnType="void" parameters=""/></file></commit></fixedCommits></bug><bug id="455" opendate="2010-09-01 09:15:00" fixdate="2010-09-01 15:00:33"><buginformation><summary>NullPointerException in AjBuildManager.findOutputDirsForAspects when compiling AspectJ project generated with Maven</summary><description>Build Identifier: 20100617-1415

When I compile my AspectJ project, I get an AspectJ Internal Compiler Error. The stack trace is : 
java.lang.NullPointerException
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.findOutputDirsForAspects(AjBuildManager.java:725)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.writeOutxmlFile(AjBuildManager.java:652)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performBuild(AjBuildManager.java:367)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:181)
at org.aspectj.a ... on$1.run(GlobalBuildAction.java:179)
at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

I digged a bit and looked into the classes. It would seem that AjState.getAspectNamesToFileNameMap() can return null in AjBuildManager.findOutputDirsForAspects. It is taken in account when AjBuildConfig.getCompilationResultDestinationManager() returns null or a list with one element, but not when it returns a list with several elements.

Reproducible: Always

Steps to Reproduce:
Always happen in my configuration, but I didn't try to make it happen again in another workspace. Here are the steps I followed.

1. Generate a AspectJ project with Maven using the pom.xml I'll join
2. Create an aspect with a few pointcuts and a few advices
3. Compile (not with maven, the Eclipse compilation)</description><comments/></buginformation><fixedCommits><commit id="03c43f5ca578273b8f94d5caf7b92718f84cd911" author="default" date="2010-09-01 15:00:33"><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"><method name="getOutxmlContents" returnType="ByteArrayOutputStream" parameters="List"/></file></commit></fixedCommits></bug><bug id="456" opendate="2010-09-08 18:30:00" fixdate="2010-09-09 16:24:43"><buginformation><summary>NullPointerException at AspectJElementHierarchy.java:677</summary><description>Build Identifier: 20100617-1415

After removing a "throws" clause from the constructor of a class and then saving I got the following error:

java.lang.NullPointerException
at org.aspectj.asm.internal.AspectJElementHierarchy.getCanonicalFilePath(AspectJElementHierarchy.java:677)
at org.aspectj.asm.internal.AspectJElementHierarchy.updateHandleMap(AspectJElementHierarchy.java:641)
at org.aspectj.asm.AsmManager.removeStructureModelForFiles(AsmManager.java:572)
at org.aspectj.asm.AsmManager.processDelta(AsmManager.java:604)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager ... oBuildJob.run(AutoBuildJob.java:242)
at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

Compile error: NullPointerException thrown: null

Reproducible: Didn't try</description><comments/></buginformation><fixedCommits><commit id="6249672405e8d1303ea9087f35b72114586f0aad" author="default" date="2010-09-09 16:24:43"><file name="asm/src/org/aspectj/asm/internal/AspectJElementHierarchy.java"><method name="toSummaryString" returnType="String" parameters=""/><method name="forget" returnType="void" parameters="IProgramElement IProgramElement"/></file></commit></fixedCommits></bug><bug id="457" opendate="2011-02-11 14:01:00" fixdate="2011-02-11 19:03:13"><buginformation><summary>IllegalStateException for generic ITD usage</summary><description>java.lang.IllegalStateException: Can't answer binding questions prior to resolving
	at org.aspectj.weaver.TypeVariable.canBeBoundTo(TypeVariable.java:175)
	at org.aspectj.weaver.ReferenceType.isAssignableFrom(ReferenceType.java:496)
	at org.aspectj.weaver.ReferenceType.isAssignableFrom(ReferenceType.java:399)
	at org.aspectj.weaver.ResolvedType.checkLegalOverride(ResolvedType.java:1999)
	at org.aspectj.weaver.ResolvedType.clashesWithExistingMember(ResolvedType.java:1843)
	at org.aspectj.weaver.ResolvedType.addInterTypeMunger(ResolvedType.java:1699)
	at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.weaveInterTypeDeclarations(AjLookupEnvironment.java:795)
	at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.weaveInterTypeDeclarations(AjLookupEnvironment.java:652)
	at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.createBinaryTypeFrom(AjLookupEnvironment.java:1398)
	at org.aspectj.org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.createBinaryTypeFrom(LookupEnvironment.java:599)
	at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.accept(Compiler.java:276)
	at org.aspectj.org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.askForType(LookupEnvironment.java:113)
	at org.aspectj.org.eclipse.jdt.internal.compiler.lookup.UnresolvedReferenceBinding.resolve(UnresolvedReferenceBinding.java:49)
	at org.aspectj.org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.resolveType(BinaryTypeBinding.java:99)
	at org.aspectj.org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.getType(LookupEnvironment.java:971)
	at org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.lookupBinding(EclipseFactory.java:749)
	at org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.makeTypeBinding1(EclipseFactory.java:743)
	at org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.makeTypeBinding(EclipseFactory.java:605)
	at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.addParent(AjLookupEnvironment.java:1314)
	at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.doDeclareParents(AjLookupEnvironment.java:902)
	at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.weaveInterTypeDeclarations(AjLookupEnvironment.java:730)
	at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.weaveIntertypes(AjLookupEnvironment.java:418)
	at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.completeTypeBindings(AjLookupEnvironment.java:255)
	at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.internalBeginToCompile(Compiler.java:616)
	at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.beginToCompile(Compiler.java:357)
	at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:371)
	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:1021)
	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performBuild(AjBuildManager.java:268)
	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:181)
	at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:112)
	at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:60)
	at org.aspectj.tools.ajc.Main.run(Main.java:371)
	at org.aspectj.tools.ajc.Main.runMain(Main.java:248)
	at org.codehaus.mojo.aspectj.AbstractAjcCompiler.execute(AbstractAjcCompiler.java:360)
	at org.apache.maven.plugin.DefaultPluginManager.executeMojo(DefaultPluginManager.java:490)
	at org.apache.maven.lifecycle.DefaultLifecycleExecutor.executeGoals(DefaultLifecycleExecutor.java:694)
	at org.apache.maven.lifecycle.DefaultLifecycleExecutor.executeGoalWithLifecycle(DefaultLifecycleExecutor.java:556)
	at org.apache.maven.lifecycle.DefaultLifecycleExecutor.executeGoal(DefaultLifecycleExecutor.java:535)
	at org.apache.maven.lifecycle.DefaultLifecycleExecutor.executeGoalAndHandleFailures(DefaultLifecycleExecutor.java:387)
	at org.apache.maven.lifecycle.DefaultLifecycleExecutor.executeTaskSegments(DefaultLifecycleExecutor.java:348)
	at org.apache.maven.lifecycle.DefaultLifecycleExecutor.execute(DefaultLifecycleExecutor.java:180)
	at org.apache.maven.DefaultMaven.doExecute(DefaultMaven.java:328)
	at org.apache.maven.DefaultMaven.execute(DefaultMaven.java:138)
	at org.apache.maven.cli.MavenCli.main(MavenCli.java:362)
	at org.apache.maven.cli.compat.CompatibleMain.main(CompatibleMain.java:60)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at org.codehaus.classworlds.Launcher.launchEnhanced(Launcher.java:315)
	at org.codehaus.classworlds.Launcher.launch(Launcher.java:255)
	at org.codehaus.classworlds.Launcher.mainWithExitCode(Launcher.java:430)
	at org.codehaus.classworlds.Launcher.main(Launcher.java:375)</description><comments/></buginformation><fixedCommits><commit id="80785bfd5347e6bf06b3202013d435f68727c910" author="default" date="2011-02-11 19:03:13"><file name="org.aspectj.matcher/src/org/aspectj/weaver/TypeVariable.java"><method name="setAdditionalInterfaceBounds" returnType="void" parameters="UnresolvedType[]"/></file><file name="org.aspectj.matcher/src/org/aspectj/weaver/World.java"><method name="resolve" returnType="ResolvedType" parameters="UnresolvedType boolean"/></file><file name="org.aspectj.matcher/src/org/aspectj/weaver/TypeVariableReferenceType.java"><method name="getTypeVariable" returnType="TypeVariable" parameters=""/><method name="getUpperBound" returnType="ReferenceType" parameters=""/></file></commit></fixedCommits></bug><bug id="458" opendate="2011-03-08 18:49:00" fixdate="2011-03-09 01:14:39"><buginformation><summary>problem weaving anonymous inner (member owned) classes in scala library</summary><description>Reported by Ramnivas.

Due to the use of numerous $ chars in scala classnames, some of the AspectJ handling of inner classes breaks down.  It should be possible to correctly use the available class attributes rather than mess around with attributes.  A while back one use did contribute a change to enable scala weaving which tried to use the InnerClasses attribute before falling back on string chopping.  However we have now hit another case.

In the scenario we are dealing with the class scala.Predef$$anon$3 in the scala library (a 2.9.0-SNAPSHOT version).  What we normally do here is in that type we discover the InnerClass attribute and refer to the outerclass index it holds.  Unfortunately, due to it being an anonymous inner inside a method, the index is 0.  So we fail to process the attribute and with string chopping come up with a stupid guessed name for the outer.

The solution is to use the EnclosingMethod attribute in these situations.  The EnclosingMethod attribute is an optional attribute. A class must have an EnclosingMethod attribute if and only if it is a local class or an anonymous class. A class may have no more than one EnclosingMethod attribute.

The EnclosingMethod attribute includes a pointer to the containing outerclass (that had the method in which encloses this inner type).</description><comments/></buginformation><fixedCommits><commit id="945402f177906a2a421b092050c2baab31665c59" author="default" date="2011-03-09 01:14:39"><file name="weaver/src/org/aspectj/weaver/bcel/BcelObjectType.java"><method name="getOuterClass" returnType="ResolvedType" parameters=""/></file></commit></fixedCommits></bug><bug id="459" opendate="2011-03-17 10:34:00" fixdate="2011-03-28 19:37:01"><buginformation><summary>NPE when weaving java.lang.Object at org.aspectj.weaver.bcel.BcelTypeMunger.createAnyBridgeMethodsForCovariance(BcelTypeMunger.java:1251)</summary><description>Created  attachment 191423   [details] 
AJ core dump

I'm trying to add a method to Object using a inter-type declaration. When calling ajc, I encounter a NPE. From a cursory glance, it would appear that the code is looking for the parents classes of Object, which presumably is null.

I've attached the dump and a simple example that causes it.</description><comments/></buginformation><fixedCommits><commit id="a8e6797a9268d9fb041c075ee7701831f7e848b4" author="default" date="2011-03-28 19:37:01"><file name="weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java"><method name="createAnyBridgeMethodsForCovariance" returnType="void" parameters="BcelClassWeaver"/></file></commit></fixedCommits></bug><bug id="460" opendate="2011-06-06 21:12:00" fixdate="2011-06-07 16:46:19"><buginformation><summary>"register definition failed" with NullPointerException</summary><description>Build Identifier: 20110218-0911

Here's another rare &amp; hard to reproduce exception I encountered upon starting an RCP application with load-time weaving enabled (see  bug 338033  for another exception found in the the same environment):

Jun 6, 2011 3:19:50 PM org.aspectj.weaver.tools.Jdk14Trace error
SEVERE: register definition failed
java.lang.NullPointerException
	at org.aspectj.weaver.bcel.AtAjAttributes.getMethodArgumentNames(AtAjAttributes.java:1760)
	at org.aspectj.weaver.bcel.AtAjAttributes.access$000(AtAjAttributes.java:92)
	at org.aspectj.weaver.bcel.AtAjAttributes$AjAttributeMethodStruct.getArgumentNames(AtAjAttributes.java:153)
	at org.aspectj.weaver.bcel.AtAjAttributes.extractBindings(AtAjAttributes.java:1576)
	at org.aspectj.weaver.bcel.AtAjAttributes.handleAroundAnnotation(AtAjAttributes.java:1348)
	at org.aspectj.weaver.bcel.AtAjAttributes.readAj5MethodAttributes(AtAjAttributes.java:448)
	at org.aspectj.weaver.bcel.BcelMethod.unpackAjAttributes(BcelMethod.java:203)
	at org.aspectj.weaver.bcel.BcelMethod.&lt;init&gt;(BcelMethod.java:92)
	at org.aspectj.weaver.bcel.BcelObjectType.getDeclaredMethods(BcelObjectType.java:290)
	at org.aspectj.weaver.ReferenceType.getDeclaredMethods(ReferenceType.java:770)
	at org.aspectj.weaver.ResolvedType.getDeclaredAdvice(ResolvedType.java:947)
	at org.aspectj.weaver.ResolvedType.getDeclaredShadowMungers(ResolvedType.java:987)
	at org.aspectj.weaver.ResolvedType.collectShadowMungers(ResolvedType.java:822)
	at org.aspectj.weaver.ResolvedType.collectCrosscuttingMembers(ResolvedType.java:749)
	at org.aspectj.weaver.CrosscuttingMembersSet.addOrReplaceAspect(CrosscuttingMembersSet.java:85)
	at org.aspectj.weaver.CrosscuttingMembersSet.addOrReplaceAspect(CrosscuttingMembersSet.java:69)
	at org.aspectj.weaver.bcel.BcelWeaver.addLibraryAspect(BcelWeaver.java:202)
	at org.aspectj.weaver.loadtime.ClassLoaderWeavingAdaptor.registerAspects(ClassLoaderWeavingAdaptor.java:466)
	at org.aspectj.weaver.loadtime.ClassLoaderWeavingAdaptor.registerDefinitions(ClassLoaderWeavingAdaptor.java:290)
	at org.aspectj.weaver.loadtime.ClassLoaderWeavingAdaptor.initialize(ClassLoaderWeavingAdaptor.java:176)
	at org.eclipse.equinox.weaving.aspectj.loadtime.OSGiWeavingAdaptor.initialize(Unknown Source)
	at org.eclipse.equinox.weaving.aspectj.AspectJWeavingService.ensureAdaptorInit(Unknown Source)
	at org.eclipse.equinox.weaving.aspectj.AspectJWeavingService.preProcess(Unknown Source)
	at org.eclipse.equinox.weaving.adaptors.WeavingAdaptor.weaveClass(Unknown Source)
	at org.eclipse.equinox.weaving.hooks.WeavingHook.processClass(Unknown Source)
	at org.eclipse.osgi.baseadaptor.loader.ClasspathManager.defineClass(ClasspathManager.java:575)
	at org.eclipse.osgi.baseadaptor.loader.ClasspathManager.findClassImpl(ClasspathManager.java:550)
	at org.eclipse.osgi.baseadaptor.loader.ClasspathManager.findLocalClassImpl(ClasspathManager.java:481)
	at org.eclipse.osgi.baseadaptor.loader.ClasspathManager.findLocalClass_LockClassLoader(ClasspathManager.java:469)
	at org.eclipse.osgi.baseadaptor.loader.ClasspathManager.findLocalClass(ClasspathManager.java:449)
	at org.eclipse.osgi.internal.baseadaptor.DefaultClassLoader.findLocalClass(DefaultClassLoader.java:216)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:393)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClassInternal(BundleLoader.java:469)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:422)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:410)
	at org.eclipse.osgi.internal.baseadaptor.DefaultClassLoader.loadClass(DefaultClassLoader.java:107)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:247)
	at org.eclipse.osgi.internal.loader.BundleLoader.loadClass(BundleLoader.java:338)
	at org.eclipse.osgi.framework.internal.core.BundleHost.loadClass(BundleHost.java:232)
	at org.eclipse.osgi.framework.internal.core.AbstractBundle.loadBundleActivator(AbstractBundle.java:149)
	at org.eclipse.osgi.framework.internal.core.BundleContextImpl.start(BundleContextImpl.java:751)
	at org.eclipse.osgi.framework.internal.core.BundleHost.startWorker(BundleHost.java:370)
	at org.eclipse.osgi.framework.internal.core.AbstractBundle.resume(AbstractBundle.java:374)
	at org.eclipse.osgi.framework.internal.core.Framework.resumeBundle(Framework.java:1067)
	at org.eclipse.osgi.framework.internal.core.StartLevelManager.resumeBundles(StartLevelManager.java:561)
	at org.eclipse.osgi.framework.internal.core.StartLevelManager.resumeBundles(StartLevelManager.java:546)
	at org.eclipse.osgi.framework.internal.core.StartLevelManager.incFWSL(StartLevelManager.java:459)
	at org.eclipse.osgi.framework.internal.core.StartLevelManager.doSetStartLevel(StartLevelManager.java:243)
	at org.eclipse.osgi.framework.internal.core.StartLevelManager.dispatchEvent(StartLevelManager.java:440)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:227)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:337)
[foo] warning register definition failed -- (NullPointerException) null
null
java.lang.NullPointerException
	at org.aspectj.weaver.bcel.AtAjAttributes.getMethodArgumentNames(AtAjAttributes.java:1760)
	at org.aspectj.weaver.bcel.AtAjAttributes.access$000(AtAjAttributes.java:92)
	at org.aspectj.weaver.bcel.AtAjAttributes$AjAttributeMethodStruct.getArgumentNames(AtAjAttributes.java:153)
	at org.aspectj.weaver.bcel.AtAjAttributes.extractBindings(AtAjAttributes.java:1576)
	at org.aspectj.weaver.bcel.AtAjAttributes.handleAroundAnnotation(AtAjAttributes.java:1348)
	at org.aspectj.weaver.bcel.AtAjAttributes.readAj5MethodAttributes(AtAjAttributes.java:448)
	at org.aspectj.weaver.bcel.BcelMethod.unpackAjAttributes(BcelMethod.java:203)
	at org.aspectj.weaver.bcel.BcelMethod.&lt;init&gt;(BcelMethod.java:92)
	at org.aspectj.weaver.bcel.BcelObjectType.getDeclaredMethods(BcelObjectType.java:290)
	at org.aspectj.weaver.ReferenceType.getDeclaredMethods(ReferenceType.java:770)
	at org.aspectj.weaver.ResolvedType.getDeclaredAdvice(ResolvedType.java:947)
	at org.aspectj.weaver.ResolvedType.getDeclaredShadowMungers(ResolvedType.java:987)
	at org.aspectj.weaver.ResolvedType.collectShadowMungers(ResolvedType.java:822)
	at org.aspectj.weaver.ResolvedType.collectCrosscuttingMembers(ResolvedType.java:749)
	at org.aspectj.weaver.CrosscuttingMembersSet.addOrReplaceAspect(CrosscuttingMembersSet.java:85)
	at org.aspectj.weaver.CrosscuttingMembersSet.addOrReplaceAspect(CrosscuttingMembersSet.java:69)
	at org.aspectj.weaver.bcel.BcelWeaver.addLibraryAspect(BcelWeaver.java:202)
	at org.aspectj.weaver.loadtime.ClassLoaderWeavingAdaptor.registerAspects(ClassLoaderWeavingAdaptor.java:466)
	at org.aspectj.weaver.loadtime.ClassLoaderWeavingAdaptor.registerDefinitions(ClassLoaderWeavingAdaptor.java:290)
	at org.aspectj.weaver.loadtime.ClassLoaderWeavingAdaptor.initialize(ClassLoaderWeavingAdaptor.java:176)
	at org.eclipse.equinox.weaving.aspectj.loadtime.OSGiWeavingAdaptor.initialize(Unknown Source)
	at org.eclipse.equinox.weaving.aspectj.AspectJWeavingService.ensureAdaptorInit(Unknown Source)
	at org.eclipse.equinox.weaving.aspectj.AspectJWeavingService.preProcess(Unknown Source)
	at org.eclipse.equinox.weaving.adaptors.WeavingAdaptor.weaveClass(Unknown Source)
	at org.eclipse.equinox.weaving.hooks.WeavingHook.processClass(Unknown Source)
	at org.eclipse.osgi.baseadaptor.loader.ClasspathManager.defineClass(ClasspathManager.java:575)
	at org.eclipse.osgi.baseadaptor.loader.ClasspathManager.findClassImpl(ClasspathManager.java:550)
	at org.eclipse.osgi.baseadaptor.loader.ClasspathManager.findLocalClassImpl(ClasspathManager.java:481)
	at org.eclipse.osgi.baseadaptor.loader.ClasspathManager.findLocalClass_LockClassLoader(ClasspathManager.java:469)
	at org.eclipse.osgi.baseadaptor.loader.ClasspathManager.findLocalClass(ClasspathManager.java:449)
	at org.eclipse.osgi.internal.baseadaptor.DefaultClassLoader.findLocalClass(DefaultClassLoader.java:216)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:393)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClassInternal(BundleLoader.java:469)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:422)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:410)
	at org.eclipse.osgi.internal.baseadaptor.DefaultClassLoader.loadClass(DefaultClassLoader.java:107)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:247)
	at org.eclipse.osgi.internal.loader.BundleLoader.loadClass(BundleLoader.java:338)
	at org.eclipse.osgi.framework.internal.core.BundleHost.loadClass(BundleHost.java:232)
	at org.eclipse.osgi.framework.internal.core.AbstractBundle.loadBundleActivator(AbstractBundle.java:149)
	at org.eclipse.osgi.framework.internal.core.BundleContextImpl.start(BundleContextImpl.java:751)
	at org.eclipse.osgi.framework.internal.core.BundleHost.startWorker(BundleHost.java:370)
	at org.eclipse.osgi.framework.internal.core.AbstractBundle.resume(AbstractBundle.java:374)
	at org.eclipse.osgi.framework.internal.core.Framework.resumeBundle(Framework.java:1067)
	at org.eclipse.osgi.framework.internal.core.StartLevelManager.resumeBundles(StartLevelManager.java:561)
	at org.eclipse.osgi.framework.internal.core.StartLevelManager.resumeBundles(StartLevelManager.java:546)
	at org.eclipse.osgi.framework.internal.core.StartLevelManager.incFWSL(StartLevelManager.java:459)
	at org.eclipse.osgi.framework.internal.core.StartLevelManager.doSetStartLevel(StartLevelManager.java:243)
	at org.eclipse.osgi.framework.internal.core.StartLevelManager.dispatchEvent(StartLevelManager.java:440)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:227)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:337)



Reproducible: Couldn't Reproduce</description><comments/></buginformation><fixedCommits><commit id="95e70d2a23b64e7773d8edf909b1365c19752aa3" author="default" date="2011-06-07 16:46:19"><file name="weaver/src/org/aspectj/weaver/bcel/AtAjAttributes.java"><method name="lastbit" returnType="String" parameters="String"/></file></commit></fixedCommits></bug><bug id="461" opendate="2011-06-16 20:13:00" fixdate="2011-06-17 22:39:42"><buginformation><summary>AspectJ reports "abort trouble" while instrumenting a class on startup</summary><description>Build Identifier: 20110218-0911

java.lang.NullPointerException
	at org.aspectj.weaver.bcel.Utility.appendConversion(Utility.java:272)
	at org.aspectj.weaver.bcel.BcelVar.appendConvertableArrayLoad(BcelVar.java:81)
	at org.aspectj.weaver.bcel.BcelVar.createConvertableArrayLoad(BcelVar.java:101)
	at org.aspectj.weaver.bcel.BcelShadow.makeClosureClassAndReturnConstructor(BcelShadow.java:3066)
	at org.aspectj.weaver.bcel.BcelShadow.weaveAroundClosure(BcelShadow.java:2830)
	at org.aspectj.weaver.bcel.BcelAdvice.implementOn(BcelAdvice.java:342)
	at org.aspectj.weaver.Shadow.implementMungers(Shadow.java:630)
	at org.aspectj.weaver.Shadow.implement(Shadow.java:544)
	at org.aspectj.weaver.bcel.BcelClassWeaver.implement(BcelClassWeaver.java:3147)
	at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:490)
	at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:100)
	at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1687)
	at org.aspectj.weaver.bcel.BcelWeaver.weaveWithoutDump(BcelWeaver.java:1631)
	at org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify(BcelWeaver.java:1394)
	at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1180)
	at org.aspectj.weaver.tools.WeavingAdaptor.getWovenBytes(WeavingAdaptor.java:467)
	at org.aspectj.weaver.tools.WeavingAdaptor.weaveClass(WeavingAdaptor.java:318)
	at org.eclipse.equinox.weaving.aspectj.loadtime.OSGiWeavingAdaptor.weaveClass(Unknown Source)
	at org.eclipse.equinox.weaving.aspectj.AspectJWeavingService.preProcess(Unknown Source)
	at org.eclipse.equinox.weaving.adaptors.WeavingAdaptor.weaveClass(Unknown Source)
	at org.eclipse.equinox.weaving.hooks.WeavingHook.processClass(Unknown Source)
	at org.eclipse.osgi.baseadaptor.loader.ClasspathManager.defineClass(ClasspathManager.java:575)
	at org.eclipse.osgi.baseadaptor.loader.ClasspathManager.findClassImpl(ClasspathManager.java:550)
	at org.eclipse.osgi.baseadaptor.loader.ClasspathManager.findLocalClassImpl(ClasspathManager.java:481)
	at org.eclipse.osgi.baseadaptor.loader.ClasspathManager.findLocalClass_LockClassLoader(ClasspathManager.java:469)
	at org.eclipse.osgi.baseadaptor.loader.ClasspathManager.findLocalClass(ClasspathManager.java:449)
	at org.eclipse.osgi.internal.baseadaptor.DefaultClassLoader.findLocalClass(DefaultClassLoader.java:216)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:393)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClassInternal(BundleLoader.java:469)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:422)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:410)
	at org.eclipse.osgi.internal.baseadaptor.DefaultClassLoader.loadClass(DefaultClassLoader.java:107)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:247)
	at org.eclipse.osgi.internal.loader.BundleLoader.loadClass(BundleLoader.java:338)
	at org.eclipse.osgi.framework.internal.core.BundleHost.loadClass(BundleHost.java:232)
	at org.eclipse.osgi.framework.internal.core.AbstractBundle.loadClass(AbstractBundle.java:1197)
	at org.springframework.osgi.util.BundleDelegatingClassLoader.findClass(BundleDelegatingClassLoader.java:99)
	at org.springframework.osgi.util.BundleDelegatingClassLoader.loadClass(BundleDelegatingClassLoader.java:157)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:247)
	at org.springframework.util.ClassUtils.forName(ClassUtils.java:257)
	at org.springframework.beans.factory.support.AbstractBeanDefinition.resolveBeanClass(AbstractBeanDefinition.java:408)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doResolveBeanClass(AbstractBeanFactory.java:1271)
	at org.springframework.beans.factory.support.AbstractBeanFactory.resolveBeanClass(AbstractBeanFactory.java:1242)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.predictBeanType(AbstractAutowireCapableBeanFactory.java:576)
	at org.springframework.beans.factory.support.AbstractBeanFactory.isFactoryBean(AbstractBeanFactory.java:1319)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.getBeanNamesForType(DefaultListableBeanFactory.java:315)
	at org.springframework.osgi.context.support.AbstractDelegatedExecutionApplicationContext.invokeBeanFactoryPostProcessors(AbstractDelegatedExecutionApplicationContext.java:391)
	at org.springframework.osgi.context.support.AbstractDelegatedExecutionApplicationContext.invokeBeanFactoryPostProcessors(AbstractDelegatedExecutionApplicationContext.java:364)
	at org.springframework.osgi.context.support.AbstractDelegatedExecutionApplicationContext$3.run(AbstractDelegatedExecutionApplicationContext.java:256)
	at org.springframework.osgi.util.internal.PrivilegedUtils.executeWithCustomTCCL(PrivilegedUtils.java:87)
	at org.springframework.osgi.context.support.AbstractDelegatedExecutionApplicationContext.startRefresh(AbstractDelegatedExecutionApplicationContext.java:222)
	at org.springframework.osgi.extender.internal.dependencies.startup.DependencyWaiterApplicationContextExecutor.stageOne(DependencyWaiterApplicationContextExecutor.java:225)
	at org.springframework.osgi.extender.internal.dependencies.startup.DependencyWaiterApplicationContextExecutor.refresh(DependencyWaiterApplicationContextExecutor.java:178)
	at org.springframework.osgi.context.support.AbstractDelegatedExecutionApplicationContext.refresh(AbstractDelegatedExecutionApplicationContext.java:159)
	at org.springframework.osgi.extender.internal.activator.LifecycleManager$1.run(LifecycleManager.java:223)
	at java.lang.Thread.run(Thread.java:662)



Reproducible: Sometimes</description><comments/></buginformation><fixedCommits><commit id="f7b11932d5e3bdbb2de85fe21af8443ad9351530" author="default" date="2011-06-17 22:39:42"><file name="weaver/src/org/aspectj/weaver/bcel/Utility.java"><method name="appendConversion" returnType="void" parameters="InstructionList InstructionFactory"/><method name="createSuperInvoke" returnType="Instruction" parameters="InstructionFactory"/></file></commit></fixedCommits></bug><bug id="462" opendate="2011-06-19 05:42:00" fixdate="2011-06-20 17:10:01"><buginformation><summary>Repeated output of ASPECTJ: aspectj.overweaving=true: overweaving switched ON</summary><description>Build Identifier: 1.6.11

The message is repeated every time a new class loader is being use to load weaving configuration (using  -Dorg.aspectj.tracing.factory=default). Since this value is a system (!) property there is no need to display its value more than once (or even check it more than once - it could be lazily initialized and cached...)

Reproducible: Always

Steps to Reproduce:
1. use -Dorg.aspectj.tracing.factory=default -Daspectj.overweaving=true properties
2. place some JAR that contains aop.xml with some aspects and weaving options where it can be loaded/visible from several class loaders
3. runt the application and check the STDOUT output</description><comments/></buginformation><fixedCommits><commit id="bb2aea40a61fd4bd91d8a0b67cf7933ee728942e" author="default" date="2011-06-20 17:10:01"><file name="org.aspectj.matcher/src/org/aspectj/weaver/World.java"><method name="ensureAdvancedConfigurationProcessed" returnType="void" parameters=""/></file></commit></fixedCommits></bug><bug id="463" opendate="2011-06-30 11:32:00" fixdate="2011-06-30 15:34:56"><buginformation><summary>overweaving misbehaving when subclassing WeavingURLClassLoader</summary><description>Raised by the Spring Insight team, they observed that in a system where they are using a special classloader (subclassing weaving url classloader) they see it fail to weave an aspect if overweaving is on.</description><comments/></buginformation><fixedCommits><commit id="2302e94e25862a540ccab34b8f4707081ec7fc06" author="default" date="2011-06-30 15:34:56"><file name="weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java"><method name="addLibraryJarFile" returnType="void" parameters="File"/></file></commit></fixedCommits></bug><bug id="464" opendate="2011-07-18 16:08:00" fixdate="2011-07-18 20:44:33"><buginformation><summary>overweaving can attribute duplicate attributes, one of which will not deserialize correctly</summary><description>When overweaving it is possible that a class will get a second WeaverState attribute.  This second one will not be valid (it hasn't been correctly configured).  This isn't normally a problem because the next thing that happens is that the class is defined to the VM.  But if *another* weave step occurs, the malformed attribute will cause that weave to fail with this kind of message:

bad WeaverState.Kind: -115

The solution is to avoid adding the duplicate when overweaving.</description><comments/></buginformation><fixedCommits><commit id="8553b30c9211a49b225e6c6bc81abda849263740" author="default" date="2011-07-18 20:44:33"><file name="weaver/src/org/aspectj/weaver/bcel/LazyClassGen.java"><method name="writeBack" returnType="void" parameters="BcelWorld"/></file></commit></fixedCommits></bug><bug id="465" opendate="2011-07-26 08:47:00" fixdate="2011-07-26 15:52:40"><buginformation><summary>Need to demote "warning ignoring duplicate definition" from warning to debug</summary><description>Build Identifier: 1.6.11

This kind of 鈥減roblem鈥 can occur for complex class loader hierarchies, and since it is not really a problem, we should make it debug level message so as not to write log messages un-necessarily.

Reproducible: Always

Steps to Reproduce:
1. Create an application that has some weaved class loaders hierarchy - recommend some URLClassLoader derived ones
2. Add the same(!) JAR with only an aop.xml file to more than one loader along the hierarchy
3. Make the loader the default context thread loader and start running some code.</description><comments/></buginformation><fixedCommits><commit id="c6fb752d7ca6910bcb825cfd5ccdf8d39e419408" author="default" date="2011-07-26 15:52:40"><file name="loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"><method name="registerIncludeExclude" returnType="void" parameters="BcelWeaver ClassLoader List"/><method name="registerOptions" returnType="void" parameters="BcelWeaver ClassLoader List"/><method name="initialize" returnType="void" parameters="ClassLoader IWeavingContext"/><method name="registerDump" returnType="void" parameters="BcelWeaver ClassLoader List"/></file></commit></fixedCommits></bug><bug id="466" opendate="2011-07-28 13:52:00" fixdate="2011-07-28 20:48:42"><buginformation><summary>NPE in deleteNewAndDup</summary><description>java.lang.NullPointerException
        at org.aspectj.weaver.bcel.BcelShadow.deleteNewAndDup(BcelShadow.java:179)
        at org.aspectj.weaver.bcel.BcelShadow.prepareForMungers(BcelShadow.java:303)
        at org.aspectj.weaver.Shadow.implement(Shadow.java:543)
        at org.aspectj.weaver.bcel.BcelClassWeaver.implement(BcelClassWeaver.java:3147)
        at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:490)
        at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:100)
        at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1687)
        at org.aspectj.weaver.bcel.BcelWeaver.weaveWithoutDump(BcelWeaver.java:1631)
        at org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify(BcelWeaver.java:1394)
        at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1180)
        at org.aspectj.weaver.tools.WeavingAdaptor.getWovenBytes(WeavingAdaptor.java:467)
        at org.aspectj.weaver.tools.WeavingAdaptor.weaveClass(WeavingAdaptor.java:318)
        at org.aspectj.weaver.loadtime.Aj.preProcess(Aj.java:96)</description><comments/></buginformation><fixedCommits><commit id="e8ef5bfcf9faabf99c443572dca0ddbde545d832" author="default" date="2011-07-28 20:48:42"><file name="weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"><method name="deleteNewAndDup" returnType="void" parameters=""/><method name="prepareForMungers" returnType="void" parameters=""/></file></commit></fixedCommits></bug><bug id="467" opendate="2011-03-23 16:35:00" fixdate="2011-08-03 20:22:40"><buginformation><summary>Race condition in JavaLangTypeToResolvedTypeConverter (potentially exposed through Spring AOP)</summary><description>Build Identifier: 1.6.11

Spinoff of  https://jira.springsource.org/browse/SPR-8070  and  Bug 337855 

There is a race condition in JavaLangTypeToResolvedTypeConverter's use of the
'typeVariablesInProgress' Map.  This can lead to fromType() returning NULL (which eventually leads to the NPE in World).

        } else if (aType instanceof java.lang.reflect.TypeVariable) {
            if (typeVariablesInProgress.get().get(aType) != null) {
 &gt;&gt;&gt;             // aType can get removed from the Map after this null check! 
                return typeVariablesInProgress.get().get(aType);
            }

The error results in the following stack trace:
java.lang.NullPointerException: null
	at org.aspectj.weaver.World.resolve(World.java:278) ~[aspectjweaver.jar:1.6.11]
	at org.aspectj.weaver.World.resolve(World.java:218) ~[aspectjweaver.jar:1.6.11]
	at org.aspectj.weaver.World.resolve(World.java:253) ~[aspectjweaver.jar:1.6.11]
	at org.aspectj.weaver.TypeFactory.createParameterizedType(TypeFactory.java:42) ~[aspectjweaver.jar:1.6.11]
	at org.aspectj.weaver.reflect.JavaLangTypeToResolvedTypeConverter.fromType(JavaLangTypeToResolvedTypeConverter.java:88) ~[aspectjweaver.jar:1.6.11]

I have also attached a BTrace script that shows further analysis of the problem:
  onFromType_Line91: RETURNING TYPE FROM MAP (typeVariablesInProgress: {T=T})
  onFromType_FieldGet: typeVariablesInProgress: {T=T}
  onFromType_Return: fromType(T) --&gt; null

We have tested a patch that wraps the 'typeVariablesInProgress' Map in a ThreadLocal.  In limited testing, this appears to have fixed the problem.  I have attached the patch.

Reproducible: Sometimes

Steps to Reproduce:
Perform type resolution on classes with parameterized/generic signatures concurrently with multiple threads.

Note: I have been unable to reproduce this issue outside of our server.  We see the issue with Spring and during Server initialization under heavy load.</description><comments/></buginformation><fixedCommits><commit id="167b801c5c71bfa1e0667e85429e097f03d7e849" author="default" date="2011-08-03 20:22:40"><file name="weaver5/java5-src/org/aspectj/weaver/reflect/JavaLangTypeToResolvedTypeConverter.java"><method name="fromType" returnType="ResolvedType" parameters="Type"/></file></commit></fixedCommits></bug><bug id="468" opendate="2011-08-05 12:17:00" fixdate="2011-08-05 16:17:39"><buginformation><summary>constructor inlining can fail for some groovy built code</summary><description>The file grails.util.BuildSettings contains bytecode where the constructors are recursive.

You can't compile this in Java

A() {
  this();
}

but groovy generates some code where it switches on a value in the ctor and if it is a certain value, the recursive ctor call is made.  I imagine this 'never happens' in practice but because it is in the bytecode it trips up the AspectJ code which inlines this() calls before weaving - since it gets into an infinite loop.

For now, just keep track of ctors making the recursive call and so don't get trapped in the infinite loop.</description><comments/></buginformation><fixedCommits><commit id="6ae463a7494a0e04878e2d265a3505dd0d32cc4a" author="default" date="2011-08-05 16:17:39"><file name="weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"><method name="inlineSelfConstructors" returnType="boolean" parameters="List&lt;LazyMethodGen&gt;"/><method name="weave" returnType="boolean" parameters=""/></file></commit></fixedCommits></bug><bug id="469" opendate="2011-07-30 17:23:00" fixdate="2011-08-15 20:28:37"><buginformation><summary>NPE when saving an aspect - Aspectj Internal Compiler Error</summary><description>Created  attachment 200625   [details] 
Two projects

java.lang.NullPointerException
at org.aspectj.weaver.ShadowMunger.getBinaryFile(ShadowMunger.java:201)
at org.aspectj.weaver.ShadowMunger.getBinarySourceLocation(ShadowMunger.java:188)
at org.aspectj.weaver.model.AsmRelationshipProvider.createAdviceChild(AsmRelationshipProvider.java:699)
at org.aspectj.weaver.model.AsmRelationshipProvider.addChildNodes(AsmRelationshipProvider.java:657)
at org.aspectj.weaver.model.AsmRelationshipProvider.crea ... bleAspect$edu_uat_cs2011_observerpattern_Observable$observers(java.util.List)
end public class edu.uat.csc263.su10045.observermodel.DepartmentManager

I have attached a zip file containing the two projects that in combination caused this problem.  To recreate, load the projects, go into DepartmentManagerObservableAspect, modify the pointcut and save the file.</description><comments/></buginformation><fixedCommits><commit id="0f506abfabde7877848e3cdac925361e1d134455" author="default" date="2011-08-15 20:28:37"><file name="org.aspectj.matcher/src/org/aspectj/weaver/ShadowMunger.java"><method name="getBinaryFile" returnType="File" parameters=""/><method name="getBinarySourceLocation" returnType="ISourceLocation" parameters="ISourceLocation"/></file></commit></fixedCommits></bug><bug id="470" opendate="2011-08-17 09:28:00" fixdate="2011-08-17 15:54:09"><buginformation><summary>Nullpointer-Exception while parsing definition file (aop.xml) in DocumentParser</summary><description>Build Identifier: 20100617-1415

With an activated NullpointerException-Breakpoint i recently stumpled upon a thrown NPE in the DocumentParser.parse()-method (Line 106):

	public static Definition parse(final URL url) throws Exception {
		InputStream in = null;
		try {
			if (CACHE &amp;&amp; parsedFiles.containsKey(url.toString())) {
				return parsedFiles.get(url.toString());
			}
			Definition def=null;
			
			if(LIGHTPARSER){	
				def = SimpleAOPParser.parse(url);
			}else{
				def = saxParsing(url);
			}
		
			if (CACHE &amp;&amp; def.getAspectClassNames().size() &gt; 0) {
				parsedFiles.put(url.toString(), def);
			}

			return def;
		} finally {
			try {
				in.close();
			} catch (Throwable t) {

			}
		}
	}

... The parsing of the configuration file works fine, merely the InputStream seems not to be used anymore. 


Reproducible: Always</description><comments/></buginformation><fixedCommits><commit id="e71e287b8c6c18370b79f7f8bacc734274573267" author="default" date="2011-08-17 15:54:09"><file name="weaver/src/org/aspectj/weaver/loadtime/definition/DocumentParser.java"><method name="parse" returnType="Definition" parameters="URL"/></file></commit></fixedCommits></bug><bug id="471" opendate="2011-09-29 00:22:00" fixdate="2011-09-29 16:34:42"><buginformation><summary>NPE in AjBuildManager.java:528 after non-Java/AJ file was renamed</summary><description>Build Identifier: 

Upon using Eclipse's "Rename Resource" dialog to rename my project's "src/main/resources/META-INF/spring/email.properties" file to "scheduler.properties" in the same directory, Eclipse displayed the "AspectJ Internal Compiler Error" dialog with this stack trace: 

java.io.FileNotFoundException
at java.io.FileInputStream.open(Native Method)
at java.io.FileInputStream.&lt;init&gt;(FileInputStream.java:120)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.copyResourcesFromFile(AjBuildManager.java:528)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.copyResourcesToDestination(AjBuildManager.java:466)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performBuild(AjBuildManager.java:363)
 ... e error: FileNotFoundException thrown: /Users/aswan/projects/foo/src/main/resources/META-INF/spring/email.properties (No such file or directory)

Reproducible: Couldn't Reproduce

Steps to Reproduce:
N/A</description><comments/></buginformation><fixedCommits><commit id="14a6eac32a20c81682e9b6875e8c3a4a8d9e8897" author="default" date="2011-09-29 16:34:42"><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"><method name="copyResourcesFromFile" returnType="void" parameters="File String File"/></file></commit></fixedCommits></bug><bug id="472" opendate="2011-11-04 20:33:00" fixdate="2011-11-07 16:17:10"><buginformation><summary>neo4j NPE</summary><description>java.lang.NullPointerException
        at org.aspectj.weaver.patterns.ExactAnnotationTypePattern.matches(ExactAnnotationTypePattern.java:128)
        at org.aspectj.weaver.patterns.ExactAnnotationTypePattern.matches(ExactAnnotationTypePattern.java:96)
        at org.aspectj.weaver.patterns.AndAnnotationTypePattern.matches(AndAnnotationTypePattern.java:42)
        at org.aspectj.weaver.patterns.AnyWithAnnotationTypePattern.matchesExactly(AnyWithAnnotationTypePattern.java:55)
        at org.aspectj.weaver.patterns.TypePattern.matchesStatically(TypePattern.java:132)
        at org.aspectj.weaver.patterns.TypePattern.matches(TypePattern.java:146)
        at org.aspectj.weaver.patterns.SignaturePattern.couldEverMatch(SignaturePattern.java:999)
        at org.aspectj.weaver.patterns.DeclareAnnotation.couldEverMatch(DeclareAnnotation.java:483)
        at org.aspectj.weaver.bcel.BcelClassWeaver.getMatchingSubset(BcelClassWeaver.java:1065)
        at org.aspectj.weaver.bcel.BcelClassWeaver.weaveDeclareAtField(BcelClassWeaver.java:1301)
        at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:445)
        at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:100)
        at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1687)
        at org.aspectj.weaver.bcel.BcelWeaver.weaveWithoutDump(BcelWeaver.java:1631)
        at org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify(BcelWeaver.java:1394)
        at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1180)
        at org.aspectj.ajdt.internal.compiler.AjPipeliningCompilerAdapter.weaveQueuedEntries(AjPipeliningCompilerAdapter.java:514)
        at org.aspectj.ajdt.internal.compiler.AjPipeliningCompilerAdapter.queueForWeaving(AjPipeliningCompilerAdapter.java:447)
        at org.aspectj.ajdt.internal.compiler.AjPipeliningCompilerAdapter.afterProcessing(AjPipeliningCompilerAdapter.java:432)
        at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$after$org_aspectj_ajdt_internal_compiler_CompilerAdapter$5$6b855184(CompilerAdapter.aj:98)
        at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:652)
        at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:392)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:1021)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performBuild(AjBuildManager.java:268)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:181)
        at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:112)
        at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:60)
        at org.aspectj.tools.ajc.Main.run(Main.java:371)</description><comments/></buginformation><fixedCommits><commit id="942da06faacec35b0aab76eb2729e55b174e3c97" author="default" date="2011-11-07 16:17:10"><file name="org.aspectj.matcher/src/org/aspectj/weaver/ReferenceType.java"><method name="getAnnotationOfType" returnType="AnnotationAJ" parameters="UnresolvedType"/><method name="addParent" returnType="void" parameters="ResolvedType"/><method name="makeDeclaredSignature" returnType="String" parameters="ResolvedType"/><method name="setGenericType" returnType="void" parameters="ReferenceType"/><method name="getWeaverState" returnType="WeaverStateInfo" parameters=""/></file></commit></fixedCommits></bug><bug id="473" opendate="2012-02-15 17:16:00" fixdate="2012-02-15 14:25:02"><buginformation><summary>type construction for signature makes mistakes with wildcards</summary><description>If you have a type with multiple type params, like this:

Foo&lt;?,T&gt;

the signature is:

LFoo&lt;*TT;&gt;;

and the handling of * is not working in TypeFactory.  If that signature is passed in it will actually build:

Foo&lt;?&gt;

having lost the second type parameter, this breaks code later that has expectations on the number of params.  (e.g. ArrayIndexOutOfBoundsException when building parameterization map)</description><comments/></buginformation><fixedCommits><commit id="89756cdfe58319d4e8e29b88de6fd8810d84244d" author="default" date="2012-02-15 14:25:02"><file name="org.aspectj.matcher/src/org/aspectj/weaver/TypeFactory.java"><method name="locateFirstBracket" returnType="int" parameters="StringBuffer"/><method name="createTypeFromSignature" returnType="UnresolvedType" parameters="String"/></file></commit></fixedCommits></bug><bug id="474" opendate="2012-02-19 15:42:00" fixdate="2012-03-02 08:17:44"><buginformation><summary>org.aspectj.weaver.BCException compiling @DeclareParents with value using "||"</summary><description>Build Identifier: 20110916-0149

Using:

import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.DeclareParents;

@Aspect
public class AspectTest {
    
    private interface X {}
    private static class XImpl {}

    @DeclareParents(value="java.lang.Runnable || java.util.concurrent.Callable",  defaultImpl=XImpl.class)
    private X xImpl;
  
}


Throws:

org.aspectj.weaver.BCException
at org.aspectj.weaver.patterns.ExactTypePattern.resolveBindings(ExactTypePattern.java:312)
at org.aspectj.weaver.patterns.OrTypePattern.resolveBindings(OrTypePattern.java:121)
at org.aspectj.weaver.bcel.AtAjAttributes.handleDeclareParentsAnnotation(AtAjAttributes.java:746)
at org.aspectj.weaver.bcel.AtAjAttributes.readAj5ClassAttributes(AtAjAttributes.java:384)
at org.aspectj.weaver.bcel.BcelObjectType.ens ... \Program Files\Java\jre6\lib\ext\sunjce_provider.jar;C:\Users\xxx\software\eclipse-j2ee\\plugins/org.eclipse.equinox.launcher_1.2.0.v20110502.jar;

Current workaround is to use multiple DeclareParents annotations on different variables.

Reproducible: Always

Steps to Reproduce:
1. Create new class given the code in the details.
2. Save and compile in Eclipse.</description><comments/></buginformation><fixedCommits><commit id="f37c56e02982a1043e7821bf033b58495f8a6b74" author="default" date="2012-03-02 08:17:44"><file name="weaver/src/org/aspectj/weaver/bcel/AtAjAttributes.java"><method name="handleDeclareParentsAnnotation" returnType="boolean" parameters=""/></file></commit></fixedCommits></bug><bug id="475" opendate="2012-03-04 01:25:00" fixdate="2012-03-06 08:33:16"><buginformation><summary>Memory leak in CompilationAndWeavingContext leading to PermGen OOME</summary><description>Build Identifier: 1.6.11

The static contextMap in CompilationAndWeavingContext keeps strong references to Thread instances (which in turn strongly reference their contextClassLoader which prevents all kinds of stuff from unloading).

In my particular use case I am running unit tests, each in their own WeavingURLClassLoader, but these ClassLoaders are never released, and running several unit tests at once leads to PermGen OutOfMemoryError.

Using -XX:+HeapDumpOnOutOfMemory and analyzing the resulting heap dump in Eclipse Memory Analyzer points to CompilationAndWeavingContext.contextMap.

I am able to work around this issue by executing the following at the end of each unit test to clear out this contextMap:

    CompilationAndWeavingContext.setMultiThreaded(false);
    CompilationAndWeavingContext.reset();
    CompilationAndWeavingContext.setMultiThreaded(true);

I am also able to resolve this issue (more satisfactorily) by patching CompilationAndWeavingContext and changing contextMap into a ThreadLocal.

Reproducible: Always</description><comments/></buginformation><fixedCommits><commit id="6defb4e5a2565f5568cf6c1346001abf99305d51" author="default" date="2012-03-06 08:33:16"><file name="bridge/src/org/aspectj/bridge/context/CompilationAndWeavingContext.java"><method name="reset" returnType="void" parameters=""/><method name="getContextStack" returnType="Stack&lt;ContextStackEntry&gt;" parameters=""/><method name="resetForThread" returnType="void" parameters=""/><method name="leavingPhase" returnType="void" parameters="ContextToken"/></file></commit></fixedCommits></bug><bug id="476" opendate="2012-03-20 07:19:00" fixdate="2012-03-23 16:57:10"><buginformation><summary>Performance regression in 1.6.12</summary><description>Build Identifier: 1.6.12

The application I'm working on takes 152 seconds to start under the 1.6.11 LTW agent, but takes 37 *minutes* to start under the 1.6.12 LTW agent.  Profiling it under the 1.6.12 LTW agent shows the extra time is spent in ReferenceType.addDependentType() (being called from TypeFactory.createParameterizedType()).  Under a debugger, I can see that the ReferenceType.derivativeTypes HashSet is getting very very big (because ResolvedType.equals() falls back to ==, so there are lots of 'duplicates' in the HashSet), which is causing each successive add() to get slower and slower.  It looks like derivativeTypes was changed from ArrayList to HashSet in 1.6.12 (as part of the changeset for  bug 344005 ), which seems to be what caused the performance regression.  Changing derivativeTypes back to ArrayList solves the issue and brings startup times back in line with 1.6.11.  I'm not sure if this is the best fix though, I started thinking about storing parameterized types in World.typeMap to remove duplicate instances globally and/or changing ResolvedType.equals() to remove duplicate instances inside of derivativeTypes, but quickly got in over my head.

Reproducible: Always</description><comments/></buginformation><fixedCommits><commit id="549d227a8ded88d708415162b36cb273ec496b77" author="default" date="2012-03-23 16:57:10"><file name="org.aspectj.matcher/src/org/aspectj/weaver/ReferenceType.java"><method name="getPerClause" returnType="PerClause" parameters=""/><method name="getTypeVariables" returnType="TypeVariable[]" parameters=""/><method name="setDelegate" returnType="void" parameters="ReferenceTypeDelegate"/><method name="addParent" returnType="void" parameters="ResolvedType"/><method name="addAnnotation" returnType="void" parameters="AnnotationAJ"/><method name="getWeaverState" returnType="WeaverStateInfo" parameters=""/></file><file name="org.aspectj.matcher/src/org/aspectj/weaver/TypeFactory.java"><method name="createParameterizedType" returnType="ReferenceType" parameters="ResolvedType"/></file><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"><method name="addSourceTypeBinding" returnType="void" parameters="SourceTypeBinding"/></file><file name="org.aspectj.matcher/src/org/aspectj/weaver/ResolvedType.java"><method name="getWorld" returnType="World" parameters=""/></file></commit></fixedCommits></bug><bug id="477" opendate="2012-03-21 14:02:00" fixdate="2012-03-23 18:17:09"><buginformation><summary>Performance - improve pointcut expensiveness calculation</summary><description>Build Identifier: 1.6.12

I'm able to reduce the AspectJ LTW startup overhead on the app I'm working on, from 95 seconds down to 47 seconds, just by switching the "expensiveness" of THIS_OR_TARGET and CALL in PointcutEvaluationExpenseComparator.  It seems to make sense to me that THIS_OR_TARGET is more expensive since it requires type matching (under profiler ExactTypePattern.matchesInstanceof() is what shows up as very expensive), whereas CALL can evaluate very quickly in most cases since it just fails to match on method name.  I'm not sure if this is specific to my particular usage, but cutting 50% of the LTW startup is a very nice improvement.  If you think this change doesn't make sense for everyone, I can work on a patch that makes this configurable somehow.  Thanks.

Reproducible: Always</description><comments/></buginformation><fixedCommits><commit id="f85631fd2fb2e0f3213abb9c5a7cd86eec2c9ab5" author="default" date="2012-03-23 18:17:09"><file name="org.aspectj.matcher/src/org/aspectj/weaver/patterns/PointcutEvaluationExpenseComparator.java"><method name="getScore" returnType="int" parameters="Pointcut"/></file></commit></fixedCommits></bug><bug id="478" opendate="2012-04-09 15:13:00" fixdate="2012-04-09 14:15:55"><buginformation><summary>attribute problems with Java 7 compilation</summary><description>From the mailing list, this goes wrong:

***R.java***
public class R{ 
  public static void main(String[] args) {System.out.println(new R().getClass().getName());}
}

***R1.java***
public class R1 extends R {}

***RAj.aj***
public aspect RAj
{
    private ThreadLocal&lt;Object&gt; inAspect = new ThreadLocal&lt;Object&gt;();
    
    pointcut createR() : execution(R.new());
    Object around() : createR()
    {
        System.out.println("aspect:" + inAspect.get() + ":" + this);
        if (inAspect.get() != null)
        {
            return proceed();
        }
        else
        {
            inAspect.set(this);
            return new R1();
        }
    }
}


compile command:
/cygdrive/c/Program\ Files/Java/aspectj-1.6.12/bin/ajc.bat -source 1.7 -outxml -outjar araj.jar -classpath "aspectjrt.jar;." RAj.aj 

run:

/cygdrive/c/Program\ Files/Java/aspectj-1.6.12/bin/aj5.bat  -classpath ".;./araj.jar" R

errors:
Apr 06, 2012 1:37:40 PM org.aspectj.weaver.tools.Jdk14Trace error
SEVERE: register definition failed
java.lang.RuntimeException: Problem processing attributes in RAj
    at org.aspectj.weaver.bcel.BcelObjectType.ensureAspectJAttributesUnpacked(BcelObjectType.java:385)</description><comments/></buginformation><fixedCommits><commit id="be063b851651ebcfe1e147198842e28ea7dbbb26" author="default" date="2012-04-09 14:15:55"><file name="weaver/src/org/aspectj/weaver/bcel/asm/StackMapAdder.java"><method name="addStackMaps" returnType="byte[]" parameters="World byte[]"/></file></commit></fixedCommits></bug><bug id="479" opendate="2012-06-15 06:31:00" fixdate="2012-06-15 11:29:35"><buginformation><summary>An package-level abstract generic privileged aspect, which extends an abstract generic aspect, gives a IlligalStateException on a method call in around advice</summary><description>Build Identifier: AJDT Version: 2.1.3.e37x-20110628-1900 / AspectJ version: 1.6.12.20110613132200 / eclipse.buildId=M20120208-0800

around advice targetting a generic constructor call in a package visability  generic privileged abstract apsect, which extends a abstract generic aspect gives a compiler error when in this around advice a method call is made to a method defined in the aspect, superaspect or abstract defined methods. This only affects around advice and only when the aspect is package-visible and privileged.

Workaround: either make the aspect public or remove privileged.

Compiler output:
Compile error: IllegalStateException thrown: Use generic type, not parameterized type
StackTrace:

java.lang.IllegalStateException: Use generic type, not parameterized type
	at org.aspectj.weaver.ResolvedTypeMunger.&lt;init&gt;(ResolvedTypeMunger.java:72)
	at org.aspectj.weaver.PrivilegedAccessMunger.&lt;init&gt;(PrivilegedAccessMunger.java:31)
	at org.aspectj.weaver.CrosscuttingMembers.addPrivilegedAccesses(CrosscuttingMembers.java:232)
	at org.aspectj.weaver.ResolvedType.collectCrosscuttingMembers(ResolvedType.java:756)
	at org.aspectj.weaver.CrosscuttingMembersSet.addOrReplaceAspect(CrosscuttingMembersSet.java:89)
	at org.aspectj.weaver.CrosscuttingMembersSet.addOrReplaceAspect(CrosscuttingMembersSet.java:69)
	at org.aspectj.weaver.bcel.BcelWeaver.prepareForWeave(BcelWeaver.java:512)
	at org.aspectj.ajdt.internal.compiler.AjPipeliningCompilerAdapter.ensureWeaverInitialized(AjPipeliningCompilerAdapter.java:529)
	at org.aspectj.ajdt.internal.compiler.AjPipeliningCompilerAdapter.weaveQueuedEntries(AjPipeliningCompilerAdapter.java:509)
	at org.aspectj.ajdt.internal.compiler.AjPipeliningCompilerAdapter.queueForWeaving(AjPipeliningCompilerAdapter.java:447)
	at org.aspectj.ajdt.internal.compiler.AjPipeliningCompilerAdapter.afterProcessing(AjPipeliningCompilerAdapter.java:432)
	at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$after$org_aspectj_ajdt_internal_compiler_CompilerAdapter$5$6b855184(CompilerAdapter.aj:98)
	at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:652)
	at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:392)
	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:1021)
	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performBuild(AjBuildManager.java:305)
	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.incrementalBuild(AjBuildManager.java:185)
	at org.aspectj.ajde.core.internal.AjdeCoreBuildManager.performBuild(AjdeCoreBuildManager.java:127)
	at org.aspectj.ajde.core.AjCompiler.build(AjCompiler.java:91)
	at org.eclipse.ajdt.core.builder.AJBuilder.build(AJBuilder.java:257)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:728)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:199)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:239)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:292)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:295)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:351)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:374)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:143)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:241)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)
Session data:
eclipse.buildId=M20120208-0800
java.version=1.6.0_22
java.vendor=Sun Microsystems Inc.
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=nl_NL
Command-line arguments:  -data C:\workspace\ -os win32 -ws win32 -arch x86_64


Reproducible: Always

Steps to Reproduce:
1. In a empty AspectJ project create the file Foo.java:
import java.util.LinkedList;
public class Foo {
	public LinkedList bar()
	{
		new LinkedList();
		return null;
	}
}
2. Create the file FooAspect.aj containing:
import java.util.AbstractList;
import java.util.List;
abstract aspect FooAspectParent&lt;T extends List&gt;
{
	protected int getNumber(int k)
	{
		return -1*k;
	}
}



abstract privileged aspect FooAspect&lt;T extends AbstractList&gt; extends FooAspectParent&lt;T&gt; {
    pointcut pc():  call(T.new());
	T around():pc()
	{
		//getNumber(1); //&lt;-- method call to superAspect fails   
		//method();  // &lt;-- method call to abstract local defined method fails
		//localMethod(); //&lt;-- method call to local private method fails
		Math.random(); //&lt;-- works
		hashCode(); //&lt;-- works
		return null;
	}	
	private void localMethod(){}
	
	protected abstract T method();
}
3. Uncomment one or more of the three commentted functions calls in the around advice and the compiler will reproduce the error.
(note: this example with List which is a generic object is just for illustration of hierachy, this problem occured on production code when doing the same with non-generic, but hierachal objects. This way was the easiest to issolate and reproduce the bug the fastest.)</description><comments/></buginformation><fixedCommits><commit id="ba9d43ccaf2660ddc9916ea48f79a77ba60d435e" author="default" date="2012-06-15 11:29:35"><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AccessForInlineVisitor.java"><method name="makePublic" returnType="void" parameters="TypeBinding"/></file></commit></fixedCommits></bug><bug id="480" opendate="2012-06-10 10:48:00" fixdate="2012-06-15 17:42:25"><buginformation><summary>NPE in BcelTypeMunger.createBridgeMethod</summary><description>Build Identifier: 

Since I updated to version     

AspectJ Development Tools	2.2.0.e37x-20120529-0900

I get during compile:

java.lang.NullPointerException
at org.aspectj.weaver.bcel.BcelTypeMunger.createBridgeMethod(BcelTypeMunger.java:1325)
at org.aspectj.weaver.bcel.BcelTypeMunger.createAnyBridgeMethodsForCovariance(BcelTypeMunger.java:1272)
at org.aspectj.weaver.bcel.BcelTypeMunger.mungeNewMethod(BcelTypeMunger.java:971)
at org.aspectj.weaver.bcel.BcelTypeMunger.munge(BcelTypeMunger.java:108)
at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeave ... )

Before, I had     AspectJ Development Tools	2.2.0.e37x-20120507-1400 and the same project compiled without that exception.


Reproducible: Always</description><comments/></buginformation><fixedCommits><commit id="a7483038e86dd39894d9b347f227eb6c3a33e09e" author="default" date="2012-06-15 17:42:25"><file name="tests/src/org/aspectj/systemtest/ajc170/Ajc170Tests.java"><method name="testGenericAspectAround382723_4" returnType="void" parameters=""/></file><file name="weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java"><method name="createAnyBridgeMethodsForCovariance" returnType="void" parameters="BcelClassWeaver"/><method name="createBridgeMethod" returnType="void" parameters="BcelWorld NewMethodTypeMunger"/></file><file name="org.aspectj.matcher/src/org/aspectj/weaver/ResolvedType.java"><method name="parameterizedWith" returnType="ResolvedType" parameters="UnresolvedType[]"/><method name="parameterize" returnType="UnresolvedType" parameters="UnresolvedType&gt;"/></file></commit></fixedCommits></bug><bug id="481" opendate="2012-07-03 14:06:00" fixdate="2012-07-03 13:46:29"><buginformation><summary>make ajcore file creation optional</summary><description>Although cores are useful, there may be situations where you are working around whatever they are reporting and are perhaps unable to pick up a later version of AJ that includes the fix.  In these situations it might be helpful to make the creation of cores optional, through a sys prop.</description><comments/></buginformation><fixedCommits><commit id="5d0e1860cb5069b266ba70d33bc356d36e285a90" author="default" date="2012-07-03 13:46:29"><file name="org.aspectj.matcher/src/org/aspectj/weaver/Dump.java"><method name="dumpOnExit" returnType="String" parameters="IMessageHolder boolean"/><method name="dumpWithException" returnType="String" parameters="IMessageHolder Throwable"/></file></commit></fixedCommits></bug><bug id="482" opendate="2012-07-05 13:42:00" fixdate="2012-07-10 10:18:35"><buginformation><summary>Type Mismatch error when using inner classes contained in generic types within ITDs</summary><description>Please see attached example project. 

I get the following (strange) compiler error:

Type mismatch: cannot convert from A&lt;T&gt;.InnerA&lt;&gt; to A.InnerA	

BAspect.aj   /AspectJInnerclassInGenericTypeBug/src/de/example	line 12</description><comments/></buginformation><fixedCommits><commit id="bf949d3260232dd69a5fd3a2b81a19cb3dd1a6a6" author="default" date="2012-07-10 10:18:35"><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"><method name="fromBinding" returnType="UnresolvedType" parameters="TypeBinding"/></file><file name="tests/src/org/aspectj/systemtest/AllTests17.java"><method name="suite" returnType="Test" parameters=""/></file></commit></fixedCommits></bug><bug id="483" opendate="2012-07-26 10:15:00" fixdate="2012-08-22 12:43:56"><buginformation><summary>Error "must implement abstract inter-type declaration" even though build is fine</summary><description>Build Identifier: Version: 4.2.0 Build id: I20120608-1400

I have an AspectJ project with Java classes like this (schematically, not the full code):

public abstract class BasicFilter {
    protected abstract String getLogMessage();
}

public class PreJTidyFilter extends BasicFilter
{
    @Override
    protected String getLogMessage() {
        return "Fixing HTML so as to enable JTidy to parse it";
    }
}

public class JTidyFilter extends BasicFilter {
    @Override
    protected String getLogMessage() {
        return "Converting to clean, pretty-printed XHTML";
    }
}

public class XOMUnclutterFilter extends BasicFilter {
    @Override
    protected String getLogMessage() {
        return "Removing clutter (header, footer, navigation, ads) and fixing structure";
    }
}

###################################

I also have this aspect:

privileged aspect LoggingAspect {
    pointcut runFilter() : execution(* BasicFilter.run());

    void around(BasicFilter filter) : runFilter() &amp;&amp; this(filter) {
        String message = filter.getLogMessage();
        SimpleLogger.verbose(message, IndentMode.INDENT_AFTER);
        proceed(filter);
        SimpleLogger.dedent();
    }
}

###################################

The aspects compile and run fine, but the Eclipse error view always shows two errors:

must implement abstract inter-type declaration:
    java.lang.String de.scrum_master.galileo.filter.BasicFilter.getLogMessage()
    (XOMUnclutterFilter.java)

must implement abstract inter-type declaration:
    java.lang.String de.scrum_master.galileo.filter.BasicFilter.getLogMessage()
    (JTidyFilter.java)

The errors even re-occur after cleaning and rebuilding the project. But as I said, the code runs just fine.

Please note: The funny thing is that in those two classes I just need to add and remove whitespace, then save the file, and the error goes away file by file. As soon as I rebuild though, the errors are there again.

Please also note: The errors always are shown for subclasses XOMUnclutterFilter and JTidyFilter, but strangely *not* for subclass PreJTidyFilter, even though it is affected by the same pointcut and advice as the others and also subclassing the same base class.

Reproducible: Always

Steps to Reproduce:
I do not know if there is a way for you to reproduce this behaviour with the little code snippets I provided above, but here it happens all the time.

If you would like to clone my project, it is located at  https://github.com/kriegaex/Galileo-Openbook-Cleaner .

My Eclipse was configured via Yoxos, but AJDT
  Version: 2.2.0.e42x-RELEASE-20120703-2200
  AspectJ version: 1.7.0.20120703164200
was installed by me manually because right after the Juno release AJDT were not available via Yoxos yet (I do not know if they are now).</description><comments/></buginformation><fixedCommits><commit id="7c6e9361dae7f2ee4cf15b68eccdf54e889d1f75" author="default" date="2012-08-22 12:43:56"><file name="weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java"><method name="addMethodDispatch" returnType="void" parameters="LazyClassGen ResolvedMember"/></file><file name="org.aspectj.matcher/src/org/aspectj/weaver/ResolvedType.java"><method name="checkInterTypeMungers" returnType="void" parameters=""/></file></commit></fixedCommits></bug><bug id="484" opendate="2012-08-21 13:30:00" fixdate="2012-08-22 13:13:54"><buginformation><summary>RuntimeException when trying to compile broken code</summary><description>java.lang.RuntimeException
at org.aspectj.weaver.NameMangler.makeVisibilityName(NameMangler.java:297)
at org.aspectj.weaver.NameMangler.interMethod(NameMangler.java:242)
at org.aspectj.weaver.AjcMemberMaker.interMethod(AjcMemberMaker.java:538)
at org.aspectj.ajdt.internal.compiler.problem.AjProblemReporter.methodMustOverride(AjProblemReporter.java:385)
at org.aspectj.org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(M ... dJob.java:241)
at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

Compile error: RuntimeException thrown: protected inter-types not allowed</description><comments/></buginformation><fixedCommits><commit id="cbb6f5a7d50075dbb4482ff1a112463661aafe19" author="default" date="2012-08-22 13:13:54"><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/problem/AjProblemReporter.java"><method name="methodMustOverride" returnType="void" parameters="AbstractMethodDeclaration"/></file></commit></fixedCommits></bug><bug id="485" opendate="2012-08-16 20:46:00" fixdate="2012-08-23 12:19:58"><buginformation><summary>Softening exception in try-with-resources</summary><description>From this post on the Eclipse AJDT forum:  http://www.eclipse.org/forums/index.php/t/369503/ 

When softening exceptions, AspectJ doesn't seem to soften the exception thrown by the automatic close() invocation when using the try-with-resources syntax introduced in Java 7 (often an IOException).  eg:

---
In Java code:

try (BufferedReader reader = new BufferedReader(new FileReader("test.txt"))) {
  System.out.println(reader.readLine());
}


In AspectJ code:

declare soft: IOException: within(*)

---
The above will result in a compilation error, "Unhandled exception type IOException thrown by automatic close() invocation".

A workaround is to add a catch for the IOException, or to add a throws clause to the method, which kind of makes the exception softening somewhat redundant.

If you're using AJDT, doing these workarounds then adds AJDT add markers to the try-with-resources block, one of which looks like it's for the automatic close() - maybe the 'unhandled exception' error is preventing AspectJ from properly softening the exception?</description><comments/></buginformation><fixedCommits><commit id="76d695ff1a6f8863a1b64f17e38a5ffee170f09f" author="default" date="2012-08-23 12:19:58"><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/problem/AjProblemReporter.java"><method name="unhandledException" returnType="void" parameters="TypeBinding ASTNode"/></file></commit></fixedCommits></bug><bug id="486" opendate="2012-09-06 12:34:00" fixdate="2012-09-06 09:37:31"><buginformation><summary>Double Synthetic attributes on some around advice members</summary><description>Some of the support members in aspects were getting Synthetic attributes added twice (once when compiled, once when used as an aspect library).  Some JVMs appear to flag this as a verify error.  The fix is simply to check before adding to make sure the attribute isn't added twice.</description><comments/></buginformation><fixedCommits><commit id="c2ff74fd569ea2ef0c4abdc06e3f36a77b1ddd2c" author="default" date="2012-09-06 09:37:31"><file name="weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"><method name="pack" returnType="MethodGen" parameters=""/></file></commit></fixedCommits></bug><bug id="487" opendate="2012-09-17 14:25:00" fixdate="2012-09-19 10:19:17"><buginformation><summary>Inconsistent classfile encountered: The undefined type parameter xxx is referenced from within yyy</summary><description>With the declare parents pattern below, I'm getting this **runtime** error (compiler completes ok):

Inconsistent classfile encountered: The undefined type parameter ID is referenced from within PersistableAspect

If I remove the generics part of the interface declaration, the error goes away.  Here's the pattern:

interface:
==========
package example.trait;

// imports...

public interface Persistable&lt;ID extends Serializable&gt; {

	Object getOid();

	ID getId();

	String getIdString();

	long getVersion();
}

annotation:
===========
package example.anno;

// imports...

@Target(TYPE)
@Retention(RUNTIME)
@Trait
public @interface Persistable {

	String in() default "MONGO";

	StoreType inAsEnum() default StoreType.MONGO;

	String id() default "STRING";

	IdType idAsEnum() default IdType.STRING;
}


aspect:
=======
package example.aspect;

// imports...

public privileged aspect PersistableAspect {

	public interface I&lt;ID extends Serializable&gt; extends example.trait.Persistable&lt;ID&gt; {
	}

	public interface L extends I&lt;Long&gt; {
	}

	public interface S extends I&lt;String&gt; {
	}

	declare parents :
        (@Persistable(id="LONG") *)
        implements L;

	declare parents :
        (@Persistable(id="STRING") *)
        implements S;

	// remaining code is ITDs introducing vars &amp; methods...
}</description><comments/></buginformation><fixedCommits><commit id="b9c7a190f452cf888854e4fa6599269a5a2c0212" author="default" date="2012-09-19 10:19:17"><file name="tests/src/org/aspectj/systemtest/AllTests17.java"><method name="suite" returnType="Test" parameters=""/></file></commit></fixedCommits></bug><bug id="488" opendate="2012-09-17 14:47:00" fixdate="2012-09-19 16:35:53"><buginformation><summary>declare parents &amp; @type not matching on annotation properties of enum types</summary><description>NOTE:  real project private git repo demonstrating bug has been shared with Andy Clement privately.  I'm reporting bug as Andy requested with as much info as I feel I can.

I have a case where 'declare parents' and 'declare @type' instructions are not being applied because their type patterns, which use annotations whose properties are of enumerated types, are not matching.

Below find the relevant artifacts and their shapes.  The lines in the aspect PersistableJpaAspect that are not matching as they should are the 'declare parents' and 'declare @type'.  If I change the annotation properties to be of type String and change the type patterns to use string literals (see "matches" comments in annotation:  StoreType.JPA =&gt; "JPA" and IdType.LONG =&gt; "LONG"), the matching works properly.

enums:
======

public enum StoreType {
	MONGO, JDO, JPA;
}

=====

public enum IdType {
	LONG, STRING;
}

annotation:
===========

public @interface Persistable {

	StoreType in() default StoreType.MONGO; // doesn't match
	// matches: String in() default "MONGO";

	IdType id() default IdType.STRING; // doesn't match
	// matches: String id() default "STRING";
}

aspect:
=======

public abstract privileged aspect PersistableAspect {

	public interface I extends ....trait.interfaces.persistence.Persistable {
		long version();
		void version(long version);
	}

	public interface L extends I {
		Long idLong();
		void idLong(Long id);
	}

	public interface S extends I {
		String idString();
		void idString(String id);
	}
	
	declare @type : I+ : @Configurable;

	// ...
}

=====

public privileged aspect PersistableJpaAspect extends PersistableAspect {

	public interface JL extends L {
	}

	public interface JS extends S {
	}

	declare parents :
        (@Persistable(id = IdType.LONG, in = StoreType.JPA) *)
        implements JL;

	declare parents :
        (@Persistable(id = IdType.STRING, in = StoreType.JPA) *)
        implements JS;

	declare @type : @Persistable(in="JPA") JL+ : @Entity;
	declare @type : @Persistable(in="JPA") JS+ : @Entity;

	// ...
}</description><comments/></buginformation><fixedCommits><commit id="0d69bd3eba361bcfb1ba013466841ee3611b3531" author="default" date="2012-09-19 16:35:53"><file name="org.aspectj.matcher/src/org/aspectj/weaver/StandardAnnotation.java"><method name="hasNameValuePair" returnType="boolean" parameters="String String"/></file><file name="org.aspectj.matcher/src/org/aspectj/weaver/EnumAnnotationValue.java"><method name="stringify" returnType="stringify" parameters=""/></file><file name="org.aspectj.matcher/src/org/aspectj/weaver/patterns/WildAnnotationTypePattern.java"><method name="resolveAnnotationValues" returnType="void" parameters="ResolvedType"/></file></commit></fixedCommits></bug><bug id="489" opendate="2012-09-12 19:05:00" fixdate="2012-09-20 13:38:35"><buginformation><summary>NPE in EclipseTypeMunger.mungeNewMethod()</summary><description>Likely related to:
    302460 NullPointerException in BcelTypeMunger.mungeNewMethod()
Seems to have been fixed there, but seems to still be present in the EclipseTypeMunger.


kerouac:base giuliano$ gradle compileTestJava
The reportsDir property has been deprecated and will be removed in the next version of Gradle. Please use the reporting.baseDir property instead.
:processResources UP-TO-DATE
:compileTestJava
[ant:iajc] /Users/giuliano/baynote/src-dev/ramsay/base/src/test/java/com/baynote/base/BaynoteObjectsTests.java [error] Internal compiler error
[ant:iajc] java.lang.NullPointerException
[ant:iajc] 	at org.aspectj.ajdt.internal.compiler.lookup.EclipseTypeMunger.mungeNewMethod(EclipseTypeMunger.java:143)
[ant:iajc] 	at org.aspectj.ajdt.internal.compiler.lookup.EclipseTypeMunger.munge(EclipseTypeMunger.java:120)
[ant:iajc] 	at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.weaveInterTypeDeclarations(AjLookupEnvironment.java:813)
[ant:iajc] 	at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.weaveInterTypeDeclarations(AjLookupEnvironment.java:652)
[ant:iajc] 	at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.createBinaryTypeFrom(AjLookupEnvironment.java:1398)
[ant:iajc] 	at org.aspectj.org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.createBinaryTypeFrom(LookupEnvironment.java:599)
[ant:iajc] 	at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.accept(Compiler.java:276)
[ant:iajc] 	at org.aspectj.org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.askForType(LookupEnvironment.java:113)
[ant:iajc] 	at org.aspectj.org.eclipse.jdt.internal.compiler.lookup.UnresolvedReferenceBinding.resolve(UnresolvedReferenceBinding.java:49)
[ant:iajc] 	at org.aspectj.org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.resolveType(BinaryTypeBinding.java:99)
[ant:iajc] 	at org.aspectj.org.eclipse.jdt.internal.compiler.lookup.PackageBinding.getTypeOrPackage(PackageBinding.java:167)
[ant:iajc] 	at org.aspectj.org.eclipse.jdt.internal.compiler.lookup.Scope.getTypeOrPackage(Scope.java:2507)
[ant:iajc] 	at org.aspectj.org.eclipse.jdt.internal.compiler.lookup.Scope.getType(Scope.java:2228)
[ant:iajc] 	at org.aspectj.org.eclipse.jdt.internal.compiler.ast.SingleTypeReference.getTypeBinding(SingleTypeReference.java:44)
[ant:iajc] 	at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveType(TypeReference.java:142)
[ant:iajc] 	at org.aspectj.org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.resolve(LocalDeclaration.java:148)
[ant:iajc] 	at org.aspectj.org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:433)
[ant:iajc] 	at org.aspectj.org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:196)
[ant:iajc] 	at org.aspectj.org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:404)
[ant:iajc] 	at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1121)
[ant:iajc] 	at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1200)
[ant:iajc] 	at org.aspectj.org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:366)
[ant:iajc] 	at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:636)
[ant:iajc] 	at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:392)
[ant:iajc] 	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:1021)
[ant:iajc] 	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performBuild(AjBuildManager.java:268)
[ant:iajc] 	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:181)
[ant:iajc] 	at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:112)
[ant:iajc] 	at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:60)
[ant:iajc] 	at org.aspectj.tools.ajc.Main.run(Main.java:371)
[ant:iajc] 	at org.aspectj.tools.ajc.Main.runMain(Main.java:248)
[ant:iajc] 	at org.aspectj.tools.ajc.Main.main(Main.java:84)
[ant:iajc] 
[ant:iajc] (no source information available)
[ant:iajc] ABORT
[ant:iajc] 	
[ant:iajc] Exception thrown from AspectJ 1.6.11
[ant:iajc] 
[ant:iajc] This might be logged as a bug already -- find current bugs at
[ant:iajc]    http://bugs.eclipse.org/bugs/buglist.cgi?product=AspectJ&amp;component=Compiler 
[ant:iajc] 
[ant:iajc] Bugs for exceptions thrown have titles File:line from the top stack, 
[ant:iajc] e.g., "SomeFile.java:243"
[ant:iajc] 
[ant:iajc] If you don't find the exception below in a bug, please add a new bug
[ant:iajc] at  http://bugs.eclipse.org/bugs/enter_bug.cgi?product=AspectJ 
[ant:iajc] To make the bug a priority, please include a test program
[ant:iajc] that can reproduce this exception.
[ant:iajc] 
[ant:iajc] when batch building BuildConfig[null] #Files=5 AopXmls=#0
[ant:iajc] null
[ant:iajc] java.lang.NullPointerException
[ant:iajc] 	at org.aspectj.ajdt.internal.compiler.lookup.EclipseTypeMunger.mungeNewMethod(EclipseTypeMunger.java:143)
[ant:iajc] 	at org.aspectj.ajdt.internal.compiler.lookup.EclipseTypeMunger.munge(EclipseTypeMunger.java:120)
[ant:iajc] 	at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.weaveInterTypeDeclarations(AjLookupEnvironment.java:813)
[ant:iajc] 	at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.weaveInterTypeDeclarations(AjLookupEnvironment.java:652)
[ant:iajc] 	at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.createBinaryTypeFrom(AjLookupEnvironment.java:1398)
[ant:iajc] 	at org.aspectj.org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.createBinaryTypeFrom(LookupEnvironment.java:599)
[ant:iajc] 	at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.accept(Compiler.java:276)
[ant:iajc] 	at org.aspectj.org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.askForType(LookupEnvironment.java:113)
[ant:iajc] 	at org.aspectj.org.eclipse.jdt.internal.compiler.lookup.UnresolvedReferenceBinding.resolve(UnresolvedReferenceBinding.java:49)
[ant:iajc] 	at org.aspectj.org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.resolveType(BinaryTypeBinding.java:99)
[ant:iajc] 	at org.aspectj.org.eclipse.jdt.internal.compiler.lookup.PackageBinding.getTypeOrPackage(PackageBinding.java:167)
[ant:iajc] 	at org.aspectj.org.eclipse.jdt.internal.compiler.lookup.Scope.getTypeOrPackage(Scope.java:2507)
[ant:iajc] 	at org.aspectj.org.eclipse.jdt.internal.compiler.lookup.Scope.getType(Scope.java:2228)
[ant:iajc] 	at org.aspectj.org.eclipse.jdt.internal.compiler.ast.SingleTypeReference.getTypeBinding(SingleTypeReference.java:44)
[ant:iajc] 	at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveType(TypeReference.java:142)
[ant:iajc] 	at org.aspectj.org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.resolve(LocalDeclaration.java:148)
[ant:iajc] 	at org.aspectj.org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:433)
[ant:iajc] 	at org.aspectj.org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:196)
[ant:iajc] 	at org.aspectj.org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:404)
[ant:iajc] 	at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1121)
[ant:iajc] 	at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1200)
[ant:iajc] 	at org.aspectj.org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:366)
[ant:iajc] 	at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:636)
[ant:iajc] 	at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:392)
[ant:iajc] 	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:1021)
[ant:iajc] 	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performBuild(AjBuildManager.java:268)
[ant:iajc] 	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:181)
[ant:iajc] 	at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:112)
[ant:iajc] 	at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:60)
[ant:iajc] 	at org.aspectj.tools.ajc.Main.run(Main.java:371)
[ant:iajc] 	at org.aspectj.tools.ajc.Main.runMain(Main.java:248)
[ant:iajc] 	at org.aspectj.tools.ajc.Main.main(Main.java:84)
[ant:iajc] 
[ant:iajc] Sep 12, 2012 4:03:20 PM org.aspectj.weaver.tools.Jdk14Trace info
[ant:iajc] INFO: Dumping to /Users/giuliano/baynote/src-dev/ramsay/base/./ajcore.20120912.160320.442.txt
[ant:iajc] 
[ant:iajc] 1 fail|abort, 1 error

FAILURE: Build failed with an exception.

* Where:
Script '/Users/giuliano/baynote/src-dev/ramsay/base/aspectJ.gradle' line: 46

* What went wrong:
Execution failed for task ':compileTestJava'.
 &gt; compile errors: 255 

* Try:
Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output.

BUILD FAILED

Total time: 27.316 secs</description><comments/></buginformation><fixedCommits><commit id="b8ebdc33c75aa081ac3bf9b1a45f79e4177467a6" author="default" date="2012-09-20 13:38:35"><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseTypeMunger.java"><method name="mungeNewMethod" returnType="boolean" parameters="SourceTypeBinding"/></file></commit></fixedCommits></bug><bug id="490" opendate="2012-09-20 02:38:00" fixdate="2012-10-01 13:22:37"><buginformation><summary>Weaved aspects mechanism does not take into account modified classes</summary><description>The current caching mechanism assumes that if the same class is encountered then its cached weaved version can be used. However, the mechanism uses only the (fully qualified) class name to identify the class and does not take into account the fact that the class bytes may have changed (e.g., the user re-compiled and re-deployed some changes to the same class).</description><comments/></buginformation><fixedCommits><commit id="9a3cc2bc5c824d252140fb3d1e2e27f2163e6d53" author="default" date="2012-10-01 13:22:37"><file name="weaver/src/org/aspectj/weaver/tools/cache/CacheStatistics.java"><method name="reset" returnType="void" parameters=""/></file><file name="weaver/src/org/aspectj/weaver/tools/cache/CacheBacking.java"><method name="get" returnType="CachedClassEntry" parameters="CachedClassReference"/><method name="put" returnType="void" parameters="CachedClassEntry"/></file><file name="util/src/org/aspectj/util/LangUtil.java"><method name="isEmpty" returnType="boolean" parameters=""/></file><file name="weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java"><method name="initialValue" returnType="Boolean" parameters=""/><method name="acceptResult" returnType="void" parameters="IUnwovenClassFile"/></file><file name="weaver/src/org/aspectj/weaver/tools/cache/CachedClassReference.java"><method name="getClassName" returnType="String" parameters=""/></file><file name="loadtime/src/org/aspectj/weaver/loadtime/WeavingURLClassLoader.java"><method name="acceptClass" returnType="void" parameters="String byte[]"/></file><file name="loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"><method name="acceptClass" returnType="void" parameters="String byte[]"/></file><file name="weaver/src/org/aspectj/weaver/tools/cache/CachedClassEntry.java"><method name="isGenerated" returnType="boolean" parameters=""/><method name="getClassName" returnType="String" parameters=""/><method name="getBytes" returnType="byte[]" parameters=""/><method name="getKey" returnType="String" parameters=""/><method name="isWeaved" returnType="boolean" parameters=""/><method name="isIgnored" returnType="boolean" parameters=""/></file><file name="org.aspectj.matcher/src/org/aspectj/weaver/tools/GeneratedClassHandler.java"><method name="acceptClass" returnType="void" parameters="String byte[]"/></file><file name="weaver/src/org/aspectj/weaver/tools/cache/DefaultCacheFactory.java"><method name="createBacking" returnType="CacheBacking" parameters="String"/></file></commit></fixedCommits></bug><bug id="491" opendate="2012-11-13 18:48:00" fixdate="2012-11-14 15:41:57"><buginformation><summary>Invalid StackMapTable generated in Java 7</summary><description>When compiling for Java 7, AspectJ can compute an invalid StackMapTable. The verifier will throw a ClassNotFoundException when the generated class is loaded.

Example:
class Parent&lt;T&gt; {}
class ChildA&lt;T&gt; extends Parent&lt;T&gt; {}
class ChildB&lt;T&gt; extends Parent&lt;T&gt; {}

public Object methodWithBadStackMapTable(boolean value) {
	return value ? new ChildA&lt;String&gt;() : new ChildB&lt;String&gt;();
}

javap shows the computed StackMapTable to be:
StackMapTable: number_of_entries = 2
   frame_type = 15 /* same */
   frame_type = 71 /* same_locals_1_stack_item */
  stack = [ class "Parent&lt;T&gt;" ]

when it should be:
StackMapTable: number_of_entries = 2
   frame_type = 15 /* same */
   frame_type = 71 /* same_locals_1_stack_item */
  stack = [ class Parent ]</description><comments/></buginformation><fixedCommits><commit id="fc554310bc0268244c001a421d2868d14cb45fb1" author="default" date="2012-11-14 15:41:57"><file name="weaver/src/org/aspectj/weaver/bcel/asm/StackMapAdder.java"><method name="getCommonSuperClass" returnType="String" parameters="String String"/></file></commit></fixedCommits></bug><bug id="492" opendate="2012-11-27 17:34:00" fixdate="2012-11-27 14:52:33"><buginformation><summary>weird error about unbound formals when mixing generics with annotation style</summary><description>From the mailing list:

I have following problem with following Aspect:

@Aspect
public class CounterAspect extends AbstractMoskitoAspect {

	@Around(value = "execution(* *(..)) &amp;&amp; (@annotation(method))")
    public Object countMethod(ProceedingJoinPoint pjp, Count method) throws Throwable {
    	return count(pjp, method.producerId(), method.subsystem(), method.category());
    }

	@Around(value = "execution(* *(..)) &amp;&amp; (@annotation(method))")
	public Object countByParameter(ProceedingJoinPoint pjp, CountByParameter method) throws Throwable {
		return countByParameter(pjp, method.producerId(), method.subsystem(), method.category());
	}

	@Around(value = "execution(* *.*(..)) &amp;&amp; (@within(clazz))")
    public Object countClass(ProceedingJoinPoint pjp, Count clazz) throws Throwable {
    	return count(pjp, clazz.producerId(), clazz.subsystem(), clazz.category());
    }

	private Object countByParameter(ProceedingJoinPoint pjp, String aProducerId, String aSubsystem, String aCategory) throws Throwable {
....

It works. However, since I have two similar aspects that differ only in using some internal classes, I made my super class using generics:
public class AbstractMoskitoAspect&lt;S extends IStats&gt; {

@Aspect
public class CounterAspect extends AbstractMoskitoAspect&lt;CounterStats&gt; {

this breaks the build instantly with the very unhelpful error message:
[ERROR] Failed to execute goal org.codehaus.mojo:aspectj-maven-plugin:1.4:compile (default) on project moskito-aop: Compiler errors:
[ERROR] error at @Around(value = "execution(* *(..)) &amp;&amp; (@annotation(method))")
[ERROR] ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
[ERROR] /Users/another/projects/moskito/moskito-aop/java/net/anotheria/moskito/aop/aspect/CounterAspect.java:24:0::0 the parameter pjp is not bound in [all branches of] pointcut
[ERROR] error at @Around(value = "execution(* *(..)) &amp;&amp; (@annotation(method))")
[ERROR] ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
[ERROR] /Users/another/projects/moskito/moskito-aop/java/net/anotheria/moskito/aop/aspect/CounterAspect.java:29:0::0 the parameter pjp is not bound in [all branches of] pointcut
[ERROR] error at @Around(value = "execution(* *.*(..)) &amp;&amp; (@within(clazz))")
[ERROR] ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
[ERROR] /Users/another/projects/moskito/moskito-aop/java/net/anotheria/moskito/aop/aspect/CounterAspect.java:34:0::0 the parameter pjp is not bound in [all branches of] pointcut

what am i doing wrong here?</description><comments/></buginformation><fixedCommits><commit id="3e5af0fdccbe49653ddd59f05e14e33c177c5fc4" author="default" date="2012-11-27 14:52:33"><file name="org.aspectj.matcher/src/org/aspectj/weaver/patterns/AndPointcut.java"><method name="parameterizeWith" returnType="Pointcut" parameters="Map World"/><method name="concretize1" returnType="Pointcut" parameters="ResolvedType ResolvedType"/></file></commit></fixedCommits></bug><bug id="493" opendate="2013-01-20 01:42:00" fixdate="2013-01-21 10:46:15"><buginformation><summary>Using aspect 'requires' clause causes all aspects with 'requires' clauses not be loaded regardless</summary><description>The usage of the 'requires' clause causes all aspects that have have 'requires' clauses not to be loaded regardless of whether the specified required class exists or not. Here is the scenario and why it happens:

   Let's assume we have a bunch of aspects (A1, A2, A3, etc.) - all with 'requires' clauses and all referencing classes that can be satisfied. ClassLoaderWeavingAdaptor#registerAspects goes over the aspects in a Definition one by one. It reaches aspect A1 and detects that it has a 'requires' clause, and so it invokes BcelWorld#addAspectRequires. This causes the aspect A1 and its required class to be registered in an internal 'aspectRequiredTypes' map.

   Then the code calls BcelWeaver#addLibraryAspect with A1 as the argument, which in turn calls addOrReplaceAspect which invokes 'hasUnsatisfiedDependency'. The 'hasUnsatisfiedDependency' has been written to run only ONCE - i.e., it checks if it has already run, and if so then it does nothing. Otherwise, it removes from the 'aspectRequiredTypes' map all the types that can be resolved, thus leaving only those that cannot be resolved. In other words, it assumes that after having run (once !!!) any remaining type must be unsatified. Thus, when it is invoked with A1, being the 1st time, it resolves the required type by A1 and leaves the 'aspectRequiredTypes' map empty - but also marks that no further running is required.

   When the ClassLoaderWeavingAdaptor#registerAspects loop reaches A2, it call BcelWorld#addAspectRequires since A2 also declares a 'requires' clause. This causes A2 and its referenced class to be mapped in the 'aspectRequiredTypes' map. However, when BcelWeaver#addLibraryAspect is called with A2 and the code reaches 'hasUnsatisfiedDependency' - the code assumes that it has already run (which it has - with A1), so it does not check if indeed A2's referenced class can be satisfied (which we assume it can). In other words, all subsequent aspects (A2, A3, etc.) are declared as having unsatisified dependencies - which they don't.

   The (quick) bugfix seems rather simple: every time BcelWorld#addAspectRequires method is called, it should mark 'aspectRequiredTypesProcessed' as FALSE, in order to force a re-evaluation in case 'hasUnsatisfiedDependency' is called.</description><comments/></buginformation><fixedCommits><commit id="96ebaaed65fe5d507cae3d56126d76f217a9f13a" author="default" date="2013-01-21 10:46:15"><file name="weaver/src/org/aspectj/weaver/bcel/BcelWorld.java"><method name="addAspectRequires" returnType="void" parameters="String String"/><method name="hasUnsatisfiedDependency" returnType="boolean" parameters="ResolvedType"/></file><file name="tests/src/org/aspectj/systemtest/ajc172/Ajc172Tests.java"><method name="testAnnotationValueError_pr389752_2" returnType="void" parameters=""/></file></commit></fixedCommits></bug><bug id="494" opendate="2013-01-29 12:01:00" fixdate="2013-01-29 09:20:10"><buginformation><summary>NPE in ExactAnnotationTypePattern.matches</summary><description>[ERROR] java.lang.NullPointerException
[ERROR] at org.aspectj.weaver.patterns.ExactAnnotationTypePattern.matches(ExactAnnotationTypePattern.java:137)
[ERROR] at org.aspectj.weaver.patterns.ExactAnnotationTypePattern.matches(ExactAnnotationTypePattern.java:96)
[ERROR] at org.aspectj.weaver.patterns.AnyWithAnnotationTypePattern.matchesExactly(AnyWithAnnotationTypePattern.java:55)
[ERROR] at org.aspectj.weaver.patterns.TypePattern.matchesStatically(TypePattern.java:132)
[ERROR] at org.aspectj.weaver.patterns.DeclareParents.match(DeclareParents.java:63)
[ERROR] at org.aspectj.weaver.patterns.DeclareParents.findMatchingNewParents(DeclareParents.java:358)
[ERROR] at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.doDeclareParents(AjLookupEnvironment.java:885)
[ERROR] at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.weaveInterTypeDeclarations(AjLookupEnvironment.java:766)
[ERROR] at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.weaveIntertypes(AjLookupEnvironment.java:424)
[ERROR] at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.weaveIntertypes(AjLookupEnvironment.java:410)
[ERROR] at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.completeTypeBindings(AjLookupEnvironment.java:261)</description><comments/></buginformation><fixedCommits><commit id="d524403d64f7d5d8f84ddb3e91afa4e3b91fd958" author="default" date="2013-01-29 09:20:10"><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseSourceType.java"><method name="getAnnotations" returnType="AnnotationAJ[]" parameters=""/></file></commit></fixedCommits></bug><bug id="495" opendate="2013-01-31 04:17:00" fixdate="2013-02-04 13:33:26"><buginformation><summary>Bad generics signature generated</summary><description>Please see  http://jira.springsource.org/browse/SPR-5949 .  The bug ID  https://bugs.eclipse.org/bugs/show_bug.cgi?id=284297  was raised for this issue and fixed in version 1.6.6.  We were using AspectJ version 1.7.1 and got hit by this bug today.

During investigation we have found that the problem does not occur with AspectJ versions 1.6.6 - 1.6.8 but it resurfaces with version 1.6.9 and can be reproduced all the way up to the current version 1.7.1.</description><comments/></buginformation><fixedCommits><commit id="4af4b1e634c9dbb8af1741aad22a2c3441aa1751" author="default" date="2013-02-04 13:33:26"><file name="org.aspectj.matcher/src/org/aspectj/weaver/BoundedReferenceType.java"><method name="parameterize" returnType="UnresolvedType" parameters="UnresolvedType&gt;"/></file></commit></fixedCommits></bug><bug id="496" opendate="2012-11-18 10:54:00" fixdate="2013-02-05 10:45:03"><buginformation><summary>Java throws OutOfMemory in call to Class.getGenericSuperclass() on woven class</summary><description>Ran AspectJ compiler on this class:

  public class Bug {

    @org.springframework.beans.factory.annotation.Configurable
    public static class ClassA&lt;T extends Interface1 &amp; Interface2&gt; {
    }

    public static class ClassB extends ClassA&lt;ClassB&gt; implements Interface1, Interface2 {
    }

    public interface Interface1 {
    }

    public interface Interface2 {
    }

    public static void main(String[] args) throws Exception {
        System.out.println(ClassB.class.getGenericSuperclass());
    }
  }

Then tried to execute the class' main() method using Java 1.6.0-37 and got OOM:

  Exception in thread "main" java.lang.OutOfMemoryError: Java heap space
    at java.util.Arrays.copyOf(Arrays.java:2760)
    at java.util.Arrays.copyOf(Arrays.java:2734)
    at java.util.ArrayList.ensureCapacity(ArrayList.java:167)
    at java.util.ArrayList.add(ArrayList.java:351)
    at sun.reflect.generics.parser.SignatureParser.parseFormalTypeParameters(SignatureParser.java:190)
    at sun.reflect.generics.parser.SignatureParser.parseZeroOrMoreFormalTypeParameters(SignatureParser.java:177)
    at sun.reflect.generics.parser.SignatureParser.parseClassSignature(SignatureParser.java:171)
    at sun.reflect.generics.parser.SignatureParser.parseClassSig(SignatureParser.java:126)
    at sun.reflect.generics.repository.ClassRepository.parse(ClassRepository.java:34)
    at sun.reflect.generics.repository.ClassRepository.parse(ClassRepository.java:23)
    at sun.reflect.generics.repository.AbstractRepository.&lt;init&gt;(AbstractRepository.java:56)
    at sun.reflect.generics.repository.GenericDeclRepository.&lt;init&gt;(GenericDeclRepository.java:30)
    at sun.reflect.generics.repository.ClassRepository.&lt;init&gt;(ClassRepository.java:30)
    at sun.reflect.generics.repository.ClassRepository.make(ClassRepository.java:47)
    at java.lang.Class.getGenericInfo(Class.java:2254)
    at java.lang.Class.getTypeParameters(Class.java:621)
    at sun.reflect.generics.reflectiveObjects.ParameterizedTypeImpl.validateConstructorArguments(ParameterizedTypeImpl.java:39)
    at sun.reflect.generics.reflectiveObjects.ParameterizedTypeImpl.&lt;init&gt;(ParameterizedTypeImpl.java:35)
    at sun.reflect.generics.reflectiveObjects.ParameterizedTypeImpl.make(ParameterizedTypeImpl.java:77)
    at sun.reflect.generics.factory.CoreReflectionFactory.makeParameterizedType(CoreReflectionFactory.java:86)
    at sun.reflect.generics.visitor.Reifier.visitClassTypeSignature(Reifier.java:122)
    at sun.reflect.generics.tree.ClassTypeSignature.accept(ClassTypeSignature.java:31)
    at sun.reflect.generics.repository.ClassRepository.getSuperclass(ClassRepository.java:66)
    at java.lang.Class.getGenericSuperclass(Class.java:677)
    at Bug.main(Bug.java:18)

Using JDK 1.7 we get a java.lang.reflect.GenericSignatureFormatError instead.

Users mailing list discussion thread:

   http://dev.eclipse.org/mhonarc/lists/aspectj-users/msg13789.html 

This bug may be related to  Bug #360253 .

Reproducible test case will be attached.</description><comments/></buginformation><fixedCommits><commit id="46f90792c01a4333eb62bc2ea6a1dcfb3efb0d23" author="default" date="2013-02-05 10:45:03"><file name="org.aspectj.matcher/src/org/aspectj/weaver/TypeVariable.java"><method name="getSignatureForAttribute" returnType="String" parameters=""/><method name="getSignature" returnType="String" parameters=""/></file><file name="tests/src/org/aspectj/systemtest/ajc172/Ajc172Tests.java"><method name="testPSignatures_pr399590_2" returnType="void" parameters=""/><method name="testPSignatures_pr399590_3" returnType="void" parameters=""/><method name="testPSignatures_pr399590_4" returnType="void" parameters=""/><method name="testPSignatures_pr399590" returnType="void" parameters=""/><method name="testPSignatures_pr399590_5" returnType="void" parameters=""/></file></commit></fixedCommits></bug><bug id="497" opendate="2012-10-09 00:09:00" fixdate="2013-02-05 11:14:40"><buginformation><summary>WildAnnotationTypePattern.java:231</summary><description>OK, I get that this is not supported (and what I *want* here is matching on the existence of the supplied header *among* the headers in the String[]). A feature request might be in order, but a syntax for specifying how you want to match the array would be needed....

The bug that I'm reporting is that trying to *save* this program gets an error that pops up a dialog. This should just become another error marker.

It might the compiler that has to change what it throws, but in the end it's the Eclipse IDE that ends up breaking from a user standpoint.

(RequestMapping.headers() is of type String[]).

public aspect Fail {
    pointcut testable(): execution(public * @RequestMapping(headers="x-test=test") com.example..*(..));
}

java.lang.RuntimeException
at org.aspectj.weaver.patterns.WildAnnotationTypePattern.resolveAnnotationValues(WildAnnotationTypePattern.java:231)
at org.aspectj.weaver.patterns.WildAnnotationTypePattern.resolveBindings(WildAnnotationTypePattern.java:325)
at org.aspectj.weaver.patterns.WildTypePattern.resolveBindings(WildTypePattern.java:657)
at org.aspectj.weaver.patterns.SignaturePattern.resolveBindings(SignaturePattern.java:81)
at org.a ... n(Worker.java:53)

Compile error: RuntimeException thrown: Compiler limitation: annotation value support not implemented for type java.lang.String[]</description><comments/></buginformation><fixedCommits><commit id="edb41e385f232f7aebe1f6517d9a201221175a55" author="default" date="2013-02-05 11:14:40"><file name="org.aspectj.matcher/src/org/aspectj/weaver/patterns/WildAnnotationTypePattern.java"><method name="resolveAnnotationValues" returnType="void" parameters="ResolvedType"/></file></commit></fixedCommits></bug><bug id="498" opendate="2010-07-05 07:23:00" fixdate="2013-02-25 15:18:12"><buginformation><summary>Pertarget aspect instantiation is not thread-safe</summary><description>The way in which pertarget aspects compiled with ajc check if a given target already has an aspect is not thread safe. When two different threads trigger an advice on a target object for the first time at the same time, sometimes the aspect for that target gets created twice.

The following code demonstrates the problem:

The following pertarget aspect will add itself to a (synchronized) set in another class in it's constructor.

aspect Pertarget pertarget(execution(void foo())) {
        public Pertarget() {
                Main.aspects.add(this); // Add this instance to the set in Main
        }
        before(): execution(void foo()) {} // Empty advice to trigger creation
}

This class creates 10000 target objects and has two separate threads call a method (that causes the aspect to be instantiated) on each object. The aspects add themselves to the "aspects" set and this set's size is printed when all threads have finished.

import java.util.Collections;
import java.util.IdentityHashMap;
import java.util.Set;

public class Main {
    public static Set aspects = Collections.synchronizedSet(
        Collections.newSetFromMap(new IdentityHashMap()));
    public static void main(String[] args) throws InterruptedException {
        for (int i = 0; i &lt; 10000; ++i) {
            final Main m = new Main(); // Create a new target for the aspect
            Runnable r = new Runnable() {
                public void run() { m.foo(); } // This will trigger the advice
            };
            Thread t1 = new Thread(r);
            Thread t2 = new Thread(r);
            t1.start();
            t2.start();
            t1.join();
            t2.join();
        }
        System.out.println(aspects.size()); // Should be 10000
    }
    private void foo() {}
}

When compiled with ajc and run, the main method prints values over 10000 (something like 10030-10060 typically), which means that some target objects get multiple aspect instances.

In my own application I sometimes also saw some threads accessing partially built aspect instances. This was quite rare however and I wasn't able to make a test case for it.

The ajc version (the current stable) used was:
AspectJ Compiler 1.6.8 (1.6.8 - Built: Friday Jan 8, 2010 at 21:53:37 GMT) - Eclipse Compiler 0.785_R33x, 3.3

The sun vm version was:
Java(TM) SE Runtime Environment (build 1.6.0_20-b02)
Java HotSpot(TM) 64-Bit Server VM (build 16.3-b01, mixed mode)

I investigated the source of this problem: the ajc compiler generates the following (decompiled) method into the aspect class:

public static void ajc$perObjectBind(Object obj)
{
    if((obj instanceof ajcMightHaveAspect) &amp;&amp; ((ajcMightHaveAspect)obj).perObjectGet() == null)
        ((ajcMightHaveAspect)obj).perObjectSet(new Pertarget());
}

, which obviously is not thread safe.</description><comments/></buginformation><fixedCommits><commit id="be5a53001fda264fc8fdebe7d2b64c20e748e51c" author="default" date="2013-02-25 15:18:12"><file name="org.aspectj.matcher/src/org/aspectj/weaver/AjcMemberMaker.java"><method name="perObjectBind" returnType="ResolvedMember" parameters="UnresolvedType"/></file></commit></fixedCommits></bug><bug id="499" opendate="2013-03-28 16:53:00" fixdate="2013-04-01 15:29:13"><buginformation><summary>Assertion failed at ResolvedType.java:614</summary><description>Created  attachment 229171   [details] 
Sample Maven project

Stacktrace:
java.lang.AssertionError
  at org.aspectj.weaver.ResolvedType.lookupResolvedMember(ResolvedType.java:614)
  at org.aspectj.weaver.JoinPointSignatureIterator.findSignaturesFromSupertypes(JoinPointSignatureIterator.java:192)
  at org.aspectj.weaver.JoinPointSignatureIterator.hasNext(JoinPointSignatureIterator.java:68)
  at org.aspectj.weaver.patterns.SignaturePattern.matches(SignaturePattern.java:317)
  at org.aspectj.weaver.patterns.KindedPointcut.matchInternal(KindedPointcut.java:202)
  at org.aspectj.weaver.patterns.Pointcut.match(Pointcut.java:137)
  at org.aspectj.weaver.patterns.AndPointcut.matchInternal(AndPointcut.java:51)
  at org.aspectj.weaver.patterns.Pointcut.match(Pointcut.java:137)
  at org.aspectj.weaver.patterns.OrPointcut.matchInternal(OrPointcut.java:50)
  at org.aspectj.weaver.patterns.Pointcut.match(Pointcut.java:137)
  at org.aspectj.weaver.patterns.OrPointcut.matchInternal(OrPointcut.java:50)
  at org.aspectj.weaver.patterns.Pointcut.match(Pointcut.java:137)
  at org.aspectj.weaver.patterns.OrPointcut.matchInternal(OrPointcut.java:50)
  at org.aspectj.weaver.patterns.Pointcut.match(Pointcut.java:137)
  at org.aspectj.weaver.ShadowMunger.match(ShadowMunger.java:113)
  at org.aspectj.weaver.Advice.match(Advice.java:109)
  at org.aspectj.weaver.bcel.BcelAdvice.match(BcelAdvice.java:149)
  at org.aspectj.weaver.bcel.BcelClassWeaver.match(BcelClassWeaver.java:3167)
  at org.aspectj.weaver.bcel.BcelClassWeaver.matchInvokeInstruction(BcelClassWeaver.java:3115)
  at org.aspectj.weaver.bcel.BcelClassWeaver.match(BcelClassWeaver.java:2773)
  at org.aspectj.weaver.bcel.BcelClassWeaver.match(BcelClassWeaver.java:2553)
  at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:480)
  at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:99)
  at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1691)
  at org.aspectj.weaver.bcel.BcelWeaver.weaveWithoutDump(BcelWeaver.java:1635)
  at org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify(BcelWeaver.java:1400)
  at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1186)
  at org.aspectj.ajdt.internal.compiler.AjPipeliningCompilerAdapter.weaveQueuedEntries(AjPipeliningCompilerAdapter.java:514)
  at org.aspectj.ajdt.internal.compiler.AjPipeliningCompilerAdapter.queueForWeaving(AjPipeliningCompilerAdapter.java:447)
  at org.aspectj.ajdt.internal.compiler.AjPipeliningCompilerAdapter.afterProcessing(AjPipeliningCompilerAdapter.java:432)
  at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$after$org_aspectj_ajdt_internal_compiler_CompilerAdapter$5$6b855184(CompilerAdapter.aj:98)
  at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:805)
  at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:468)
  at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:1028)
  at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performBuild(AjBuildManager.java:272)
  at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:185)
  at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:112)
  at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:60)
  at org.aspectj.tools.ajc.Main.run(Main.java:371)
  at org.aspectj.tools.ajc.Main.runMain(Main.java:248)
  ...

Sample Maven project attached. It fails on test-compile phase, and assertions should be enabled: "MAVEN_OPTS=-ea mvn test-compile".</description><comments/></buginformation><fixedCommits><commit id="4e34477ab6aa6701b93f0f331f2c6874e70b424f" author="default" date="2013-04-01 15:29:13"><file name="org.aspectj.matcher/src/org/aspectj/weaver/ResolvedType.java"><method name="lookupResolvedMember" returnType="ResolvedMember" parameters="ResolvedMember"/></file></commit></fixedCommits></bug><bug id="500" opendate="2013-03-29 00:48:00" fixdate="2013-04-02 12:26:57"><buginformation><summary>Unhandled RuntimeException</summary><description>I'm getting an unhandled RuntimeException from STS 3.2.0.RELEASE:

java.lang.RuntimeException
at org.aspectj.asm.AsmManager.sameType(AsmManager.java:897)
at org.aspectj.asm.AsmManager.removeRelationshipsTargettingThisType(AsmManager.java:711)
at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1033)
at org.aspectj.ajdt.internal.compiler.AjPipeliningCompilerAdapter.weaveQueuedEntries(AjPipeliningCompilerAdapter.java:514)
at org.aspectj.ajdt.internal.compiler.AjPipeliningCompilerAdapter.queueForWeavin ... ndation-domain/src\/main\/java&lt;com.scispike.foundation.domain.trait.persistence*PersistableAspect.aj%com.scispike.foundation.domain.trait.persistence)

Andy Clement, this can be reproduced in our private foundation repo's dev branch at commit d879446f2bfd83b51bf711d2931f4b28ce8c1901.

After clicking ok on the exception dialog, there is an error marker on the package statement with text:

Internal compiler error: java.lang.RuntimeException: Exception whilst walking up from target com.scispike.foundation.domain.trait.persistence kind=(package declaration) 
 hid=(=foundation-domain/src\/main\/java&lt;com.scispike.foundation.domain.trait.persistence*PersistableAspect.aj%com.scispike.foundation.domain.trait.persistence) at 
 org.aspectj.asm.AsmManager.sameType(AsmManager.java:897)

If I do a Project\Clean..., the exception is not reproduced and everything compiles ok.  Next edit repros the exception.</description><comments/></buginformation><fixedCommits><commit id="ff0859d6f529a17c851dd774488ee7b0ca8391d3" author="default" date="2013-04-02 12:26:57"><file name="weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java"><method name="weaveParentTypeMungers" returnType="void" parameters="ResolvedType"/></file></commit></fixedCommits></bug><bug id="501" opendate="2013-05-22 12:10:00" fixdate="2013-06-26 15:08:06"><buginformation><summary>java.util.ConcurrentModificationException when multiple threads enter the weaver</summary><description>I am using AspectJ 1.7.1.  Occasionally I see the following exception, which I believe is related to multiple threads initializing some internal state.

java.util.ConcurrentModificationException: null
       at java.util.ArrayList$Itr.checkForComodification(Unknown Source) ~[na:1.7.0_11]
       at java.util.ArrayList$Itr.next(Unknown Source) ~[na:1.7.0_11]
       at org.aspectj.weaver.ReferenceType.findDerivativeType(ReferenceType.java:1122) ~[aspectjweaver.jar:1.7.1]
       at org.aspectj.weaver.TypeFactory.createParameterizedType(TypeFactory.java:44) ~[aspectjweaver.jar:1.7.1]
       at org.aspectj.weaver.ResolvedType.parameterize(ResolvedType.java:2479) ~[aspectjweaver.jar:1.7.1]
       at org.aspectj.weaver.ReferenceType.getDeclaredInterfaces(ReferenceType.java:673) ~[aspectjweaver.jar:1.7.1]
       at org.aspectj.weaver.ResolvedType.getDirectSupertypes(ResolvedType.java:82) ~[aspectjweaver.jar:1.7.1]
       at org.aspectj.weaver.patterns.TypePattern.matchesSubtypes(TypePattern.java:178) ~[aspectjweaver.jar:1.7.1]
       at org.aspectj.weaver.patterns.ExactTypePattern.matchesSubtypes(ExactTypePattern.java:74) ~[aspectjweaver.jar:1.7.1]
       at org.aspectj.weaver.patterns.TypePattern.matchesStatically(TypePattern.java:130) ~[aspectjweaver.jar:1.7.1]
       at org.aspectj.weaver.patterns.KindedPointcut.fastMatch(KindedPointcut.java:130) ~[aspectjweaver.jar:1.7.1]
       at org.aspectj.weaver.internal.tools.PointcutExpressionImpl.couldMatchJoinPointsInType(PointcutExpressionImpl.java:84) ~[aspectjweaver.jar:1.7.1]
       at org.springframework.aop.aspectj.AspectJExpressionPointcut.matches(AspectJExpressionPointcut.java:250) ~[spring-aop.jar:3.2.1.RELEASE]
       at org.springframework.aop.support.AopUtils.canApply(AopUtils.java:208) ~[spring-aop.jar:3.2.1.RELEASE]
       at org.springframework.aop.support.AopUtils.canApply(AopUtils.java:262) ~[spring-aop.jar:3.2.1.RELEASE]
       at org.springframework.aop.support.AopUtils.findAdvisorsThatCanApply(AopUtils.java:294) ~[spring-aop.jar:3.2.1.RELEASE]
       at org.springframework.aop.framework.autoproxy.AbstractAdvisorAutoProxyCreator.findAdvisorsThatCanApply(AbstractAdvisorAutoProxyCreator.java:118) ~[spring-aop.jar:3.2.1.RELEASE]</description><comments/></buginformation><fixedCommits><commit id="3f6e16677d20489a6390dde825608e0d2e29f5d7" author="default" date="2013-06-26 15:08:06"><file name="org.aspectj.matcher/src/org/aspectj/weaver/ReferenceType.java"><method name="findDerivativeType" returnType="ReferenceType" parameters="ResolvedType[]"/><method name="setDelegate" returnType="void" parameters="ReferenceTypeDelegate"/><method name="checkDuplicates" returnType="void" parameters="ReferenceType"/><method name="addParent" returnType="void" parameters="ResolvedType"/></file></commit></fixedCommits></bug><bug id="502" opendate="2013-05-01 15:10:00" fixdate="2013-06-28 16:30:34"><buginformation><summary>Stack trace being printed, but want to mute it</summary><description>In org.aspectj.ajdt.internal.core.builder.AjState.getDelegate(ReferenceType), there is a call to printStackTrace().  On the AJDT build server, this exception is being printed and causing some noise.  Can you replace that call with a call to the IMessageHandler for the build?</description><comments/></buginformation><fixedCommits><commit id="e6cb5086ad825e8df5f182aa0c5586b0b4af9d21" author="default" date="2013-06-28 16:30:34"><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java"><method name="getDelegate" returnType="ReferenceTypeDelegate" parameters="ReferenceType"/></file></commit></fixedCommits></bug><bug id="503" opendate="2013-07-20 02:22:00" fixdate="2013-07-22 14:50:14"><buginformation><summary>A constructor added by ITD cannot invoke the method of its super class</summary><description>AspectJ Development Tools	2.2.0.e37x-RELEASE-20120704-0900





It seems *super.someMethod()* can not be correctly resolved in the
constructor added by ITD 

It can be compiled with no problem, but* at runtime, exception is raised.*


The class which I'll add a new constructor to:

public class Child extends Parent{

    public String mParent = "John";
    
    public Child(String parent) {
        this.mParent = parent;
    }
    
    public String getParent()
    {
        return this.mParent;
    }
}

As we can see, *Child * extends *Parent*

class Parent has a method getAge()

public class Parent {
    private String mName = "John";
    private int mAge = 50;
    
    public int getAge(){
        return mAge;
    }
}

If I add a new constructor for the *Child * in my aspect.

public aspect MyTest {

    public Child.new(String parent, int age) {
        this(parent);
        
        System.out.println("Get Age:" + super.getAge());
        System.out.println("Child Name:" + this.mParent);
    }
}

The above aspect code will trigger an exception.

Exception in thread "main" java.lang.NoSuchMethodError: com.test.Child.ajc$superDispatch$com_test_Child$getAge()I
	at MyTest.ajc$postInterConstructor$MyTest$com_test_Child(MyTest.aj:13)
	at com.test.Child.&lt;init&gt;(Child.java:1)
	at MainProgram.main(MainProgram.java:14)

Is this a limitation of AspectJ? Is this the only way to resolve this
issue?


I also attach the src &amp; compiled binary files</description><comments/></buginformation><fixedCommits><commit id="302c14ee680d5782cba619d8cc748e60afd09561" author="default" date="2013-07-22 14:50:14"><file name="weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java"><method name="mungeNewConstructor" returnType="boolean" parameters="BcelClassWeaver"/><method name="addNeededSuperCallMethods" returnType="void" parameters="BcelClassWeaver ResolvedType Set&lt;ResolvedMember&gt;"/></file><file name="tests/src/org/aspectj/systemtest/AllTests17.java"><method name="suite" returnType="Test" parameters=""/></file></commit></fixedCommits></bug><bug id="504" opendate="2012-01-06 12:05:00" fixdate="2013-07-29 22:25:23"><buginformation><summary>configure a set of classloader for which weavers should not be created in an LTW scenario</summary><description>Prototyped and tested for JspClassLoaders (see the thread 'aspectj and jsp load' on the mailing list).

That was done through a system property but it would be easier via aop.xml.  However, this would be the first time we have an aop.xml setting that affects global operation of loadtime weaving.  When any classloader actually got far enough to load the aop.xmls it would discover this setting and from that point on it would be set.  In our JspClassLoader case this would mean that either some non-JspClassLoader is run early enough to discover this setting and turn it off for all JspClassLoaders or the first JspClassLoader will discover the setting and turn it off for all other JspClassLoaders.  I think we can live with that mode of operation.</description><comments/></buginformation><fixedCommits><commit id="0c0adc560d413ad0ec2a6dcd076e3ab292d12806" author="default" date="2013-07-29 22:25:23"><file name="tests/src/org/aspectj/systemtest/ajc174/Ajc174Tests.java"><method name="testSuperItdCtor_413378" returnType="void" parameters=""/></file><file name="loadtime/src/org/aspectj/weaver/loadtime/Options.java"><method name="parse" returnType="WeaverOption" parameters="String ClassLoader"/></file><file name="loadtime/src/org/aspectj/weaver/loadtime/Aj.java"><method name="checkQ" returnType="void" parameters=""/><method name="preProcess" returnType="byte[]" parameters="String byte[] ClassLoader ProtectionDomain"/></file><file name="loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"><method name="registerOptions" returnType="void" parameters="BcelWeaver ClassLoader"/></file></commit></fixedCommits></bug><bug id="505" opendate="2013-09-26 14:31:00" fixdate="2013-10-01 10:00:14"><buginformation><summary>Can't introduce annotation onto introduced method from trait-patterned aspect</summary><description>Created  attachment 235865   [details] 
eclipse AspectJ testcase

An aspect is introducing a field and a method.  Introducing an annotation onto the introduced field works fine; introducing an annotation onto the introduced **method** fails with the message "The method '...' does not exist" (where '...' is the method pattern).

Aspect follows trait pattern:

public interface Behavior { String hello(); }

=====

@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface Behaved {}

=====

public aspect Trait {

	public interface I extends Behavior {}
	
	declare parents: @Behaved * implements I;
	
	private String I.name = getClass().getName();
	
	public String I.hello() {
		return "hello" + name;
	}
}

=====

@Behaved
public class Target {
	public static aspect A {
		declare @field: * Target.name: @Tagged; // WORKY
		declare @method: * Target.hello(..): @Tagged; // NO WORKY
	}
}

=====

@Target({ ElementType.TYPE, ElementType.METHOD, ElementType.FIELD,
		ElementType.CONSTRUCTOR })
@Retention(RetentionPolicy.RUNTIME)
public @interface Tagged {}

Test eclipse AspectJ project attached.</description><comments/></buginformation><fixedCommits><commit id="2393befbdf0ef3842b838591f7af08e7d1467e34" author="default" date="2013-10-01 10:00:14"><file name="weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"><method name="weaveDeclareAtField" returnType="boolean" parameters="LazyClassGen"/><method name="weaveDeclareAtMethodCtor" returnType="boolean" parameters="LazyClassGen"/><method name="weave" returnType="boolean" parameters=""/><method name="doesAlreadyHaveAnnotation" returnType="boolean" parameters="ResolvedMember DeclareAnnotation List&lt;Integer&gt;"/></file></commit></fixedCommits></bug><bug id="506" opendate="2013-08-16 17:51:00" fixdate="2013-10-01 10:08:31"><buginformation><summary>LTW not working when JMX is enabled</summary><description>When I enable JMX remote management on a JVM along with AspectJ load-time weaving (LTW), our Aspect doesn't appear to get woven in.

This are the JVM arguments:

-Dvisualvm.display.name=JdbcTimingAspectTest -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.port=1024 -javaagent:/jars/aspectjweaver.jar -Dorg.aspectj.weaver.loadtime.configuration=com/trgr/cobalt/infrastructure/instrumentation/aspects/timing/jdbc/jdbcmonitor.xml

Note that if I don't enable JMX remote management (by remove the -Dcom.sun.management.jmxremote.* JVM arguments), the Aspect works fine.</description><comments/></buginformation><fixedCommits><commit id="9e992d6e5e2809afdc18ee4ce4e3bc42b9883e00" author="default" date="2013-10-01 10:08:31"><file name="loadtime/src/org/aspectj/weaver/loadtime/Aj.java"><method name="getWeaver" returnType="WeavingAdaptor" parameters="ClassLoader"/></file></commit></fixedCommits></bug><bug id="507" opendate="2013-10-11 15:20:00" fixdate="2013-10-23 12:44:23"><buginformation><summary>ajc option to change -Xlint level per-message without Xlintfile</summary><description>The -Xlintfile option is not a great fit for controlling message across multiple build projects, specifically in my case from the pluginManagement section of a maven parent pom. The problem is that you need a local file to configure the per-message output levels (ignore/warning/error) when you really want to specify it in the build script or in a shared file.

As an alternative to -Xlintfile, it would be handy to be able to change an Xlint warning level per message using command line options.

For example:

ajc -Xlint:adviceDidNotMatch=ignore

would override the XlintDefault.properties file for the adviceDidNotMatch message.

With Regards
Rob</description><comments/></buginformation><fixedCommits><commit id="b2cd5fa175facc39bd0d1af5a4646b9b39c8bcda" author="default" date="2013-10-23 12:44:23"><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.java"><method name="setLintMode" returnType="void" parameters="String"/></file><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"><method name="initBcelWorld" returnType="void" parameters="IMessageHandler"/></file><file name="testing/newsrc/org/aspectj/testing/CompileSpec.java"><method name="setXlintfile" returnType="void" parameters="String"/></file></commit></fixedCommits></bug><bug id="508" opendate="2013-10-23 16:00:00" fixdate="2013-10-23 13:16:20"><buginformation><summary>Support additional message insert keys in declare error/warning</summary><description>It would be good to be able to insert the enclosing class name or enclosing member for a joinpoint.</description><comments/></buginformation><fixedCommits><commit id="9319e343d54a65bcfc4a8c19e4305147ce9e27b8" author="default" date="2013-10-23 13:16:20"><file name="org.aspectj.matcher/src/org/aspectj/weaver/Checker.java"><method name="getValue" returnType="String" parameters="String Shadow"/></file></commit></fixedCommits></bug><bug id="509" opendate="2013-12-04 19:43:00" fixdate="2013-12-06 10:33:48"><buginformation><summary>LTW - java.lang.VerifyError: Bad return type with generics and local variables</summary><description>This code:



package com.foo.bar;

public class Test {

    abstract class X&lt;T&gt; {}

    class X1 extends X&lt;Integer&gt; {}

    class X2 extends X&lt;String&gt; {}

    public Test foo() {
        return this;
    }

    public &lt;T&gt; X&lt;T&gt; createMessage(int n) {
        X x;
        if (n == 0) {
            x = new X1();
        } else {
            x = new X2();
        }
        return x;
    }
}



produces:


java.lang.VerifyError: Bad return type in method com.foo.bar.Test.createMessage(I)Lcom/foo/bar/Test$X; at offset 26
	at com.betfair.marketupdates.Main.start(Main.java:18)
	at org.vertx.java.platform.Verticle.start(Verticle.java:82)
	at org.vertx.java.platform.impl.DefaultPlatformManager$19.run(DefaultPlatformManager.java:1551)
	at org.vertx.java.core.impl.DefaultContext$3.run(DefaultContext.java:176)
	at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:354)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:353)
	at io.netty.util.concurrent.SingleThreadEventExecutor$2.run(SingleThreadEventExecutor.java:101)
	at java.lang.Thread.run(Thread.java:722)




even when the createMessage is not being weaved:



package com.foo.bar;

@Aspect
public class AspectX {
    @Before("execution(* com.foo.bar.Test.foo())")
    public void advice() {
        System.out.println("Hello");
    }
}




The problem lies in the first local variable type as can be seen by analyzing the bytecode (notice the last line):



Before:

  public &lt;T extends java/lang/Object&gt; com.foo.bar.Test$X&lt;T&gt; createMessage(int);
    flags: ACC_PUBLIC

    Code:
      stack=3, locals=3, args_size=2
         0: iload_1       
         1: ifne          16
         4: new           #2                  // class com/foo/bar/Test$X1
         7: dup           
         8: aload_0       
         9: invokespecial #3                  // Method com/foo/bar/Test$X1."&lt;init&gt;":(Lcom/foo/bar/Test;)V
        12: astore_2      
        13: goto          25
        16: new           #4                  // class com/foo/bar/Test$X2
        19: dup           
        20: aload_0       
        21: invokespecial #5                  // Method com/foo/bar/Test$X2."&lt;init&gt;":(Lcom/foo/bar/Test;)V
        24: astore_2      
        25: aload_2       
        26: areturn       
      LineNumberTable:
        line 17: 0
        line 18: 4
        line 20: 16
        line 22: 25
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
              13       3     2     x   Lcom/foo/bar/Test$X;
               0      27     0  this   Lcom/foo/bar/Test;
               0      27     1     n   I
              25       2     2     x   Lcom/foo/bar/Test$X;
      StackMapTable: number_of_entries = 2
           frame_type = 16 /* same */
           frame_type = 252 /* append */
             offset_delta = 8
        locals = [ class com/foo/bar/Test$X ]




After:

  public &lt;T extends java/lang/Object&gt; com.foo.bar.Test$X&lt;T&gt; createMessage(int);
    flags: ACC_PUBLIC

    Code:
      stack=3, locals=3, args_size=2
         0: iload_1       
         1: ifne          16
         4: new           #2                  // class com/foo/bar/Test$X1
         7: dup           
         8: aload_0       
         9: invokespecial #3                  // Method com/foo/bar/Test$X1."&lt;init&gt;":(Lcom/foo/bar/Test;)V
        12: astore_2      
        13: goto          25
        16: new           #4                  // class com/foo/bar/Test$X2
        19: dup           
        20: aload_0       
        21: invokespecial #5                  // Method com/foo/bar/Test$X2."&lt;init&gt;":(Lcom/foo/bar/Test;)V
        24: astore_2      
        25: aload_2       
        26: areturn       
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
              13       3     2     x   Lcom/foo/bar/Test$X;
               0      27     0  this   Lcom/foo/bar/Test;
               0      27     1     n   I
              25       2     2     x   Lcom/foo/bar/Test$X;
      LineNumberTable:
        line 17: 0
        line 18: 4
        line 20: 16
        line 22: 25
      StackMapTable: number_of_entries = 2
           frame_type = 16 /* same */
           frame_type = 252 /* append */
             offset_delta = 8
        locals = [ class java/lang/Object ]





Note: This is probably the same bug as  https://bugs.eclipse.org/bugs/show_bug.cgi?id=417041 
Note2: I'm running jdk1.7.0_17</description><comments/></buginformation><fixedCommits><commit id="dd88d21ef6d515bbc7034ca429d392f62101802a" author="default" date="2013-12-06 10:33:48"><file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java"><method name="getDelegate" returnType="ReferenceTypeDelegate" parameters="ReferenceType"/></file><file name="weaver/src/org/aspectj/weaver/bcel/asm/StackMapAdder.java"><method name="getCommonSuperClass" returnType="String" parameters="String String"/></file><file name="tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java"><method name="testAdviceDidNotMatch_pr152589" returnType="void" parameters=""/><method name="testAspectPath_pr249212_c1" returnType="void" parameters=""/><method name="testPr148285" returnType="void" parameters=""/></file><file name="tests/src/org/aspectj/systemtest/AllTests17.java"><method name="suite" returnType="Test" parameters=""/></file></commit></fixedCommits></bug></bugrepository>