<?xml version="1.0" encoding="ISO-8859-1"?>

<bugrepository name="AspectJ">
  <bug id="28974" opendate="2003-1-3 10:28:00" fixdate="2003-1-14 14:30:16">
    <buginformation>
      <summary>"Compiler error when introducing a ""final"" field"</summary>
      <description>The aspect below fails to compile with 1.1b2, producing the compilation error: 
--------------------
$ ajc com/ibm/amc/*.java com/ibm/amc/ejb/*.java
d:/eclipse/runtime-workspace-ajsamples/Mock EJBs/com/ibm/amc/DemoBeanEJB.java:1:
 Cannot assign a value to the final field com.ibm.amc.DemoBean.ajc$interField$co
m_ibm_amc$verbose

!! no source information available !!

1 error
---------------------------


package com.ibm.amc;

import com.ibm.amc.ejb.SessionBean;
/**
 * @author colyer
 *
 * To change this generated comment edit the template variable "typecomment":
 * Window&gt;Preferences&gt;Java&gt;Templates.
 * To enable and disable the creation of type comments go to
 * Window&gt;Preferences&gt;Java&gt;Code Generation.
 */
public aspect DemoBeanEJB {

	declare parents: DemoBean implements SessionBean;
	
        // THIS NEXT LINE IS THE CULPRIT
	static final boolean DemoBean.verbose = true;
	
	private transient String DemoBean.ctx;
	
	public void DemoBean.ejbActivate( ) {
		if ( verbose ) {
			System.out.println( "ejbActivate Called" );	
		}	
	}
}


-------------------
Making the inter-type declaration non-final solves the problem...</description>
      <comments>
		<comment id="1" date="2003-01-03 10:31:40 EST" author="Adrian Colyer">Created attachment 2885 [details]
Mini-project that reproduces the error</comment>
		<comment id="2" date="2003-01-07 21:13:48 EST" author="Jim Hugunin">This seems like it could be reduced to a much smaller minimal test case that
would be easier to add to our test suite.  Can you reproduce this with just 2 
classes an no external dependencies?</comment>
		<comment id="3" date="2003-01-08 04:09:50 EST" author="Adrian Colyer">Created attachment 2918 [details]
Smallest possible test that reproduces the problem

:-). Yes, here's a 5-line program that reproduces the problem.
Thanks, Adrian.</comment>
		<comment id="4" date="2003-01-14 14:30:16 EST" author="Jim Hugunin">fixed cvs tree, testcase in new/finalfield/*

The fix involved a minor change to 
org.aspectj.weaver.AjcMemberMaker.makePublic to makePublicNonFinal

This means that all introduced fields are always implemented with a non-final 
field in the target class.  The compiler's checking rules still operate on the 
inter-type declaration which remains final.  The test case was extended to 
ensure that this checking still works to signal errors when final fields are 
assigned to.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="99a873c3070bea836e8cd4bd33c610fb41efa2c6" author="jhugunin" date="2003-01-15 04:31:02"/>
          <file name="weaver/src/org/aspectj/weaver/AjcMemberMaker.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="28919" opendate="2002-12-30 16:40:00" fixdate="2003-1-14 15:06:00">
    <buginformation>
      <summary>waever tries to weave into native methods ...</summary>
      <description>If you don't find the exception below in a bug, please add a new bug
To make the bug a priority, please include a test program
that can reproduce this exception.
bad non-abstract method with no code: private native int 
nativeMessagePumpInitialize() on public class 
plc.comm.pvi.PviCom$LinkEventHandlerImpl
bad non-abstract method with no code: private native int 
nativeMessagePumpInitialize() on public class 
plc.comm.pvi.PviCom$LinkEventHandlerImpl
java.lang.RuntimeException: bad non-abstract method with no code: private 
native int nativeMessagePumpInitialize() on public class 
plc.comm.pvi.PviCom$LinkEventHandlerImpl
        at org.aspectj.weaver.bcel.LazyMethodGen.&lt;init&gt;(Unknown Source)
        at org.aspectj.weaver.bcel.LazyClassGen.&lt;init&gt;(Unknown Source)
        at org.aspectj.weaver.bcel.BcelObjectType.getLazyClassGen(Unknown Source)
        at org.aspectj.weaver.bcel.BcelWeaver.weave(Unknown Source)
        at org.aspectj.weaver.bcel.BcelWeaver.weave(Unknown Source)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.weaveAndGenerateClassFiles(Unknown Source)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(Unknown Source)
        at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(Unknown Source)
        at org.aspectj.tools.ajc.Main.run(Unknown Source)
        at org.aspectj.tools.ajc.Main.runMain(Unknown Source)
        at org.aspectj.tools.ajc.Main.main(Unknown Source)</description>
      <comments>
		<comment id="1" date="2003-01-14 15:06:20 EST" author="Erik Hilsdale">The problem was an over-eager debugging guard that throws an exception when
given seriously malformed classfiles.  Seriously malformed, in this particular
case, being non-abstract with no code.  This has now been properly relaxed to
non-(abstract or native) with no code.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="27817202657a92778479de5063097086b511385b" author="ehilsdal" date="2003-01-15 05:02:43"/>
          <file name="weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="29186" opendate="2003-1-8 21:22:00" fixdate="2003-1-14 16:43:00">
    <buginformation>
      <summary>ajc -emacssym chokes on pointcut that includes an intertype method</summary>
      <description>This works fine without -emacssym, but dies with it:

aspect Foo {
  before() : call(void foo()) { }
  void Bar.bar() { foo(); }
}
class Bar {
  void foo() { }
}

munger: (before: (persingleton(Foo) &amp;&amp; call(ExactTypePattern(void) foo()))-&gt;void Foo.ajc$before$Foo$f()) on method-call(void Bar.foo())
trouble in: 
public class Foo extends java.lang.Object:
  TypeMungers: [(BcelTypeMunger ResolvedTypeMunger(Method, void Bar.bar()))]
  public static final Foo ajc$perSingletonInstance
  static void &lt;clinit&gt;():
                    INVOKESTATIC Foo.ajc$clinit ()V   (line 1)
    staticinitialization(void Foo.&lt;clinit&gt;())
    |               RETURN
    staticinitialization(void Foo.&lt;clinit&gt;())
  end static void &lt;clinit&gt;()

  void &lt;init&gt;():
                    ALOAD_0     // Foo this   (line 1)
                    INVOKESPECIAL java.lang.Object.&lt;init&gt; ()V
    constructor-execution(void Foo.&lt;init&gt;())
    |               RETURN
    constructor-execution(void Foo.&lt;init&gt;())
  end void &lt;init&gt;()

  public void ajc$before$Foo$f()    AdviceAttribute(before, call(ExactTypePattern(void) foo()), 0, 15)
:
    advice-execution(void Foo.ajc$before$Foo$f())
    |               RETURN   (line 2)
    advice-execution(void Foo.ajc$before$Foo$f())
  end public void ajc$before$Foo$f()

  public static void ajc$interMethod$Foo$Bar$bar(Bar)    EffectiveSignatureAttribute(void Bar.bar(), method-execution)
:
    method-execution(void Bar.bar())
    |               ALOAD_0     // Bar arg0   (line 3)
    | method-call(void Bar.foo())
    | |             GETSTATIC Foo.ajc$perSingletonInstance LFoo;
    | |             INVOKEVIRTUAL Foo.ajc$before$Foo$f ()V
    | |             INVOKEVIRTUAL Bar.foo ()V
    | method-call(void Bar.foo())
    |               RETURN
    method-execution(void Bar.bar())
  end public static void ajc$interMethod$Foo$Bar$bar(Bar)

  public static void ajc$interMethodDispatch1$Foo$Bar$bar(Bar)    EffectiveSignatureAttribute(void Bar.bar(), method-call)
:
                    ALOAD_0     // Bar arg0
                    INVOKEVIRTUAL Bar.ajc$interMethodDispatch2$$bar ()V
                    RETURN
  end public static void ajc$interMethodDispatch1$Foo$Bar$bar(Bar)

  public static Foo aspectOf()    org.aspectj.weaver.AjAttribute$AjSynthetic@f8f7db
:
                    GETSTATIC Foo.ajc$perSingletonInstance LFoo;
                    ARETURN
  end public static Foo aspectOf()

  public static boolean hasAspect()    org.aspectj.weaver.AjAttribute$AjSynthetic@5856a5
:
                    GETSTATIC Foo.ajc$perSingletonInstance LFoo;
                    IFNULL L0
                    ICONST_1
                    IRETURN
                L0: ICONST_0
                    IRETURN
  end public static boolean hasAspect()

  private static void ajc$clinit()    org.aspectj.weaver.AjAttribute$AjSynthetic@c39a20
:
                    NEW Foo
                    DUP
                    INVOKESPECIAL Foo.&lt;init&gt; ()V
                    PUTSTATIC Foo.ajc$perSingletonInstance LFoo;
                    RETURN
  end private static void ajc$clinit()
end public class Foo
Exception thrown from AspectJ 1.1b2

This might be logged as a bug already -- see the bug database at
  http://dev.eclipse.org (product: AspectJ, component: compiler)

Bugs for exceptions thrown have titles File:line from the top stack, 
e.g., "SomeFile.java:243"

If you don't find the exception below in a bug, please add a new bug
To make the bug a priority, please include a test program
that can reproduce this exception.
null
java.lang.NullPointerException
	at org.aspectj.weaver.AsmAdaptor.findOrCreateBodyNode(Unknown Source)
	at org.aspectj.weaver.AsmAdaptor.getNode(Unknown Source)
	at org.aspectj.weaver.AsmAdaptor.noteMunger(Unknown Source)
	at org.aspectj.weaver.Shadow.implementMungers(Unknown Source)
	at org.aspectj.weaver.Shadow.implement(Unknown Source)
	at org.aspectj.weaver.bcel.BcelClassWeaver.implement(Unknown Source)
	at org.aspectj.weaver.bcel.BcelClassWeaver.weave(Unknown Source)
	at org.aspectj.weaver.bcel.BcelClassWeaver.weave(Unknown Source)
	at org.aspectj.weaver.bcel.BcelWeaver.weave(Unknown Source)
	at org.aspectj.weaver.bcel.BcelWeaver.weave(Unknown Source)
	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.weaveAndGenerateClassFiles(Unknown Source)
	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(Unknown Source)
	at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(Unknown Source)
	at org.aspectj.tools.ajc.Main.run(Unknown Source)
	at org.aspectj.tools.ajc.Main.runMain(Unknown Source)
	at org.aspectj.tools.ajc.Main.main(Unknown Source)


1 fail|abort</description>
      <comments>
		<comment id="1" date="2003-01-14 16:43:59 EST" author="Jim Hugunin">This bug just touched on the surface of many problems with structure model 
generation.  The worst of those bugs are now all fixed in the current tree.  
The testcase for these is to run the standard test suite with the -emacssym 
flag so that model will be generated for every test case in the suite.

This bug shows up in all of the ide support implementations, and using -
emacssym is a good way of testing all of them minimally.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="c1260e6b26b78f0f431b778cd8f22d3493e97f3f" author="jhugunin" date="2003-01-15 06:36:18"/>
          <file name="asm/src/org/aspectj/asm/StructureModel.java">
              <method name="findNodeForClass" returnType="ProgramElementNode" parameters="String String"/>
          </file>
          <file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmBuilder.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/AsmAdaptor.java">
              <method name="getNode" returnType="ProgramElementNode" parameters="StructureModel Advice"/>
          </file>
          <file name="weaver/src/org/aspectj/weaver/Lint.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/ResolvedTypeX.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/Shadow.java">
              <method name="implementMungers" returnType="void" parameters=""/>
          </file>
          <file name="weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="29769" opendate="2003-1-19 11:42:00" fixdate="2003-1-24 21:17:00">
    <buginformation>
      <summary>Ajde does not support new AspectJ 1.1 compiler options</summary>
      <description>The org.aspectj.ajde.BuildOptionsAdapter interface does not yet support the new 
AspectJ 1.1 compiler options. These need to be added to the interface, any old 
or renamed options deprecated, and then the correct processing needs to happen 
within Ajde to pass these options to the compiler.

This enhancement is needed by the various IDE projects for there AspectJ 1.1
support.</description>
      <comments>
		<comment id="1" date="2003-01-22 08:23:48 EST" author="Adrian Colyer">Created attachment 3075 [details]
Patch for ajbrowser project</comment>
		<comment id="2" date="2003-01-22 08:24:20 EST" author="Adrian Colyer">Created attachment 3076 [details]
Patch for Ajde project</comment>
		<comment id="3" date="2003-01-22 08:24:49 EST" author="Adrian Colyer">Created attachment 3077 [details]
Patch for org.aspcetj.ajdt.core project</comment>
		<comment id="4" date="2003-01-22 08:25:39 EST" author="Adrian Colyer">As ever, turned into a bigger task than you would intially think. The attached
patches bring Ajde up to speed with the new AspectJ 11 options.

In opts11.ajde.patch.txt:
=========================
Patch for the ajde project.

First off, a set of fixes for the AjdeModuleTests -these were broken even
before I started work, so I had to fix them first! They now run successfully
using a Junit Launcher in eclipse from the ajde project. There are a lot of
relative directory paths specified throughout the tests, so I worry that these
may not work in an automated Ant run without further mods, but since they were
broken anyway, I figure they can't have been included for the time being. Three 
tests in the suite still fail, one of which at least I think is waiting for 
Mik's additional structure to be generated. The other two look like suspicious 
tests, but I've left them in (not related to my options processing work). 

Secondly, a comprehensive set of new tests to exercise all the new options. 
Primarily in BuildConfigurationTests.java (run at least this test suite after 
applying the patch to verify that all has gone well).

Thirdly, the new BuildOptionsAdapter and ProjectPropertiesAdapter interfaces, 
and the relevant updates (quite a few!) inside Ajde to correctly populate an 
AjBuildConfig based on them.

In opts11.ajbrowser.patch.txt:
==============================
Patch for the ajbrowser project

An update to ajbrowser.BrowserProperties to support the new interfaces


In opts11.org.aspectj.ajdt.core.patch.txt:
==========================================
Patch for the org.aspectj.ajdt.core project

Extension to the test case, and updates to the BuildArgParser and AjBuildConfig.

Notes:
=======
* The BuildArgParser currently accepts "-Xlintfile somefile.properties", but NOT
"-Xlintfile:somefile.properties". The latter style is specified in the 11 
readme, but I didn't change it as thsi would have affected command-line options
processing too.
* I added -XnoWeave as a valid option in the BuildArgParser
* When -sourcedirs are specified, Ajde now sets the source dirs in AjBuildConfig
correctly - it does NOT add all of the (*.java,*.aj) files in those directories 
into the list of files returned by AjBuildConfig.getFiles(). The comment in
AjBuildConfig surrounding that method suggests it should, but this wasn't being 
done previously so I've followed suit. Let me know if I should change to 
populate the files list.</comment>
		<comment id="5" date="2003-01-24 21:17:09 EST" author="Mik Kersten">These patches are now integrated.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="85a827a7f269a18a0c80802811bbc2aa3766c2e4" author="mkersten" date="2003-01-25 10:25:30"/>
          <file name="ajbrowser/src/org/aspectj/tools/ajbrowser/BrowserProperties.java">
          </file>
          <file name="ajde/src/org/aspectj/ajde/BuildOptionsAdapter.java">
          </file>
          <file name="ajde/src/org/aspectj/ajde/ProjectPropertiesAdapter.java">
          </file>
          <file name="ajde/src/org/aspectj/ajde/internal/AspectJBuildManager.java">
              <method name="run" returnType="void" parameters=""/>
          </file>
          <file name="ajde/src/org/aspectj/ajde/internal/CompilerAdapter.java">
          </file>
          <file name="ajde/src/org/aspectj/ajde/ui/internal/AjcBuildOptions.java">
          </file>
          <file name="ajde/testdata/examples/figures-coverage/figures/Figure.java">
          </file>
          <file name="ajde/testsrc/org/aspectj/ajde/AjdeTests.java">
              <method name="suite" returnType="Test" parameters=""/>
          </file>
          <file name="ajde/testsrc/org/aspectj/ajde/BuildConfigurationTests.java">
          </file>
          <file name="ajde/testsrc/org/aspectj/ajde/BuildOptionsTest.java">
          </file>
          <file name="ajde/testsrc/org/aspectj/ajde/NullIdeManager.java">
              <method name="init" returnType="void" parameters="String"/>
          </file>
          <file name="ajde/testsrc/org/aspectj/ajde/NullIdeProperties.java">
          </file>
          <file name="ajde/testsrc/org/aspectj/ajde/StructureModelRegressionTest.java">
          </file>
          <file name="ajde/testsrc/org/aspectj/ajde/StructureModelTest.java">
          </file>
          <file name="ajde/testsrc/org/aspectj/ajde/ui/StructureViewManagerTest.java">
              <method name="testFreshStructureModelCreation" returnType="void" parameters=""/>
          </file>
          <file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java">
              <method name="parseOption" returnType="void" parameters="String LinkedList"/>
          </file>
          <file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.java">
          </file>
          <file name="org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/ajc/BuildArgParserTestCase.java">
              <method name="testXlint" returnType="void" parameters=""/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="29959" opendate="2003-1-22 7:10:00" fixdate="2003-2-13 16:00:00">
    <buginformation>
      <summary>super call in intertype method declaration body causes VerifyError</summary>
      <description>AspectJ Compiler 1.1beta4
This program:

aspect Foo {
  void A.foo() { }
  void B.foo() { super.foo(); }
}

class A { }
class B extends A { }

class Main {
  public static void main(String[] args) {
    new B();
  }
}

causes this error at runtime:

Exception in thread "main" java.lang.VerifyError: (class: B, method: ajc$superDispatch$B$foo signature: ()V) Illegal use of nonvirtual function call
	at Main.main(Foo.java:11)

Note that foo is never even called; the error happens at load time when the new B() expression causes class B to be loaded.  There's no error if either one of the foo methods is declared in its class directly.

This is kind of a showstopper...

--Doug</description>
      <comments>
		<comment id="1" date="2003-02-13 16:00:54 EST" author="Jim Hugunin">fixed in current cvs tree with test in bugs/SuperToIntro.java</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="3e2801ad504e8f6b3fa7b50a42bf2706994e1727" author="jhugunin" date="2003-02-14 06:00:35"/>
          <file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/InterTypeConstructorDeclaration.java">
              <method name="makePreMethod" returnType="MethodDeclaration" parameters="ClassScope ExplicitConstructorCall"/>
          </file>
          <file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/SuperFixerVisitor.java">
          </file>
          <file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/InterTypeMethodBinding.java">
          </file>
          <file name="org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java">
          </file>
          <file name="org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ExplicitConstructorCall.java">
          </file>
          <file name="org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java">
          </file>
          <file name="org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodBinding.java">
              <method name="getAccessMethod" returnType="MethodBinding" parameters="boolean"/>
          </file>
          <file name="tests/bugs/SuperToIntro.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="30168" opendate="2003-1-24 7:25:00" fixdate="2003-2-13 16:59:00">
    <buginformation>
      <summary>Error with certain combination of advice</summary>
      <description>This program causes the java VM to crash. It is a minimal example -- if you remove anything in the aspects it works. 

1. PROGRAM CODE

package test;
import org.aspectj.lang.*;
import org.aspectj.lang.reflect.*;

public class Test3 {
   public static void main(String[] args) throws Exception {
      Test3 a = new Test3();
      a.foo(-3);
   }
   public void foo(int i) {
      this.x=i;
   }
   int x;
   

}

aspect Log {
   pointcut assign(Object newval, Object targ):
      set(* test..*)  &amp;&amp; args(newval) &amp;&amp; target(targ);

   before(Object newval, Object targ): assign(newval,targ) {
      Signature sign = thisJoinPoint.getSignature();
      System.out.println(targ.toString() + "." + sign.getName() + ":=" + newval);
   }
   /*
}
// Different error message if you divide into two aspects
aspect Tracing {
   */
   pointcut tracedCall():
      call(* test..*(..))/* &amp;&amp; !within(Tracing)*/ &amp;&amp; !within(Log);

   after() returning (Object o):  tracedCall() {
      // Works if you comment out either of these two lines
      thisJoinPoint.getSignature();
      System.out.println(thisJoinPoint);
   }
} 

2. RESULTS ON SOLARIS

[erik@oden test] java test.Test3 
test.Test3@b8df17.x:=-3
 
Unexpected Signal : 11 occurred at PC=0xFA415A00
Function=[Unknown.]
Library=(N/A)
 
NOTE: We are unable to locate the function name symbol for the error
      just occurred. Please refer to release documentation for possible
      reason and solutions.
 
 
Current Java thread:
 
Dynamic libraries:
0x10000         java
0xff350000      /usr/lib/libthread.so.1
0xff390000      /usr/lib/libdl.so.1
0xff200000      /usr/lib/libc.so.1
0xff330000      /usr/platform/SUNW,Ultra-250/lib/libc_psr.so.1
0xfe000000      /usr/j2se/jre/lib/sparc/client/libjvm.so
0xff2e0000      /usr/lib/libCrun.so.1
0xff1e0000      /usr/lib/libsocket.so.1
0xff100000      /usr/lib/libnsl.so.1
0xff0d0000      /usr/lib/libm.so.1
0xff310000      /usr/lib/libw.so.1
0xff0b0000      /usr/lib/libmp.so.2
0xff080000      /usr/j2se/jre/lib/sparc/native_threads/libhpi.so
0xff050000      /usr/j2se/jre/lib/sparc/libverify.so
0xff020000      /usr/j2se/jre/lib/sparc/libjava.so
0xfe7e0000      /usr/j2se/jre/lib/sparc/libzip.so
0xfe5b0000      /usr/lib/locale/sv_SE/sv_SE.so.2
 
Local Time = Fri Jan 24 13:38:29 2003
Elapsed Time = 2
#
# HotSpot Virtual Machine Error : 11
# Error ID : 4F530E43505002D3 01
# Please report this error at
# http://java.sun.com/cgi-bin/bugreport.cgi
#
# Java VM: Java HotSpot(TM) Client VM (1.4.0-b92 mixed mode)
#
# An error report file has been saved as hs_err_pid15099.log.
# Please refer to the file for further information.
#
Abort
[erik@oden test] 
[erik@oden test] /usr/j2se.old/bin/java test.Test3
test.Test3@1afa3.x:=-3
 
Unexpected Signal : 11 occurred at PC=0x85c24
Function name=(N/A)
Library=(N/A)
 
NOTE: We are unable to locate the function name symbol for the error
      just occurred. Please refer to release documentation for possible
      reason and solutions.
 
 
 
Current Java thread:
 
Dynamic libraries:
0x10000         /usr/j2se.old/bin/../bin/sparc/native_threads/java
0xff350000      /usr/lib/libthread.so.1
0xff390000      /usr/lib/libdl.so.1
0xff200000      /usr/lib/libc.so.1
0xff330000      /usr/platform/SUNW,Ultra-250/lib/libc_psr.so.1
0xfe480000      /usr/j2se.old/jre/lib/sparc/client/libjvm.so
0xff2e0000      /usr/lib/libCrun.so.1
0xff1e0000      /usr/lib/libsocket.so.1
0xff100000      /usr/lib/libnsl.so.1
0xff0d0000      /usr/lib/libm.so.1
0xff310000      /usr/lib/libw.so.1
0xff0b0000      /usr/lib/libmp.so.2
0xff080000      /usr/j2se.old/jre/lib/sparc/native_threads/libhpi.so
0xff050000      /usr/j2se.old/jre/lib/sparc/libverify.so
0xfe440000      /usr/j2se.old/jre/lib/sparc/libjava.so
0xff020000      /usr/j2se.old/jre/lib/sparc/libzip.so
0xfe260000      /usr/lib/locale/sv_SE/sv_SE.so.2
 
Local Time = Fri Jan 24 13:39:20 2003
Elapsed Time = 2
#
# HotSpot Virtual Machine Error : 11
# Error ID : 4F530E43505002C4 01
# Please report this error at
# http://java.sun.com/cgi-bin/bugreport.cgi
#
# Java VM: Java HotSpot(TM) Client VM (1.3.1_02-b02 mixed mode)
#
# An error report file has been saved as hs_err_pid15100.log.
# Please refer to the file for further information.
#
Abort
[erik@oden test] 

3. RESULTS ON WINDOWS 2000

Results on Windows 2000 (If I have copied it correctly)
&gt;java -classpath ..\..\aspectj1.1\lib\aspectjrt.jar;. test.Test3
test.Test3@1a8c4e7.x:=-3
Exception in thread "main" java.lang.NullPointerException
        at test.Log.ajc$afterReturning$test_Log$30d(Test3.java:37)
        at test.Test3.main(Test3.java:8)
&gt;java -version
java version "1.4.1_01"
Java(TM) 2 Runtime Environment, Standard Edition (build 1.4.1_01-b01)
Java HotSpot(TM) Client VM (build 1.4.1_01-b01, mixed mode)
java</description>
      <comments>
		<comment id="1" date="2003-02-13 16:59:00 EST" author="Jim Hugunin">This is now fixed in the current cvs tree with a test in bugs/crashes.

This was a fascinating bug, and you did an excellent job of reducing it to a 
minimal test case.  The problem had to do with ajc's attempts to optimize away 
the creation of dynamic JoinPoint objects, which can be very expensive.  Your 
code managed to confuse this optimization and caused it to generate a call to 
the method ThisJoinPoint.StaticPart.getSignature on an object that was 
statically typed to ThisJoinPoint.  This is illegal bytecode.

You should consider reporting this as a bug to SUN.  While ajc did generate 
illegal bytecode here, the correct VM behavior should have been to produce a 
VerifyError when loading the classes.  Neither the Solaris or Windows VM is 
handling this case at all well.  The Solaris VMs behavior is particularly 
troubling as it causes such a hard crash.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="d15eb325fc77d9f1eb0ac9ec1f6886562d531105" author="jhugunin" date="2003-02-14 07:00:34"/>
          <file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/ThisJoinPointVisitor.java">
              <method name="computeJoinPointParams" returnType="void" parameters=""/>
          </file>
          <file name="tests/bugs/crashes/test/Test3.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="31423" opendate="2003-2-9 12:29:00" fixdate="2003-2-13 17:24:00">
    <buginformation>
      <summary>Pointcut adviceexecution() does not work</summary>
      <description>Pointcut adviceexecution() does not seem to pick advice execution
join points in beta4. Here is a program that shows the problem:

public class Test {
    public static void main(String[] args) {
    }
}

aspect Aspect1 {
    before() : execution(* Test.*(..)) {
	System.out.println("Reached " + thisJoinPoint);
    }
}

aspect Aspect2 {
    before() : adviceexecution() &amp;&amp; !within(Aspect2) {
	System.out.println("Reached " + thisJoinPoint);
    }
}

F:\aop\bugs\1.1\b4\adviceexecution&gt;ajc -version
AspectJ Compiler 1.1beta4

F:\aop\bugs\1.1\b4\adviceexecution&gt;ajc Test.java

F:\aop\bugs\1.1\b4\adviceexecution&gt;java Test
Reached execution(void Test.main(String[]))</description>
      <comments>
		<comment id="1" date="2003-02-13 17:24:21 EST" author="Jim Hugunin">Fixed in current cvs tree, test in bugs/AdviceExec.java

Thanks for catching this rather embarassingly obvious bug.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="19c3e16d2212bdd41144da2150c8ef46b4a759a5" author="jhugunin" date="2003-02-14 07:24:56"/>
          <file name="tests/bugs/AdviceExec.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/patterns/KindedPointcut.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/patterns/SignaturePattern.java">
              <method name="matches" returnType="boolean" parameters="Member World"/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="33635" opendate="2003-3-2 20:01:00" fixdate="2003-3-5 16:48:00">
    <buginformation>
      <summary>Negation of if pointcut does not work</summary>
      <description>In "!if(expression)" the negation part is ignored. I am using beta4.

How to reproduce:

public class Test {
    public static void main(String args[]) {
    }
}

aspect NotIfBugAspect {
    before() : execution(* main(..)) &amp;&amp; !if(true) {
	System.out.println("NotIfBugAspect message");
    }
}

&gt; ajc *.java
&gt; java Test
NotIfBugAspect message

If I change the pointcut in before advice to move negation inside if(), 
everything works fine:
aspect NotIfBugAspect {
    before() : execution(* main(..)) &amp;&amp; if(!true) {
	System.out.println("NotIfBugAspect message");
    }
}

&gt; ajc *.java
&gt; java Test
  &lt;no output&gt;</description>
      <comments>
		<comment id="1" date="2003-03-05 16:48:19 EST" author="Jim Hugunin">fixed in tree, test in bugs/NotIf.java

This bug was caused by a previous fix for handling the interaction between 
args and if pcd's.  This interaction is much messier than it should be and
is a prime opportunity for a better design.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="cb775240056309c20aac308be5ab2abd9696be84" author="jhugunin" date="2003-03-06 06:46:49"/>
          <file name="tests/bugs/NotIf.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/patterns/IfPointcut.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="32463" opendate="2003-2-21 5:59:00" fixdate="2003-3-5 19:18:00">
    <buginformation>
      <summary>ajc reports error when encountering static declaration of nested classes</summary>
      <description>Version: AspectJ Compiler 1.1beta4

The ajc compiler issues a spurious error message and exits with a negative 
error code when weaving code containing static declaration of a nested class. 
The compiler seem to write the classfiles correctly but the negative exit 
status causes problems when e.g. using the AjcCompilerAdapter in ant.

To reproduce:
1) Extract the following two files into an empty directory:
// File: A.aj:
aspect A  {

    pointcut withinTest(): within(Test);
    pointcut callToHandleOrder() : (withinTest() &amp;&amp;
                             call(* handleOrder(..)));

    Object around(): callToHandleOrder() {

      return "DUMMY inserted by ASPECT" ;
   }
}
// End of File A.aj

// File : Test.java
public class Test
{
    // Commenting out the static declaration makes everything work OK
    static
    {
        class StaticNestedClass
        {
        }
    }
    
    public static void main(String[] args)
    {
      System.out.println(new Test().handleOrder("test"));
    }

    private String handleOrder(String t)
    {
      return t;
    }

}
// End of Test.java

2) Compile the files 
   ajc -sourceroots . -verbose

Output:
-----
compiling c:/aspectj1.1/doc/examples/bug/./A.aj
compiling c:/aspectj1.1/doc/examples/bug/./Test.java
weaving
might need to weave [UnwovenClassFile(null, Test$1$StaticNestedClass), 
UnwovenClassFile(null, A), UnwovenClassFile(null, Test)](world=true)
wrote class file: c:\aspectj1.1\doc\examples\bug\A.class
can't find type Test$1
wrote class file: c:\aspectj1.1\doc\examples\bug\Test$1$StaticNestedClass.class
wrote class file: c:\aspectj1.1\doc\examples\bug\Test.class

1 error
------</description>
      <comments>
		<comment id="1" date="2003-03-05 19:18:35 EST" author="Jim Hugunin">fixed in current tree, test in bugs/WeaveLocal.java

This bug had been reported before on the mailing list, but by including
a small self-contained test case, this report made the bug easy to reproduce
and hence easy to fix.  Thanks.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="d1e5c0a57c5da220b8f7357550db84f1009dbe2e" author="jhugunin" date="2003-03-06 09:24:39"/>
          <file name="tests/bugs/WeaveLocal.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/NameMangler.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/ResolvedTypeX.java">
              <method name="getInterTypeMungers" returnType="List" parameters=""/>
          </file>
          <file name="weaver/src/org/aspectj/weaver/TypeX.java">
              <method name="isArray" returnType="boolean" parameters=""/>
          </file>
          <file name="weaver/src/org/aspectj/weaver/patterns/WithinPointcut.java">
          </file>
          <file name="weaver/testsrc/org/aspectj/weaver/TypeXTestCase.java">
              <method name="testNameAndSigWithInners" returnType="void" parameters=""/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="29934" opendate="2003-1-21 20:13:00" fixdate="2003-3-11 19:49:00">
    <buginformation>
      <summary>runtime NullPointerException when applying around advice to other around advice</summary>
      <description>When the program below is run, it produces a NullPointerException...
java.lang.NullPointerException
	at A2.ajc$around$A2$3b6proceed(CflowCycles.java)
	at A2.ajc$around$A2$3b6_aroundBody3(CflowCycles.java:35)
	at Target.run(CflowCycles.java:24)
	at CflowCycles.run_aroundBody4(CflowCycles.java:8)
	at CflowCycles.main_aroundBody6(CflowCycles.java:24)
	at CflowCycles.main(CflowCycles.java:24)

---(in new/CflowCycles.java and in ajcTestsFailing.xml)

import org.aspectj.testing.Tester; 

/** @testcase cflow cycles in advice from different aspects */
public class CflowCycles {
  public static void main( String args[] ) {
        Tester.expectEvent("target A1");
        Tester.expectEvent("target A2");
        new Target().run();
        Tester.checkAllEventsIgnoreDups();
  }
}

class Target {
    public void run(){ }
}

aspect A1 {
    pointcut TargetRunFlow () 
        // ok if no cflow: within(Target) &amp;&amp; execution(* *(..)) &amp;&amp; !within
(A1+);
        : !within(A1+) &amp;&amp; !preinitialization(new(..)) &amp;&amp; !initialization(new
(..))//cflow(within(Target) &amp;&amp; execution(* *(..))) &amp;&amp; !within(A1+)
        ;
    Object around () : TargetRunFlow() {
        Tester.event("target A1");
        return proceed();
    }
    // ok if in the same class
}

aspect A2 {
    pointcut TargetRun () 
        : within(Target) &amp;&amp; execution(* *(..)) &amp;&amp; !within(A2+);
        ;
    Object around () : TargetRun() {
        Tester.event("target A2");
        return proceed();
    }
}</description>
      <comments>
		<comment id="1" date="2003-03-11 19:49:11 EST" author="Jim Hugunin">fixed in current tree, fix is to not inline around advice that has
other around advice applied to it</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="0fb5f693794e571ab693813cbc80578b2bc7b470" author="jhugunin" date="2003-03-12 09:48:57"/>
          <file name="weaver/src/org/aspectj/weaver/bcel/BcelShadow.java">
              <method name="weaveAroundInline" returnType="void" parameters="BcelAdvice boolean"/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="34858" opendate="2003-3-12 14:50:00" fixdate="2003-3-12 18:07:00">
    <buginformation>
      <summary>Weaver crash</summary>
      <description>this test file (Test.java) crashes the weaver:

public class Test {
    static aspect MockProcessing {
        pointcut testFlow(final Thread thread) : 
            cflow(execution(void run()) &amp;&amp; this(thread) &amp;&amp; within(Thread)); // 
the within is an optimization

        Object around() :
                call(* DummyConfiguration.createRootApplicationModule(..)) &amp;&amp; 
testFlow(Thread)
        {
            return null;
        }
    }
}

class Bar {
    void foo() {
        DummyConfiguration.createRootApplicationModule();
    }
}

class DummyConfiguration {
    static Object createRootApplicationModule() {
        return null;
    }
}

prompt&gt;ajc -d 11bin -1.4 Test.java
Exception thrown from AspectJ 1.1rc1

This might be logged as a bug already -- find current bugs at
  http://bugs.eclipse.org/bugs/buglist.cgi?product=AspectJ&amp;component=Compiler

Bugs for exceptions thrown have titles File:line from the top stack,
e.g., "SomeFile.java:243"

If you don't find the exception below in a bug, please add a new bug
at http://bugs.eclipse.org/bugs/enter_bug.cgi?product=AspectJ
To make the bug a priority, please include a test program
that can reproduce this exception.
0
0
java.lang.ArrayIndexOutOfBoundsException: 0
        at org.aspectj.weaver.IntMap.get(IntMap.java:109)
        at org.aspectj.weaver.patterns.CflowPointcut.concretize1(CflowPointcut.java:170)
        at org.aspectj.weaver.patterns.ReferencePointcut.concretize1(ReferencePointcut.java:270)
        at org.aspectj.weaver.patterns.AndPointcut.concretize1(AndPointcut.java:88)
        at org.aspectj.weaver.patterns.Pointcut.concretize(Pointcut.java:127)
        at org.aspectj.weaver.patterns.Pointcut.concretize(Pointcut.java:120)
        at org.aspectj.weaver.Advice.concretize(Advice.java:207)
        at org.aspectj.weaver.CrosscuttingMembers.addShadowMunger(CrosscuttingMembers.java:78)
        at org.aspectj.weaver.CrosscuttingMembers.addShadowMungers(CrosscuttingMembers.java:72)
        at org.aspectj.weaver.ResolvedTypeX.collectCrosscuttingMembers(ResolvedTypeX.java:328)
        at org.aspectj.weaver.CrosscuttingMembersSet.addOrReplaceAspect(CrosscuttingMembersSet.java:54)
        at org.aspectj.weaver.bcel.BcelWeaver.prepareForWeave(BcelWeaver.java:164)
        at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:214)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.weaveAndGenerateClassFiles(AjBuildManager.java:394)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:149)
        at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:55)
        at org.aspectj.tools.ajc.Main.run(Main.java:216)
        at org.aspectj.tools.ajc.Main.runMain(Main.java:155)
        at org.aspectj.tools.ajc.Main.main(Main.java:72)


1 fail|abort</description>
      <comments>
		<comment id="1" date="2003-03-12 14:59:49 EST" author="Jim Hugunin">I've reproduced this bug easily from the submitted test.  It should be fixed 
today for the rc1 release.</comment>
		<comment id="2" date="2003-03-12 18:07:52 EST" author="Jim Hugunin">fixed in tree, tests in bings/CflowBinding*.java

issue was with cflow capturing state that was not actually exposed to any 
advice</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="7746fcb7e977c7a91bd70081a2197a999ec18ad3" author="jhugunin" date="2003-03-13 08:07:08"/>
          <file name="tests/bugs/CflowBinding.java">
          </file>
          <file name="tests/bugs/CflowBindingOrig.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/patterns/CflowPointcut.java">
              <method name="concretize1" returnType="Pointcut" parameters="ResolvedTypeX IntMap"/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="34925" opendate="2003-3-13 11:58:00" fixdate="2003-3-14 16:29:00">
    <buginformation>
      <summary>compiler crash on yesterday's rc1 build</summary>
      <description>These test files crash the compiler (in fact if you just compile 
ConvertToUnchecked it crashes it):

ConvertToUnchecked.java:

import java.io.IOException;

// example 3
aspect ConvertToUnchecked {
  // make all exceptions in an application unchecked; "soft"
  //declare soft: (Exception &amp;&amp; !RuntimeException): within(com.foo.app..*);

  // convert IOExceptions in a package to PersistenceException
  pointcut module() : within(test.*); // within
(com.foo.framework.persistence.*);
  // convert exceptions
  // within(test.*) would work to allow an immediate catch, except for
  // the last statement in a try block
  // however, I suspect that would also generate inefficient code
  // even this might be inefficient: it needs to wrap every method body in a
  // try ... catch block
  after() throwing (IOException e) : within(test.*) {
    throw new PersistenceException(e);
  }
  declare soft: (IOException): module();
}
// tested by: test.ConvertToUnchecked
----

PersistenceException.java
public class PersistenceException extends Exception 
{
  public PersistenceException(Throwable cause) {
    super(cause);
  }
}

---
sample run:
C:\ron\devel\articles\errorHandling&gt;ajc -1.4 ConvertToUnchecked.java 
Persistence
Exception.java
java.lang.RuntimeException: unimplemented: throw new PersistenceException(e)
        at org.aspectj.ajdt.internal.compiler.lookup.EclipseShadow.makeShadow(EclipseShadow.java:148)
        at org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.makeShadow(EclipseFactory.java:292)
        at org.aspectj.ajdt.internal.compiler.problem.AjProblemReporter.unhandledException(AjProblemReporter.java:67)
        at org.eclipse.jdt.internal.compiler.flow.FlowContext.checkExceptionHandlers(FlowContext.java:249)
        at org.eclipse.jdt.internal.compiler.ast.ThrowStatement.analyseCode(ThrowStatement.java:35)
        at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.analyseCode(AbstractMethodDeclaration.java:106)
        at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:445)
        at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:76)
        at org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:539)
        at org.aspectj.ajdt.internal.compiler.AjCompiler.process(AjCompiler.java:65)
        at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:340)
        at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile(AbstractImageBuilder.java:232)
        at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile(AbstractImageBuilder.java:171)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager$BatchBuilder.run(AjBuildManager.java:656)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:139)
        at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:55)
        at org.aspectj.tools.ajc.Main.run(Main.java:216)
        at org.aspectj.tools.ajc.Main.runMain(Main.java:155)
        at org.aspectj.tools.ajc.Main.main(Main.java:72)
C:\ron\devel\articles\errorHandling\ConvertToUnchecked.java:0 Internal compiler
error
java.lang.RuntimeException: unimplemented: throw new PersistenceException(e)
        at org.aspectj.ajdt.internal.compiler.lookup.EclipseShadow.makeShadow(EclipseShadow.java:148)
        at org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.makeShadow(EclipseFactory.java:292)
        at org.aspectj.ajdt.internal.compiler.problem.AjProblemReporter.unhandledException(AjProblemReporter.java:67)
        at org.eclipse.jdt.internal.compiler.flow.FlowContext.checkExceptionHandlers(FlowContext.java:249)
        at org.eclipse.jdt.internal.compiler.ast.ThrowStatement.analyseCode(ThrowStatement.java:35)
        at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.analyseCode(AbstractMethodDeclaration.java:106)
        at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:445)
        at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:76)
        at org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:539)
        at org.aspectj.ajdt.internal.compiler.AjCompiler.process(AjCompiler.java:65)
        at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:340)
        at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile(AbstractImageBuilder.java:232)
        at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile(AbstractImageBuilder.java:171)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager$BatchBuilder.run(AjBuildManager.java:656)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:139)
        at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:55)
        at org.aspectj.tools.ajc.Main.run(Main.java:216)
        at org.aspectj.tools.ajc.Main.runMain(Main.java:155)
        at org.aspectj.tools.ajc.Main.main(Main.java:72)


!! no source information available !!
ABORT
Exception thrown from AspectJ 1.1rc1

This might be logged as a bug already -- find current bugs at
  http://bugs.eclipse.org/bugs/buglist.cgi?product=AspectJ&amp;component=Compiler

Bugs for exceptions thrown have titles File:line from the top stack,
e.g., "SomeFile.java:243"

If you don't find the exception below in a bug, please add a new bug
at http://bugs.eclipse.org/bugs/enter_bug.cgi?product=AspectJ
To make the bug a priority, please include a test program
that can reproduce this exception.
unimplemented: throw new PersistenceException(e)
unimplemented: throw new PersistenceException(e)
java.lang.RuntimeException: unimplemented: throw new PersistenceException(e)
        at org.aspectj.ajdt.internal.compiler.lookup.EclipseShadow.makeShadow(EclipseShadow.java:148)
        at org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.makeShadow(EclipseFactory.java:292)
        at org.aspectj.ajdt.internal.compiler.problem.AjProblemReporter.unhandledException(AjProblemReporter.java:67)
        at org.eclipse.jdt.internal.compiler.flow.FlowContext.checkExceptionHandlers(FlowContext.java:249)
        at org.eclipse.jdt.internal.compiler.ast.ThrowStatement.analyseCode(ThrowStatement.java:35)
        at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.analyseCode(AbstractMethodDeclaration.java:106)
        at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:445)
        at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:76)
        at org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:539)
        at org.aspectj.ajdt.internal.compiler.AjCompiler.process(AjCompiler.java:65)
        at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:340)
        at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile(AbstractImageBuilder.java:232)
        at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile(AbstractImageBuilder.java:171)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager$BatchBuilder.run(AjBuildManager.java:656)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:139)
        at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:55)
        at org.aspectj.tools.ajc.Main.run(Main.java:216)
        at org.aspectj.tools.ajc.Main.runMain(Main.java:155)
        at org.aspectj.tools.ajc.Main.main(Main.java:72)


1 fail|abort, 1 error</description>
      <comments>
		<comment id="1" date="2003-03-13 12:31:12 EST" author="Ron Bodkin">I actually ran this test against the latest rc1 build (I pulled it from cvs on 
my home machine and didn't realize there was a new build til I read my 
email)...</comment>
		<comment id="2" date="2003-03-13 13:16:03 EST" author="Jim Hugunin">This bug is easily reproduced.  The bug means that declare soft can not
be used in a system that has explicit throw statements which throw checked 
exceptions that are not permitted except through the declare soft.

This particular example could be worked-around by making PersistenceException a
RuntimeException.  This clearly seems to be the right choice in this minimal 
test case.  However, the bug would still be revealed if the rest of the code 
contains an explicit 'throw IOException' that was not declared by the 
enclosing method.

This bug is right on the border-line for delaying the RC1 release and we are 
currently evaluating that.  It will be fixed shortly in the active cvs tree.</comment>
		<comment id="3" date="2003-03-14 16:29:26 EST" author="Jim Hugunin">resolved in tree and for 1.1rc1 release</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="56cc4f27afaf591f8cebb2450513cc6eb7d51299" author="jhugunin" date="2003-03-14 04:16:53"/>
          <file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseShadow.java">
          </file>
          <file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/problem/AjProblemReporter.java">
              <method name="unhandledException" returnType="void" parameters="TypeBinding AstNode"/>
          </file>
          <file name="tests/bugs/ConvertToUnchecked.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="36803" opendate="2003-4-23 12:56:00" fixdate="2003-4-25 14:10:00">
    <buginformation>
      <summary>BCException thrown by AspectJ 1.1rc1</summary>
      <description>[iajc] expected state: resolved got: concrete
     [iajc] expected state: resolved got: concrete
     [iajc] org.aspectj.weaver.BCException: expected state: resolved got: concrete
     [iajc]     at org.aspectj.weaver.patterns.Pointcut.assertState(Pointcut.java:236)
     [iajc]     at org.aspectj.weaver.patterns.Pointcut.concretize(Pointcut.java:126)
     [iajc]     at org.aspectj.weaver.patterns.CflowPointcut.concretize1(CflowPointcut.java:143)
     [iajc]     at org.aspectj.weaver.patterns.NotPointcut.concretize1(NotPointcut.java:94)
     [iajc]     at org.aspectj.weaver.patterns.AndPointcut.concretize1(AndPointcut.java:88)
     [iajc]     at org.aspectj.weaver.patterns.ReferencePointcut.concretize1(ReferencePointcut.java:270)
     [iajc]     at org.aspectj.weaver.patterns.AndPointcut.concretize1(AndPointcut.java:88)
     [iajc]     at org.aspectj.weaver.patterns.ReferencePointcut.concretize1(ReferencePointcut.java:270)
     [iajc]     at org.aspectj.weaver.patterns.Pointcut.concretize(Pointcut.java:127)
     [iajc]     at org.aspectj.weaver.patterns.Pointcut.concretize(Pointcut.java:120)
     [iajc]     at org.aspectj.weaver.Advice.concretize(Advice.java:207)
     [iajc]     at org.aspectj.weaver.CrosscuttingMembers.addShadowMunger(CrosscuttingMembers.java:78)
     [iajc]     at org.aspectj.weaver.CrosscuttingMembers.addShadowMungers(CrosscuttingMembers.java:72)
     [iajc]     at org.aspectj.weaver.ResolvedTypeX.collectCrosscuttingMembers(ResolvedTypeX.java:328)
     [iajc]     at org.aspectj.weaver.CrosscuttingMembersSet.addOrReplaceAspect(CrosscuttingMembersSet.java:54)
     [iajc]     at org.aspectj.weaver.bcel.BcelWeaver.prepareForWeave(BcelWeaver.java:164)
     [iajc]     at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:214)
     [iajc]     at org.aspectj.ajdt.internal.core.builder.AjBuildManager.weaveAndGenerateClassFiles(AjBuildManager.java:394)
     [iajc]     at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:149)
     [iajc]     at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:55)
     [iajc]     at org.aspectj.tools.ajc.Main.run(Main.java:216)
     [iajc]     at org.aspectj.tools.ajc.Main.runMain(Main.java:155)
     [iajc]     at org.aspectj.tools.ant.taskdefs.AjcTask.execute(AjcTask.java:646)
     [iajc]     at org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:193)
     [iajc]     at org.apache.tools.ant.Task.perform(Task.java:341)
     [iajc]     at org.apache.tools.ant.Target.execute(Target.java:309)
     [iajc]     at org.apache.tools.ant.Target.performTasks(Target.java:336)
     [iajc]     at org.apache.tools.ant.Project.executeTarget(Project.java:1339)
     [iajc]     at org.apache.tools.ant.Project.executeTargets(Project.java:1255)
     [iajc]     at org.apache.tools.ant.Main.runBuild(Main.java:609)
     [iajc]     at org.apache.tools.ant.Main.start(Main.java:196)
     [iajc]     at org.apache.tools.ant.Main.main(Main.java:235)</description>
      <comments>
		<comment id="1" date="2003-04-24 17:19:39 EDT" author="Jim Hugunin">Can you come up with a short self-contained test case that will reproduce this 
bug?  That would help us a lot in tracking it down and fixing it.  With such a 
test case, I believe this bug will be fixed for the 1.1rc2 release, otherwise 
it might take longer.</comment>
		<comment id="2" date="2003-04-25 11:20:34 EDT" author="Roger White">Created attachment 4703 [details]
test file to make compiler throw BCException

I pared this down to something small that still gets the exception.
I emailed it as well before I noticed the facility to add it to the bug report.</comment>
		<comment id="3" date="2003-04-25 14:10:25 EDT" author="Jim Hugunin">fixed in tree, test in bugs/CflowConcrete.java

This was easily reproduced from the provided test case.  FYI - for nice small 
test cases like this one, it is easiest if you can just provide the test 
inline with your comments rather than as an attachment.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="1e502f504f2ad333ad5627d8e9d106315c38ecc0" author="jhugunin" date="2003-04-26 03:11:33"/>
          <file name="tests/bugs/CflowConcrete.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/patterns/KindedPointcut.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/patterns/Pointcut.java">
              <method name="concretize1" returnType="Pointcut" parameters="ResolvedTypeX IntMap"/>
          </file>
          <file name="weaver/src/org/aspectj/weaver/patterns/WithinPointcut.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/patterns/WithincodePointcut.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="34951" opendate="2003-3-13 14:38:00" fixdate="2003-4-27 19:14:00">
    <buginformation>
      <summary>NPE compiling without aspectjrt.jar</summary>
      <description>Compiling spacewar without specifying aspectjrt.jar on the classpath causes a 
NPE.  Expected an error message "aspectjrt.jar required".

Steps to reproduce
1) install latest
2) cd doc/examples
3) java -jar ../../lib/aspectjtools.jar -verbose @spacewar/debug.lst
RESULT:NPE in attached log</description>
      <comments>
		<comment id="1" date="2003-03-13 14:41:43 EST" author="Wes Isberg">Created attachment 4113 [details]
log of verbose messages, NPE; also version</comment>
		<comment id="2" date="2003-04-27 19:14:02 EDT" author="Jim Hugunin">This should be fixed and has a unit test in 
org.aspectj.ajdt.core/BasicCommandTestCase.

The fix hasn't been verified on the command-line yet.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="f236927770b4c1029e4d108c3991870609555dfb" author="jhugunin" date="2003-04-28 08:29:27"/>
          <file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java">
          </file>
          <file name="org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/BasicCommandTestCase.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="37576" opendate="2003-5-13 23:20:00" fixdate="2003-5-13 23:23:00">
    <buginformation>
      <summary>Ant task switches {boot}classpath entities in 1.1rc2</summary>
      <description>The AjcTask (iajc) task takes nested bootclasspath entities as classpath and 
vice-versa.</description>
      <comments>
		<comment id="1" date="2003-05-13 23:23:50 EDT" author="Wes Isberg">Fixed in CVS.

Test: tests/product/build-aspectj/build.xml
  taskdefs/testsrc/...

Workaround: specify "bootclasspath" when you mean "classpath" and vice-versa.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="99f5c14fb0df142b1e25361a7ff3951a5a6d4d5d" author="wisberg" date="2003-05-14 12:36:34"/>
          <file name="taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java">
          </file>
          <file name="taskdefs/testsrc/org/aspectj/tools/ant/taskdefs/AjcTaskTest.java">
              <method name="testNoSuchFileList" returnType="void" parameters=""/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="37739" opendate="2003-5-15 21:20:00" fixdate="2003-5-19 14:12:00">
    <buginformation>
      <summary>Unexpected Xlint:unresolvableMember warning with withincode</summary>
      <description>The following code produces an Xlint:unresolvableMember warning:

class A {
    A(Class type) {}

    A() {
        this(String.class);
    }
}

class B {

    public void test() {
    }

    public void test2() {
        test();
    }
}

aspect C {
    void around() :
        (call (void B.test()) &amp;&amp;
         withincode (void B.test2())) {
        proceed();
    }
}

The warning text is:

Warning.java:22 can not resolve this member:
void A.&lt;catch&gt;(java.lang.ClassNotFoundException) [Xlint:unresolvableMember]

Line 22 is the line in the aspect that says "withincode".  If I comment out 
the aspect, the warning goes away.  Also, if I comment out A's default 
constructor, it goes away.  The "String.class" seems to have something to do 
with the warning.  

I can reproduce this with 1.1rc1 and 1.1rc2.</description>
      <comments>
		<comment id="1" date="2003-05-19 14:12:35 EDT" author="Jim Hugunin">fixed in cvs, test in bugs/CatchSig.java

This issue is with any code in the special pre-initialization position.  This 
is code that runs in a constructor before either this or super has been 
called.  This code doesn't have an enclosing execution join point because it 
is defined to run before constructor execution starts.  The String.class 
reference in class A is in this position and includes both method calls and an 
exception handler under AspectJ-1.1.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="2072ac11448e493e26ab7ff818ce26c6ef33c19c" author="jhugunin" date="2003-05-20 03:06:04"/>
          <file name="tests/bugs/CatchSig.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/bcel/BcelShadow.java">
              <method name="getThisEnclosingJoinPointStaticPartBcelVar" returnType="BcelVar" parameters=""/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="38131" opendate="2003-5-27 1:46:00" fixdate="2003-5-27 13:41:00">
    <buginformation>
      <summary>ajc needs -d . option while correctly compiling classes from subpackage</summary>
      <description>I am using 1.1rc1. This is a regression since rc1 and a deviation from javac.
I am guessing this may have to do something with change in the underlying
Eclipse compiler.

Create a class in a subpackage such as:
package subpackage;

public class Test {
    public static void main(String[] args) {
	System.out.println("Hello");
    }
}

Then compile using following command:
&gt; ajc subpackage\Test.java

You will see a directory "subpackage" created under the existing "subpackage"
directory. The test.class is then put in subpackage\subpackage directory.
This means running java command results in 
Exception in thread "main" java.lang.NoClassDefFoundError: subpackage/Test

Running either of the following command fixes the problem:
&gt; ajc -d . subpackage\Test.java

or 

&gt; javac subpackage\Test.java

No big deal, really. But it will be nice to have same behavior as javac.</description>
      <comments>
		<comment id="1" date="2003-05-27 13:41:35 EDT" author="Jim Hugunin">This was a significant regression from 1.1rc1.  It is now fixed in the tree 
with a test in org.aspectj.ajdt.core/*/BasicCommandTestCase.  The behavior 
should exactly mimic that of javac (and the eclipse command-line compiler) 
when -d is not passed.

We had no test cases for this behavior because all of our testing 
infrastructure explicitly passes in an output directory to keep class files 
out of the source tree.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="c509c6f751a553cc85d0210a408681f4f3ae05cb" author="jhugunin" date="2003-05-28 02:35:13"/>
          <file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java">
              <method name="outputClassFiles" returnType="void" parameters="CompilationResult"/>
          </file>
          <file name="org.aspectj.ajdt.core/testdata/src1/WrongPackage.java">
          </file>
          <file name="org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/BasicCommandTestCase.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="39626" opendate="2003-7-4 5:26:00" fixdate="2003-07-30 05:07:10">
    <buginformation>
      <summary>Compiler error when compiling a buggy class</summary>
      <description>I use AspectJ 1.1 from within eclipse.
After some time of developing, I get following stack trace (Wrapped in the 
eclipse gui), when I try to compile a java file with a huge amount of syntax 
errors, missing variables, and other problems.

As soon as I have fixed these issues, I can comnpile normally as ever.

Unfortunatly I can not provide any more detailed information because:
this errors pops up randomly,
disappears when the bug is fixed, 
I have neither the time nor the permission to create a more accurate sample

java.lang.NullPointerException
    at java.lang.String.&lt;init&gt;(String.java:214)
    at org.aspectj.ajdt.internal.core.builder.AsmBuilder.visit(AsmBuilder.java:231)
    at org.aspectj.ajdt.internal.core.builder.AsmBuilder.visit(AsmBuilder.java:259)
    at org.eclipse.jdt.internal.compiler.ast.AnonymousLocalTypeDeclaration.traverse(AnonymousLocalTypeDeclaration.java:138)
    at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.traverse(QualifiedAllocationExpression.java:342)
    at org.eclipse.jdt.internal.compiler.ast.MessageSend.traverse(MessageSend.java:299)
    at org.eclipse.jdt.internal.compiler.ast.Block.traverse(Block.java:147)
    at org.eclipse.jdt.internal.compiler.ast.ForStatement.traverse(ForStatement.java:347)
    at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.traverse(MethodDeclaration.java:157)
    at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.traverse(TypeDeclaration.java:946)
    at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.traverse(CompilationUnitDeclaration.java:303)
    at org.aspectj.ajdt.internal.core.builder.AsmBuilder.internalBuild(AsmBuilder.java:169)
    at org.aspectj.ajdt.internal.core.builder.AsmBuilder.build(AsmBuilder.java:66)
    at org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.finishedCompilationUnit(EclipseFactory.java:303)
    at org.aspectj.ajdt.internal.compiler.AjCompiler.process(AjCompiler.java:67)
    at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:338)
    at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:372)
    at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:133)
    at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:78)
    at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:117)
    at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:164)
    LoadTest.java   CrefoClient/src/com/dcbank/scoring/socketserver 
 
kind regards
   Arno Schmidmeier</description>
      <comments>
		<comment id="1" date="2003-07-22 20:34:32 EDT" author="Jim Hugunin">This appears to be caused by an invalid local type declaration causing the asm 
builder to be confused.  I'm assigning this to Mik in the hopes that he'll 
have the time to isolate this into a test case.  The fix is almost certainly 
to add a null check on AsmBuilder.java:231; however, I'd like to get a test 
case that reproduces the bug before fixing it.</comment>
		<comment id="2" date="2003-07-30 05:07:10 EDT" author="Mik Kersten">Added AsmBuilderTest class that tests handling for this and related null 
parameters.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="78869703a8bf08bfa4e8f19b26dcf877949b0ad2" author="mkersten" date="2003-07-30 06:10:45"/>
          <file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmBuilder.java">
          </file>
          <file name="org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/core/builder/AjdtBuilderTests.java">
              <method name="suite" returnType="Test" parameters=""/>
          </file>
          <file name="org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/core/builder/AsmBuilderTest.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="40257" opendate="2003-7-16 15:06:00" fixdate="2003-08-07 03:52:38">
    <buginformation>
      <summary>"parsing of ""../"" paths in LST files is broken"</summary>
      <description>Relative paths (e.g. "../") are no longer parser properly in AJDE 1.1.0.</description>
      <comments>
		<comment id="1" date="2003-08-07 03:52:38 EDT" author="Mik Kersten">Fixed in 1.1.1</comment>
		<comment id="2" date="2003-08-28 06:40:19 EDT" author="Adrian Colyer">updated target milestone field to 1.1.1</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="acdf688ccc4d8b376141b2c8e28bc5d7b7612e90" author="mkersten" date="2003-08-07 05:10:01"/>
          <file name="ajbrowser/testsrc/org/aspectj/tools/ajbrowser/InteractiveBrowserTest.java">
          </file>
          <file name="ajde/src/org/aspectj/ajde/ui/swing/CompilerMessagesCellRenderer.java">
              <method name="getListCellRendererComponent" returnType="Component" parameters="JList Object int boolean boolean"/>
          </file>
          <file name="org.aspectj.ajdt.core/testdata/bug-40257/d1/A.java">
          </file>
          <file name="org.aspectj.ajdt.core/testdata/bug-40257/d1/d2/B.java">
          </file>
          <file name="org.aspectj.ajdt.core/testdata/bug-40257/d3/C.java">
          </file>
          <file name="org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/ajc/AjdtAjcTests.java">
              <method name="suite" returnType="Test" parameters=""/>
          </file>
          <file name="org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/ajc/BuildArgParserTestCase.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="41123" opendate="2003-8-5 0:39:00" fixdate="2003-08-07 21:32:11">
    <buginformation>
      <summary>Weaving failure when using injars</summary>
      <description>Sample run that fails using injars:
C:\devel\test\libraryWeave&gt;ajc ajee\testing\ExecutionMonitor.aj

C:\devel\test\libraryWeave&gt;jar cf ajee.jar ajee\testing\*.class

C:\devel\test\libraryWeave&gt;ajc -injars ajee.jar model\BusObj.java 
model\MonitorB
usObj.java
C:\devel\test\libraryWeave\model\BusObj.java:3 Class must implement the 
inherite
d abstract method ExecutionMonitor.MonitoredItem.ajc$interMethodDispatch2
$ajee_t
esting_ExecutionMonitor$record(String, String)
public class BusObj {
             ^^^^^^

1 error

It works in a single pass compilation:
C:\devel\test\libraryWeave&gt;ajc ajee\testing\ExecutionMonitor.aj 
model\BusObj.jav
a model\MonitorBusObj.java

C:\devel\test\libraryWeave&gt;

Sample source code:
package ajee.testing;

public aspect ExecutionMonitor {
    public interface MonitoredItem {}
    private void MonitoredItem.record(String eventType, String eventName) {}
}         
---
package model;

public class BusObj {

}
---
package model;

import ajee.testing.ExecutionMonitor;

public aspect MonitorBusObj {
    declare parents: BusObj implements ExecutionMonitor.MonitoredItem;
}</description>
      <comments>
		<comment id="1" date="2003-08-05 00:49:12 EDT" author="Ron Bodkin">I uncovered this bug in trying to track down the following compiler crash, 
which may or may not be related:
Kind Status Priority Description Resource In Folder
 Location
Error   Internal compiler error
java.lang.NullPointerException
 at org.aspectj.weaver.patterns.CflowPointcut.concretize1(CflowPointcut.java:126)
 at org.aspectj.weaver.patterns.ReferencePointcut.concretize1(ReferencePointcut.java:270)
 at org.aspectj.weaver.patterns.AndPointcut.concretize1(AndPointcut.java:88)
 at org.aspectj.weaver.patterns.AndPointcut.concretize1(AndPointcut.java:88)
 at org.aspectj.weaver.patterns.AndPointcut.concretize1(AndPointcut.java:88)
 at org.aspectj.weaver.patterns.ReferencePointcut.concretize1(ReferencePointcut.java:270)
 at org.aspectj.weaver.patterns.AndPointcut.concretize1(AndPointcut.java:88)
 at org.aspectj.weaver.patterns.Pointcut.concretize(Pointcut.java:127)
 at org.aspectj.weaver.patterns.Pointcut.concretize(Pointcut.java:120)
 at org.aspectj.weaver.Advice.concretize(Advice.java:216)
 at org.aspectj.weaver.CrosscuttingMembers.addShadowMunger(CrosscuttingMembers.java:78)
 at org.aspectj.weaver.CrosscuttingMembers.addShadowMungers(CrosscuttingMembers.java:72)
 at org.aspectj.weaver.ResolvedTypeX.collectCrosscuttingMembers(ResolvedTypeX.java:328)
 at org.aspectj.weaver.CrosscuttingMembersSet.addOrReplaceAspect(CrosscuttingMembersSet.java:50)
 at org.aspectj.ajdt.internal.compiler.ast.AspectDeclaration.buildInterTypeAndPerClause(AspectDeclaration.java:747)
 at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.buildInterTypeAndPerClause(AjLookupEnvironment.java:120)
 at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.buildInterTypeAndPerClause(AjLookupEnvironment.java:136)
 at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.completeTypeBindings(AjLookupEnvironment.java:87)
 at org.eclipse.jdt.internal.compiler.Compiler.beginToCompile(Compiler.java:310)
 at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:324)
 at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:372)
 at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:133)
 at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:78)
 at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:117)
 at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:164)
 ClaimForm.java
 ClaimsSample/src/com/newaspects/claimsSample/ui/controller </comment>
		<comment id="2" date="2003-08-07 04:41:57 EDT" author="Andrew Clement">I *think* the NPE that Ron mentions is a dup of another bug Jim fixed recently 
to do with concretizing advice too early when it was coming from a library.  I 
can recreate Rons initial bug with the currently available version of 1.1 - I'm 
going to retry it on a development build of 1.1.1.</comment>
		<comment id="3" date="2003-08-07 10:41:47 EDT" author="Andrew Clement">Also fails in the same way if I change it to:

ajc -aspectpath ajee.jar model\BusObj.java model\MonitorBusObj.java

Or

set CLASSPATH=ajee.jar
ajc model\*.java

Does that mean the method:

ExecutionMonitor.MonitoredItem.ajc$interMethodDispatch2
$ajee_testing_ExecutionMonitor$record(String, String)

is not being made synthetic when it is written out?</comment>
		<comment id="4" date="2003-08-07 21:32:11 EDT" author="Jim Hugunin">Andy was right on both counts.  Ron's original stack-trace issue has been
resolved.  This bug is caused by the weaver not putting the Synthetic attribute
on methods with mangled names, which can cause problems for code that extends
those classes/interfaces.

In addition to adding the Synthetic attribute, I also added several checks in
the eclipse compiler phase to produce errors when a class implements an
interface that has either non-abstract methods or non-static fields -- and the
aspect that produced those is not on the source or aspectpath.  Without this
error, it is easy for ajc to generate code that will have unimplemented method
exceptions thrown at runtime from the VM.</comment>
		<comment id="5" date="2003-08-28 08:07:08 EDT" author="Adrian Colyer">updated target milestone field to 1.1.1</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="3e5974557278e81a9891edd4269eca39a8d42f43" author="jhugunin" date="2003-08-08 10:23:31"/>
          <file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java">
              <method name="weaveInterTypeDeclarations" returnType="void" parameters="SourceTypeBinding Collection Collection boolean"/>
          </file>
          <file name="tests/bugs/moreInterfaceLibrary/model/BusObj.java">
          </file>
          <file name="tests/bugs/moreInterfaceLibrary/model/MonitorBusObj.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="40380" opendate="2003-07-17 11:08:00" fixdate="2003-07-23 13:11:59">
    <buginformation>
      <summary>AspectJ does not honour libraries defined via Project Properties</summary>
      <description>AJDT 1.1.3, Eclipse 2.1

To build a JDK 1.4. program under Eclipse using JDK 1.3 the appropriate build 
library should be selected in the Project Properties "Java Build Path". 
However AspectJ continues to use the JDK associated with Eclipse so errors 
result from using 1.4 APIs. The same will occur running Eclipse under 1.4 and 
compiling programs for 1.5

Testcase:
1. Run Eclipse under JDK 1.3
2. Create a Java project which uses a 1.4 JDK
3. Write a Java classes that uses 1.4 APIs e.g.

public class TestStringBuffer {

	public  static void main(String[] args) {
		new StringBuffer("Test").indexOf("T");
  	}
}
4. Convert to AspectJ project</description>
      <comments>
		<comment id="1" date="2003-07-23 13:11:59 EDT" author="Mik Kersten">Fixed.  The problem was not with project settings, but with the fact that the 
AspectJ compiler was always getting the user's classpath and prepending it to 
the classpath set by the IDE.</comment>
		<comment id="2" date="2003-08-28 08:17:04 EDT" author="Adrian Colyer">updated target milestone to 1.1.4</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="d5ea336dac0b484629f6453afcc7b271446732d4" author="mkersten" date="2003-07-24 02:23:22"/>
          <file name="ajde/src/org/aspectj/ajde/internal/CompilerAdapter.java">
          </file>
          <file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/AjdtCommand.java">
              <method name="doCommand" returnType="boolean" parameters="IMessageHandler boolean"/>
          </file>
          <file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java">
              <method name="BuildArgParser" returnType="null" parameters=""/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="42539" opendate="2003-9-4 11:15:00" fixdate="2003-9-4 11:44:00">
    <buginformation>
      <summary>throw derivative pointcuts not advised.</summary>
      <description>Given the following point cut and advice:

public aspect ExceptionAspect
{
    pointcut exceptionThrower() : execution(public * ExceptionBugTest.*(..)
throws Exception+);

    declare warning : exceptionThrower() : "throws Exception+";
}

And the to be aspected code:

public class ExceptionBugTest
{

    class MyException extends Exception
    {
    }

    public void method1() throws Exception
    {
    }

    public void method2() throws MyException
    {
    }
}

listing file default.lst:
C:\temp\AJC Bug\ExceptionAspect.aj
C:\temp\AJC Bug\ExceptionBugTest.java


AJC does not advise ExceptionBugTest.method2().  The output from the compilation
is the following:
C:\temp\AJC Bug&gt;ajc -argfile default.lst -classpath %ASPECTJ_HOME%\lib\aspectjrt.jar
C:\eclipse\workspace\AJC Bug\ExceptionBugTest.java:11 throws Exception+

From the aspect-j mailing list, contributed by Jim Hugunin:
&amp;lt;detail&amp;gt;The bug was caused because the code for ThrowsPattern mistakenly
used the internal protected method TypePattern.matchesExactly instead of the
external public method TypePattern.matchesStatically.  Because the classes were
in the same package, Java's accessibility rules allowed this.  It would be nice
if there was an easy way to specifiy that a method could only be accessed from
subtypes.&amp;lt;/detail&amp;gt;</description>
      <comments>
		<comment id="1" date="2003-09-04 11:16:53 EDT" author="Keith Sader">Created attachment 5985 [details]
A to be advised class</comment>
		<comment id="2" date="2003-09-04 11:17:19 EDT" author="Keith Sader">Created attachment 5986 [details]
The offending aspect and pointcut</comment>
		<comment id="3" date="2003-09-04 11:17:33 EDT" author="Keith Sader">Created attachment 5987 [details]
listing file for ajc</comment>
		<comment id="4" date="2003-09-04 11:44:35 EDT" author="Jim Hugunin">The test provided has been added to tests/bugs/throwsSignature.  This bug is now
fixed in the tree for the 1.1.1 release.  Thanks for the clear and easy to
reproduce bug report.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="8660cc12bfbcd6f4957abd4dfc84735de6c048cf" author="jhugunin" date="2003-09-05 12:49:08"/>
          <file name="tests/bugs/throwsSignature/ExceptionAspect.java">
          </file>
          <file name="tests/bugs/throwsSignature/ExceptionBugTest.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/patterns/ThrowsPattern.java">
              <method name="matchesAny" returnType="boolean" parameters="TypePattern ResolvedTypeX[]"/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="42993" opendate="2003-9-12 4:26:00" fixdate="2003-9-12 12:55:00">
    <buginformation>
      <summary>"Language regression, or possible language improvement?"</summary>
      <description>The file AspectBug.java:

public aspect AspectBug extends AbstractCaching
perthis(execution(ContainerLoader+.new(..)))
{
	declare parents: ContainerDescriptor implements AbstractCaching.Key;

	protected pointcut loadExecutions( Key key ):
		ContainerLoader.containerLoads( *, key );
}

abstract aspect AbstractCaching  {
	interface Key {}
	protected abstract pointcut loadExecutions(Key key);
}

class Key {
}

class ContainerDescriptor {
}

class ActiveContainer {
}

class ContainerLoader {
	public ActiveContainer createContainer(ContainerDescriptor c) {
		return null;
	}

    public pointcut containerLoads(ContainerLoader loader,
								   
ContainerDescriptor containerDesc ):
        this(loader) &amp;&amp; args(containerDesc)
        &amp;&amp; execution(ActiveContainer ContainerLoader.createContainer
(ContainerDescriptor));
}

        First, here are the versions of AspectJ I'm using (this is a bash
        shell under cygwin on Windows XP):

~&gt; CLASSPATH='C:\aspectj1.0\lib\aspectjrt.jar' /cygdrive/c/aspectj1.0/bin/ajc -
version
ajc version 1.0.6 (built Jul 24, 2002 6:21 PM PST) running on java 1.4.1_02
~&gt; CLASSPATH='C:\aspectj1.1\lib\aspectjrt.jar' /cygdrive/c/aspectj1.1/bin/ajc -
version
AspectJ Compiler 1.1.0
~&gt; CLASSPATH='C:\aspectj1.1.1rc1
\lib\aspectjrt.jar' /cygdrive/c/aspectj1.1.1rc1/bin/ajc -version
AspectJ Compiler 1.1.1rc1
~&gt; CLASSPATH='C:\aspectj1.1.1
\lib\aspectjrt.jar' /cygdrive/c/aspectj1.1.1/bin/ajc -version
AspectJ Compiler 1.1.1

        For all four of these compilers, I give them the AspectBug.java file
	(which is attached):

~&gt; CLASSPATH='C:\aspectj1.0\lib\aspectjrt.jar' /cygdrive/c/aspectj1.0/bin/ajc 
AspectBug.java
~&gt; CLASSPATH='C:\aspectj1.1\lib\aspectjrt.jar' /cygdrive/c/aspectj1.1/bin/ajc 
AspectBug.java
~&gt; CLASSPATH='C:\aspectj1.1.1rc1
\lib\aspectjrt.jar' /cygdrive/c/aspectj1.1.1rc1/bin/ajc AspectBug.java
~&gt; CLASSPATH='C:\aspectj1.1.1
\lib\aspectjrt.jar' /cygdrive/c/aspectj1.1.1/bin/ajc AspectBug.java
C:\Documents and Settings\Macneil Shonle\AspectBug.java:7 incompatible type, 
expected ContainerDescriptor found BindingTypePattern(AbstractCaching$Key, 0)

1 error

        As you can see, only the final run (with the Sept 11 build of
	ajc) do we see the "incompatible type" error. If this is not a
	regression but a desirable result, how should the code be ported?</description>
      <comments>
		<comment id="1" date="2003-09-12 12:55:32 EDT" author="Jim Hugunin">This is a regression bug, and was easily reproduced from the nice self-contained
test included below.  It's marked as P1 because it is a regression from 1.1.0
and 1.1.1rc1.  This test is now in HEAD, along with a fix for the bug.

The problem was caused by moving name binding in pointcut declarations to happen
before declare parents are evaluated.  Because of this, the compiler doesn't
know that ContainerDescriptor isa Key when resolving the
ContainerLoader.containerLoads reference.

The change in ordering was made to fix a bug reported in declare error and
declare soft whose pcds where being evaluated before name binding had happened
in the pointcut declarations.  Unfortunately, declare error and declare soft are
concretized at the same time as declare parents (and all other declares , so
this move also led to the regression noted above. </comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="b5127388a3b5a2403e8d8944766bbe1895e09530" author="jhugunin" date="2003-09-13 01:49:58"/>
          <file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java">
              <method name="completeTypeBindings" returnType="void" parameters=""/>
          </file>
          <file name="tests/bugs/ParentsAndPointcuts.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/CrosscuttingMembersSet.java">
              <method name="addOrReplaceAspect" returnType="boolean" parameters="ResolvedTypeX"/>
          </file>
          <file name="weaver/src/org/aspectj/weaver/ResolvedTypeX.java">
              <method name="collectCrosscuttingMembers" returnType="CrosscuttingMembers" parameters=""/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="39993" opendate="2003-7-13 15:02:00" fixdate="2003-07-22 19:11:57">
    <buginformation>
      <summary>ajc stack trace on declaring hashcode() method in aspect</summary>
      <description>From an email sent to the user's list 6/26/2003:
------------------------------------------
ajc 1.1 NPE when an aspect declares hashcode() as follows:

     interface Identifiable {
         void setId(Id id);
         Id getId();
     }
 
     aspect IdentifiableAspect {
         private Id Identifiable.id = null;
         public Id Identifiable.getId() {
 		return this.id;
 	  }
         public void Identifiable.setId(Id id) {
             this.id = id;
         }
 
         public int Identifiable.hashCode() {
             return (this.getId() == null)
                 ? super.hashCode()
                 : this.getId().hashCode();
         }
     }

A workaround for callers the compiler controls is to replace the declaration
with around advice:

     int around(Identifiable i): target(i)
         &amp;&amp; call(public int hashCode())
     {
         return (i.getId() == null)
             ? proceed(i)
             : i.getId().hashCode();
     }</description>
      <comments>
		<comment id="1" date="2003-07-22 13:32:01 EDT" author="Jim Hugunin">*** Bug 40589 has been marked as a duplicate of this bug. ***</comment>
		<comment id="2" date="2003-07-22 13:34:26 EDT" author="Jim Hugunin">Raising to P2 based on second independent report of problem.  I'm working on a 
fix.</comment>
		<comment id="3" date="2003-07-22 19:11:57 EDT" author="Jim Hugunin">tests and fix in tree

Handle use of super inside of inter-type declaration on an interface.  If the 
interface has more than one super interface, that is a compile-time error
because super can not be resolved.</comment>
		<comment id="4" date="2003-08-28 08:06:39 EDT" author="Adrian Colyer">updated target milestone field to 1.1.1</comment>
		<comment id="5" date="2003-09-16 13:08:39 EDT" author="Jim Hugunin">*** Bug 43163 has been marked as a duplicate of this bug. ***</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="026b2728aef846823419ebffceb57fe8161e3d15" author="jhugunin" date="2003-07-23 05:57:17"/>
          <file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/InterSuperFixerVisitor.java">
          </file>
          <file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/InterSuperReference.java">
          </file>
          <file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/InterTypeDeclaration.java">
          </file>
          <file name="tests/bugs/MultipleSuperCf.java">
          </file>
          <file name="tests/bugs/OverridingInterfaceObjectMethod.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java">
              <method name="mungeNewMethod" returnType="boolean" parameters="BcelClassWeaver NewMethodTypeMunger"/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="43194" opendate="2003-9-16 23:21:00" fixdate="2003-9-18 14:45:00">
    <buginformation>
      <summary>java.lang.VerifyError in generated code</summary>
      <description>See the attached file VerifyBug.jar for the source files. You won't need 
anything else to compiler and reproduce this bug:

~/bug&gt; ls
AbstractCaching.java   TreeNode.java         VerifyBug.jar
ContainerCaching.java  TreeNodeFolding.java  WorkspaceGroup.java
ContainerLoader.java   TreePanel.java        WorkspaceNode.java
Makefile               TreeWorkspace.java
~/bug&gt; gmake   
/cygdrive/c/aspectj1.1.1/bin/ajc -classpath "C:\aspectj1.1.1
\lib\aspectjrt.jar" -version
AspectJ Compiler 1.1.1

/cygdrive/c/aspectj1.1.1/bin/ajc -classpath "C:\aspectj1.1.1\lib\aspectjrt.jar" 
*.java
java -classpath "C:\aspectj1.1.1\lib\aspectjrt.jar;." TreeNode
java.lang.VerifyError: (class: TreeNode, method: doShowAction signature: ()V) 
Unable to pop operand off an empty stack
Exception in thread "main" make: *** [all] Error 1</description>
      <comments>
		<comment id="1" date="2003-09-16 23:23:30 EDT" author="Macneil Shonle">Created attachment 6124 [details]
9 source files, plus a Makefile for cygwin

The makefile isn't necessary, you just need to do a "ajc *.java" with the files
unjarred in a new directory. Then, run java as in the report.</comment>
		<comment id="2" date="2003-09-18 14:45:22 EDT" author="Jim Hugunin">Erik and I pair fixed this in the tree.  The bug was caused by
ReferencePointcut.concretize mutating state rather than behaving
properly functionally.

After removing the layers of after advice and cflow entry/exits, the
minimal test case is below.  The multiple levels of indirection, as
well as the concretization with a typename in the first advice followed
by concretization with a parameter name in the second are all required
to cause the bug.

class C {    
    public void m1() {}
    public void m2() {}
}

aspect A {    
    pointcut exec1(C c): this(c) &amp;&amp; execution(void m1());
    pointcut execs(C c): exec1(c); 
    
    before (): execs(*) {}
    before (C c):  execs(c) {}
}</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="fc0d2af02cc6b6f8a4d9425e3c1cdd166957dde9" author="jhugunin" date="2003-09-19 03:38:14"/>
          <file name="tests/bugs/AdviceInteraction.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/patterns/ReferencePointcut.java">
              <method name="concretize1" returnType="Pointcut" parameters="ResolvedTypeX IntMap"/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="43033" opendate="2003-9-12 13:34:00" fixdate="2003-9-19 3:48:00">
    <buginformation>
      <summary>Compiler crash in ajc head (post 1.1.1 rc1) on erroneous program</summary>
      <description>This must be caused by the fix to concretization...

Input sources:
package base;

public abstract aspect ExceptionHandling {
    public abstract pointcut scope();
    declare soft: Exception: scope();
}

package model;

import base.ExceptionHandling;

public aspect ModelExceptionHandling extends ExceptionHandling {
    public pointcut scope() : within(*);

    protected RuntimeException convertCheckedException(Throwable t) {
        return new RuntimeException(t.getMessage(), t
}

Compiler output:
C:\eclipse\workspace\atrack&gt;ajc -d debug @narrow.lst
java.lang.NullPointerException
        at org.aspectj.weaver.patterns.ReferencePointcut.concretize1(ReferencePointcut.java:243)
        at org.aspectj.weaver.patterns.Pointcut.concretize(Pointcut.java:127)
        at org.aspectj.weaver.patterns.Pointcut.concretize(Pointcut.java:110)
        at org.aspectj.weaver.CrosscuttingMembers.addDeclare(CrosscuttingMembers.java:111)
        at org.aspectj.weaver.CrosscuttingMembers.addDeclares(CrosscuttingMembers.java:92)
        at org.aspectj.weaver.ResolvedTypeX.collectCrosscuttingMembers(ResolvedTypeX.java:332)
        at org.aspectj.weaver.CrosscuttingMembersSet.addOrReplaceAspect(CrosscuttingMembersSet.java:50)
        at org.aspectj.ajdt.internal.compiler.ast.AspectDeclaration.buildInterTypeAndPerClause(AspectDeclaration.java:754)
        at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.buildInterTypeAndPerClause(AjLookupEnvironment.java:124)
        at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.completeTypeBindings(AjLookupEnvironment.java:91)
        at org.eclipse.jdt.internal.compiler.Compiler.beginToCompile(Compiler.java:310)
        at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:324)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:373)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:125)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:70)
        at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:99)
        at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:53)
        at org.aspectj.tools.ajc.Main.run(Main.java:217)
        at org.aspectj.tools.ajc.Main.runMain(Main.java:155)
        at org.aspectj.tools.ajc.Main.main(Main.java:72)
C:\eclipse\workspace\atrack\src\org\atrack\model\error\impl\ModelExceptionHandling.java:0 Internal compiler error
java.lang.NullPointerException
        at org.aspectj.weaver.patterns.ReferencePointcut.concretize1(ReferencePointcut.java:243)
        at org.aspectj.weaver.patterns.Pointcut.concretize(Pointcut.java:127)
        at org.aspectj.weaver.patterns.Pointcut.concretize(Pointcut.java:110)
        at org.aspectj.weaver.CrosscuttingMembers.addDeclare(CrosscuttingMembers.java:111)
        at org.aspectj.weaver.CrosscuttingMembers.addDeclares(CrosscuttingMembers.java:92)
        at org.aspectj.weaver.ResolvedTypeX.collectCrosscuttingMembers(ResolvedTypeX.java:332)
        at org.aspectj.weaver.CrosscuttingMembersSet.addOrReplaceAspect(CrosscuttingMembersSet.java:50)
        at org.aspectj.ajdt.internal.compiler.ast.AspectDeclaration.buildInterTypeAndPerClause(AspectDeclaration.java:754)
        at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.buildInterTypeAndPerClause(AjLookupEnvironment.java:124)
        at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.completeTypeBindings(AjLookupEnvironment.java:91)
        at org.eclipse.jdt.internal.compiler.Compiler.beginToCompile(Compiler.java:310)
        at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:324)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:373)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:125)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:70)
        at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:99)
        at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:53)
        at org.aspectj.tools.ajc.Main.run(Main.java:217)
        at org.aspectj.tools.ajc.Main.runMain(Main.java:155)
        at org.aspectj.tools.ajc.Main.main(Main.java:72)


!! no source information available !!
C:\eclipse\workspace\atrack\src\org\atrack\model\error\impl\ModelExceptionHandling.java:23 Unmatched bracket
return new RuntimeException(t.getMessage(), t
                           ^
ABORT
Exception thrown from AspectJ DEVELOPMENT

This might be logged as a bug already -- find current bugs at
  http://bugs.eclipse.org/bugs/buglist.cgi?product=AspectJ&amp;component=Compiler

Bugs for exceptions thrown have titles File:line from the top stack,
e.g., "SomeFile.java:243"

If you don't find the exception below in a bug, please add a new bug
at http://bugs.eclipse.org/bugs/enter_bug.cgi?product=AspectJ
To make the bug a priority, please include a test program
that can reproduce this exception.
null
java.lang.NullPointerException
        at org.aspectj.weaver.patterns.ReferencePointcut.concretize1
(ReferencePo
intcut.java:243)
        at org.aspectj.weaver.patterns.Pointcut.concretize(Pointcut.java:127)
        at org.aspectj.weaver.patterns.Pointcut.concretize(Pointcut.java:110)
        at org.aspectj.weaver.CrosscuttingMembers.addDeclare(CrosscuttingMembers.java:111)
        at org.aspectj.weaver.CrosscuttingMembers.addDeclares(CrosscuttingMembers.java:92)
        at org.aspectj.weaver.ResolvedTypeX.collectCrosscuttingMembers(ResolvedTypeX.java:332)
        at org.aspectj.weaver.CrosscuttingMembersSet.addOrReplaceAspect(CrosscuttingMembersSet.java:50)
        at org.aspectj.ajdt.internal.compiler.ast.AspectDeclaration.buildInterTypeAndPerClause(AspectDeclaration.java:754)
        at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.buildInterTypeAndPerClause(AjLookupEnvironment.java:124)
        at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.completeTypeBindings(AjLookupEnvironment.java:91)
        at org.eclipse.jdt.internal.compiler.Compiler.beginToCompile(Compiler.java:310)
        at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:324)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:373)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:125)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:70)
        at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:99)
        at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:53)
        at org.aspectj.tools.ajc.Main.run(Main.java:217)
        at org.aspectj.tools.ajc.Main.runMain(Main.java:155)
        at org.aspectj.tools.ajc.Main.main(Main.java:72)


1 fail|abort, 2 errors

C:\eclipse\workspace\atrack&gt;cd \devel\test\excHandling\c1

C:\devel\test\excHandling\c1&gt;ajc base\ExceptionHandling.java 
model\ModelExceptio
nHandling.java
java.lang.NullPointerException
        at org.aspectj.weaver.patterns.ReferencePointcut.concretize1(ReferencePointcut.java:243)
        at org.aspectj.weaver.patterns.Pointcut.concretize(Pointcut.java:127)
        at org.aspectj.weaver.patterns.Pointcut.concretize(Pointcut.java:110)
        at org.aspectj.weaver.CrosscuttingMembers.addDeclare(CrosscuttingMembers.java:111)
        at org.aspectj.weaver.CrosscuttingMembers.addDeclares(CrosscuttingMembers.java:92)
        at org.aspectj.weaver.ResolvedTypeX.collectCrosscuttingMembers(ResolvedTypeX.java:332)
        at org.aspectj.weaver.CrosscuttingMembersSet.addOrReplaceAspect(CrosscuttingMembersSet.java:50)
        at org.aspectj.ajdt.internal.compiler.ast.AspectDeclaration.buildInterTypeAndPerClause(AspectDeclaration.java:754)
        at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.buildInterTypeAndPerClause(AjLookupEnvironment.java:124)
        at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.completeTypeBindings(AjLookupEnvironment.java:91)
        at org.eclipse.jdt.internal.compiler.Compiler.beginToCompile(Compiler.java:310)
        at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:324)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:373)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:125)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:70)
        at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:99)
        at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:53)
        at org.aspectj.tools.ajc.Main.run(Main.java:217)
        at org.aspectj.tools.ajc.Main.runMain(Main.java:155)
        at org.aspectj.tools.ajc.Main.main(Main.java:72)
C:\devel\test\excHandling\c1\model\ModelExceptionHandling.java:0 Internal compiler error
java.lang.NullPointerException
        at org.aspectj.weaver.patterns.ReferencePointcut.concretize1(ReferencePointcut.java:243)
        at org.aspectj.weaver.patterns.Pointcut.concretize(Pointcut.java:127)
        at org.aspectj.weaver.patterns.Pointcut.concretize(Pointcut.java:110)
        at org.aspectj.weaver.CrosscuttingMembers.addDeclare(CrosscuttingMembers.java:111)
        at org.aspectj.weaver.CrosscuttingMembers.addDeclares(CrosscuttingMembers.java:92)
        at org.aspectj.weaver.ResolvedTypeX.collectCrosscuttingMembers(ResolvedTypeX.java:332)
        at org.aspectj.weaver.CrosscuttingMembersSet.addOrReplaceAspect(CrosscuttingMembersSet.java:50)
        at org.aspectj.ajdt.internal.compiler.ast.AspectDeclaration.buildInterTypeAndPerClause(AspectDeclaration.java:754)
        at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.buildInterTypeAndPerClause(AjLookupEnvironment.java:124)
        at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.completeTypeBindings(AjLookupEnvironment.java:91)
        at org.eclipse.jdt.internal.compiler.Compiler.beginToCompile(Compiler.java:310)
        at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:324)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:373)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:125)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:70)
        at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:99)
        at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:53)
        at org.aspectj.tools.ajc.Main.run(Main.java:217)
        at org.aspectj.tools.ajc.Main.runMain(Main.java:155)
        at org.aspectj.tools.ajc.Main.main(Main.java:72)


!! no source information available !!
C:\devel\test\excHandling\c1\model\ModelExceptionHandling.java:9 Unmatched bracket
return new RuntimeException(t.getMessage(), t
                           ^
ABORT
Exception thrown from AspectJ DEVELOPMENT

This might be logged as a bug already -- find current bugs at
  http://bugs.eclipse.org/bugs/buglist.cgi?product=AspectJ&amp;component=Compiler

Bugs for exceptions thrown have titles File:line from the top stack,
e.g., "SomeFile.java:243"

If you don't find the exception below in a bug, please add a new bug
at http://bugs.eclipse.org/bugs/enter_bug.cgi?product=AspectJ
To make the bug a priority, please include a test program
that can reproduce this exception.
null
java.lang.NullPointerException
        at org.aspectj.weaver.patterns.ReferencePointcut.concretize1(ReferencePointcut.java:243)
        at org.aspectj.weaver.patterns.Pointcut.concretize(Pointcut.java:127)
        at org.aspectj.weaver.patterns.Pointcut.concretize(Pointcut.java:110)
        at org.aspectj.weaver.CrosscuttingMembers.addDeclare(CrosscuttingMembers.java:111)
        at org.aspectj.weaver.CrosscuttingMembers.addDeclares(CrosscuttingMembers.java:92)
        at org.aspectj.weaver.ResolvedTypeX.collectCrosscuttingMembers(ResolvedTypeX.java:332)
        at org.aspectj.weaver.CrosscuttingMembersSet.addOrReplaceAspect(CrosscuttingMembersSet.java:50)
        at org.aspectj.ajdt.internal.compiler.ast.AspectDeclaration.buildInterTypeAndPerClause(AspectDeclaration.java:754)
        at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.buildInterTypeAndPerClause(AjLookupEnvironment.java:124)
        at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.completeTypeBindings(AjLookupEnvironment.java:91)
        at org.eclipse.jdt.internal.compiler.Compiler.beginToCompile(Compiler.java:310)
        at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:324)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:373)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:125)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:70)
        at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:99)
        at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:53)
        at org.aspectj.tools.ajc.Main.run(Main.java:217)
        at org.aspectj.tools.ajc.Main.runMain(Main.java:155)
        at org.aspectj.tools.ajc.Main.main(Main.java:72)


1 fail|abort, 2 errors</description>
      <comments>
		<comment id="1" date="2003-09-18 11:59:39 EDT" author="Andrew Clement">Created attachment 6145 [details]
Minor fix to avoid the NPE</comment>
		<comment id="2" date="2003-09-18 12:34:21 EDT" author="Jim Hugunin">Andy seems to be on top of this one.</comment>
		<comment id="3" date="2003-09-18 16:53:10 EDT" author="Andrew Clement">I've sent the test suite changes direct to Adrian to integrate.  They consist 
of the programs Ron provided.

- Andy.</comment>
		<comment id="4" date="2003-09-19 03:48:06 EDT" author="Adrian Colyer">Fixed by patch and test cases contributed by Andy Clement.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="53570863fa77364052937376a0ff65ce2fa37842" author="acolyer" date="2003-09-19 05:16:17"/>
          <file name="tests/bugs/concretizeNpe/base/ExceptionHandling.java">
          </file>
          <file name="tests/bugs/concretizeNpe/model/ModelExceptionHandling.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/patterns/ReferencePointcut.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="43709" opendate="2003-09-25 18:30:00" fixdate="2003-09-26 01:23:00">
    <buginformation>
      <summary>structure view crash when extending library aspects</summary>
      <description>I have an library with an aspect that includes advice, which I compile into an 
outjar. In my client project I extend it, and make a concrete pointcut that 
results in the library aspect affecting parts of my system. 

There is a bug and an enhancement request here:

1) A bug: when you look at the structure view for affected classes, there is a 
problem if you try to navigate from calls to advice (in AJDT, it results in an 
NPE). Here is the stack trace in AJDT:
java.lang.NullPointerException
at org.aspectj.asm.internal.ProgramElement.toLinkLabelString(ProgramElement.java:403)
at org.eclipse.ajdt.internal.core.AJDTStructureViewNode.getLabel(AJDTStructureViewNode.java:171)
at org.eclipse.ajdt.internal.core.AJDTStructureViewNodeAdapter.getLabel(AJDTStructureViewNodeAdapter.java:89)
at org.eclipse.ui.model.WorkbenchLabelProvider.getText(WorkbenchLabelProvider.java:142)
at org.eclipse.jface.viewers.TreeViewer.doUpdateItem(TreeViewer.java:95)
at org.eclipse.jface.viewers.AbstractTreeViewer$UpdateItemSafeRunnable.run(AbstractTreeViewer.java:87)
at org.eclipse.core.internal.runtime.InternalPlatform.run(InternalPlatform.java:1006)
at org.eclipse.core.runtime.Platform.run(Platform.java:413)
at org.eclipse.jface.viewers.AbstractTreeViewer.doUpdateItem(AbstractTreeViewer.java:406)
at org.eclipse.jface.viewers.StructuredViewer$UpdateItemSafeRunnable.run(StructuredViewer.java:119)
at org.eclipse.core.internal.runtime.InternalPlatform.run(InternalPlatform.java:1006)
at org.eclipse.core.runtime.Platform.run(Platform.java:413)
at org.eclipse.jface.viewers.StructuredViewer.updateItem(StructuredViewer.java:1271)
at org.eclipse.jface.viewers.AbstractTreeViewer.createTreeItem(AbstractTreeViewer.java:320)
at org.eclipse.jface.viewers.AbstractTreeViewer$1.run(AbstractTreeViewer.java:303)
at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:69)
at org.eclipse.jface.viewers.AbstractTreeViewer.createChildren(AbstractTreeViewer.java:289)
at org.eclipse.jface.viewers.AbstractTreeViewer.handleTreeExpand(AbstractTreeViewer.java:697)
at org.eclipse.jface.viewers.AbstractTreeViewer$4.treeExpanded(AbstractTreeViewer.java:709)
at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:175)
at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:81)
at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:840)
at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:865)
at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:849)
at org.eclipse.swt.widgets.Tree.wmNotifyChild(Tree.java:1909)
at org.eclipse.swt.widgets.Control.WM_NOTIFY(Control.java:3815)
at org.eclipse.swt.widgets.Composite.WM_NOTIFY(Composite.java:642)
at org.eclipse.swt.widgets.Control.windowProc(Control.java:2816)
at org.eclipse.swt.widgets.Display.windowProc(Display.java:2361)
at org.eclipse.swt.internal.win32.OS.CallWindowProcW(Native Method)
at org.eclipse.swt.internal.win32.OS.CallWindowProc(OS.java:1236)
at org.eclipse.swt.widgets.Tree.callWindowProc(Tree.java:156)
at org.eclipse.swt.widgets.Tree.WM_LBUTTONDOWN(Tree.java:1517)
at org.eclipse.swt.widgets.Control.windowProc(Control.java:2799)
at org.eclipse.swt.widgets.Display.windowProc(Display.java:2361)
at org.eclipse.swt.internal.win32.OS.DispatchMessageW(Native Method)
at org.eclipse.swt.internal.win32.OS.DispatchMessage(OS.java:1303)
at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1543)
at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:1402)
at org.eclipse.ui.internal.Workbench.run(Workbench.java:1385)
at org.eclipse.core.internal.boot.InternalBootLoader.run(InternalBootLoader.java:858)
at org.eclipse.core.boot.BootLoader.run(BootLoader.java:461)
at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
at java.lang.reflect.Method.invoke(Unknown Source)
at org.eclipse.core.launcher.Main.basicRun(Main.java:291)
at org.eclipse.core.launcher.Main.run(Main.java:747)
at org.eclipse.core.launcher.Main.main(Main.java:583)
 

2) The enhancement request: the concrete aspect that applies the advice should 
also show what is affected in the project. Of course, it would also be nice to 
see how a given concrete library aspect in the aspect path affects your 
project too.</description>
      <comments>
		<comment id="1" date="2003-09-26 01:23:56 EDT" author="Mik Kersten">The bad news is that the NPE shows in the typical uninformative Eclipse 
dialog.  The good news is that once the user click's "OK" there are no 
problems other than the lack of a label for that node.  The problem stems from 
the fact that I never implemented the case of structure model elements living 
inside JARs.

I've fixed this, added a corresponding test project to AJDT, and added some UI 
support to make it clear when something is being advised by an aspect in an 
injar.  Since navigating to the sourceline of the aspect in the injar is not 
possible the label is grayed-out.  Also note that I finally added hyperlink 
style coloring to the link nodes in the outline (by adding an 
AspectJLabelProvider).

So it's all working in CVS.  But the label for injar could be improved (e.g. 
give the path to the injar, and the full signature of the advice).  That's 
doable but might require us to change the IProgramElement String handle 
format, since elements in bytecode aren't naturally identified by sourcelines--
so at the moment we can only look up the sourcefile containing the aspect.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="426d89b639c5f64504ff372b849495d75cdc7540" author="mkersten" date="2003-09-26 02:24:49"/>
          <file name="asm/src/org/aspectj/asm/internal/ProgramElement.java">
              <method name="toSignatureString" returnType="String" parameters=""/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="44117" opendate="2003-10-03 01:17:00" fixdate="2003-10-16 11:27:00">
    <buginformation>
      <summary>NPE on compile</summary>
      <description>java.lang.NullPointerException
at org.aspectj.weaver.AsmRelationshipProvider.checkerMunger(AsmRelationshipProvider.java:51)
at org.aspectj.weaver.Checker.match(Checker.java:58)
at org.aspectj.weaver.bcel.BcelClassWeaver.match(BcelClassWeaver.java:985)
at org.aspectj.weaver.bcel.BcelClassWeaver.match(BcelClassWeaver.java:791)
at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:291)
at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:77)
at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:417)
at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:390)
at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:316)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.weaveAndGenerateClassFiles(AjBuildManager.java:256)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:156)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:70)
at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:103)
at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run
(AspectJBuildManager.java:165)</description>
      <comments>
		<comment id="1" date="2003-10-16 11:27:17 EDT" author="Mik Kersten">I've fixed this NPE.  I'm guessing that it was the result of relationships 
trying to map into JARs that they couldn't produce an accurate sourceline 
for.  We may need to improve upon the structure in the model in this case.

Reports like this are much more useful when they're submitted with either a 
test case or at least some code triggering this to fail.  Due to limited time 
and the difficulty of determining the cause from a stack trace alone, I will 
be marking reports without a description of what causes them to fail down to 
P4 (unless they are blockers).</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="311725549a379f2bd3c0fcce2aaaae50b7a92ddb" author="mkersten" date="2003-10-17 12:15:45"/>
          <file name="weaver/src/org/aspectj/weaver/AsmRelationshipProvider.java">
              <method name="checkerMunger" returnType="void" parameters="IHierarchy Shadow Checker"/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="47318" opendate="2003-11-23 16:18:00" fixdate="2003-11-23 16:36:00">
    <buginformation>
      <summary>org.aspectj.asm.IRelationship.Kind.ALL does not contain all kinds</summary>
      <description>org.aspectj.asm.IRelationship.Kind.ALL is an array that should contain all kinds
that an IRelationship may have. There are three possible kinds defined in
IRelationship.java: ADVICE, DECLARE and DECLARE_INTER_TYPE. The Kind[] ALL does
only contain ADVICE and DECLARE. This can lead to an ArrayIndexOutOfBoundsException.</description>
      <comments>
		<comment id="1" date="2003-11-23 16:36:22 EST" author="Mik Kersten">This is now fixed in the current tree.  Thanks for the report!

Also, consider letting us know how you're using the ASM APIs in case there are 
other improvements needed for your application.  We want to make the ASM more 
complete so that we can invite more extensions to be built on it.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="bdc79f1b42c11fe2bcaa45bbaa5a063173777d28" author="mkersten" date="2003-11-24 06:32:30"/>
          <file name="asm/src/org/aspectj/asm/IRelationship.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="39436" opendate="2003-06-27 14:32:00" fixdate="2003-12-10 14:53:44">
    <buginformation>
      <summary>[Tasks] No summary shown in status line</summary>
      <description>build I20030625

The old tasks view showed a summary of the number of tasks, errors, warnings 
and infos in the status line.  This is missing in the reworked view.</description>
      <comments>
		<comment id="1" date="2003-07-02 22:27:51 EDT" author="Nick Edgar">This is a regression from 2.1.</comment>
		<comment id="2" date="2003-09-04 11:27:18 EDT" author="Nick Edgar">*** Bug 41213 has been marked as a duplicate of this bug. ***</comment>
		<comment id="3" date="2003-09-24 14:29:20 EDT" author="Debbie Wilson">Created attachment 6212 [details]
Proposed fix</comment>
		<comment id="4" date="2003-09-24 16:16:30 EDT" author="Debbie Wilson">Created attachment 6217 [details]
Proposed fix incorporating comments</comment>
		<comment id="5" date="2003-09-29 11:36:53 EDT" author="Debbie Wilson">Created attachment 6276 [details]
Proposed fix with Javadoc</comment>
		<comment id="6" date="2003-09-30 10:31:38 EDT" author="Debbie Wilson">Code released in time for I20030930.  Javadoc altered slightly and released 
for post-I20030930.</comment>
		<comment id="7" date="2003-10-07 14:04:46 EDT" author="Debbie Wilson">This fix appears to cause severe degradation of performance with Problems 
Views containing 1000+ markers that are filtered through a working set or 
selection list.  See bug 44069.</comment>
		<comment id="8" date="2003-10-14 11:03:02 EDT" author="Debbie Wilson">*** Bug 44726 has been marked as a duplicate of this bug. ***</comment>
		<comment id="9" date="2003-12-10 14:18:29 EST" author="Stefan Xenos">I believe this was fixed in the Dec 9 integration build.</comment>
		<comment id="10" date="2003-12-10 14:53:44 EST" author="Debbie Wilson">Thanks Stefan.  Changing to FIXED.</comment>
		<comment id="11" date="2003-12-10 16:08:46 EST" author="Debbie Wilson">Fix available I200312109+.</comment>
		<comment id="12" date="2003-12-16 11:27:18 EST" author="Debbie Wilson">Verified fixed in the Problems View in I20031216 (8am).  Note this no longer 
applies to the Tasks View.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="d90acdcedd63f04b906b0efc5e249e93245f5618" author="ehilsdal" date="2003-08-22 01:02:53"/>
          <file name="weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java">
              <method name="unpackLocals" returnType="void" parameters="MethodGen"/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="41952" opendate="2003-8-26 5:38:00" fixdate="2004-1-7 12:07:00">
    <buginformation>
      <summary>XLint warning for call PCD's using subtype of defining type</summary>
      <description>Some would like an XLint compiler warning when the user in a call PCD specifies
a declaring type that is not the defining type, because that constrains the join
points to those whose bytecode signature contain the specified type as the
declaring type.  e.g., 

----
class A { void run() {} }
class B extends A {}
aspect C {
    before() : call(void B.run()) { } // warn here
}
public class Main {
    public static void main(String[] args) {
        // ok with -1.4; otherwise, becomes A.run in bytecode
        new B().run();        
        // never works - compile-time type of reference is A, not B
        ((A) new B()).run();
}
----
This warning is useful for two reasons.  First, the user probably intended that
any call to an instance of that object be picked out (regardless of the
compile-time type of the reference used to make the call), and thus should use

   target(B) &amp;&amp; call(void run())

(This suggestion could be in the XLint message.)

Second, older compilers (i.e., compilers not using -1.4) would incorrectly
specify the declaring type of the method call as the first type in the hierarchy
which defined the method, so even if the user meant to constrain the join point
by the compile-time reference type, the bytecode signature could be incorrect
and the pointcut fail to pick out the join point.

One problem with this XLint warning is that is also picks out valid declare
warning/error statements enforcing requirements at compile-time about the type
of the reference used to invoke a method (e.g., when using a static reference of
the wrong type).  So perhaps the default level should be ignore.

See also bug 41888.</description>
      <comments>
		<comment id="1" date="2003-08-26 05:45:12 EDT" author="Wes Isberg">Created attachment 5851 [details]
adds requested XLint warning

This works but seem expensive and like there are probably utilities elsewhere
to do this kind of matching (the signature matches are not quite right).</comment>
		<comment id="2" date="2003-08-26 05:46:39 EDT" author="Wes Isberg">Created attachment 5852 [details]
minimal test case for the patch, to install in tests/bugs</comment>
		<comment id="3" date="2004-01-07 04:32:38 EST" author="Jim Hugunin">*** Bug 49371 has been marked as a duplicate of this bug. ***</comment>
		<comment id="4" date="2004-01-07 12:05:41 EST" author="Matthew Webster">fixed in tree based on patch from George Harley and Matthew Webster</comment>
		<comment id="5" date="2004-01-07 12:07:28 EST" author="Jim Hugunin">see previous comment</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="97ab1e91dfba52187c14f0f7e5fdf6fafd9966c4" author="jhugunin" date="2004-01-08 02:00:52"/>
          <file name="bridge/src/org/aspectj/bridge/IMessage.java">
              <method name="getDetails" returnType="String" parameters=""/>
          </file>
          <file name="bridge/src/org/aspectj/bridge/Message.java">
          </file>
          <file name="bridge/src/org/aspectj/bridge/MessageUtil.java">
              <method name="renderMessage" returnType="String" parameters="IMessage boolean"/>
          </file>
          <file name="bridge/src/org/aspectj/bridge/SourceLocation.java">
              <method name="toString" returnType="String" parameters=""/>
          </file>
          <file name="org.aspectj.ajdt.core/src/org/aspectj/tools/ajc/Main.java">
              <method name="render" returnType="String" parameters="IMessage"/>
          </file>
          <file name="testing/src/org/aspectj/testing/xml/SoftMessage.java">
          </file>
          <file name="tests/bugs/DeclaringTypeWarning.java">
          </file>
          <file name="tests/new/CallTypesI.java">
          </file>
          <file name="tests/new/IndeterminateArg.java">
              <method name="check" returnType="void" parameters="String JoinPoint"/>
          </file>
          <file name="tests/new/IndeterminateArgType.java">
              <method name="check" returnType="void" parameters="String JoinPoint"/>
          </file>
          <file name="weaver/src/org/aspectj/weaver/Checker.java">
              <method name="match" returnType="boolean" parameters="Shadow World"/>
          </file>
          <file name="weaver/src/org/aspectj/weaver/Lint.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/patterns/AndPointcut.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/patterns/ExactTypePattern.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/patterns/KindedPointcut.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/patterns/NotPointcut.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/patterns/OrPointcut.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/patterns/Pointcut.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/patterns/ReferencePointcut.java">
              <method name="concretize1" returnType="Pointcut" parameters="ResolvedTypeX IntMap"/>
          </file>
          <file name="weaver/src/org/aspectj/weaver/patterns/SignaturePattern.java">
              <method name="read" returnType="SignaturePattern" parameters="DataInputStream ISourceContext"/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="49250" opendate="2003-12-21 15:01:00" fixdate="2004-01-07 08:34:45">
    <buginformation>
      <summary>alias getCause for getWrappedThrowable in SoftException</summary>
      <description>SoftException should implement getCause():

   public Throwable getCause() {
       return inner;
   }

(As pointed out by Ramnivas, misc mail messages, code comments...)

Using getCause() means the chain should print as expected in 1.4+, esp. when
SoftException is itself wrapped as a RemoteException.  Since getCause()
replicates getWrappedThrowable(), we could deprecate that, but we must continue
to support it to maintain upwards binary compatibility in the runtime classes.</description>
      <comments>
		<comment id="1" date="2004-01-07 08:34:45 EST" author="Andrew Clement">getCause() on SoftException has been added.  Testcase added to verify it works 
as expected on 1.3 JVMs.  Adrian is integrating the patch right now ...</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="eac16aee966695c8f0d22c4961c63a27e61dd2bf" author="acolyer" date="2004-01-07 10:30:26"/>
          <file name="runtime/src/org/aspectj/lang/SoftException.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="47754" opendate="2003-11-29 3:48:00" fixdate="2004-01-07 11:05:00">
    <buginformation>
      <summary>illegal method modifier</summary>
      <description>the attached example throws this at class load time.

please note that this bug results in a different exception when happens in a 
different setup, and when the class is loaded by JBoss. (more cryptic, talking 
about generic class format error)



Exception in thread "main" java.lang.ClassFormatError: 
com/netvisor/nvsr/client/InvalidByteCodeBug$Test$ITest (Illegal method modifiers: 0x409)
        at java.lang.ClassLoader.defineClass0(Native Method)
        at java.lang.ClassLoader.defineClass(ClassLoader.java:537)
        at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:123)
        at java.net.URLClassLoader.defineClass(URLClassLoader.java:251)
        at java.net.URLClassLoader.access$100(URLClassLoader.java:55)
        at java.net.URLClassLoader$1.run(URLClassLoader.java:194)
        at java.security.AccessController.doPrivileged(Native Method)
        at java.net.URLClassLoader.findClass(URLClassLoader.java:187)
        at java.lang.ClassLoader.loadClass(ClassLoader.java:289)
        at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:274)
        at java.lang.ClassLoader.loadClass(ClassLoader.java:235)
        at java.lang.ClassLoader.loadClassInternal(ClassLoader.java:302)
        at java.lang.ClassLoader.defineClass0(Native Method)
        at java.lang.ClassLoader.defineClass(ClassLoader.java:537)
        at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:123)
        at java.net.URLClassLoader.defineClass(URLClassLoader.java:251)
        at java.net.URLClassLoader.access$100(URLClassLoader.java:55)
        at java.net.URLClassLoader$1.run(URLClassLoader.java:194)
        at java.security.AccessController.doPrivileged(Native Method)
        at java.net.URLClassLoader.findClass(URLClassLoader.java:187)
        at java.lang.ClassLoader.loadClass(ClassLoader.java:289)
        at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:274)
        at java.lang.ClassLoader.loadClass(ClassLoader.java:235)
        at java.lang.ClassLoader.loadClassInternal(ClassLoader.java:302)
        at com.netvisor.nvsr.client.InvalidByteCodeBug.run(InvalidByteCodeBug.java:15)
        at com.netvisor.nvsr.client.InvalidByteCodeBug.main(InvalidByteCodeBug.java:8)</description>
      <comments>
		<comment id="1" date="2003-11-29 03:50:57 EST" author="attila lendvai">Created attachment 7008 [details]
bad bytecode is generated for this class

results in bad bytecode due to a static inter-type method declaration with the
CVS version of ajc. (sorry if i catched a checked-in half-done implementation
with this, as it was not supported before)</comment>
		<comment id="2" date="2004-01-07 11:05:00 EST" author="Adrian Colyer">The AspectJ compiler was not signalling an error when attempting to declare a 
static method on an interface (via an inter-type declaration).

Fixed by ACAC.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="7322131ad6d3c5c14114a6b7945757f45d438112" author="acolyer" date="2004-01-08 12:57:25"/>
          <file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/InterTypeMethodDeclaration.java">
          </file>
          <file name="tests/bugs/StaticInterfaceMethods.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="49638" opendate="2004-1-7 12:31:00" fixdate="2004-1-9 4:27:00">
    <buginformation>
      <summary>exception logging: after() throwing advice can't convert Throwable obj to string and ajc aborts</summary>
      <description>The problem is found by the example in Listing 5.15 from Laddad's AspectJ in
Action book. It looks like an exception object in after() throwing(Throwable ex)
advice has a problem being converted to string in a _logger.logp() call.

Environment
-----------
OS:
Solaris 8 kernel patch level 108528-27 plus j2se recommended patches

Java version:
java -version
java version "1.4.2"
Java(TM) 2 Runtime Environment, Standard Edition (build 1.4.2-b28)
Java HotSpot(TM) Client VM (build 1.4.2-b28, mixed mode)

The problem has also been reproduced with AspectJ 1.1.1 on Windows 2000
5.00.2195, SP 4.

Description
-----------
ajc aborts with the following output:

trouble in: 
public class TestException extends java.lang.Object:
  public static final org.aspectj.lang.JoinPoint$StaticPart ajc$tjp_0
  public static final org.aspectj.lang.JoinPoint$StaticPart ajc$tjp_1
  public void &lt;init&gt;():
                    ALOAD_0     // TestException this   (line 1)
                    INVOKESPECIAL java.lang.Object.&lt;init&gt; ()V
    constructor-execution(void TestException.&lt;init&gt;())
    |               RETURN
    constructor-execution(void TestException.&lt;init&gt;())
  end public void &lt;init&gt;()

  public static void main(String[]):
    method-execution(void TestException.main(java.lang.String[]))
    | method-call(void TestException.perform())
    | | catch java.lang.Throwable -&gt; E0
    | | |           INVOKESTATIC TestException.perform ()V   (line 4)
    | | catch java.lang.Throwable -&gt; E0
    | |             GOTO L0
    | |         E0: ASTORE_1
    | |             INVOKESTATIC ExceptionLoggerAspectV2.aspectOf
()LExceptionLoggerAspectV2;
    | |             ALOAD_1
    | |             GETSTATIC TestException.ajc$tjp_0
Lorg/aspectj/lang/JoinPoint$StaticPart;
    | |             INVOKEVIRTUAL
ExceptionLoggerAspectV2.ajc$after$ExceptionLoggerAspectV2$14a
(Ljava/lang/Throwable;Lorg/aspectj/lang/JoinPoint$StaticPart;)V
    | |             ALOAD_1
    | |             ATHROW
    | |         L0: NOP
    | |             ACONST_NULL
    | |             ASTORE_2
    | |             INVOKESTATIC ExceptionLoggerAspectV2.aspectOf
()LExceptionLoggerAspectV2;
    | |             ALOAD_2
    | |             CHECKCAST java.lang.Throwable
    | |             GETSTATIC TestException.ajc$tjp_0
Lorg/aspectj/lang/JoinPoint$StaticPart;
    | |             INVOKEVIRTUAL
ExceptionLoggerAspectV2.ajc$after$ExceptionLoggerAspectV2$14a
(Ljava/lang/Throwable;Lorg/aspectj/lang/JoinPoint$StaticPart;)V
    | |             NOP
    | method-call(void TestException.perform())
    |               RETURN   (line 5)
    method-execution(void TestException.main(java.lang.String[]))
  end public static void main(String[])

  public static void perform():
    method-execution(void TestException.perform())
    |               ACONST_NULL   (line 8)
    |               ASTORE_0
    |               ALOAD_0     // java.lang.Object nullObj   (line 9)
    | method-call(java.lang.String java.lang.Object.toString())
    | | catch java.lang.Throwable -&gt; E0
    | | |           INVOKEVIRTUAL java.lang.Object.toString ()Ljava/lang/String;
    | | catch java.lang.Throwable -&gt; E0
    | |             GOTO L0
    | |         E0: ASTORE_1
    | |             INVOKESTATIC ExceptionLoggerAspectV2.aspectOf
()LExceptionLoggerAspectV2;
    | |             ALOAD_1
    | |             GETSTATIC TestException.ajc$tjp_1
Lorg/aspectj/lang/JoinPoint$StaticPart;
    | |             INVOKEVIRTUAL
ExceptionLoggerAspectV2.ajc$after$ExceptionLoggerAspectV2$14a
(Ljava/lang/Throwable;Lorg/aspectj/lang/JoinPoint$StaticPart;)V
    | |             ALOAD_1
    | |             ATHROW
    | |         L0: NOP
    | method-call(java.lang.String java.lang.Object.toString())
    |               POP
    |               RETURN   (line 10)
    method-execution(void TestException.perform())
  end public static void perform()
end public class TestException
ABORT
Exception thrown from AspectJ 1.1.1

This might be logged as a bug already -- find current bugs at
  http://bugs.eclipse.org/bugs/buglist.cgi?product=AspectJ&amp;component=Compiler

Bugs for exceptions thrown have titles File:line from the top stack, 
e.g., "SomeFile.java:243"

If you don't find the exception below in a bug, please add a new bug
at http://bugs.eclipse.org/bugs/enter_bug.cgi?product=AspectJ
To make the bug a priority, please include a test program
that can reproduce this exception.
can't convert from java.lang.String to java.lang.Throwable
can't convert from java.lang.String to java.lang.Throwable
org.aspectj.weaver.BCException: can't convert from java.lang.String to
java.lang.Throwable
        at org.aspectj.weaver.bcel.Utility.appendConversion(Utility.java:203)
        at org.aspectj.weaver.bcel.BcelVar.appendLoadAndConvert(BcelVar.java:57)
        at org.aspectj.weaver.bcel.BcelAdvice.getAdviceArgSetup(BcelAdvice.java:287)
        at org.aspectj.weaver.bcel.BcelAdvice.getAdviceInstructions(BcelAdvice.java:244)
        at org.aspectj.weaver.bcel.BcelShadow.weaveAfterReturning(BcelShadow.java:986)
        at org.aspectj.weaver.bcel.BcelShadow.weaveAfter(BcelShadow.java:941)
        at org.aspectj.weaver.bcel.BcelAdvice.implementOn(BcelAdvice.java:126)
        at org.aspectj.weaver.Shadow.implementMungers(Shadow.java:341)
        at org.aspectj.weaver.Shadow.implement(Shadow.java:313)
        at org.aspectj.weaver.bcel.BcelClassWeaver.implement(BcelClassWeaver.java:1006)
        at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:299)
        at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:77)
        at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:417)
        at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:390)
        at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:327)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.weaveAndGenerateClassFiles(AjBuildManager.java:256)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:156)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:70)
        at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:99)
        at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:53)
        at org.aspectj.tools.ajc.Main.run(Main.java:217)
        at org.aspectj.tools.ajc.Main.runMain(Main.java:155)
        at org.aspectj.tools.ajc.Main.main(Main.java:72)


1 fail|abort

Sample code is two files, TextException.java and ExceptionLoggerAspectV2.java
(see below). To reproduce the problem, do

$ ajc *.java

File 1  - TestException.java
----------------------------
public class TestException 
{
    public static void main(String[] args) {
        perform();
    }

    public static void perform() {
        Object nullObj = null;
        nullObj.toString();
    }
}

File 2 - ExceptionLoggerAspectV2.java
-------------------------------------
import java.util.logging.*;
import org.aspectj.lang.*;

public aspect ExceptionLoggerAspectV2 
{
    Logger _logger = Logger.getLogger("exceptions");

    ExceptionLoggerAspectV2() {
        _logger.setLevel(Level.ALL);
    }

    pointcut exceptionLogMethods()
        : call(* *.*(..)) &amp;&amp; !within(ExceptionLoggerAspectV2);

    after() thowing(Throwable ex) : exceptionLogMethods() {
        if (_logger.isLoggable(Level.WARNING)) {
            Signature sig = thisJoinPointStaticPart.getSignature();
            _logger.logp(Level.WARNING,
                         sig.getDeclaringType().getName(),
                         sig.getName(),
                         "Exception logger aspect", ex);
        }
    }
}</description>
      <comments>
		<comment id="1" date="2004-01-08 10:18:30 EST" author="Matthew Webster">The reason for the compiler failure is a transcription error in the program:

    after() thowing(Throwable ex) : exceptionLogMethods() {

should be

    after() throwing(Throwable ex) : exceptionLogMethods() {

(there is an 'r' missing int throwing). However the compiler should issue a 
syntax error rather than aborting.</comment>
		<comment id="2" date="2004-01-09 04:27:04 EST" author="Jim Hugunin">Fixed to produce nice parser error message based on patch from Matthew Webster.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="7b081f2e0bece3414ac4f385cde75d7b54981099" author="jhugunin" date="2004-01-09 06:21:03"/>
          <file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/parser/AjParser.java">
              <method name="consumeExtraParameterNoFormal" returnType="void" parameters=""/>
          </file>
          <file name="tests/bugs/AfterThrowingAdviceSyntaxError.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="46280" opendate="2003-11-7 11:32:00" fixdate="2004-1-14 6:34:00">
    <buginformation>
      <summary>compiler issues error on inner aspects when privilieged</summary>
      <description>The compiler complains that "inner aspects must be static" whenever I try to 
qualify an inner (and static) aspect as privileged, no matter what the 
enclosing type is (aspect, interface or class).
I was using j2sdk1.4.0_02, AspectJ 1.1, eclipse 2.1 (with AJDT 1.1.3).
Test case:
------------------
BASE CLASS:
public class Capsule {
   private int hidden;
   public int visible;
   public Capsule(int priv, int pub) {
      hidden = priv;
      visible = pub;
   }
   public void doSomething() {
      System.out.println(""" + hidden + ", " + visible + """);
   }
   public static void main(String[] args) {
      Capsule capsule = new Capsule(1, 1);
      capsule.doSomething();
   }
}
------------------
ASPECT:
public aspect Outer {
   static //privileged &lt;== JUST TRY TO UNCOMMENT THIS!
   aspect Inner {
      pointcut call2doSomething(Capsule capsule):
         call(void Capsule.doSomething())
         &amp;&amp; target(capsule);
      before(Capsule capsule): call2doSomething(capsule) {
         capsule.visible++;
         //capsule.hidden++;
      }
   }
}
------------------
INTERFACE:
public interface Marker {
   static //privileged &lt;== JUST TRY TO UNCOMMENT THIS!
   aspect Inner {
      pointcut call2doSomething(Capsule capsule):
         call(void Capsule.doSomething())
         &amp;&amp; target(capsule);
      before(Capsule capsule): call2doSomething(capsule) {
         capsule.visible++;
         //capsule.hidden++;
      }
   }
}</description>
      <comments>
		<comment id="1" date="2003-11-10 08:57:10 EST" author="Matthew Webster">As a workaround try reversing the static and privileged modifiers i.e.

public aspect Outer {
   privileged static
   aspect Inner {
   pointcut call2doSomething(Capsule capsule):
   call(void Capsule.doSomething())
   &amp;&amp; target(capsule);
   before(Capsule capsule): call2doSomething(capsule) {
   capsule.visible++;
   capsule.hidden++;
   }
   }
}

This compiles cleanly and runs.</comment>
		<comment id="2" date="2004-01-14 06:34:15 EST" author="Jim Hugunin">Fixed in tree.  The bug was caused by an unusual grammar for privileged 
aspects to be as compatibile with the existing Java grammar as possible.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="7bbd1f419239dc9e8b46e7fd912b2bc007bbd76a" author="jhugunin" date="2004-01-14 08:28:13"/>
          <file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/parser/AjParser.java">
              <method name="consumeAspectHeaderName" returnType="void" parameters="boolean"/>
          </file>
          <file name="tests/bugs/PrivilegedParsing.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="50570" opendate="2004-1-25 11:47:00" fixdate="2004-1-27 20:21:00">
    <buginformation>
      <summary>CatchClauseSignature has broken operation</summary>
      <description>It looks like the getParameterName() operation on org.aspectj.lang.reflect.
CatchClauseSignature is not working. Instead of returning the name of the 
exception as declared in the matched handler, returns the string value 
"&lt;missing&gt;".

Here is a test case that shows the problem :-

------START OF TEST CASE CODE-----------

public class MyApp {

    public void doSomething() {
        // Get around "unreachable code error...
        if (true)
        {
            throw new BusinessException("Surprise!!");
        }
        System.out.println("Busy doing something.");
    }

    public static void main(String[] args) {
        try {
            MyApp m = new MyApp();
            m.doSomething();
        } catch (BusinessException be) {
            System.out.println("Exception caught : " + be.getMessage()); 
        }
    }
}

class BusinessException extends RuntimeException {
    BusinessException(String message) {
        super(message);
    }
}

aspect AppMonitor {
    pointcut problemHandling() : handler(Throwable+);

    before() : problemHandling() {
        CatchClauseSignature cSig =
            (CatchClauseSignature) thisJoinPointStaticPart.getSignature();

        System.out.println(
            "MONITOR::\tCaught a "
                + cSig.getParameterType().getName()
                + " called "
                + cSig.getParameterName());
    }
}

------END OF TEST CASE CODE-----------

The output from running the above was ...

MONITOR::	Caught a BusinessException called &lt;missing&gt;
Exception caught : Surprise !!!!

Operating system : Windows XP
AspectJ : 1.1.1 final and also on latest from CVS HEAD</description>
      <comments>
		<comment id="1" date="2004-01-27 20:21:34 EST" author="Jim Hugunin">This is fixed in the tree for simple cases.  The parameter name will be 
correct when a store instruction is the first bytecode of the handler.  This 
appears to always be true for javac and the eclipse compiler.  Other compilers 
have not been tested.  Also, the code must have been compiled with -g mode for 
this parameter name to be visible in the bytecode.  If -g is not used or the 
handler doesn't match the typical pattern, then this name will revert to 
&lt;missing&gt; as before.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="19bac866e44563dad29b6bebefa31c4e354ee96c" author="jhugunin" date="2004-01-28 10:12:17"/>
          <file name="tests/bugs/HandlerSig.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/Member.java">
              <method name="pointcut" returnType="Member" parameters="TypeX int TypeX String TypeX[]"/>
          </file>
          <file name="weaver/src/org/aspectj/weaver/ResolvedMember.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/bcel/BcelShadow.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="49457" opendate="2004-1-2 0:21:00" fixdate="2004-01-07 06:26:07">
    <buginformation>
      <summary>No error on overloaded pointcuts unless binding variables</summary>
      <description>The compiler might not be detecting overloaded pointcut names when parameters
are not bound, and/or might not be implementing the pointcut correctly.  Below
is the context from my reply to Ron Bodkin on aspectj-dev "Proper behavior of
overloaded pointcut definitions".  (I have not checked this code recently or
submitted a test case, nor have I evaluated whether my code below actually
replicates Ron's bug.)

---- context from the email
The programming guide says,

  It is an error for two pointcuts to be named with the same
  name in the same class or aspect declaration.

When I compile with overloaded pointcut names, I do get an error.

    pointcut pc(Runnable r) : target(r) &amp;&amp; call(void run());
    pointcut pc(SubRunnable r) : target(r) &amp;&amp; call(void run());

 $ aspectj-1.1.1 -classpath $ajrt11 OverloadedPointcut.java
 ...\OverloadedPointcut.java:14 duplicate pointcut name: pc
 ...\OverloadedPointcut.java:15 duplicate pointcut name: pc

...

When I use these pointcuts with bound parameters, I get an error.

    before(Runnable r) : pc(r) { log("pc(Runnable r)"); }
    before(SubRunnable r) : pc(r) { log("pc(SubRunnable r)"); }

When I use these pointcuts with type parameters, I get no errors.

    before() : pc(Runnable) { log("pc(Runnable)"); }
    before() : pc(SubRunnable) { log("pc(SubRunnable)"); }
    before() : pc(*) { log("pc(*)"); }

[...]

---- my code
public class OverloadedPointcut {
    public static void main(String[] args) {
        new C().run();
    }
}
class C { public void run() {} }

aspect A {
    declare parents: C implements Runnable;
    declare parents: C implements SubRunnable;
    interface SubRunnable extends Runnable {}

    pointcut pc(Runnable r) : target(r) &amp;&amp; call(void run());
    pointcut pc(SubRunnable r) : target(r) &amp;&amp; call(void run());
    before(Runnable r) : pc(r) { log("pc(Runnable r)"); }
    before(SubRunnable r) : pc(r) { log("pc(SubRunnable r)"); }
    before() : pc(Runnable) { log("pc(Runnable)"); }
    before() : pc(SubRunnable) { log("pc(SubRunnable)"); }
    before() : pc(*) { log("pc(*)"); }
    void log(String s) { System.out.println(s); }
} 

---- Ron's code
[...] the following program compiles with no warnings, produces no output when
run under AspectJ 1.1.1.  It appears to behave as if the more specific
definition is the only definition of the pointcut
[...]
Here is a simple program that illustrates the question and odd behavior:

package lib;

public class RunnablePointcuts {
    public pointcut runnableCalls(Runnable runnable, Object caller) :
        call(* run(..)) &amp;&amp; target(runnable) &amp;&amp; this(caller);

    //public pointcut specialRunnableCalls(SpecialRunnable runnable, Object
caller) :
    public pointcut runnableCalls(SpecialRunnable runnable, Object caller) :
        call(* run(..)) &amp;&amp; target(runnable) &amp;&amp; this(caller);
}
---
package lib;

public interface SpecialRunnable extends Runnable {
}
---
package client;

import lib.RunnablePointcuts;
import lib.SpecialRunnable;

public aspect Use {
    before(Object caller) : RunnablePointcuts.runnableCalls(*, caller) &amp;&amp;
target(MyRunnable) {
        System.out.println("my runnable called from "+caller);
    }
    public static void main(String args[]) {
	Use.aspectOf().doIt();
    }
    public void doIt() {
        new MyRunnable().run();
    }
}

// the advice will run if you make this implement SpecialRunnable
//class MyRunnable implements SpecialRunnable {
class MyRunnable implements Runnable {
    public void run() {}
}</description>
      <comments>
		<comment id="1" date="2004-01-07 06:07:38 EST" author="Andrew Clement">The bug is that the compiler is not policing the case when two pointcuts with 
the same name are declared in a CLASS.  In Rons program he should get errors 
against his RunnablePointcuts class at compile time.  The fix is to add 
behaviour to AjLookupEnvironment.resolvePointcutDeclarations such that if the 
ClassScope being processed has pointcut definitions in it, we do the check.</comment>
		<comment id="2" date="2004-01-07 06:26:07 EST" author="Andrew Clement">Patch sent to Adrian.</comment>
		<comment id="3" date="2004-01-27 20:29:42 EST" author="Jim Hugunin">*** Bug 42842 has been marked as a duplicate of this bug. ***</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="c517e8507cbc0be482d3eb1be2694e3f6486a4e3" author="acolyer" date="2004-01-07 10:10:07"/>
          <file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectDeclaration.java">
              <method name="resolve" returnType="void" parameters=""/>
          </file>
          <file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java">
              <method name="resolvePointcutDeclarations" returnType="void" parameters="ClassScope"/>
          </file>
          <file name="tests/bugs/OverloadedPointcutsInAspect.java">
          </file>
          <file name="tests/bugs/OverloadedPointcutsInClass.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="48091" opendate="2003-12-4 12:18:00" fixdate="2004-01-23 21:37:14">
    <buginformation>
      <summary>Lazy instantiation of thisJoinPoint</summary>
      <description>In cases where the body of advice refers to a non-statically evaluable portion 
of thisJoinPoint (so that it can't be optimized by the compiler to 
thisJoinPointStaticPart), the JoinPoint object is currently always created 
before entering the advice body - even if the JoinPoint object would never 
actually be accessed (because of a test within the advice for example). Since
a) thisJoinPoint is often used in tracing applications
b) tracing applications tend to be very pervasive,
c) they must have low overhead when tracing is disabled, and 
d) creation of thisJoinPoint objects is expensive (v. expensive compared to just 
testing a flag)
it would be nice if there was a way to create JoinPoint objects lazily on first 
actual reference within the advice body.</description>
      <comments>
		<comment id="1" date="2004-01-23 21:37:14 EST" author="Jim Hugunin">Implemented in tree with unit test in ajdt.core test sources under 
PerformanceTestCase.  Speed-ups of 10-100X are measured even when running a 
small test case with minimal GC issues.

The actual feature implemented is that thisJoinPoint objects are only created 
just before calling the method for advice that requires them.  To take 
advantage of this feature you must use an if PCD or some other dynamic test 
that occurs in the PCD not the advice body to guard the expensive creation of 
the thisJoinPoint object.

-XlazyTjp flag must be passed to compiler to enable this feature.
If any around advice is present on the joinpoint then lazy instantiation
will be disabled.  An Xlint warning will be displayed in this case.

As a related optimization, several helper methods were added to
Factory.makeJP to reduce the code size when thisJoinPoint is used.</comment>
		<comment id="2" date="2004-02-16 07:01:08 EST" author="Matthew Webster">I discovered When trying to write a new logging aspect to exploit this 
enhancement that the new -X option is difficult to use. Although accepted by 
AJDT it is ignore and the Ant task also ignores it because it has its own 
option parsing. The only ways are to use the command line or an entry in an 
argfile. I was surprised at how many placed we police options.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="0c833438dadeeb26659cd901870d18d2c103658b" author="jhugunin" date="2004-01-24 11:28:54"/>
          <file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java">
              <method name="parseOption" returnType="void" parameters="String LinkedList"/>
          </file>
          <file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.java">
          </file>
          <file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java">
              <method name="initBcelWorld" returnType="void" parameters="IMessageHandler"/>
          </file>
          <file name="org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/AjdtBatchTests.java">
              <method name="suite" returnType="Test" parameters=""/>
          </file>
          <file name="org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/CommandTestCase.java">
          </file>
          <file name="org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/PerformanceTestCase.java">
          </file>
          <file name="runtime/src/org/aspectj/runtime/reflect/Factory.java">
              <method name="makeSJP" returnType="JoinPoint.StaticPart" parameters="String Signature int"/>
          </file>
          <file name="weaver/src/org/aspectj/weaver/Lint.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/World.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java">
              <method name="specializeOn" returnType="void" parameters="Shadow"/>
          </file>
          <file name="weaver/src/org/aspectj/weaver/bcel/BcelShadow.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="51929" opendate="2004-2-12 21:13:00" fixdate="2004-2-19 16:25:00">
    <buginformation>
      <summary>Advice calling protected super method causing java.lang.VerifyError 'Bad access to protected data'</summary>
      <description>A java.lang.VerifyError is thrown at runtime complaining about 'Bad access to  
protected data' when advice, on a sub-aspect, that calls a protected method, on  
the super-aspect, is woven into a class. 
However another call to the same method woven into the same class but due to  
advice declared in the super-aspect works fine. 
 
The aspects were woven into precompiled (by sun's 1.4 javac) classes. 
The verify error occurs under both sun's 1.4 and blackdowns 1.3 VMs, and presumably 
all VMs. 
 
Workaround: 
Making the protected method public fixes the verify error. 
 
A test case is available in CVS: 
tests/bugs/protectedvf/... 
tests/ajcTestFailing.xml</description>
      <comments>
		<comment id="1" date="2004-02-19 09:57:28 EST" author="Adrian Colyer">Any verify error is serious so marking for investigation in 1.2 timeframe.</comment>
		<comment id="2" date="2004-02-19 16:25:11 EST" author="Jim Hugunin">Thanks for the simple and clear test case.

This is now fixed in the tree.  I also expanded the test to cover protected 
field access as well as methods.

Fix required getting the correct receiver type for both field access and method
calls to correspond to Java's complicated rules for accessing protected
members (JLSv2 6.6.2 and mentioned in passing in JVMv2 5.4.4).  This only 
matters for code in the body of around advice that may potentially be inlined
at join point shadows.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="6ddae42579ceb781831e08f0fcf77a4ff4ffb5c0" author="jhugunin" date="2004-02-20 07:09:16"/>
          <file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AccessForInlineVisitor.java">
          </file>
          <file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java">
          </file>
          <file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/InlineAccessFieldBinding.java">
          </file>
          <file name="tests/bugs/protectedvf/main/Driver.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="36430" opendate="2003-4-13 3:35:00" fixdate="2004-2-24 8:58:00">
    <buginformation>
      <summary>Support -Xreweavable option</summary>
      <description>Adding a RFE as Wes suggested...

Wes' reply:
There are some issues with the -Xnoweave option that we won't
have the time to carefully resolve for 1.1, even though, 
as you suggest, there may be times when it would be useful.

The workaround at present is to weave tracing into transactions 
when the transactions jar is compiled. e.g.,

-- do the build
  ajc @tracing.lst -outjar tracing.jar
  ajc @transactions.lst -aspectpath tracing.jar \
      -outjar transactions.jar
  ajc @app.lst -aspectpath "tracing.jar;transactions.jar" \
      -outjar app.jar
-- build the jar
  mkdir final
  cd final
  jar xf ../tracing.jar
  jar xf ../transactions.jar
  jar xf ../app.jar
  # fixup manifest, etc?
  jar cf ../final.jar *

What if you don't have the sources for the transactions.jar?
This is a case of getting binary transactions aspects from a 
vendor who won't provide source and wanting to weave your 
tracing into it.  I would hope that by the time that problem 
becomes prevalent, we will have a solution for it.

If you'd like to keep this on the radar, please submit this
discussion as an RFE for the compiler at

  http://dev.eclipse.org/bugs/enter_bug.cgi?product=AspectJ

Thank you -
Wes

P.S. - Personally, I think this case

&gt; &gt; ajc -injars app.jar;transaction.jar
&gt;       -aspectpath transaction.jar;tracing.jar

doesn't make sense.  Things on the aspectpath are defined,
whereas things in injars will be woven into and redefined.
It's not clear from this command which variant the user 
expects when refering to a type in transactions.jar.

Ramnivas Laddad wrote:
&gt; 
&gt; Hello,
&gt; 
&gt; I think I have a use case that cannot be implemented
&gt; (at least elegantly, anyway) without noweave/XnoWeave
&gt; option (and thus I request to make it a regular option
&gt; instead of experimental -X).
&gt; 
&gt; Basically, I want to have my tracing.jar (
&gt; contains tracing aspect) weave into transaction.jar
&gt; (contains abstract transaction mangement aspects,
&gt; concrete policy enforcement aspects, and supporting
&gt; classes). Assume app.jar contain business classes
&gt; and interfaces. Each of the jar is created using
&gt; -ourjar (but not -noweave or -XnoWeave).
&gt; 
&gt; To build the final system I issue the following
&gt; command:
&gt; &gt; ajc -injars app.jar;transaction.jar
&gt;       -aspectpath transaction.jar;tracing.jar
&gt; 
&gt; Now compiler gives me error due to multiply woven
&gt; classes and aspects in transaction.jar.
&gt; 
&gt; Everything works fine if I create the original jar
&gt; files using -noweave.
&gt; 
&gt; I could workaround by creating multiple jars, but
&gt; I hink -noweave is the right approach as
&gt; I really don't want to ship multiple jars that are
&gt; needed to implement a single concern and expect the
&gt; users to correctly specify jar files in -injars
&gt; and -aspectpath.
&gt; 
&gt; -Ramnivas</description>
      <comments>
		<comment id="1" date="2003-04-22 18:38:29 EDT" author="Jim Hugunin">Marking this as an enhancement request for consideration in 1.1.1</comment>
		<comment id="2" date="2004-01-26 16:27:45 EST" author="Jim Hugunin">We should add a âXreweavable option to generate classfiles that will have 
enough additional information in them that they can be rewoven.  The goal is 
that in AspectJ-1.3 (or maybe even 1.2.1) this option can become a standard 
option and the âXnoweave option can either be removed or left as an X option 
forever.

In addition to Ramnivasâ example, this option is very important as we start to 
provide standard support in AspectJ for load-time weaving.  In this case we 
definitely need a standard supported option for building libraries with 
AspectJ that can be safely passed to a load-time weaver.

The reweavable option is better than the noweave option in many ways.  The 
most significant benefit is that it will produce classfiles that can be 
legally loaded by a JVM.  The noweave option makes it much too easy to produce 
verify errors.  In addition, the reweavable option will make it easier to 
weave code many times without having to decide which weave is the final one.

Ideally, producing reweavable classfiles should be the default mode for ajc.  
There is at least one major space issue that needs to be resolved before that 
can happen.

The implementation of âXreweavable for 1.2 is straightforward.  The 
org.aspectj.weaver.WeaverStateInfo attribute needs to be extended to have a 
reweavable variant.  This reweavable variant will include two new field.

1. A list of the fully qualified type names for all aspects that modified the 
classfile during weaving.  BcelClassWeaver will need some minor changes to 
populate this list.  When reweaving, the weaver will check that all of these 
aspects can be found and issue an error if any are missing.

2. Enough binary information to recover the original unwoven classfile for the 
current classfile.  An initial naÃ¯ve implementation should simply include all 
of the bytes from the original classfiles in this slot.  This is the potential 
major space issue.  A more advanced version of this implementation should use 
a binary diff library to minimize the bytes required by only encoding the 
difference between the woven classfile and the unwoven one.  In general, this 
diff should be very small.  Some thought needs to go into making sure that 
this attribute works well for multiple reweaving steps.

BTW â The ability to reweave classfiles opens up the possibility of some very 
different incremental compilation models in the command-line ant world.  If 
this attribute goes well those should be explored in the future.</comment>
		<comment id="3" date="2004-02-24 08:58:45 EST" author="Andrew Clement">Fixed - as per Jims design.  Implementation overview document in CVS:

modules/docs/design-Xreweavable.doc</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="16a0abd70e5fe2538c32994de05f52b6bf939ef5" author="aclement" date="2004-02-24 10:43:56"/>
          <file name="ajde/testdata/ReweavableTest/CalculatePI.java">
          </file>
          <file name="ajde/testdata/ReweavableTest/tjp/Demo.java">
          </file>
          <file name="ajde/testdata/ReweavableTest/tjp/GetInfo.java">
          </file>
          <file name="ajde/testsrc/org/aspectj/ajde/AjdeTests.java">
              <method name="suite" returnType="Test" parameters=""/>
          </file>
          <file name="ajde/testsrc/org/aspectj/ajde/ReweavableTestCase.java">
          </file>
          <file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java">
              <method name="parseOption" returnType="void" parameters="String LinkedList"/>
          </file>
          <file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.java">
          </file>
          <file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java">
              <method name="initBcelWorld" returnType="void" parameters="IMessageHandler"/>
          </file>
          <file name="taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java">
              <method name="setXNoweave" returnType="void" parameters="boolean"/>
          </file>
          <file name="testing/src/org/aspectj/testing/harness/bridge/CompilerRun.java">
              <method name="CRSOptions" returnType="null" parameters=""/>
          </file>
          <file name="weaver/src/org/aspectj/weaver/Advice.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/CrosscuttingMembers.java">
              <method name="addDeclare" returnType="void" parameters="Declare"/>
          </file>
          <file name="weaver/src/org/aspectj/weaver/CrosscuttingMembersSet.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/Shadow.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/WeaverStateInfo.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/bcel/BcelCflowStackFieldAdder.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/bcel/BcelObjectType.java">
              <method name="BcelObjectType" returnType="null" parameters="ResolvedTypeX.Name JavaClass boolean"/>
          </file>
          <file name="weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/bcel/LazyClassGen.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/patterns/CflowPointcut.java">
              <method name="concretize1" returnType="Pointcut" parameters="ResolvedTypeX IntMap"/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="51320" opendate="2004-2-7 12:26:00" fixdate="2004-2-25 6:41:00">
    <buginformation>
      <summary>ClasscastException on concretization of if(false)</summary>
      <description>I get the following exception when weaving the attached aspect on the dev build.

java.lang.ClassCastException
	at org.aspectj.weaver.patterns.IfPointcut.concretize1(IfPointcut.java:156)
	at org.aspectj.weaver.patterns.IfPointcut.concretize(IfPointcut.java:143)
	at org.aspectj.weaver.patterns.Pointcut.concretize(Pointcut.java:119)
	at org.aspectj.weaver.Checker.concretize(Checker.java:35)
	at org.aspectj.weaver.CrosscuttingMembers.addShadowMunger(CrosscuttingMembers.java:78)
	at org.aspectj.weaver.CrosscuttingMembers.addDeclare(CrosscuttingMembers.java:102)
	at org.aspectj.weaver.CrosscuttingMembers.addDeclares(CrosscuttingMembers.java:92)
	at org.aspectj.weaver.CrosscuttingMembersSet.addAdviceLikeDeclares(CrosscuttingMembersSet.java:65)
	at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.addAdviceLikeDeclares(AjLookupEnvironment.java:147)
	at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.completeTypeBindings(AjLookupEnvironment.java:122)
	at org.eclipse.jdt.internal.compiler.Compiler.beginToCompile(Compiler.java:300)
	at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:314)
	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:384)
	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:125)
	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:70)
	at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:104)
	at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:53)
	at org.aspectj.tools.ajc.Main.run(Main.java:234)
	at org.aspectj.tools.ajc.Main.runMain(Main.java:170)
	at org.aspectj.tools.ajc.Main.main(Main.java:81)</description>
      <comments>
		<comment id="1" date="2004-02-07 12:27:39 EST" author="Eric Bodden">Created attachment 7721 [details]
Aspect</comment>
		<comment id="2" date="2004-02-07 12:29:17 EST" author="Eric Bodden">additional comments:
1.) The object "advice" is of type Checker, which is _not_ a subtype of Advice.
2.) I do realize that the declare warning statement is not necessarily supposed 
to work with an if pointcut. Though a decent error should be given.</comment>
		<comment id="3" date="2004-02-19 09:51:52 EST" author="Adrian Colyer">It would be good to improve the error handling here for 1.2 if we can. Marked 
with target = 1.2 for now pending investigation.</comment>
		<comment id="4" date="2004-02-25 06:41:49 EST" author="Andrew Clement">Fix checked in.  As per the discussion on the list, the use of PCDs that may 
have dynamic residue is policed and you will get an error message if you try 
to use them in deow statements.


C:\Eclipse\212\eclipse\aspectj_ws\tests\bugs&gt;ajc DecwClassCastException.java
C:\Eclipse\212\eclipse\aspectj_ws\tests\bugs\DecwClassCastException.java:27 if
() pointcut designator cannot be used in declare statement
C:\Eclipse\212\eclipse\aspectj_ws\tests\bugs\DecwClassCastException.java:29 if
() pointcut designator cannot be used in declare statement
C:\Eclipse\212\eclipse\aspectj_ws\tests\bugs\DecwClassCastException.java:31 
cflow() pointcut designator cannot be used in declare statement
C:\Eclipse\212\eclipse\aspectj_ws\tests\bugs\DecwClassCastException.java:33 
cflow() pointcut designator cannot be used in declare statement
C:\Eclipse\212\eclipse\aspectj_ws\tests\bugs\DecwClassCastException.java:35 
cflowbelow() pointcut designator cannot be used in declare statement
C:\Eclipse\212\eclipse\aspectj_ws\tests\bugs\DecwClassCastException.java:37 
cflowbelow() pointcut designator cannot be used in declare statement
C:\Eclipse\212\eclipse\aspectj_ws\tests\bugs\DecwClassCastException.java:39 
this() pointcut designator cannot be used in declare statement
C:\Eclipse\212\eclipse\aspectj_ws\tests\bugs\DecwClassCastException.java:41 
this() pointcut designator cannot be used in declare statement
C:\Eclipse\212\eclipse\aspectj_ws\tests\bugs\DecwClassCastException.java:43 
target() pointcut designator cannot be used in declare statement
C:\Eclipse\212\eclipse\aspectj_ws\tests\bugs\DecwClassCastException.java:45 
target() pointcut designator cannot be used in declare statement
C:\Eclipse\212\eclipse\aspectj_ws\tests\bugs\DecwClassCastException.java:47 
args() pointcut designator cannot be used in declare statement
C:\Eclipse\212\eclipse\aspectj_ws\tests\bugs\DecwClassCastException.java:49 
args() pointcut designator cannot be used in declare statement

12 errors

The line number in the error is always the line number of the declare 
statement.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="fbc0aa305ea367e5fbeb99acf9907ae3a155f16a" author="aclement" date="2004-02-25 08:14:32"/>
          <file name="tests/bugs/DecwClassCastException.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/patterns/ArgsPointcut.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/patterns/CflowPointcut.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/patterns/IfPointcut.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/patterns/ThisOrTargetPointcut.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="48080" opendate="2003-12-4 11:21:00" fixdate="2004-3-15 11:42:00">
    <buginformation>
      <summary>Context information in declare warning/error messages</summary>
      <description>*** to be discussed on aspectj-dev / users before implementing ***

We have found it useful to be able to include contextual information in the 
messages produced by declare warning /error. We want to be able to write 
something like:

declare warning: call(* com.ibm.ws..*(..)) : "Call to protected WAS API: %s";

and get the compiler message:

"Call to protected WAS API: void com.ibm.ws.SomeClass.someMethod(boolean)"

We prototyped a solution using substitution variables as follows:

%%  	inserts a % character
%k	inserts the joinpoint kind
%s	inserts the signature at the joinpoint
%t	inserts the name of the declaring type at the joinpoint
%i	inserts the name of the identifier at the joinpoint
%j	inserts a string representation of the joinpoint
%f	inserts the filename where the match was found
%l 	inserts the line number where the match was found
%a	inserts the file and line number of the declare error/warning definition

(this may not be the perfect set...)

Here's a complete mini-example showing all the subsitutions in action :

Hello.java
=========

public class Hello {
  public static void main(String[] args) {
  	System.out.println("Hello");	
  	new Hello().sayItToo();
  }	
  
  private void sayItToo() {
  	System.out.println("me too");
  }
}

Warn.java
=========

public aspect Warn {
	
	declare warning : execution(* Hello.*(..)) : 
          "My warning:\n%%k=%k\n%%s=%s\n%%t=%t\n%%i=%i\n%%j=%j\n%%f=%f\n%%l=%
l\n%%a=%a";	

	declare warning : call(* Hello.*(..)) : "Illegal call to %t.%i(..)";	

}

To get the following output:

C:\ColyerRoot\Data\AspectJDev\eclipse\workspace\Notes\decwtest\Hello.java:4 
Illegal call to Hello.sayItToo(..)

C:\ColyerRoot\Data\AspectJDev\eclipse\workspace\Notes\decwtest\Hello.java:3 My 
warning:
%k=method-execution
%s=void Hello.main(java.lang.String[])
%t=Hello
%i=main
%j=method-execution(void Hello.main(java.lang.String[]))
%f=C:\ColyerRoot\Data\AspectJDev\eclipse\workspace\Notes\decwtest\Hello.java
%l=3
%a=C:\ColyerRoot\Data\AspectJDev\eclipse\workspace\Notes\decwtest\Warn.java:3

C:\ColyerRoot\Data\AspectJDev\eclipse\workspace\Notes\decwtest\Hello.java:8 My 
warning:
%k=method-execution
%s=void Hello.sayItToo()
%t=Hello
%i=sayItToo
%j=method-execution(void Hello.sayItToo())
%f=C:\ColyerRoot\Data\AspectJDev\eclipse\workspace\Notes\decwtest\Hello.java
%l=8
%a=C:\ColyerRoot\Data\AspectJDev\eclipse\workspace\Notes\decwtest\Warn.java:3

3 warnings

The following patch implements the extension (warning - based on a version of  
Checker.java from a while back).

Index: Checker.java
===================================================================
RCS file: /home/technology/org.
aspectj/modules/weaver/src/org/aspectj/weaver/Checker.java,v
retrieving revision 1.5
diff -u -r1.5 Checker.java
--- Checker.java	12 Mar 2003 19:51:43 -0000	1.5
+++ Checker.java	19 Jul 2003 12:34:12 -0000
@@ -17,6 +17,7 @@
 import java.util.Collections;
 
 import org.aspectj.bridge.IMessage;
+import org.aspectj.bridge.ISourceLocation;
 import org.aspectj.bridge.Message;
 import org.aspectj.weaver.patterns.DeclareErrorOrWarning;
 import org.aspectj.weaver.patterns.PerClause;
@@ -49,7 +50,7 @@
 	public boolean match(Shadow shadow, World world) {
 		if (super.match(shadow, world)) {
 			world.getMessageHandler().handleMessage(
-				new Message(msg,
+				new Message(format(msg,shadow),
 							isError ? IMessage.ERROR : IMessage.WARNING,
 							null,
 							shadow.getSourceLocation()));
@@ -63,5 +64,85 @@
 	}
 	
 	public Collection getThrownExceptions() { return Collections.EMPTY_LIST; }
+
+//	%%  	inserts a % character
+//	%k 		inserts the joinpoint kind
+//	%s		inserts the signature at the joinpoint
+//	%t		inserts the name of the declaring type at the joinpoint
+//	%i		inserts the name of the identifier at the joinpoint
+//	%j		inserts a string representation of the joinpoint
+//	%J		inserts an extended string representation of the joinpoint
+//	%f		inserts the filename where the match was found
+//	%l 		inserts the line number where the match was found
+//	%a		inserts the name of the aspect where the declare was defined	
+	private String format(String msg, Shadow shadow) {
+		StringBuffer ret = new StringBuffer();
+		for(int i = 0; i &lt; msg.length(); i++) {
+			if (msg.charAt(i) != '%') {
+				ret.append(msg.charAt(i));
+			} else {
+				// its a substitution character
+				int subCharPos = i+1;
+				if (subCharPos &lt; msg.length()) {
+					i++; // consume it
+					substitute(ret,shadow,msg.charAt(i));
+				}
+			}
+		}
+		return ret.toString();
+	}
+
+	/**
+	 * @param buf  the buffer in which to insert the substitution
+	 * @param shadow shadow from which to draw context info
+	 * @param c the substitution character
+	 */
+	private void substitute(StringBuffer ret, Shadow shadow, char c) {
+		ISourceLocation loc;
+		switch(c) {
+			case '%':	
+				ret.append('%');
+				break;
+			case 'k':	// kind
+				ret.append(shadow.getKind().getName());
+				break;
+			case 's':
+				ret.append(shadow.getSignature());
+				break;
+			case 't':
+				ret.append(shadow.getEnclosingType());
+				break;
+			case 'i':
+				ret.append(shadow.getSignature().getName());
+				break;
+			case 'j':
+			case 'J':
+				ret.append(shadow.toString());
+				break;
+			case 'f':	// file name
+				loc = shadow.getSourceLocation();
+				if ((loc != null) &amp;&amp; (loc.getSourceFile() != null)) {
+					ret.append(loc.getSourceFile().toString());
+				}
+				break;
+			case 'l':	// line number
+				loc = shadow.getSourceLocation();
+				if (loc != null) {
+					ret.append(loc.getLine());
+				}
+				break;			
+			case 'a':	// aspect file and line number
+				loc = getSourceLocation();
+				if ((loc != null) &amp;&amp; (loc.getSourceFile() != null)) {
+					ret.append(loc.getSourceFile().toString());
+					ret.append(':');
+					ret.append(loc.getLine());
+				}
+				break;				
+			default: // unknown substitution character, leave alone
+				ret.append('%');
+				ret.append(c);
+		}
+	}
 
 }</description>
      <comments>
		<comment id="1" date="2003-12-17 19:44:58 EST" author="Jim Hugunin">A small variation on this proposal would be to use the style of 
java.text.MessageFormat and longer names that closely match our existing 
thisJoinPoint-based reflection API, something like:
    declare warning : call(* Hello.*(..)) :
        "Illegal call to {signature.declaringType}.{signature.name}(..)";
or
    declare warning : call(* Hello.*(..)) :
        "Illegal call to {signature.shortString}";</comment>
		<comment id="2" date="2003-12-17 19:46:54 EST" author="Jim Hugunin"> more radical design that would directly use the thisJoinPoint reflection API, 
something like this:
    declare warning: call(* Hello.*(..)) {
        Signature sig = thisJoinPointStaticPart.getSignature();
        return "Illegal call to " + sig.getDeclaringType().getName() + 
            "." + sig.getName() + "(..)";
    }

As you can easily tell from the example, the purpose of this change is to make 
this kind of simple example smaller and easier to read &lt;smile&gt;.  Okay, the 
real goal is to provide a lot more flexibility to the programmer.  The open 
question is whether or not that flexibility is worth the increased complexity 
both of implementation and use of the feature.

Here are two examples that show interesting things that could be done if the 
code can decide whether or not to show an error, not just how to format the 
message. 

declare warning: execution(* *(..)) {
  Signature sig = thisJoinPointStaticPart.getSignature();
  if (Character.isUpper(sig.getName().charAt(0))) {
    return "Java method names should begin with a lower case letter";
  } else {
    return NO_MESSAGE;
  }
}

declare warning: execution(boolean equals(Object)) {
  Class c = thisJoinPointStaticPart.getSignature().getDeclaringType();
  if (c.getDeclaredMethod("hashCode", new Class[0]) == null) {
    return "should override hashCode whenever overriding equals";
  } else {
    return NO_MESSAGE;
  }
}

There's a convincing case to be made that this design would greatly increase 
the power of declare error/warning.  I think that for the user this additional 
power is easily worth the added complexity for the simple cases.  I also think 
that we could make some minor tweaks to the design to improve these simple 
cases a lot.

The big question is what are the consequences of having user code run at 
compile/weave time?  How hard will it be for programmers to understand this 
code?  How much more complicated will the implementation be?  I'm going to 
address the issue of implementation complexity below by sketching what an 
implementation might look like.

The block of code for the declare warning will be compiled into a special 
class.  At weave time that class will be loaded by a custom ClassLoader.  That 
ClassLoader will provide a sandbox for the code to run in to limit its 
capabilities.  The exact contents of this sandbox will take some thought.

Should be visible:
  java.lang: String, StringBuffer
  java.util.regex: *
  java.text: *
  org.aspectj.lang: JoinPoint.StaticPart, Signature, SourceLocation

Must not be visible:
  Anything that can interact with the outside world

Need to be faked: Class, Field, Method and Constructor
  These four classes would need to be replaced with fakes, maybe in 
org.aspectj.reflect.  The fakes would have almost all of the methods of the 
originals, but methods like invoke and newInstance would be removed.  All 
references to the original classes would be replaced with these fakes.


Minor Issues:
  How can we make this less cumbersome for simple cases?
  Can we solve the thisJoinPointStaticPart is much too long problem?
  Whatâs the best way to signal no message?
  Is there a good way to label this as an experimental feature in 1.2 to 
reduce the pressure to get the design just right the first time?
  Will people get more confused by if?


Note: There is an even more powerful proposal along these lines from Pengcheng 
Wu and Karl Lieberherr.  I don't currently have a good reference to their 
work, but it extends both the complexity and the power of the proposal above.</comment>
		<comment id="3" date="2003-12-17 20:23:04 EST" author="Jim Hugunin">This is an interesting area to pursue for the tool AspectJ.  However, all of 
the compelling examples are about duplicating the abilities of tools like 
CheckStyle (http://checkstyle.sourceforge.net).  They are not about AspectJ's 
rasion d'etre of providing better support for cross-cutting modularity.

With that in mind, we will consider a simple solution that will satisfy the 
greatest need for this feature.  The weaver will be modified very slightly to 
display the string representation of the join point shadow that is matched in 
addition to the string specified by the user.  This may be more verbose than a 
programmer specified string might be but it will provide all of the available 
information without requiring any changes to the language or standard library.

In fact, this information is already being passed to the Message object 
created by org.aspectj.weaver.Checker as "details".  The only issue seems to 
be that these details are not being printed.  This distinction between message 
and details is useful as it will allow IDE's to choose not to display this 
information all the time when their navigation features make it much less 
useful.  However, these details need to be enabled by default for command-line 
uses of the compiler/weaver.

This is being raised to a P2 enhancement request, where the feature to add is 
simply displaying the details for Messages when running on the command-line.

We will revisit this proposal in the future if this small change doesn't 
satisfy users.</comment>
		<comment id="4" date="2004-01-07 04:27:18 EST" author="Jim Hugunin">*** Bug 49328 has been marked as a duplicate of this bug. ***</comment>
		<comment id="5" date="2004-01-07 04:29:05 EST" author="Jim Hugunin">*** Bug 48796 has been marked as a duplicate of this bug. ***</comment>
		<comment id="6" date="2004-01-07 13:55:54 EST" author="Wes Isberg">More on four bugs/discussions to incorporate into this:

Two are marked as duplicates.  Typically, duplicates can be ignored as
redundant, but in this case duplicates are being incorporated for assessment
into a master bug.  (That can also be done by using a bug dependency and
optionally marking the depending bugs as LATER.)

- Bug 49328 is Pengcheng Wu's proposal for staticly-executable advice, available
from http://www.ccs.neu.edu/research/demeter/sea

- Bug 48796 is to permit compile-time string concatenation in declare
error/warning strings.

Two others are also relevant:

- Bug 31724 notes that we don't supply the source context for these messages
(like compiler-generated messages) like we used to in 1.0.  That issue is
deferred pending some implementation providing available source context to the
weaver.

- An RFE (I can't find) says the binary or source location of the declare
error/warning should be emitted along with the location of the offending join
point shadow, so that users can trace back to (and fix) the declare statement.</comment>
		<comment id="7" date="2004-03-15 11:42:34 EST" author="Adrian Colyer">Fixed in tree. Sample output for a declare error (this one against binary source 
in a jar file cdd.jar) is as follows:

D.java:6 error can only call bad from C
(no source information available)
 method-call(void C.bad())
 see also: C:\ColyerRoot\...\tests\errors\amctemp\A.java:5
 see also: C:\ColyerRoot\...\tests\errors\amctemp\cdd.jar</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="087842e53c2f60333d1114f8781fa77f619175e8" author="acolyer" date="2004-03-16 01:38:44"/>
          <file name="org.aspectj.ajdt.core/src/org/aspectj/tools/ajc/Main.java">
              <method name="render" returnType="String" parameters="IMessage"/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="44272" opendate="2003-10-7 0:05:00" fixdate="2004-3-15 12:33:00">
    <buginformation>
      <summary>"retitle warning to ""circular {advice} dependency at ..."""</summary>
      <description>When writing aspects with cycles in the advice precedence, get warning "circular
dependency at {join point}" -- should be "circular advice dependency..." or
"circular advice precedences at {join point} -- reorder the advice in the aspect".

FWIW, here's an example of circularity in advice precedence:
----
aspect A {
    pointcut crun() : execution (void run()) ;
    before() : crun() {}
    after() returning : crun() {}
    void around() : crun() { proceed(); }
}
----

See programming guide for more discussion of circularity in advice precedence.</description>
      <comments>
		<comment id="1" date="2004-02-19 09:30:23 EST" author="Adrian Colyer">This will be an easy change to incorporate in 1.2</comment>
		<comment id="2" date="2004-03-15 12:33:20 EST" author="Adrian Colyer">Fixed in tree:

sample new message:
C:\ColyerRoot\...\tests\bugs\CircularAdvicePrecedence.java:6:0 circular advice 
dependency at method-execution(void Runner.run())

also fixed a related problem whereby the message for declare precedence 
circularities was out of date:
FROM: circularity in declare dominates, '*' occurs more than once
TO: circularity in declare precedence, '*' occurs more than once</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="01095341153b24fcf5ab5f537ecc77077819b1f1" author="acolyer" date="2004-03-16 02:27:56"/>
          <file name="tests/bugs/CircularAdvicePrecedence.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/Shadow.java">
              <method name="sortMungers" returnType="void" parameters=""/>
          </file>
          <file name="weaver/src/org/aspectj/weaver/patterns/DeclarePrecedence.java">
              <method name="resolve" returnType="void" parameters="IScope"/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="51322" opendate="2004-2-7 17:11:00" fixdate="2004-3-15 17:43:00">
    <buginformation>
      <summary>Introduce Unknown Type to class causes Null pointer exception</summary>
      <description>Introduce method with an unknown type as an arguement as follows:
class A {}
public abstract aspect B
{
  public void A.someMethod(WCharType a) { //blah }
}

WCharType is an unknown type or is forgotten to be imported (in my case).

This shall cause ajc to puke the following:
java.lang.NullPointerException
        at org.aspectj.ajdt.internal.compiler.ast.InterTypeMethodDeclaration.build(InterTypeMethodDeclaration.java:87)
        at org.aspectj.ajdt.internal.compiler.ast.AspectDeclaration.buildInterTypeAndPerClause(AspectDeclaration.java:744)
        at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.buildInterTypeAndPerClause(AjLookupEnvironment.java:206)
        at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.completeTypeBindings(AjLookupEnvironment.java:94)
        at org.eclipse.jdt.internal.compiler.Compiler.beginToCompile(Compiler.java:310)
        at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:324)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:373)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:125)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:70)
        at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:99)
        at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:53)
        at org.aspectj.tools.ajc.Main.run(Main.java:217)
        at org.aspectj.tools.ajc.Main.runMain(Main.java:155)
        at org.aspectj.tools.ajc.Main.main(Main.java:72)
/home/czhang/eclipse/workspace/lib/libajob/org/omg/PortableServer/portable/Delegate.java:0
Internal compiler error
java.lang.NullPointerException
        at org.aspectj.ajdt.internal.compiler.ast.InterTypeMethodDeclaration.build(InterTypeMethodDeclaration.java:87)
        at org.aspectj.ajdt.internal.compiler.ast.AspectDeclaration.buildInterTypeAndPerClause(AspectDeclaration.java:744)
        at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.buildInterTypeAndPerClause(AjLookupEnvironment.java:206)
        at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.completeTypeBindings(AjLookupEnvironment.java:94)
        at org.eclipse.jdt.internal.compiler.Compiler.beginToCompile(Compiler.java:310)
        at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:324)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:373)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:125)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:70)
        at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:99)
        at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:53)
        at org.aspectj.tools.ajc.Main.run(Main.java:217)
        at org.aspectj.tools.ajc.Main.runMain(Main.java:155)
        at org.aspectj.tools.ajc.Main.main(Main.java:72)
 
 
!! no source information available !!
!! no source information available !!
ABORT
Exception thrown from AspectJ 1.1.1
 
This might be logged as a bug already -- find current bugs at
  http://bugs.eclipse.org/bugs/buglist.cgi?product=AspectJ&amp;component=Compiler
 
Bugs for exceptions thrown have titles File:line from the top stack,
e.g., "SomeFile.java:243"
 
If you don't find the exception below in a bug, please add a new bug
at http://bugs.eclipse.org/bugs/enter_bug.cgi?product=AspectJ
To make the bug a priority, please include a test program
that can reproduce this exception.
null
java.lang.NullPointerException
        at org.aspectj.ajdt.internal.compiler.ast.InterTypeMethodDeclaration.build(InterTypeMethodDeclaration.java:87)
        at org.aspectj.ajdt.internal.compiler.ast.AspectDeclaration.buildInterTypeAndPerClause(AspectDeclaration.java:744)
        at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.buildInterTypeAndPerClause(AjLookupEnvironment.java:206)
        at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.completeTypeBindings(AjLookupEnvironment.java:94)
        at org.eclipse.jdt.internal.compiler.Compiler.beginToCompile(Compiler.java:310)
        at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:324)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:373)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:125)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:70)
        at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:99)
        at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:53)
        at org.aspectj.tools.ajc.Main.run(Main.java:217)
        at org.aspectj.tools.ajc.Main.runMain(Main.java:155)
        at org.aspectj.tools.ajc.Main.main(Main.java:72)
 
 
1 fail|abort, 1 error</description>
      <comments>
		<comment id="1" date="2004-03-15 17:43:09 EST" author="Adrian Colyer">Now fixed in tree.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="5c67166488df998bc208567c2fd27f21b52592c5" author="acolyer" date="2004-03-16 07:38:03"/>
          <file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/InterTypeMethodDeclaration.java">
          </file>
          <file name="tests/bugs/Pr51322.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="54965" opendate="2004-3-16 10:08:00" fixdate="2004-3-16 10:12:00">
    <buginformation>
      <summary>Incremental compilation does twice as much work as necessary</summary>
      <description>When I added support for -outjar in the test harness, I was surprised to find 
duplicate entry exceptions coming from the output file writing to the outjar. I 
traced it through, and found that every source file passed to an incremental 
compile is in fact compiled twice!

The first time round we note the references, and of course each file has a 
reference to itself. Then we call "AjState.getFilesToCompile" looking to see if 
there are any further files to compile in another iteration. This method does 
not remember the set of files it just compiled, so since we have referenced each 
type we just compiled, and we have no reord of that fact, we compile them again. 
Second time around, the bytecodes are identical to the previous go, so 
recordClassFile doesn't note their dependents - and thus this time we terminate.</description>
      <comments>
		<comment id="1" date="2004-03-16 10:12:03 EST" author="Adrian Colyer">Fixed by remembering list of files we compiled on the last iteration in AjState.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="41c6f6d0a10e881ac705a108cdd59f31d160e1c7" author="acolyer" date="2004-03-17 12:07:19"/>
          <file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="47910" opendate="2003-12-2 13:35:00" fixdate="2004-3-17 7:32:00">
    <buginformation>
      <summary>ajc -outjar jarfile does not contain MANIFEST.MF</summary>
      <description>I call ajc -sourceroots &lt;mydir&gt; -outjar &lt;my.jar&gt; and an output file is created 
with a .jar extension, but it is not a valid jar file because there is no 
MANIFEST.MF file. I see that the text for ajc says:

-outjar &lt;file&gt;      put output classes in zip file &lt;file&gt;

which might imply that it is supposed to be a zip file, but a parameter called -
outjar which creates a zip file doesn't really make sense. If -outjar is used, 
the resulting file should be a valid jar file, i.e. with a META-INF/MANIFEST.MF 
file inside.</description>
      <comments>
		<comment id="1" date="2003-12-04 10:47:38 EST" author="Adrian Colyer">Matthew - another variation of the jar files and manifests problem, do you think 
you could take a look please? Thks :)</comment>
		<comment id="2" date="2003-12-10 06:07:27 EST" author="Matthew Webster">When using the â-outjarâ option and not binary weaving a simple default 
manifest, similar to that produced by other tools like jar and ant, should be 
generated:

    Manifest-Version: 1.0
    Created-By: AspectJ 1.2

If this is insuffiecent it can be replaced later by the user with:

    jar âmf â¦</comment>
		<comment id="3" date="2004-03-17 06:40:59 EST" author="Matthew Webster">Created attachment 8628 [details]
Fix

When -outjar specified a manfiest is either copied from the FIRST JAR in
-injars/-inpath or one is created. If writing to a directory the manifest is
copied but one is NOT created.</comment>
		<comment id="4" date="2004-03-17 07:32:26 EST" author="Adrian Colyer">Fixed by patch contributed by Matthew.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="34dbb0c41b3e324e3c7fc5a150c314fbecfd5e6e" author="acolyer" date="2004-03-17 09:25:49"/>
          <file name="ajde/testdata/JarManifestTest/src/Main.java">
          </file>
          <file name="ajde/testsrc/org/aspectj/ajde/AjdeTests.java">
              <method name="suite" returnType="Test" parameters=""/>
          </file>
          <file name="ajde/testsrc/org/aspectj/ajde/InpathTestcase.java">
          </file>
          <file name="ajde/testsrc/org/aspectj/ajde/JarManifestTest.java">
          </file>
          <file name="ajde/testsrc/org/aspectj/ajde/ResourceCopyTestCase.java">
          </file>
          <file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="52394" opendate="2004-2-18 13:35:00" fixdate="2004-03-12 09:36:27">
    <buginformation>
      <summary>inter-type declarations cause JRockit Crash</summary>
      <description>BEA's JRockit JVM (version:
8.1sp2-1.4.1_05-Load10-viking-win32-sthqa29-20031105-1554) crashes on simple
inter-type declarations. (Obviously I have also submitted this bug to BEA, but
the AJ team may be able to shed some light on what is going on and where (if
anywhere) BEA's JVM is behaving wrong.)

The cannonical example lies below:

public class SimpleClass {
    public static void main(String[] args) {
        SimpleClass simple = new SimpleClass();
    }
}

public aspect SimpleAspect {
    public int SimpleClass.foo;
}

When running SimpleClass I get a JVM crash with the following thread stack trace.

Thread Stack Trace:
    at _exprPush+112 ()@0082FF70
    at COM.jrockit.vm.RNI.toNative(Native Method)@32520000
    at COM.jrockit.vm.RNI.clinitTrampoline(Native Method)@325200FA
    at com.vms.adbase.jvmcrashtest.SimpleClass.&lt;init&gt;(SimpleClass.java:4)@344B0055
    at com.vms.adbase.jvmcrashtest.SimpleClass.main(SimpleClass.java:6)@344B0034
    --- End of stack trace

Feel free to ask me for further details. JRockit can be downloaded at:
http://commerce.bea.com/showallversions.jsp?family=WLJR. I reproduced this error
on Windows XP, but it also happend on RedHat.

Is it worth adding JRockit to AspectJ's compatibility test suite?</description>
      <comments>
		<comment id="1" date="2004-02-19 10:01:23 EST" author="Adrian Colyer">We need to investigate this in the 1.2 timeframe and if it can be fixed in 
AspectJ tree, do so.</comment>
		<comment id="2" date="2004-02-19 17:07:59 EST" author="Jim Hugunin">Removed 1.2 milestone and changed priority to P4.  This problem is unlikely to 
be addressed by the core AspectJ developers.  However, we would welcome a 
patch from either BEA or the user community to address this.  Rationale 
follows:

AspectJ should always generate legal Java bytecode that can run on any 
correctly implemented JVM.  If you can't run AspectJ generated bytecode then 
it is likely the result of a bug in your JVM.  Any time AspectJ can be shown 
to generate illegal bytecode that is a high-priority bug and will usually be 
handled by the core team.  I spent this morning fixing one such bug dealing 
with an interaction between around advice and Java's complicated rules for 
protected access: https://bugs.eclipse.org/bugs/show_bug.cgi?id=51929.

The harder question is what to do about bugs in popular JVMs.  These are not 
bugs in the implementation of AspectJ; however, they can cause problems for 
AspectJ's users.  Your bug report appears to clearly show this as a problem 
with the JRockit VM and therefore a bug that it is BEA's job to fix.  However, 
when resources are available we do try to fix these bugs on the AspectJ side.

I do all of my testing and development work on SUN's JVMs and will develop 
workarounds to bugs in those VMs if needed (the infamous Miranda methods are 
one example where we've done this in the past).  Several other core AspectJ 
developers work primarily on IBM's JVMs and will test and develop work-arounds 
for bugs found in those VMs.

We don't currently have any developers who work with JRockit.  We would love 
to accept patches and/or new developers who are focused on JRockit and can 
improve both testing and work-around any bugs in that platform.  I'm also open 
to contract work to address these kinds of specific low-level challenges 
(http://hugunin.net/consulting.html) but I'm personally not going to spend my 
free time dealing with the bugs of yet another JVM.</comment>
		<comment id="3" date="2004-02-20 17:41:29 EST" author="Nicholas Lesiecki">I just discovered that I was actually running the compiler shipped with the
1.1.6 (development) AJDT release. I am a bit embarrassed. (I hadn't realized
that the development AJDT came with a development compiler). Based on Jimâs
compatibility stance, I am pursuing this bug with BEA/JRockit and hope that they
will either prove that the bytecode is illegal or fix their bug. I'll leave this
case open until this bug is fixed by one party or another (unless that's
inconvenient).</comment>
		<comment id="4" date="2004-02-23 14:39:50 EST" author="Adrian Colyer">Nick wrote:
&gt;&gt;This means (as far as I know) AspectJ 1.1.1 (as distinct from
&gt;&gt;AJDT-packaged-DEV 1.1.6) *does* work with JRockit. (Apologies for earlier
&gt;&gt;statement to the contrary.)

If you can verify that the AspectJ 1.1.1 generated .class file works ok, and can 
add both the offending class file and its 1.1.1 equivalent as attachments to 
this bug that would be very helpful in identifying the likely source of the 
problem and if nothing else enable us to give the JRocket guys a little more of 
a clue as to what the problem might be...

Thanks, Adrian.

-- assigning bug to me as I'm curious enough to do the next level of analysis 
given the attachments.</comment>
		<comment id="5" date="2004-02-24 17:09:07 EST" author="Nicholas Lesiecki">Created attachment 8138 [details]
Files generated with 1.1.1 compiler: work

These files were generated with the 1.1.1 compiler and work as expected (print
3 to standard out when SimpleClass's main is run)</comment>
		<comment id="6" date="2004-02-24 17:15:40 EST" author="Nicholas Lesiecki">Created attachment 8141 [details]
Files generated with DEV compiler: crash

These class files were generated with the development version of ajc downloaded
in conjunction with AJDT 1.1.6. When I run SimpleClass, JRockit crashes. (Sun
1.4.2 works as expected)</comment>
		<comment id="7" date="2004-02-24 17:16:38 EST" author="Nicholas Lesiecki">I've attached the two cases, working and non. Thanks for looking into this Adrian.</comment>
		<comment id="8" date="2004-03-02 08:26:11 EST" author="Andrew Clement">Looking at the disassembled bytecode, we have the following.  In the working 
case the static initializer looks like this:

static {};
  Code:
   0:   invokestatic    #12; //Method ajc$postClinit:()V
   3:   return

In the failing case (where we try and cope with exceptions in ajc$postClinit) -
 it looks like this:

static {};
  Code:
   0:   invokestatic    #14; //Method ajc$postClinit:()V
   3:   goto    9
   6:   putstatic       #16; //Field ajc$initFailureCause:Ljava/lang/Throwable;
   9:   return
  Exception table:
   from   to  target type
     0     3     6   Class java/lang/Throwable

There is much more logic in it now.  But this looks valid and indeed runs in 
the JVMs in which we've tried it.  Interestingly I have two decompilers that 
cannot make sense of the code in this method.

So, now, if we code the Java that is equivalent to what we are trying to 
achieve:

    static
    {
        try {
                ajc$postClinit();
        } catch (Throwable t) {
                ajc$initFailureCause = t;
        }
    }

And compile it with javac, then disassemble that, we have:

static {};
  Code:
   0:   invokestatic    #10; //Method ajc$postClinit:()V
   3:   goto    11
   6:   astore_0
   7:   aload_0
   8:   putstatic       #6; //Field ajc$initFailureCause:Ljava/lang/Throwable;
   11:  return
  Exception table:
   from   to  target type
     0     3     6   Class java/lang/Throwable

Notice the 'extra' astore_0, aload_0.  This appears to be a pattern that we 
aren't following in the code we are generating.  If I add the generation of 
astore and aload to AspectJ then I generate a static initializer that looks 
just like the one above *and* both of my decompilers can make sense of it and 
show me what I expect to see.

I'm attaching a zip containing a SimpleAspect.class and SimpleClass.class 
built using my patched AspectJ.

Nick, can you possibly try running the classes from that zip on a JRockit JVM?

thanks,
Andy.</comment>
		<comment id="9" date="2004-03-02 08:27:27 EST" author="Andrew Clement">Created attachment 8267 [details]
Zip containing class files generated by a patched AspectJ

Contains a new SimpleAspect.class and SimpleClass.class - let me know if they
work on JRockit.
thanks.</comment>
		<comment id="10" date="2004-03-02 08:38:18 EST" author="Andrew Clement">Adding myself to cc:</comment>
		<comment id="11" date="2004-03-04 10:54:14 EST" author="Nicholas Lesiecki">I tested the classes compiled by the patched AspectJ. They passed on both sp1
and sp2 JRockit JVMs. 

I also had at least two decompilers (cavaj and decafe) crash on SimpleAspect
before the patch. They can both digest the class file comfortably now.

As far as I'm concerned, this particular bug is fixed--though there may be other
instances of similar code generated by AspectJ elsewhere. I'll let you know if
we run into any.

Test runs:
C:\ajtest\simple&gt;\bea\jrockit81sp1_141_03\bin\java -cp . SimpleClass
3

C:\ajtest\simple&gt;\bea\jrockit81sp2_141_05\bin\java -cp . SimpleClass
3</comment>
		<comment id="12" date="2004-03-04 11:28:14 EST" author="Andrew Clement">Thanks for testing those classes :)  I've just checked the fixes in - they 
should be available from our brand new best-so-far download process in about 5-
6 hours time.

I don't think we've made this kind of change anywhere else in AspectJ in the 
run up to 1.2 so hopefully all the rest of our generated bytecode will still 
be working fine in JRockit and the various decompilers.</comment>
		<comment id="13" date="2004-03-04 21:11:04 EST" author="Jim Hugunin">I'm glad Andy was able to come up with a work-around for this bug in JRockit.  
I hope that the folks at BEA are still working on fixing this bug in their VM 
as well.

This bug reminds me of another decompiler bug -- #46298.  This is another case 
where AspectJ is generating bytecode that confuses some disassemblers and has 
to do with exception handlers as well.

Nick - If you have the time could you run Ron's test case on JRockit to see if 
the same problem is present here as well.  If so that might raise the priority 
of fixing that bug.</comment>
		<comment id="14" date="2004-03-12 09:36:27 EST" author="Adrian Colyer">Fixed by Andy Clement, as per his comment on Mar 02.</comment>
		<comment id="15" date="2004-03-19 09:40:59 EST" author="Adrian Colyer">updating target flag to indicate inclusion in 1.2 release.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="5d73494d7d222b92cdbb19f860f9215a07430681" author="aclement" date="2004-03-05 01:09:34"/>
          <file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectClinit.java">
              <method name="generatePostSyntheticCode" returnType="void" parameters="ClassScope CodeStream"/>
          </file>
          <file name="weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="54625" opendate="2004-3-12 9:43:00" fixdate="2004-03-16 10:17:52">
    <buginformation>
      <summary>Incremental support does not work with outjar</summary>
      <description>Either fix the class file deleting etc. to work with jars, or always do a batch 
build when working with outjars.</description>
      <comments>
		<comment id="1" date="2004-03-16 10:17:52 EST" author="Adrian Colyer">zip files don't support adding or updating files in an existing jar (you need to 
take a copy and move everything across). This can be done, but is a bit of work. 
I'm reluctant to do it because the test harness does not support both 
incremental and outjar at the same time (and it was getting too difficult to 
make it work effectively) so I can't write a good test suite around it. 
Therefore for 1.2 I've added a simple test in AjState.prepareForNextBuild() that 
returns false (can't do incremental) if an outjar is specified. This ensures 
that results are at least always correct. We can do better post 1.2 when we have 
more time to update the test harness.</comment>
		<comment id="2" date="2004-03-19 09:41:29 EST" author="Adrian Colyer">updating target flag to indicate inclusion in 1.2 release.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="1a4c02c986332c37aa1d1e86867b2434892eb11f" author="acolyer" date="2004-03-17 12:16:46"/>
          <file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java">
              <method name="prepareForNextBuild" returnType="boolean" parameters="AjBuildConfig"/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="45489" opendate="2003-10-24 6:34:00" fixdate="2004-02-19 11:11:24">
    <buginformation>
      <summary>Structure model is wrong when re-opened</summary>
      <description>Some elements have the wrong kinds when a saved structure model is loaded.  
E.g. if I close then re-open the eclipse workbench classes are shown as 
interface in the outline view.  Also if I traverse the tree with the code 
below I get the wrong kinds assigned to classed, interfaces, aspects and 
import declarations.

List list = StructureModelUtil.getPackagesInModel();
for(Iterator i = list.iterator(); i.hasNext();){
    Object[] o = (Object[])i.next();
    IProgramElement node = (IProgramElement)o[0];
List files = StructureModelUtil.getFilesInPackage(node);
			for(Iterator i2 = files.iterator(); i2.hasNext();){
				IProgramElement file = (IProgramElement)i2.next
();
				System.out.println("file " + file.getKind
().toString() + ", " + file.getName());
				boolean added2 = false;
				
				List file_children = file.getChildren();
					// file children can be classes, 
aspects or other things
				for(Iterator i3 = file_children.iterator(); 
i3.hasNext();){
					IProgramElement file_child = 
(IProgramElement)i3.next();
					System.out.println("kind: " + 
file_child.getKind().toString() +", " + file_child.getName());</description>
      <comments>
		<comment id="1" date="2003-10-24 07:05:07 EDT" author="Sian Whiting">*** Bug 45488 has been marked as a duplicate of this bug. ***</comment>
		<comment id="2" date="2003-11-27 10:51:36 EST" author="Adrian Colyer">curious... without looking at the source I'd guess there might be some type-safe 
enum patterns used that haven't been extended properly to allow for 
serialization?</comment>
		<comment id="3" date="2004-02-19 11:11:24 EST" author="Mik Kersten">I have committed a fix for this.  The problem was indeed with the type-safe 
enum patterns.  I added a test case that compares all of the nodes in a test 
model before and after the build:

ajde/testsrc/org/aspectj/ajde/SavedModelConsistencyTest</comment>
		<comment id="4" date="2004-03-19 09:42:41 EST" author="Adrian Colyer">updating target flag to indicate inclusion in 1.2 release.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="669cd7ce8634623c004cca5732c94a20fd7f57f7" author="mkersten" date="2004-02-20 01:02:06"/>
          <file name="ajde/testsrc/org/aspectj/ajde/AjdeTests.java">
              <method name="suite" returnType="Test" parameters=""/>
          </file>
          <file name="ajde/testsrc/org/aspectj/ajde/SavedModelConsistencyTest.java">
          </file>
          <file name="asm/src/org/aspectj/asm/IProgramElement.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="50200" opendate="2004-1-19 6:01:00" fixdate="2004-01-22 17:43:40">
    <buginformation>
      <summary>aspectjrt.jar manifest file name needs changing to upper case</summary>
      <description>The name of the aspectjrt.jar's manifest file should be changed from 

META-INF/manifest.mf

to 

META-INF/MANIFEST.MF

According to the Jar file specification (see http://java.sun.com/products/jdk/1.
2/docs/guide/jar/manifest.html) the name of the manifest file needs to be all 
upper case. It's beyond trivial, I know, but it does cause an unnecessary 
warning in at least one popular IDE for J2EE development (IBM WebSphere Studio)
when the aspectjrt.jar is packaged in an EAR file.

If there was an option to assign this a "very, very trivial" severity level I 
would.</description>
      <comments>
		<comment id="1" date="2004-01-22 06:04:08 EST" author="Andrew Clement">Georges fix has been integrated but I can't change the state of this bug to 
fixed.  Can someone else? thanks.</comment>
		<comment id="2" date="2004-01-22 17:43:40 EST" author="Mik Kersten">Fixed by George.</comment>
		<comment id="3" date="2004-03-19 09:43:08 EST" author="Adrian Colyer">updating target flag to indicate inclusion in 1.2 release.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="6f099df282f6d4994e09e457132677de7194c471" author="aclement" date="2004-01-22 07:55:43"/>
          <file name="build/src/org/aspectj/internal/tools/ant/taskdefs/AntBuilder.java">
              <method name="assemble" returnType="boolean" parameters="Module File List"/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="50776" opendate="2004-1-28 12:21:00" fixdate="2004-03-05 05:54:30">
    <buginformation>
      <summary>fail in compiling aspect with overriding method introduction with different throws clause</summary>
      <description>A first class (class A) declares only one method with some exceptions in the
throws clause ( void m() throws Exception ).
A second class (class B) extends it without redefinig the method. 
An aspect declares a method introduction in the class B, with the same name,
signature and return type of the one in class A, but without throws clause; this
is a legal override.
In the second class (class B) each invocation to the overriden method doesn't
need a try-catch block, because it refers to his hown method that raises no
exception.
This code compiles using 
ajc version 1.0.6 (built Jul 24, 2002 6:21 PM PST) running on java 1.4.0
But not using
AspectJ Compiler 1.1.1 
AspectJ Compiler 1.1.0

class A{
  public A(){}
  public void m() throws Exception{}
}

class B extends A{
  public B(){}
  public void some_code(){
    m();}
}

aspect C{
  public void B.m(){}
}</description>
      <comments>
		<comment id="1" date="2004-03-04 16:54:13 EST" author="Jim Hugunin">Assigning to Andy, but including a tip.

This is probably a bug in InterTypeMemberFinder.getExactMethod.  If you look 
at the corresponding getMethods method that one checks to see if there are any 
intertype methods declared and if so adds them to the base set that comes from 
the pure jdt logic.  For this method, instead it assumes that if the base 
method returned from the jdt code is valid then there's no reason to check for 
any intertype declarations.  Set a break point here and run the given test to 
see if this is the right diagnosis.</comment>
		<comment id="2" date="2004-03-05 05:54:30 EST" author="Andrew Clement">Jim was write (as usual!) - when getExactMethod() found a method existing on 
the type, it did not check for intertype declarations that may be overriding 
it.  Basically, it did not allow for the case where the method was inherited 
from a supertype and overridden via an ITD.  Fix checked in.</comment>
		<comment id="3" date="2004-03-19 09:43:52 EST" author="Adrian Colyer">updating target flag to indicate inclusion in 1.2 release.</comment>
		<comment id="4" date="2004-03-19 09:44:49 EST" author="Adrian Colyer">I really am updating the target flag this time...</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="c79892369fa4225ee5eb71b42c96e289f2eb4fc9" author="aclement" date="2004-03-05 07:50:50"/>
          <file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/InterTypeMemberFinder.java">
              <method name="getExactMethod" returnType="MethodBinding" parameters="SourceTypeBinding char[] TypeBinding[]"/>
          </file>
          <file name="tests/bugs/IntertypeDifferentThrows.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="53012" opendate="2004-2-24 19:43:00" fixdate="2004-3-19 9:45:00">
    <buginformation>
      <summary>declare precedence on a class should be a compile-time error</summary>
      <description>The compiler silently accepts

----
public class DeclarePrecedence {
public static void main(String[] args) {
    System.out.println("hello");
}
}
aspect DP {
    declare precedence: DeclarePrecedence, DP;
    before() : staticinitialization(DeclarePrecedence) {
        System.out.println("ok"); 
    }
}
----

Since this is likely to be a mistake, an error would be nice.  However, that
would mean saying (!TargetClass &amp;&amp; TargetClass+) to pick out the aspect subtypes
of TargetClass.</description>
      <comments>
		<comment id="1" date="2004-02-27 11:13:45 EST" author="Andrew Clement">Created attachment 8210 [details]
Patch for: weaver/src/org/aspectj/weaver/patterns/DeclarePrecedence.java

This will produce a compile time error message if a declare precedence
statement includes a non-aspect type.</comment>
		<comment id="2" date="2004-03-18 13:50:07 EST" author="Jim Hugunin">I'm a little worried that this change would prevent the use of marker 
interfaces for precendence, something like this:

public aspect Priority {
    public interface Highest {}
    public interface Lowest {}
    declare precedence: Highest+, *, Lowest+;
}

aspect Security implements Priority.Highest {}

I'd suggest modifying Andy's patch to check if pi.isIncludeSubtypes() and if 
so not to produce an error since it is possible for an aspect to match any 
such pattern.

Otherwise, I'm assigning this to Andy to implement his patch and add both 
Wes's original positive test case and my negative test case to the test suite.</comment>
		<comment id="3" date="2004-03-19 04:45:30 EST" author="Andrew Clement">Fix checked in.  I modified my patch to allow for non-aspect types where the 
subtypes are included.  Both test cases are now in ajcTests.xml.  Here is the 
error message that now comes out whilst compiling Wes' test.  Wording is ok I 
hope?

"Non-aspect types can only be specified in a declare precedence statement when 
subtypes are included.  Non-aspect type is : DeclarePrecedenceTestClass"</comment>
		<comment id="4" date="2004-03-19 09:45:12 EST" author="Adrian Colyer">updating target flag to indicate inclusion in 1.2 release.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="0a017593dcbeab409c1634da87b3f500b848e903" author="aclement" date="2004-03-19 06:28:14"/>
          <file name="tests/bugs/declarePrecedenceWithClasses/DeclarePrecedenceTestClass.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/patterns/DeclarePrecedence.java">
              <method name="resolve" returnType="void" parameters="IScope"/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="36234" opendate="2003-4-8 14:04:00" fixdate="2004-01-15 06:48:35">
    <buginformation>
      <summary>out of memory error when compiling</summary>
      <description>Getting an out of memory error when compiling with Ajc 1.1 RC1. 
I know this is not very descriptive, but maybe you can point me into a 
direction of getting more output.

here some additional information though:
Code base is medium size (about 1500 classfiles)
I removed all my aspects and still receive the error.
Running it from the command line: ajc -classpath whateveritis -sourceroots 
whateveritis -d whateveritis</description>
      <comments>
		<comment id="1" date="2003-04-08 16:31:50 EDT" author="Jim Hugunin">I believe this is a duplicate bug that says we need to handle OutOfMemory in a 
friendlier way.  Hopefully you can resolve this by following the instructions 
in the FAQ:
http://dev.eclipse.org/viewcvs/indextech.cgi/~checkout~/aspectj-
home/doc/faq.html#q:ajcoom


*** This bug has been marked as a duplicate of 35636 ***</comment>
		<comment id="2" date="2003-11-17 10:00:55 EST" author="Jack Kenefick">Occurs on fresh install of winXP with one simple aspect

package com.x.y;
public aspect CurrTableUpdateAspect
{
     pointcut printouts();

     before(): printouts() {
       System.out.println("*** Entering printMessage ***");
     }
     after():  printouts() {
       System.out.println("*** Exiting printMessage ***");
     }
}

There are 687 java files in the default.lst.</comment>
		<comment id="3" date="2004-01-15 06:48:35 EST" author="Adrian Colyer">I've made a small update to the compiler to handle OutOfMemoryError in a much
more graceful way.

An ajc compile running out of memory will now produce the following message and 
then exit:

AspectJ &lt;version&gt; ran out of memory during compilation:

Please increase the memory available to ajc by editing the ajc script 
found in your AspectJ installation directory. The -Xmx parameter value
should be increased from 64M (default) to 128M or even 256M.

See the AspectJ FAQ available from the documentation link
on the AspectJ home page at http://www.eclipse.org/aspectj</comment>
		<comment id="4" date="2004-03-19 09:50:10 EST" author="Adrian Colyer">updating target flag to indicate inclusion in 1.2 release.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="b3b1eecf938fdc9d0bd8f954bc05ec38763299fb" author="acolyer" date="2004-01-15 08:43:14"/>
          <file name="org.aspectj.ajdt.core/src/org/aspectj/tools/ajc/Main.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="47952" opendate="2003-12-3 0:43:00" fixdate="2004-01-15 00:27:45">
    <buginformation>
      <summary>SoftException.printStackTrace(..) should print wrapped throwable too</summary>
      <description>SoftExceptions should print not only their trace but also that of the wrapped
throwable.

We should be able to set a flag on class initialization whether we are running
under 1.4 and then implement it under 1.4 using initCause() and otherwise by
direct delegation.  I can do this fix if we're agreed.</description>
      <comments>
		<comment id="1" date="2004-01-12 09:51:10 EST" author="Jim Hugunin">I think it would be simpler to just fix this so that we do the correct thing 
under 1.4 which supports this notion of nested exceptions, but not to change 
our behavior under 1.3.

However, I have no objections to your fix so long as you're careful to not 
break the runtime on earlier VMs.  We're still promising that aspectjrt.jar 
will work on 1.1.</comment>
		<comment id="2" date="2004-01-15 00:27:45 EST" author="Wes Isberg">fixed in tree.  JUnit test passes under 1.1, 1.3, and 1.4.</comment>
		<comment id="3" date="2004-01-15 00:42:04 EST" author="Wes Isberg">forgot target 1.2M1

I must say I thought we should use initCause:
-----
public SoftException(Throwable inner) {
  super();
  this.inner = inner;
  if (HAVE_JAVA14 &amp;&amp; (null != inner)) {
     initCause(inner);
  }
}
-----
but since you-all didn't when implementing getCause(),
I left it as-is.</comment>
		<comment id="4" date="2004-03-19 09:55:04 EST" author="Adrian Colyer">updating target flag to indicate inclusion in 1.2 release.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="ad2fb7a583f7451f3101f8101b090999d6a43341" author="wisberg" date="2004-01-15 02:21:33"/>
          <file name="runtime/src/org/aspectj/lang/SoftException.java">
          </file>
          <file name="runtime/testsrc/RuntimeModuleTests.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="40192" opendate="2003-7-16 6:57:00" fixdate="2004-3-19 10:14:00">
    <buginformation>
      <summary>build cancel during weaving</summary>
      <description>The build can not be cancelled during the bytecode weaving stage.</description>
      <comments>
		<comment id="1" date="2004-02-25 08:20:30 EST" author="Andrew Clement">Two options that I can see:

Extend the IProgressListener interface
  boolean isCanceled()
Which we then check in the BcelWeaver

Extend the IMessageHandler interface
  boolean cancelRequested()
Which we can check in multiple places - probably BcelWeaver and below 
(BcelClassWeaver).

---
The first case makes sense if we consider the only cancellation use case to be 
via some kind of UI/IDE that is monitoring the compilation and may want to 
stop it.

The second case makes sense if we think cancellation is a more general kind of 
request that any compiler/weaver user might request.
---
any comments Mik?</comment>
		<comment id="2" date="2004-02-25 11:55:46 EST" author="Mik Kersten">I just spent some time on this since in AJDE we still have a bunch of the 
infrastructure that made canceling work properly in 1.0.x.  So I'll need to 
clean that up, since the cancelling functionality already exists in other 
places (and AJBrowser, JBuidler, and NetBeans are coupled to it).

Wh don't you go ahead with your first option and extend IProgressListener, 
probably with setCancelledRequested(boolean) and isCancelledRequested() 
methods.  I believe that this is actually general enough, and that any client 
capable of cancelling builds/weaves should be aware of that progress 
listener.  The IMessageHandler is not appropriate for this.  Note that you'll 
need to add an implementation to AJDE's BuildNotifierAdapter -- just make that 
a stub since that's part of what I need to clean up.

Please update the report you've added the checks and have a test case in AJDE 
that checks the cancel during both compile and weave.  I wonder if the test 
case needs to check that there are no partly-written classfiles on disk.  But 
proper error/abort handling in the weaver should have ensured of that already.

After that I'll update AJDE accordingly, clean out the old canceling logic 
from the buld and compile manager and make sure it works in the Swing 
clients.  After that making it work for AJDT will be trivial.</comment>
		<comment id="3" date="2004-03-04 06:31:25 EST" author="Andrew Clement">As Mik suggests, I have extended IProgressListener.  I then picked some key 
points that seemed sensible valid states in which to check for cancellation:

1) Between file compilations
2) Between file weaves

In either of these states we are 'consistent' and can exit cleanly knowing 
what is on the disk and we are not half way through doing anything.
Aborting half way through weaving a file or half way through compiling an 
individual file is risky.

So, for each case:

1) Between file compilations

AjBuildManager.acceptResult() is called.  At the end of acceptResult() check 
if cancel is requested, throw 
   new AbortCompilation(true,new CompilationCancelledException());

AbortCompilation is a valid mechanism for the JDT compiler to exit, true means 
silently, the CompilationCancelledException is a new AJ type that will be 
thrown from the AbortCompilation handling code that will percolate up to 
performCompilation().  We simply put a catch around the compiler.compile() 
call in the performCompilation method and just return.

2) Between file weaves
The least intrusive change here is to check for cancellation at the start of 
the BcelWeaver.weave(UnwovenClassFile,BcelObjectType,boolean) method and have 
a WeavingCancelledException thrown which is then caught at the top level weave
() method that has a try...catch around all of its activities.  The weave() 
method is defined to return a Collection of files that were successfully 
woven - and putting the try..catch and exception throwing logic at the places 
suggested ensures weave() still returns correctly with the list of files it 
managed to weave successfully. (Just in case the code calling weave() makes 
some assumption about the results it gets back).  Of course, any caller of the 
compiler/weaver that used the cancellation mechanism will know that it cannot 
rely on the results.

Anyway, all the changes above total about 30lines of code so they don't get in 
the way of understanding what the compiler/weaver are doing today.  But I'm 
not checking this feature in right now - principally because Adrian is 
changing the whole compile/weave flow and that will impact this design.</comment>
		<comment id="4" date="2004-03-04 16:44:52 EST" author="Jim Hugunin">I think your points to interrupt compilation sound right.  I'd implement it a 
little bit differently.

For the weaver I'd modify the BcelWeaver.weave() method to insert this check 
in its various loops.  This feels much cleaner to me than throwing an 
exception.

For the compiler I think you want to understand how the JDT interrupts 
compilations.  You'll need to be compatible with this anyway for the IDE 
work.  Whatever mechanism is used there is probably the right one to use to 
interrupt ajdt compilation.</comment>
		<comment id="5" date="2004-03-18 08:21:34 EST" author="Andrew Clement">This was more straightforward after Adrians changes to the compilation/weaving 
process.  Now there is a single catch block around compiler.compile() that 
catchs OperationCancelledException.  When we wish to abort either compilation 
or weaving, we throw an AbortException containing an 
OperationCancelledException - this is the JDT way of doing things.  JDT 
unwraps it and the OperationCancelledException percolates out to where we can 
see it and catch it.  There are two points where we check for cancellation:
- After compiling a file
- After weaving a file
BuildCancellingTest has been added to ajde tests to verify the behavior is as 
expected.

In the process of getting the progresslistener into the right place in the 
weaver for checking cancellation I added some suitable progress feedback 
(percentages and messages) for weaving.</comment>
		<comment id="6" date="2004-03-19 10:14:29 EST" author="Andrew Clement">Changes now building successfully on our build machine.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="183fc23883289ae42854ce9afcf2d3b0d29b7599" author="aclement" date="2004-03-18 10:00:01"/>
          <file name="ajde/src/org/aspectj/ajde/internal/BuildNotifierAdapter.java">
          </file>
          <file name="ajde/testdata/BuildCancelling/Cl1.java">
          </file>
          <file name="ajde/testdata/BuildCancelling/Cl2.java">
          </file>
          <file name="ajde/testdata/BuildCancelling/Cl3.java">
          </file>
          <file name="ajde/testdata/BuildCancelling/HW.java">
          </file>
          <file name="ajde/testsrc/org/aspectj/ajde/AjdeTests.java">
              <method name="suite" returnType="Test" parameters=""/>
          </file>
          <file name="ajde/testsrc/org/aspectj/ajde/BuildCancellingTest.java">
          </file>
          <file name="bridge/src/org/aspectj/bridge/IProgressListener.java">
              <method name="setProgress" returnType="void" parameters="double"/>
          </file>
          <file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/AjCompilerAdapter.java">
          </file>
          <file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/WeaverAdapter.java">
          </file>
          <file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="31460" opendate="2003-2-10 10:35:00" fixdate="2004-4-2 7:31:00">
    <buginformation>
      <summary>Weaving class loader</summary>
      <description>Hi!

As discussed on the mailing list a few days ago I implemented a weaving class
loader to enable bytecode based weaving at class loading time. The class loader
is based on the URLClassLoader and can be used like any other URLClassLoader. In
addition to that you can add aspects to the weaving loader. These aspects got
woven into each class that is loaded. The test cases for the class loader aren't
implemented yet, I am still thinking about how to implement them. I will
contribute them later, okay?

-Martin</description>
      <comments>
		<comment id="1" date="2003-02-10 10:38:25 EST" author="Martin Lippert">Created attachment 3388 [details]
WeavingURLClassLoader zip file</comment>
		<comment id="2" date="2003-02-10 10:41:54 EST" author="Martin Lippert">The implementation needs the changes of bug no 30794 to compile.</comment>
		<comment id="3" date="2003-02-20 23:12:38 EST" author="Wes Isberg">This is great.

After a brief glance at the code, I have two questions: First, should the 
weaving class loader require that any aspects be defined before any class 
loading occurs?  Let's say my aspect advises calls to {Runnable}.run() and that 
I load some classes implementing Runnable before and after I register the 
aspect.  As a result, not all calls are advised.

That (to me) is an error.  As a possible counter-example, Sun's URLClassLoader 
does permit URL's to be added to the classpath, so that classes which did not 
load before a URL is added can be loaded.  But still that preserves the 
invariant that once a class is loaded, it's used throughout the associated 
namespace (lazy but final class loading (leaving aside for the moment debugger 
class unloading in recent VM's)).  

So for aspects, I believe there is an invariant the class loader must enforce: 
that any aspect in a namespace applies to all classes in the namespace -- which 
means the set of aspects must be defined before any classes are loaded.

Which brings up a second question: Should there be a classpath which the weaving 
class loader uses to load classes but not to weave them?   It seems like a 
weaving class loader could have essentially the same namespace declaration as 
the compiler in bytecode-weaving mode: an aspectpath, a classpath (for classes 
not to be woven), and an injars (for classes to be woven (leaving aside the 
difference in form between injars and classpath)).  Defining these only via 
constructor would enforce the aspect-namespace invariant.  In this scenario, 
when loading a class, the loader should first delegate upwards, and then attempt 
to load classes from the classpath (without weaving) and then from the injars 
path (with weaving).  But this means the aspect namespace invariant is broken 
for classes loaded from the weaving class loader's classpath.  Hmm.

By contrast, most people speak as if the weaving class loader should weave any 
class it loads (essentially equating injars with the classpath).  We could build 
a weaving class loader that did that, relying entirely on upwards delegation for 
resolving classes (not to be woven) on the classpath.  

But a weave-only class loader could not handle the scenario where there are 
classes which are not to be woven but which are required to weave.  For that the 
user would set up two custom class loaders: a parent class loader (say, 
URLClassLoader) to load the required-but-unwoven classes, and the weaving class 
loader that delegates upward to the parent class loader.  

On that note, the aspect-namespace invariant already *seems* broken for classes 
loaded from a parent class loader.  As a practical matter, we probably need to 
live with that since most users do not want to weave system classes (although I 
believe there a way in 1.4 to define the class used as the system class loader). 
One could try to make fine distinctions about namespace sub-hierarchies, but I 
doubt that would prevent users from making mistakes.  So parent class loaders  
result in an unfortunate but definable implementation limitation.  It's 
manageable because there's a concrete way to define it, based on the defining 
class loader of a class.

And users might want this "implementation limitation."  They might want to 
distinguish classes not to be woven for reasons of correctness or performance, 
segregating "known" correct (as unwoven) classes.  The System classes are the 
most obvious example, but it could also be required to share library classes 
across classloaders (one weaving, one not) for interoperability in systems where 
not all the classloaders are under the control of the user. 

It might even be the "worse-is-best" way to specify a namespace.  Normally it's 
best to specify any crosscutting in the source code, but in Java the way to 
specify namespaces is by arranging a class loader hierarchy, complete with the 
special behavior of any custom class loaders.  So at least we'd be doing it the 
Java way.

Back to the question of whether there should be an unwoven class path, given 
that the workaround of a parent class loader seems most understandable and 
correct, it seems that an initial version of the weaving class loader should 
weave all classes on its classpath.  The documentation should make it clear that 
it is treating the classpath like -injars input, and show a brief code example 
how to set up a parent loader for the unwoven classpath.  That way we can 
maintain the aspect-namespace invariant at least for classes loaded by the 
weaving/defining class loader.

One way to try to manage this long-term is to provide users with a factory 
method that takes a parent class loader, an (unwoven) classpath, an aspectpath, 
and a (woven) injars path and returns a WeavingClassLoader.  That way, we can 
change the implementation without affecting client code.  The initial 
implementation would set up a parent class loader with the classpath and return 
a child weaving class loader.  (The only problem with this is that the defining 
class loader of classes loaded from the classpath would not be the one returned 
by the factory.)  Subsequent implementations could have the weaving class loader 
define the unwoven classpath classes.

In any case, since the user will be living with this implementation limitation 
for any parent delegates, it would be nice if the user could request a warning 
from the weaving class loader when aspects would affect classes not woven 
because they were loaded by upwards delegation. It would also warn if the 
weaving class loader were extended to support an unwoven class path.</comment>
		<comment id="4" date="2003-02-21 01:12:37 EST" author="Wes Isberg">Sorry, this example is wrong since we're not implementing callee-side call join 
points now:

&gt; ...Let's say my aspect advises calls to {Runnable}.run() and that 
&gt; I load some classes implementing Runnable 
&gt; before and after I register the  aspect.

but you probably got the idea...</comment>
		<comment id="5" date="2003-02-24 02:56:05 EST" author="Martin Lippert">I see the point and totally agree with it. The class loader should not load any
classes before he knows all the aspects that should be woven into them. Then the
class loader should weave any classes he loads (aside of the classes loaded by
the parent loader).
The question is how to archieve that. One possiblity (that you mentioned) is to
give all the aspects to the class loader via a constructor parameter. This is
the cleanest way from my point of view.
Unfortunately this does not work for me inside my project. The reason is that I
need to have an instance of the class loader before I can figure out what
aspects are available. Therefore I originally implemented the "addAspect" method.

Okay, here is the second try: I changed my original implementation of the class
loader following your argumentation. Now the constructors have two additional
arguments: One for the aspect URLs and a second one for additional classpath
entries which got not be loaded but are needed for the weaver to resolve types
during the weaving process.
All other methods to add URLs (with or without aspects) are private and
therefore not usable from outside. There is only one exception: The addAspect
method is protected to let subclasses refine and/or use it. This allows me to
use the WeavingURLClassLoader as it is. What do you think?</comment>
		<comment id="6" date="2003-02-24 02:57:25 EST" author="Martin Lippert">Created attachment 3663 [details]
WeavingURLClassLoader version 2</comment>
		<comment id="7" date="2003-04-27 08:10:22 EDT" author="Martin Lippert">Hi,

meanwhile I adapted my weaving Eclipse runtime to Eclipse 2.1 final and slightly
changed the architecture of the integration. The result is that I do no longer
need the specialized weaving class loader for it. I separated the functionality
into a bytecode transformer component interface that is called by a special
class loader if a class is loaded. There is one AspectJ-specific implementation
to that interface that directly uses the weaving functionality I formerly
inserted into the class loader.

The result is: I do no longer need this weaving class loader for the weaving
Eclipse runtime integration. Therefore I am free to skip the dependencyAdded
method, for example, to make this a real general purpose AspectJ load-time
weaving class loader.</comment>
		<comment id="8" date="2003-12-08 08:27:36 EST" author="Adrian Colyer">moved to target = 1.2</comment>
		<comment id="9" date="2004-01-28 12:35:08 EST" author="Matthew T. Adams">Any way to refactor to allow for post-build-but-pre-classload-time bytecode 
weaving?  I'd like to be able to compile with javac/jikes, then weave with an 
AspectJ enhancer, then run with no classload-time bytecode weaving.

It appears possible since you've separated the "bytecode transformer component 
interface"....thoughts?</comment>
		<comment id="10" date="2004-01-28 12:42:56 EST" author="Martin Lippert">I think this is already possible with the standard AspectJ compiler using the
-injar option. This allows you to weave existing bytecode with aspects. Does
that match your case?</comment>
		<comment id="11" date="2004-02-27 13:50:58 EST" author="Matthew Webster">Rules for weaving class loader:
1. All aspects must be known to the weaver before any classes are loaded. 
Any aspects subsequently presented to the weaver should either be ignored or 
cause an exception to be thrown.
2. Only classes defined by the class loader can be woven i.e. in a loader 
hierarchy neither classes loaded by a parent loader (which are visible) nor a 
child (which arenât) are woven.
3. Aspects defined by a parent weaving class loader are available for 
extension or weaving i.e. both abstract and concrete pointcuts may be used.</comment>
		<comment id="12" date="2004-03-03 12:50:47 EST" author="Matthew Webster">The plan is to provide a command line tool "aj" that will perform load-time 
weaving using a supplied WeavingURLClassLoader and WeavingAdaptor to wrap the 
existing BcelWorld and BcelWeaver APIs. It will use CLASSPATH and ASPECTPATH 
(which will be some subset of CLASSPTH or absent of no weaving is required). 
Hierarchies of weaving loaders should be supported as described in the 
previous append.

As Wes as pointed out the new java.lang.instrument package can be exploited 
when 1.5 is supported. A new WeavingAdaptor subclass can connect to this API.

While using Martins sample WeavingURLClassLoader as a guide I am doing some 
reimplementation to avoid copyright and licensing issues with Sun source code.</comment>
		<comment id="13" date="2004-03-03 13:07:17 EST" author="Matthew Webster">Created attachment 8311 [details]
UML diagram</comment>
		<comment id="14" date="2004-03-03 13:10:43 EST" author="Matthew Webster">Created attachment 8312 [details]
UML diagram</comment>
		<comment id="15" date="2004-03-12 04:29:34 EST" author="Artur Biesiadowski">Have you looked at java.lang.instrument package in JDK1.5 beta1 ? I know that 
weaving support is aimed for 1.4 compatibility, but IMHO 1.5 instrumentation is 
more powerful tool - especially because it allows to modify most core classes 
(except really basic ones). Maybe it could be done in way which would support 
both ways - explicit classloaders and jvm instrumentation, with classloader 
solution being a subset of instrumentation ?</comment>
		<comment id="16" date="2004-03-12 14:13:57 EST" author="Matthew Webster">1.5 is still in beta and not fully supported yet by AspectJ. We will need to 
support 1.4 for a while. However I have a subclass of the WeavingAdaptor 
written for this enhancement, that can go into future versions of AspectJ, 
that can attach to existing class loaders using the ClassFileTransformer 
interface in Instrumentation class.

WRT to modifying system classes this breaks one of the rules of weaving class 
loaders discussed in this enhancement: a class loader must know about all 
aspects before loading a class. This is not possible for the bootstrap class 
loader.</comment>
		<comment id="17" date="2004-03-16 07:59:19 EST" author="Martin Lippert">How do you take care of classes that are generated by the weaver (for example to
realize around closures)? I just struggled into that problem with by load-time
weaving implementation because I completely forgot to think of that for my first
implementation that is still attached to this bug.

I think the weaving class loader needs to add those generated classes somehow to
his class path.</comment>
		<comment id="18" date="2004-03-17 12:45:01 EST" author="Matthew Webster">&gt;How do you take care of classes that are generated by the weaver
I don't but have a testcase now to work with. Thanks for pointing that out. I 
believe a small change to the WeavingAdaptor will allow the class to be 
defined by the class loader.

I am having mixed success with ITDs and perthis/target() aspects. What is your 
experience.</comment>
		<comment id="19" date="2004-03-17 13:10:58 EST" author="Martin Lippert">Hm, haven't tried perthis/target stuff yet. Tried successfully some
introductions some month ago (for example adding an interface to an existing
class). But my most exhaustive test case uses mostly advices (I currently advice
every method of the complete eclipse system at load-time, several thousand
classes, etc.)</comment>
		<comment id="20" date="2004-03-19 05:20:27 EST" author="Matthew Webster">I now have around closure advice, including the generated weaver class, 
working along with ITDs and perthis/pertarget aspects.</comment>
		<comment id="21" date="2004-03-19 05:52:03 EST" author="Martin Lippert">What was the problem with perthis/pertarget and some IDTs and how did you solve it?</comment>
		<comment id="22" date="2004-03-19 06:34:33 EST" author="Matthew Webster">Adrian has restructured the BcelWeaver so "weaveWithouDump()" is no longer 
appropraite for LTW. There is a new "weave()" method which I use and it works. 
It also accounts for weaver-generated files. The WeavingAdaptor will make this 
all much easier!</comment>
		<comment id="23" date="2004-03-20 13:59:20 EST" author="Matthew Webster">Created attachment 8728 [details]
Beta implementation

WeavingAdaptor, WeavingURLClassLoader, tests, javadoc, scripts, examples</comment>
		<comment id="24" date="2004-03-21 21:37:13 EST" author="Matthew Webster">Created attachment 8738 [details]
Updated patch to include missing weaver files</comment>
		<comment id="25" date="2004-04-02 06:56:13 EST" author="Matthew Webster">Created attachment 9146 [details]
Addtional testcase missing from patch

Please add to org.aspectj.ajdt.core module, run BcweaverJarMarker and check
resulting weaver/testdate/ltw-XXX.jar files into CVS.</comment>
		<comment id="26" date="2004-04-02 07:31:28 EST" author="Adrian Colyer">Fixed by patch contributed my Matthew Webster, incorporating contributions my 
Martin Lippert also.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="33d8ee9eededcd1219a6cbd1d063af005d40a3f7" author="acolyer" date="2004-04-02 09:03:40"/>
          <file name="org.aspectj.ajdt.core/testdata/src1/LTWHelloWorld.java">
          </file>
          <file name="org.aspectj.ajdt.core/testdata/src1/ltw/LTWPackageTest.java">
          </file>
          <file name="org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/BcweaverJarMaker.java">
              <method name="main" returnType="void" parameters="String[]"/>
          </file>
          <file name="util/src/org/aspectj/util/FileUtil.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/ExtensibleURLClassLoader.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/WeavingURLClassLoader.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/tools/GeneratedClassHandler.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/tools/WeavingClassLoader.java">
          </file>
          <file name="weaver/testsrc/BcweaverModuleTests.java">
              <method name="suite" returnType="Test" parameters=""/>
          </file>
          <file name="weaver/testsrc/org/aspectj/weaver/BcweaverTests.java">
          </file>
          <file name="weaver/testsrc/org/aspectj/weaver/WeavingURLClassLoaderTest.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="55341" opendate="2004-3-19 4:32:00" fixdate="2004-4-2 8:40:00">
    <buginformation>
      <summary>error Type mismatch: cannot convert from java.lang.String to java.lang.String</summary>
      <description>When compiling a binary concrete aspect library (for later LTW) consisting of
more than one aspect that performs an ITD on a target class not exposed to the 
weaver I get the following error:

error Type mismatch: cannot convert from java.lang.String to java.lang.String

The error does not oocur if a complete build &amp; weave is performed. Testcase 
attached.</description>
      <comments>
		<comment id="1" date="2004-03-19 04:34:09 EST" author="Matthew Webster">Created attachment 8683 [details]
Testcase</comment>
		<comment id="2" date="2004-03-31 03:47:40 EST" author="Andrew Clement">The message comes out of ReturnStatement.resolve().  The return statement 
is 'return message' and the problem occurs comparing the type of the return 
value with the return type declared for the method.

When it goes wrong, the method return type is a valid resolved 
java.lang.String whilst the expressionType field in the ReturnStatement object 
is 'Unresolved type java.lang.String'.  These two are classed as incompatible 
so it fails with the error "cannot convert from java.lang.String to 
java.lang.String"</comment>
		<comment id="3" date="2004-04-01 11:59:33 EST" author="Andrew Clement">Here is a simpler failing testcase:

Here is HW.java (which could be a bit simpler actually..)
==========================

import java.util.ArrayList;
import java.util.Iterator;
import java.util.Properties;

public class HW extends ArrayList {

  String message = "Hello World!";

 private void check (String args) {
 }

 public void println () {
  System.out.println(message);
 }

 public static void main(String[] args) {
  HW hw = new HW();
  hw.println();  
  for (int i = 0; i &lt; args.length; i++) {
   String jp = args[i];
   if (!hw.contains(jp)) {
    throw new RuntimeException(jp + " missing"); 
   }
  }
 }

}
============================

And here are a pair of aspects in a single file X.java:
============================
aspect F {
        private int HW.intField = 999;
}

aspect M {
        public String HW.getMessage () {
                return message;
        }
}
==========================
With these files, you can reproduce the failure as follows

ajc -outjar helloworld.jar HW.java

ajc -classpath "helloworld.jar;c:\aspectj1.1\lib\aspectjrt.jar" X.java

The failure with the 2nd intertype declaration only occurs if the first aspect 
containing an intertype on the same type is also being passed in...  It is as 
if the first intertype declaration pulls in the class (HW) upon which it is 
intertyping but doesn't bother resolving all of its contents - and when the 
second intertype comes along, we then don't bother to ensure the bits of the 
required class are fully resolved that the second intertype declaration needs.
======
I have fixed it by putting an extra bit of code in ReturnStatement.getBinding
():

if (fieldBinding.type instanceof UnresolvedReferenceBinding) 
  fieldBinding.type = ((UnresolvedReferenceBinding) fieldBinding.type).resolve
(environment());

which ensures that if we do come across something unresolved, we resolve it 
there and then.

BUT - I still don't understand why we only end up with the unresolved version 
of 'String message' if I use an intertype declaration before the failing 
one ???

FYI: When we are in getBinding() and trying to obtain the binding 
for 'message', the enclosingtype field looks like this (notice that message is 
unresolved):

public class HW
 extends java.util.ArrayList
/*   fields   */
Unresolved type java.lang.String message
/*   methods   */
void &lt;init&gt;() 
void check(Unresolved type java.lang.String) 
void println() 
void main(java.lang.String[]) </comment>
		<comment id="4" date="2004-04-02 04:23:25 EST" author="Andrew Clement">I've done some more investigation.  The whole problem here hinges on the order 
in which things are resolved (as expected).  Whether the error message occurs 
entirely depends on whether 'String' has been resolved before 'HW' is loaded 
into the system.

If String has been resolved then HW is loaded with a 'java.lang.String 
message' field and the code all works.
If String has not been resolved then HW is loaded with an 'unresolved 
java.lang.String' field and the code fails.

We can verify this as follows.  Add a new method to our pair of failing 
aspects:

aspect F {
  public String a() {return "abc";}  &lt;---- New method refers to 'String'
  private int HW.intField = 999;
}

aspect M {
  public String HW.getMessage () {
    return message;
  }
}

The inclusion of our new method ensures String is fully resolved before HW is 
brought into the system. and so the intertype declaration in aspect M works 
perfectly.  What we have here is someone not checking that something is 
unresolved before using it.  Resolution around the system is done lazily, see 
the javadoc for: LookupEnvironment.getTypeFromConstantPoolName():

/* Answer the type corresponding to the name from the binary file.
* Does not ask the oracle for the type if its not found in the cache...
* instead an unresolved type is returned which must be resolved before used.
*/

So the fix is to correctly resolve String when the intertype declaration needs 
to refer to it.</comment>
		<comment id="5" date="2004-04-02 06:56:40 EST" author="Andrew Clement">eureka.

The fix is actually to address something marked 'XXX' in the code !!!
This line:

// XXX may need to get the correct value for second parameter in the future
FieldBinding retField = sourceTypeBinding.getFieldBase(fieldName, false);  

in InterTypeMemberFinder.getField()

In the failing case we should be passing true rather than false - as it 
indicates whether to ensure the result of the get is resolved.  I just need to 
work out how to pass the flag into the method from the caller.</comment>
		<comment id="6" date="2004-04-02 08:12:13 EST" author="Andrew Clement">FIX CHECKED IN.

Having looked at the paths into this method, I can't see why we would ever not 
want to ensure the field is fully resolved.  I have changed the line:

FieldBinding retField = sourceTypeBinding.getFieldBase(fieldName, false);  

to

FieldBinding retField = sourceTypeBinding.getFieldBase(fieldName, true);

This fixes the bug.  The tests all still pass.  The only impact would be on 
performance but as this only affects a path when using intertype declarations 
of a particular sort.  The alternative would be to expand the signature of the 
method InterTypeMemberFinder.getField() which would require extending the 
signature of the JDT internal interface that it implements - that would be too 
messy (with an imminent 1.2 RC to be shipped..)

I have left the XXX in at the moment, since we are still hard wiring the value 
(but now to true) - I've annotated it with this bug number so in future 
someone doesn't come and try changing it back to false !

I have added a new testcase to the harness and uncommented the tests of 
Matthews that were impacted by it.</comment>
		<comment id="7" date="2004-04-02 08:40:26 EST" author="Adrian Colyer">fixed by andy clement</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="0521e79aea0550b1357a7ccc6a5050f8ce27ce9b" author="aclement" date="2004-04-02 09:45:13"/>
          <file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/InterTypeMemberFinder.java">
              <method name="getField" returnType="FieldBinding" parameters="SourceTypeBinding char[] InvocationSite Scope"/>
          </file>
          <file name="org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/BcweaverJarMaker.java">
              <method name="makeTestJars" returnType="void" parameters=""/>
          </file>
          <file name="tests/bugs/StringToString/HW.java">
          </file>
          <file name="tests/bugs/StringToString/X.java">
          </file>
          <file name="weaver/testsrc/org/aspectj/weaver/WeavingURLClassLoaderTest.java">
              <method name="testWeavingITD" returnType="void" parameters=""/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="57430" opendate="2004-4-5 4:58:00" fixdate="2004-5-13 5:07:00">
    <buginformation>
      <summary>exception printing</summary>
      <description>Exceptions thrown from the compiler used to be printed once, with the submit-bug
header.  Now they are printed twice, without and with the header.  True of CVS
version.</description>
      <comments>
		<comment id="1" date="2004-04-05 06:10:55 EDT" author="Andrew Clement">Just an info note ... The testcode you checked in for 57432 demonstrates this 
double exception printing.  </comment>
		<comment id="2" date="2004-04-07 03:36:06 EDT" author="Andrew Clement">I believe the duplicate is printed by the line:

internalException.printStackTrace() 

within

Compiler.handleInternalException() (line 452 to be precise)

continuing to investigate...</comment>
		<comment id="3" date="2004-04-07 05:16:02 EDT" author="Andrew Clement">Fix checked in.

The fix is to wrap (at the appropriate point) the NPE exception inside an 
AbortCompilation exception which is then rethrown.  If the JDT compiler sees 
an AbortCompilation exception it behaves differently - we can prevent it from 
being logged by the JDT code *knowing* that it will be logged by the original 
calling AspectJ code.  The JDT will unwrap the AbortException and throw the 
nested NPE.

Here is the output from the code in bug 57432 with the fix in (there is 
no 'extra' logging of the NPE):

------------------------------------------
ABORT
 
Exception thrown from AspectJ DEVELOPMENT

This might be logged as a bug already -- find current bugs at
  http://bugs.eclipse.org/bugs/buglist.cgi?product=AspectJ&amp;component=Compiler

Bugs for exceptions thrown have titles File:line from the top stack, 
e.g., "SomeFile.java:243"

If you don't find the exception below in a bug, please add a new bug
at http://bugs.eclipse.org/bugs/enter_bug.cgi?product=AspectJ
To make the bug a priority, please include a test program
that can reproduce this exception.
null
java.lang.NullPointerException
 at org.eclipse.jdt.internal.compiler.CompilationResult.computePriority
(CompilationResult.java:110)
 at org.eclipse.jdt.internal.compiler.CompilationResult.quickPrioritize
(CompilationResult.java:336)
 at org.eclipse.jdt.internal.compiler.CompilationResult.getProblems
(CompilationResult.java:230)
 at org.eclipse.jdt.internal.compiler.CompilationResult.getAllProblems
(CompilationResult.java:118)
 at org.aspectj.ajdt.internal.core.builder.AjBuildManager$4.acceptResult
(AjBuildManager.java:661)
 at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.acceptResult
(AjCompilerAdapter.java:176)
 at org.aspectj.ajdt.internal.compiler.WeaverAdapter.finishedWith
(WeaverAdapter.java:203)
 at org.aspectj.ajdt.internal.compiler.WeaverAdapter.weaveCompleted
(WeaverAdapter.java:167)
 at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:570)
 at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave
(AjCompilerAdapter.java:237)
 at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling
(AjCompilerAdapter.java:114)
 at org.eclipse.jdt.internal.compiler.Compiler.compile
(Compiler.java:376)
 at 
org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation
(AjBuildManager.java:600)
 at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild
(AjBuildManager.java:160)
 at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild
(AjBuildManager.java:94)
 at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:104)
 at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:53)
 at org.aspectj.tools.ajc.Main.run(Main.java:280)
 at org.aspectj.tools.ajc.Main.runMain(Main.java:217)
 at org.aspectj.tools.ajc.Main.main(Main.java:79)


1 fail|abort
---------------------------------------------</comment>
		<comment id="4" date="2004-05-13 05:07:28 EDT" author="Adrian Colyer">fixed by Andy.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="e7ac54fae25b797a0d3609350a27330bea302fb9" author="aclement" date="2004-04-07 06:07:43"/>
          <file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/AjCompilerAdapter.java">
              <method name="afterCompiling" returnType="void" parameters=""/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="57436" opendate="2004-4-5 5:42:00" fixdate="2004-5-13 5:09:00">
    <buginformation>
      <summary>Java 1.5 fails to run classes produced by ajc</summary>
      <description>Java 1.5 beta reports a ClassFormatError when running programs (e.g., spacewar)
compiled by ajc 1.1.1 and the latest CVS head.  Sun's Java 1.5 beta
binary-compatibility docs say that some obfuscators violated the .class format
specification, so those .class files will fail when run under 1.5.  (The docs
also say they are still incomplete.)  

Although 1.5 is still beta, we would want to submit a bug to Sun if our
implementation techniques are valid, so we don't have to change those
techniques.  For 1.2, we should at document if we don't fix, since many people
are using 1.5.</description>
      <comments>
		<comment id="1" date="2004-04-05 05:43:31 EDT" author="Wes Isberg">P2/1.2: Recommending for investigation before the 1.2 release, at least to
document the results.</comment>
		<comment id="2" date="2004-04-05 12:21:43 EDT" author="Matthew Webster">Created attachment 9217 [details]
HelloWorld + logging

Reproduce problem:

java version "1.5.0-beta"
Java(TM) 2 Runtime Environment, Standard Edition (build 1.5.0-beta-b32c)
Java HotSpot(TM) Client VM (build 1.5.0-beta-b32c, mixed mode)
java.lang.ClassFormatError: Invalid index 0 in LocalVariableTable in class file
ras/HelloWorldLogging
 at java.lang.ClassLoader.defineClass1(Native Method)
 at java.lang.ClassLoader.defineClass(ClassLoader.java:604)
 at
java.security.SecureClassLoader.defineClass(SecureClassLoader.java:123)
 at java.net.URLClassLoader.defineClass(URLClassLoader.java:260)
 at java.net.URLClassLoader.access+100(URLClassLoader.java:56)
 at java.net.URLClassLoader+1.run(URLClassLoader.java:195)
 at java.security.AccessController.doPrivileged(Native Method)
 at java.net.URLClassLoader.findClass(URLClassLoader.java:188)
 at java.lang.ClassLoader.loadClass(ClassLoader.java:289)
 at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:279)
 at java.lang.ClassLoader.loadClass(ClassLoader.java:235)
 at java.lang.ClassLoader.loadClassInternal(ClassLoader.java:302)

Exception in thread "main"</comment>
		<comment id="3" date="2004-04-07 11:34:40 EDT" author="Andrew Clement">Here is a simple test program that causes the problem:

public class H {
  public static void main(String[] argv) { }
}

aspect A {
  before(): execution(* *(..)) { }
}

Now, I'm not saying this is the actual problem but there have always been 
issues with 'decompiling' the aspectOf() method. Running jad against the 
A.class file produced after compiling the above code, jad says it has 
problems - it can't understand the aspectOf() method.  And indeed the gumpf 
that is produced looks like this on decompilation:

    public static A aspectOf()
    {
        ajc$perSingletonInstance;
        if(ajc$perSingletonInstance == null) goto _L2; else goto _L1
_L1:
        return;
_L2:
        throw new NoAspectBoundException("A", ajc$initFailureCause);
    }

When it perhaps ought to read

    public static A aspectOf()
    {
       if(ajc$perSingletonInstance != null) return ajc$perSingletonInstance;
       throw new NoAspectBoundException("A", ajc$initFailureCause);
    }

It could be that JVM 1.5 is being more strict in what it allows in - I'm not 
sure how to find out if thats actually whats happening !</comment>
		<comment id="4" date="2004-04-08 06:53:50 EDT" author="Andrew Clement">I've checked in a fix for this.  It works for my testcase and it passes all 
the tests I can find.  I will write it up when I get back from my run.</comment>
		<comment id="5" date="2004-04-09 14:08:34 EDT" author="Andrew Clement">Ok, here is the full gory details - mostly pasting bits and pieces in from a 
discussion I had with Jim.

Prior to the fix I put in, anyone who tried to run 'javap -verbose' against an 
aspect might have noticed something unusual.  Here is a snippet of javap -
verbose for the aspect 'A' described earlier in this bug report:

public void ajc$before$A$50(); 
  org.aspectj.weaver.Advice: length = 0x45 
   01 01 03 01 00 00 00 00 05 05 00 01 2A 00 01 04 
   FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF 00 
00 
 FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF 
   FFFFFFFF FFFFFFFF 00 00 FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF 
FFFFFFFF 
 FFFFFFFF FFFFFFFF 00 00 00 64 
   00 00 00 6A 00 00 00 5A 00 00 00 6B 00 00 00 00 
   50 00 00 00 6B 
  Code: 
   Stack=0, Locals=1, Args_size=1 
   0:   return 
  LocalVariableTable: 
   Start  Length  Slot  Name   Signature 
   0      0      0    this       LA; 
  LineNumberTable: 
   line 7: 0 

public static A aspectOf(); 
  org.aspectj.weaver.AjSynthetic: length = 0x 

  Code: 
   Stack=3, Locals=0, Args_size=0 
   0:   getstatic       #25; //Field ajc$perSingletonInstance:LA; 
   3:   dup 
   4:   ifnull  8 
   7:   areturn 
   8:   new     #27; //class NoAspectBoundException 
   11:  dup 
   12:  invokespecial   #28; //Method 
org/aspectj/lang/NoAspectBoundException."&lt; 
init&gt;":()V 
   15:  athrow 
  LocalVariableTable: 
   Start  Length  Slot  Name   Signature 
   0      16      0    this       LA; 

I have included the generated advice and the generated aspectOf() method.  
Observe that the aspectOf method - a *static* method has a local variable 
table with an entry in for 'this'...  This is wrong - we should have no local 
variable table at all for this aspectOf method (other static methods generated 
in the aspect exhibit the same problem).  The 1.5 beta appears to be policing 
this kind of error situation where previous JDKs don't seem to have been 
checking.  SUN might remove this agressive checking before 1.5 final ships - 
but clearly AspectJ is generated incorrect information here.  So how do we fix 
it? Where did the local variable table come from?

The answer is that in AspectDeclaration.generateMethod() where we are 
generating the code for static methods like aspectOf(), hasAspect(), etc - we 
are using the codeStream object incorrectly.  We are calling codeStream.init() 
rather than codeStream.reset().  Not using reset() means that we don't alter 
the method declaration object that the code stream thinks it is working with.  
This means that when we ask the classfile to fix up its code attributes 
(around line AspectDeclaration line 306 we call classFile.completeCodeAttribute
()) the classfile asks the methoddeclaration for the codestream whether it is 
static - based on the result of this check, it generates a local variable 
table entry for 'this' (See line 1413 in ClassFile).  Because we never updated 
the codestream with a new method declaration, it still points to the method 
declaration for our previous created method - the advice itself (public void 
ajc$before$A$50();) - this was *not* static and so we end up creating a 'this' 
local variable entry for all the subsequent generated methods in the aspect.

The fix is to replace these calls to the codeStream:

 codeStream.init(classFile);
 codeStream.initializeMaxLocals(methodBinding);

with

 codeStream.reset(md,classFile); // md is a method declaration object 
representing our static method

(reset calls init and initializeMaxLocals and correctly updates the method 
declaration in the codestream).

So far, that all seems the perfect fix.  Unfortunately there is one twist.  
Constructing a methoddeclaration of quite the right type to satisfy the 
codestream is awkward.  Here is the fix I have put into the codebase:

  MethodDeclaration md = AstUtil.makeMethodDeclaration(methodBinding); 
  md.scope = initializerScope; 
  codeStream.reset(md,classFile); 

The makeMethodDeclaration() call conjures up a method declaration object OK 
and the 'is this method static?' check in the code to generate the attributes 
works correctly.  However, code inside the reset() method tries to obtain a 
compiler setting through 'methodDeclaration.scope'.  I *have* to put something 
in the scope field or the reset() method (a JDT internal method) blows up with 
an NPE.  I didn't want to hack the JDT code to address this.

I have a local scope around: initializerScope.  If I use that then reset() is 
happy.  It isn't the right scope object but I'm not sure how to construct a 
valid one.  The scope seems to be used for only two things along this codepath:
Determining a compiler option and reporting an error about code_length&gt;64k.

Because the value in 'scope' doesn't seem to be used for anything more than 
this, I did check the above code in.  With that fix in, we don't get rogue 
local variable table entries for 'this' for static methods in the aspect - and 
the code runs on Java 1.5.

I have tagged the scope setting with a XXX in case this causes any problem in 
the future.  Since all tests I can find still pass, this seems a valid fix for 
the problem.  I hope others agree.</comment>
		<comment id="6" date="2004-05-13 05:09:54 EDT" author="Adrian Colyer">fixed by Andy</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="b0d32cafba6241023d1efdc343a2744a5e25a00d" author="aclement" date="2004-04-08 07:46:58"/>
          <file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectDeclaration.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="59909" opendate="2004-4-26 5:40:00" fixdate="2004-5-13 5:19:00">
    <buginformation>
      <summary>CFlowStack removesThreads to late</summary>
      <description>Problem:
The current implementation of CFlowStack (Version 1.1-till 1.2 rc1) stores all 
threads in a hashtable. These Threads are removes after several calls to the 
methods getThreadStack(). (In our cases &gt;70 calls.)

In our project, this cycle is much to long. We have soveral long running 
threads, which grap quite a lot of lot of memory. This memory can only be freed 
after the threads have been removed from the CFlowStack. 
In our production code we sum up to more than 300 Threads stored in different 
CFlowStack Varaibles. Often this results in out of memory Errors.

Added patch provides an improved freeing scheme.

It checks if the size of the table has grown, if it has, it checks if it can 
remove some threads.</description>
      <comments>
		<comment id="1" date="2004-04-26 05:41:01 EDT" author="Arno Schmidmeier">Created attachment 9938 [details]
Patch which solves the problem</comment>
		<comment id="2" date="2004-04-26 05:48:03 EDT" author="Arno Schmidmeier">Created attachment 9939 [details]
Sample

A short sample, which demonstrates the problem.
if run with the patch the number of threads never exceeded 5. (in most runs it
didnÂ´t 
if run without the thread, the number of threads exceeds easily 100.</comment>
		<comment id="3" date="2004-04-26 09:17:20 EDT" author="Andrew Clement">I've verified the test program behaves as described - I see the threads 
getting up to ~140 before being cleaned up.  With the patch it never goes 
above 4 for me.  It gets to ~140 because when it reaches that level, the line:

if (change_count &gt; Math.max(MIN_COLLECT_AT, COLLECT_AT/size)) {

returns true which causes a tidyup (since COLLECT_AT is 20000)

It seems the static fields COLLECT_AT and MIN_COLLECT_AT are for configuring 
the frequency of tidying up (although they can't currently be 'set' by a 
user).  The patch adds another variable oldsize - and the behavior then seems 
to be tidy up as soon as the stack grows by even 1 element - so if I then 
trace the tidying-up code it seems to run almost constantly against the test 
program.  I think I could achieve the same result by setting both of the 
COLLECT_AT fields to 1.  That doesn't seem to be quite what we want.  It is a 
bit awkward because different users/applications are likely to have different 
requirements on the space/performance trade off.</comment>
		<comment id="4" date="2004-04-26 11:31:58 EDT" author="Andrew Clement">I knew I'd realise something as soon as I appended to the bug ;)

You can't quite replicate what the patch does by setting COLLECT_AT, 
MIN_COLLECT_AT to 1 - if they were set to 1 then we would frequently be 
checking whether all the threads we currently know about are alive.  With the 
patch we only go through all the threads checking for liveness if a new one is 
added to the system or if the current test triggers it:
(change_count &gt; Math.max(MIN_COLLECT_AT, COLLECT_AT/size))
This means if the system reaches a steady state (no new threads are being 
started) then we behave how we behave today, but if the system is constantly 
seeing new threads start then it trims the hashtable more frequently.

So I think what I'm saying is that the proposal in the patch is a good one.  
The reason it looks a bit extreme on first inspection is because the sample 
program is a little contrived and just fires off threads, never reaching a 
steady state.

Anyone want to comment?</comment>
		<comment id="5" date="2004-04-26 12:40:06 EDT" author="Jim Hugunin">The current implementation of CFlowStack was built by a PARC summer intern as 
a 1 week project many, many years ago (~version 0.7).  I don't believe the 
implementation has been either carefully evaluated or changed since then.

Last week Matthew asked me about using ThreadLocals here for performance 
reasons, and I replied:

I think that it would be good to switch the cflow per-thread implementation in 
rt.jar to use ThreadLocal when run on a VM that supports this.  This might 
have some performance benefit, but I'm doubtful it would be very large right 
away.  The main benefit I see is that the current version has some memory leak 
issues with holding on to thread objects after they've terminated.  I've never 
heard a report of this being a real problem in the field, but it is a nagging 
issue.

Well, now I've heard about this being a real problem in the field ;-)

The only reason not to just use a ThreadLocal is that it is a 1.2 feature.  
Currently rt.jar only uses 1.1 features.

I see several reasonable technical solutions, all of which have different 
tradeoffs.

1. Make Arno's proposed change.  This is the simplest change to the code and 
clearly fixes Arno's problem.  However, you'd need to spend some time 
understanding the performance issues where there are a lare number of "stable" 
threads and a small number being consistently created and destroyed.  For 
example, if you have 300 threads in the system (and the hashtable), then every 
time the table grows all 300 threads will be checked for liveness.  This could 
be expensive for some use cases.

2. Switch the design of CFlowStack to use a ThreadLocal instead of the 
hashtable.  This is obviously the most efficient and precise way of mapping a 
perthread field.  This would also be a fairly simple implementation.  The 
major downside of this approach is that it would mean that AspectJ programs 
that use cflow would only run under 1.2 or later VMs.

3. Build a dual implementation of CFlowStack that uses ThreadLocal if its 
available and falls back to a simple hashtable when running under 1.1.  This 
is a slightly more challenging implementation to make sure that the 1.2 code 
is kept well separate from the 1.1 code.  However, this would give all of the 
benefits of #2 while still maintaining compatibility with 1.1 VMs.

There are additional compromise solutions such as building two different 
rt.jars, one of which will run on 1.1; or making a CFlowStack11 class and 
requiring a compile-time flag to select its use.

I'd recommend implementing solution #3 and spinning one more release candidate 
with this change and a couple of others.  At this stage, solution #3 should 
ideally be implemented by a pair or should have a thorough code review process 
of people looking at the solution.

This change clearly has the potential to cause stability problems.  However, 
Arno's bug looks serious enough to me that it should be solved for 1.2 (and 
I've raised the severity to note that).  This kind of bug can be very 
frustrating to developers because it only manifests itself as an 
OutOfMemoryError.  All of the possible solutions have the potential to break 
existing AspectJ programs if implemented incorrectly; however, #3 is the only 
solution that I can say with confidence won't break anything so long as it's 
implemented correctly.</comment>
		<comment id="6" date="2004-05-04 10:14:33 EDT" author="Andrew Clement">Created attachment 10255 [details]
ThreadLocal fix for this bug

Arno, please can you try this version of aspectjrt.jar.  It is an
implementation of Jims idea to use a ThreadLocal implementation for the stack
when on a JVM that supports it.  I've done some testing and it seems OK and it
passes all the tests in the harness - but I'm not sure how much they validate
the cflow behavior I have changed.

In case you aren't sure if it is doing anything at all - you can invoke your
program with system property "debugcflow=yes" and this will tell you through
System.err whether it is trying to use the ThreadLocal implementation.

Are you at all able to run your program on a 1.1 JVM to see if it works 'as
before' ?</comment>
		<comment id="7" date="2004-05-05 06:35:55 EDT" author="Andrew Clement">Fix checked in.  If there is one piece of the implementation that needs a 
review, it is this one method in CFlowStack:

private static void selectFactoryForVMVersion() {
  String override = System.getProperty
    ("aspectj.runtime.cflowstack.usethreadlocal","unspecified");  
  boolean useThreadLocalImplementation = false;
  if (override.equals("unspecified")) {
    String v = System.getProperty("java.class.version","0.0");
    // Java 1.2 is version 46.0 and above
    useThreadLocalImplementation = (v.compareTo("46.0") &gt;= 0);
  } else {
    useThreadLocalImplementation = override.equals("yes") || 
                                   override.equals("true");
  }
  // System.err.println("Trying to use thread local implementation? "+
  //  useThreadLocalImplementation);
  if (useThreadLocalImplementation) {
    tsFactory = getThreadLocalStackFactory();
  } else {
    tsFactory = getThreadLocalStackFactoryFor11();
  }
}

The area I am concerned about is that I've decided to introduce a system 
property override which *might* prove useful for debugging in the field:

  aspectj.runtime.cflowstack.usethreadlocal

Effectively allowing you to turn off the Thread Local implementation if you 
don't want it.  I've mainly done this because I've yet to have it confirmed by 
anyone other than my own test program that all this new code is working as 
expected.

I don't plan on publicising this setting beyond this bug report...</comment>
		<comment id="8" date="2004-05-06 05:11:50 EDT" author="Andrew Clement">Created attachment 10331 [details]
Variant of the submitted test program.

This is a modified test program that actually measures something (at least on
my SUN142 JVM it does).  It creates a 1000 threads which each grab a load of
memory and then terminate.  It checks whether the use of the thread local
storage for managing the CFlowStacks makes a difference.  Here are my
(reproduceable) measurements:

&gt;java TestThreadRunner
Using ThreadLocal mgmt = true
Max memory used through the run = 1005544
Time to execute the program = 16078

&gt;java -Daspectj.runtime.cflowstack.usethreadlocal=false TestThreadRunner
Using ThreadLocal mgmt = false
Max memory used through the run = 11926560
Time to execute the program = 36359

So it does appear to help:
-Time to execute is reduced from 36seconds to run the program down to
16seconds.
-Storage is reduced from 11Meg to 1Meg.

However, I'd still like proof that the thread stacks we are now managing in a
different way are completely correct.</comment>
		<comment id="9" date="2004-05-06 08:01:14 EDT" author="Noel Markham">Add Noel CC</comment>
		<comment id="10" date="2004-05-13 05:19:36 EDT" author="Adrian Colyer">Fixed - could do with verifying by Arno though...</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="5f6b18be7a143c961ae1de5ffbf1aef3d249a55e" author="aclement" date="2004-05-05 07:18:01"/>
          <file name="runtime/src/org/aspectj/runtime/internal/CFlowStack.java">
          </file>
          <file name="runtime/src/org/aspectj/runtime/internal/cflowstack/ThreadStack.java">
          </file>
          <file name="runtime/src/org/aspectj/runtime/internal/cflowstack/ThreadStackFactory.java">
          </file>
          <file name="runtime/src/org/aspectj/runtime/internal/cflowstack/ThreadStackFactoryImpl.java">
          </file>
          <file name="runtime/src/org/aspectj/runtime/internal/cflowstack/ThreadStackFactoryImpl11.java">
          </file>
          <file name="runtime/src/org/aspectj/runtime/internal/cflowstack/ThreadStackImpl11.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="59596" opendate="2004-4-22 5:11:00" fixdate="2004-05-13 05:16:21">
    <buginformation>
      <summary>Null pointer exception while weaving java.awt.Label</summary>
      <description>I tried to add an Aspect to java.awt.Label. I compile the aspect via:
ajc -inpath /usr/local/j2sdk_nb/j2sdk1.4.2/jre/lib/rt.jar Timestamp.java

Here is the aspect Timestamp.java:

aspect Timestamp {

    private int java.awt.Label._ts_read = 0;
    private int java.awt.Label._ts_write = 0;

    pointcut writeOp():
    call (void java.awt.Label.setText (String));

    pointcut readOp():
    call (String java.awt.Label.getText());
	
    after (java.awt.Label b) returning: readOp() &amp;&amp; target (b)
    {
	b._ts_read++;
    }
    
    after (java.awt.Label b) returning: writeOp() &amp;&amp; target (b)
    {
	b._ts_write++;
	System.out.println (b._ts_write);
    }

    public static void main (String[] args)
    {
	java.awt.Label b1 = new java.awt.Label();
	b1.setText ("abc");
    }
}

Here is the error message I get from ajc:

null
java.lang.NullPointerException
        at org.aspectj.ajdt.internal.core.builder.EclipseAdapterUtils.makeLocationContext(EclipseAdapterUtils.java:50)
        at org.aspectj.ajdt.internal.core.builder.EclipseAdapterUtils.makeSourceLocation(EclipseAdapterUtils.java:120)
        at org.aspectj.ajdt.internal.core.builder.EclipseAdapterUtils.makeMessage(EclipseAdapterUtils.java:129)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager$4.acceptResult(AjBuildManager.java:663)
        at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.acceptResult(AjCompilerAdapter.java:178)
        at org.aspectj.ajdt.internal.compiler.WeaverAdapter.finishedWith(WeaverAdapter.java:203)
        at org.aspectj.ajdt.internal.compiler.WeaverAdapter.weaveCompleted(WeaverAdapter.java:167)
        at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:570)
        at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave(AjCompilerAdapter.java:239)
        at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling(AjCompilerAdapter.java:114)
        at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:376)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:600)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:160)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:94)
        at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:102)
        at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:53)
        at org.aspectj.tools.ajc.Main.run(Main.java:280)
        at org.aspectj.tools.ajc.Main.runMain(Main.java:217)
        at org.aspectj.tools.ajc.Main.main(Main.java:79)


1 fail|abort</description>
      <comments>
		<comment id="1" date="2004-04-22 07:57:54 EDT" author="Andrew Clement">The NPE occurs whilst error reporting - if I sort out the NPE, I get the 
errors shown below.  The NPE occurs whilst trying to determine a nice source 
range against which to report the problem.  I'm now trying to determine if 
these new errors are reasonable ?? (i.e. what makes a member unresolvable...)

C:\Eclipse\212\eclipse\aspectj_ws2\tests\bugs\Timestamp.java:7 warning can not 
resolve this member: java.lang.String 
org.apache.crimson.tree.ParentNode.getNodeName() [Xlint:unresolvableMember]
(no source information available)
 
 see also: C:\Eclipse\212\eclipse\aspectj_ws2\tests\bugs\rt.jar
C:\Eclipse\212\eclipse\aspectj_ws2\tests\bugs\Timestamp.java:7 warning can not 
resolve this member: short org.apache.crimson.tree.ParentNode.getNodeType() 
[Xlint:unresolvableMember]
(no source information available)
 
 see also: C:\Eclipse\212\eclipse\aspectj_ws2\tests\bugs\rt.jar
C:\Eclipse\212\eclipse\aspectj_ws2\tests\bugs\Timestamp.java:7 warning can not 
resolve this member: void javax.swing.text.TextAction.actionPerformed
(java.awt.event.ActionEvent) [Xlint:unresolvableMember]
(no source information available)
 
 see also: C:\Eclipse\212\eclipse\aspectj_ws2\tests\bugs\rt.jar
C:\Eclipse\212\eclipse\aspectj_ws2\tests\bugs\Timestamp.java:7 warning can not 
resolve this member: java.lang.String 
org.apache.crimson.tree.ParentNode.getNodeName() [Xlint:unresolvableMember]
(no source information available)
 
 see also: C:\Eclipse\212\eclipse\aspectj_ws2\tests\bugs\rt.jar
C:\Eclipse\212\eclipse\aspectj_ws2\tests\bugs\Timestamp.java:7 warning can not 
resolve this member: void javax.swing.text.TextAction.actionPerformed
(java.awt.event.ActionEvent) [Xlint:unresolvableMember]
(no source information available)
 
 see also: C:\Eclipse\212\eclipse\aspectj_ws2\tests\bugs\rt.jar
C:\Eclipse\212\eclipse\aspectj_ws2\tests\bugs\Timestamp.java:7 warning can not 
resolve this member: short org.apache.crimson.tree.NamespacedNode.getNodeType
() [Xlint:unresolvableMember]
(no source information available)
 
 see also: C:\Eclipse\212\eclipse\aspectj_ws2\tests\bugs\rt.jar
C:\Eclipse\212\eclipse\aspectj_ws2\tests\bugs\Timestamp.java:10 warning can 
not resolve this member: void javax.swing.text.TextAction.actionPerformed
(java.awt.event.ActionEvent) [Xlint:unresolvableMember]
(no source information available)
 
 see also: C:\Eclipse\212\eclipse\aspectj_ws2\tests\bugs\rt.jar
C:\Eclipse\212\eclipse\aspectj_ws2\tests\bugs\Timestamp.java:10 warning can 
not resolve this member: void javax.swing.text.TextAction.actionPerformed
(java.awt.event.ActionEvent) [Xlint:unresolvableMember]
(no source information available)
 
 see also: C:\Eclipse\212\eclipse\aspectj_ws2\tests\bugs\rt.jar
C:\Eclipse\212\eclipse\aspectj_ws2\tests\bugs\Timestamp.java:10 warning can 
not resolve this member: java.lang.String 
org.apache.crimson.tree.ParentNode.getNodeName() [Xlint:unresolvableMember]
(no source information available)
 
 see also: C:\Eclipse\212\eclipse\aspectj_ws2\tests\bugs\rt.jar
C:\Eclipse\212\eclipse\aspectj_ws2\tests\bugs\Timestamp.java:10 warning can 
not resolve this member: short org.apache.crimson.tree.ParentNode.getNodeType
() [Xlint:unresolvableMember]
(no source information available)
 
 see also: C:\Eclipse\212\eclipse\aspectj_ws2\tests\bugs\rt.jar
C:\Eclipse\212\eclipse\aspectj_ws2\tests\bugs\Timestamp.java:10 warning can 
not resolve this member: java.lang.String 
org.apache.crimson.tree.ParentNode.getNodeName() [Xlint:unresolvableMember]
(no source information available)
 
 see also: C:\Eclipse\212\eclipse\aspectj_ws2\tests\bugs\rt.jar
C:\Eclipse\212\eclipse\aspectj_ws2\tests\bugs\Timestamp.java:10 warning can 
not resolve this member: short 
org.apache.crimson.tree.NamespacedNode.getNodeType() [Xlint:unresolvableMember]
(no source information available)
 
 see also: C:\Eclipse\212\eclipse\aspectj_ws2\tests\bugs\rt.jar

13 warnings</comment>
		<comment id="2" date="2004-04-22 08:47:20 EDT" author="Andrew Clement">Andys definition - is this anywhere near right?
An unresolvable member is a member (method declaration) we have found in some 
inheritance hierarchy (its on some interface somewhere) that has no 
implementation within that hierarchy, apparently due to the use of abstract 
classes that provide no implementation for it.
Without the concrete implementation it can't be successfully 'resolved' and so 
we can't match on it.</comment>
		<comment id="3" date="2004-04-22 11:34:32 EDT" author="Andrew Clement">This is the patch for the NPE (just capturing it here so anyone else can try 
it before we decide about committing it):
============================================================================
============================================================================
Index: EclipseAdapterUtils.java
===================================================================
RCS 
file: /home/technology/org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspect
j/ajdt/internal/core/builder/EclipseAdapterUtils.java,v
retrieving revision 1.6
diff -u -r1.6 EclipseAdapterUtils.java
--- EclipseAdapterUtils.java 2 Apr 2004 12:47:35 -0000 1.6
+++ EclipseAdapterUtils.java 22 Apr 2004 15:07:56 -0000
@@ -40,7 +40,8 @@
         int endPosition = problem.getSourceEnd();
         
         if ((startPosition &gt; endPosition)
-            || ((startPosition &lt;= 0) &amp;&amp; (endPosition &lt;= 0)))
+            || ((startPosition &lt;= 0) &amp;&amp; (endPosition &lt;= 0))
+            || compilationUnit==null)
             //return Util.bind("problem.noSourceInformation"); //$NON-NLS-1$
          return "(no source information available)";
 
============================================================================
============================================================================
I think I have convinced myself that the unresolvable member messages are 
fine - they are just a quirk of some of the classes in rt.jar.  It doesn't 
affect the actual woven result in this case.

Actually, if you change the pointcuts to set a scope in which to look for 
set/get join points:

 pointcut writeOp():within(java.awt.Label) &amp;&amp;
 call (void java.awt.Label.setText (String));

 pointcut readOp():within(java.awt.Label) &amp;&amp;
 call (String java.awt.Label.getText());

then the program runs faster and doesn't hit the NPE.</comment>
		<comment id="4" date="2004-04-23 12:34:05 EDT" author="Andrew Clement">I give up!  I can't create a minimal library equivalent to rt.jar that 
contains an unresolvable member - so I can't create a testcase in CVS (since I 
can't check in rt.jar!).  I am going to integrate the fix because it passes 
all the tests and fixes the case discussed in this bug:

ajc -inpath /usr/local/j2sdk_nb/j2sdk1.4.2/jre/lib/rt.jar Timestamp.java

Does anyone know how to create a scenario resulting in an unresolvable member 
warning?</comment>
		<comment id="5" date="2004-05-13 05:16:21 EDT" author="Adrian Colyer">Fix checked in.  A related bug (causing the NPE on the same line) gave us the 
testcase we needed to verify the fix is OK.</comment>
		<comment id="6" date="2004-05-13 05:23:21 EDT" author="Adrian Colyer">*** Bug 60862 has been marked as a duplicate of this bug. ***</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="a97f3b6758f778e9a19843ef984085b34be8e7d0" author="aclement" date="2004-04-24 01:24:27"/>
          <file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/EclipseAdapterUtils.java">
              <method name="makeLocationContext" returnType="String" parameters="ICompilationUnit IProblem"/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="59895" opendate="2004-4-25 20:43:00" fixdate="2004-05-13 05:18:51">
    <buginformation>
      <summary>NPE updating an aspect in incremental mode</summary>
      <description>NPE when updating an aspect in incremental mode.
Find test case in incremental/full-rebuild.

AjBuildManager.java:208 finally clause runs after 
every iteration:

     ret = !handler.hasErrors();
     handler = null;

But at AjBuildManager.java:124, handler is only set if 
there is not a complete rebuild: 

    if (!canIncremental &amp;&amp; !batch) { // retry as batch?
        return doBuild(buildConfig, baseHandler, true);
    }
    this.handler = ...

Since result is set by return doBuild..), could say

    if (null != handler) {
        ret = !handler.hasErrors();
    }

(Seems to have been introduced in a month ago in 1.44.  Our test coverage of
incremental mode is awful.)</description>
      <comments>
		<comment id="1" date="2004-04-25 20:45:07 EDT" author="Wes Isberg">Created attachment 9930 [details]
patch fix

minimal, also adds warning guard, passes test suite.  But I don't like this
code ...</comment>
		<comment id="2" date="2004-04-25 20:46:40 EDT" author="Wes Isberg">raising priority to fix before 1.2 final</comment>
		<comment id="3" date="2004-05-13 05:18:51 EDT" author="Adrian Colyer">Adrian fixed.</comment>
		<comment id="4" date="2004-05-13 05:27:12 EDT" author="Adrian Colyer">*** Bug 61845 has been marked as a duplicate of this bug. ***</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="d48a48032c832e261bbfa3dd94e2c9f1cfc5a0a1" author="wisberg" date="2004-04-26 09:45:48"/>
          <file name="tests/incremental/full-rebuild/src/Aspect.20.java">
          </file>
          <file name="tests/incremental/full-rebuild/src/Aspect.java">
          </file>
          <file name="tests/incremental/full-rebuild/src/Main.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="62227" opendate="2004-5-14 5:34:00" fixdate="2004-5-18 15:46:00">
    <buginformation>
      <summary>Load Time Weaving aborts on any kind of warning (declare/xlint)</summary>
      <description>The message handler in the weaving adapter for load time weaving says:

public boolean handleMessage(IMessage message) throws AbortException {
  if (!isIgnoring(message.getKind())) {
    if (verbose) System.err.println(message.getMessage());
    throw new AbortException(message);
  }
  return true;
}

This means for warnings it goes bang.  So, even a declare warning that is 
meant to tell the user something informational during a LTW will cause the 
code to blow up.  The fix is straightforward and simply to log warning 
messages and only fail for error messages.  I am waiting for a testcase from 
Matthew before checking in the fix.</description>
      <comments>
		<comment id="1" date="2004-05-14 07:01:17 EDT" author="Matthew Webster">Created attachment 10642 [details]
Tescases for declare warning declare error

Please run the modified BcweaverJarMaker for running BcweaverModuleTests. There
should be one failure for declare warning</comment>
		<comment id="2" date="2004-05-18 15:46:59 EDT" author="Andrew Clement">fix and testcases checked in.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="9ebfc84930fde3f56a0166a5abb671029d457ea4" author="aclement" date="2004-05-14 09:51:52"/>
          <file name="org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/BcweaverJarMaker.java">
              <method name="makeURLWeavingClassLoaderJars" returnType="void" parameters=""/>
          </file>
          <file name="weaver/src/org/aspectj/weaver/WeavingURLClassLoader.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java">
          </file>
          <file name="weaver/testsrc/org/aspectj/weaver/WeavingURLClassLoaderTest.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="72671" opendate="2004-08-26 06:56:00" fixdate="2004-09-07 08:01:00">
    <buginformation>
      <summary>Bootclasspath specification for compiling is not possible</summary>
      <description>I have following bug running  eclipse 3.0 and ajdt 1.1.12

I have following class:
 
import java.io.FileNotFoundException;
import java.io.FileOutputStream;

import org.w3c.dom.DOMConfiguration;
import org.w3c.dom.DOMError;
import org.w3c.dom.DOMErrorHandler;
import org.w3c.dom.Document;
import org.w3c.dom.DocumentFragment;
import org.w3c.dom.NodeList;
import org.w3c.dom.ls.DOMImplementationLS;
import org.w3c.dom.ls.LSInput;
import org.w3c.dom.ls.LSOutput;
import org.w3c.dom.ls.LSParser;

import com.dcbank.common.DOMImplementationLSSingleton;

public class DOMHelper {

   public static final String CLASS_ID = "%full_filespec:
DOMHelper.java~1:java:1 %";
   
   public static void save(Document document, String filename)
   throws ClassNotFoundException, InstantiationException,  
IllegalAccessException, FileNotFoundException {
   
      document.normalizeDocument();
   }

}

which compiles very fine with JDK 1.4.2_02 on Windows XP, 
as soon as the  dom2-xml-apis.jar and dom3-xercesImpl.jar are added at the
beginning of the jre container, or are included in
the jar-library list before the system jar. 

As soon as I convert this project to an AspectJ project, the code does not
compile anymore. The aspectJ compiler does not find the  normalizeDocument,
which is included in the one of the two additional jars.
method any more.

kind regards
Arno Schmidmeier</description>
      <comments>
		<comment id="1" date="2004-08-31 08:30:29 EDT" author="Matt Chapman">We have reproduced the problem and are investigating further. The conversion to
an AspectJ project does appear to be changing the order of entries on the
classpath so that the dom jars end up after the JRE ones.</comment>
		<comment id="2" date="2004-08-31 14:17:18 EDT" author="Arno Schmidmeier">Hello,
I do not believe that this is a bug in the conversion of the project, as the 
same issue seems to appears if I set up the project as an AspectJ-project from 
the beginning.

I expect it is a problem in the bootclasspath handling of Ajdt/AspectJ.

I can compile it from the command line directly but not from the ajc batch 
script.
following command do work on NT:

C:\j2sdk1.4.2_02\jre\bin\java -Xbootclasspath:%BP% -classpath %ASPECTJ_HOME%
\lib\aspectjtools.jar;%JAVA_HOME%\lib\tools.jar;%CLASSPATH% -Xmx64M 
org.aspectj.tools.ajc.Main DOMHelper.java

kind regards
  Arno</comment>
		<comment id="3" date="2004-08-31 16:48:32 EDT" author="Matt Chapman">You can pass a bootclasspath option directly to the AspectJ compiler (ajc
script), the flag is -bootclasspath instead of -Xbootclasspath. 

There is no GUI in AJDT for specifying this bootclasspath option to the AspectJ
compiler, but there is at least a textfield you can use: right-click on the
project and select properties, then the "AspectJ" tab. You can then use the "non
standard compiler options" field to type in the -bootclasspath settings you need.

We'll consider further if there is more we can do in this situation.</comment>
		<comment id="4" date="2004-09-07 04:30:55 EDT" author="Matt Chapman">We believe we've now fixed this. The fix is in two parts: one, which was handled
separately in bug 73035, was to change the build classpath of aspectj projects
so that it matches that of java projects, and the order of entries matches the
defined order in the build properties. The other part of the fix was to change
ajde so that a fixed bootclasspath is not passed to the ajc compiler, so that
the jre jars from the regular classpath are used, in the right order.

Either way of putting the dom jars ahead of the jre ones should now work,
although I'd recommend changing the project classpath appropriately, in
preference to redefining the contents of the jre itself.

The fixes will be available in the next release of AJDT. We are also starting to
publish development builds if you want to try it out before then. I'll add
details here of where to get this from once we have a suitable build.</comment>
		<comment id="5" date="2004-09-07 08:01:56 EDT" author="Matt Chapman">Fixed. A development build containing the fix is now available via the following
update site: http://download.eclipse.org/technology/ajdt/30/dev/update/</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="d1551bda9b14c6c2035e0c8df6f09bf4634041de" author="aclement" date="2004-09-07 12:13:46"/>
          <file name="ajde/src/org/aspectj/ajde/internal/CompilerAdapter.java">
              <method name="configureProjectOptions" returnType="void" parameters="AjBuildConfig ProjectPropertiesAdapter"/>
          </file>
          <file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java">
              <method name="populateBuildConfig" returnType="AjBuildConfig" parameters="AjBuildConfig String[] boolean File"/>
          </file>
          <file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.java">
          </file>
          <file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java">
          </file>
          <file name="org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/ajc/BuildArgParserTestCase.java">
              <method name="testPathResolutionFromConfigArgs" returnType="void" parameters=""/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="76096" opendate="2004-10-12 12:17:00" fixdate="2004-10-20 03:58:33">
    <buginformation>
      <summary>Anonymous classes unaware of introductions into abstract classes (error can't find type $Local$)</summary>
      <description>The example below generates a compiler error, on both Linux and Windows. The
error occurs for ajdt (eclipse) as well.

The compiler error:

$ ajc -version
&gt; AspectJ Compiler 1.2 built on Friday May 21, 2004 at
&gt; 15:06:22 GMT
&gt; $ ajc ConcreteClassA.java
&gt; error can't find type $Local$
&gt; 
&gt; /home/marin/tests/ConcreteClassA.java:18 error Class
&gt; must implement the inherited abstract method
&gt; InterfaceA.a2()
&gt; InterfaceA a = new AbstractClassA() {
&gt;                    ^^^^^^^^^^^^^
&gt; 
&gt; 2 errors
&gt; --------
&gt; 


The example (in ConcreteClassA.java):


interface InterfaceA {

 public void a1();
 
 public void a2();
 
}

abstract class AbstractClassA implements InterfaceA {

 public void a1() {
  System.out.println("AbstractClassA.a()");
 }
 
}


public class ConcreteClassA extends AbstractClassA {

 public void someMethod() {
  InterfaceA a = new AbstractClassA() {
  };
 }
 
}

aspect IntroAspectA {

 public void AbstractClassA.a2() {
  System.out.println("AbstractClassA.a2() from IntroAspectA");
 }
}

------------
If you comment out the body of someMethod() (the anonymous class), the code
compiles without errors.</description>
      <comments>
		<comment id="1" date="2004-10-19 06:49:53 EDT" author="Andrew Clement">This was a problem in the AjProblemReporter code.  Before putting out the error
it checks if an ITD exists that would resolve the issue.  It used to attempt to
resolve the type for the generated class that represented the anonymous type
($Local$) - this obviously fails.  It now allows for anonymous types and checks
for ITDs on the parent of the anonymous type.  Tests added, fixed checked in. 
Will close when build available.</comment>
		<comment id="2" date="2004-10-20 03:58:33 EDT" author="Andrew Clement">Fix available.

BUILD COMPLETE -  build.385
Date of build: 10/19/2004 15:08:44
Time to build: 230 minutes 55 seconds
Last changed: 10/19/2004 11:37:35
Last log entry: Fix for Bugzilla Bug 76096: Anonymous classes unaware of
introductions into abstract classes (error can't find type $Local$)
Latest good AspectJ jar available at:
download.eclipse.org/technology/ajdt/dev/aspectj-DEVELOPMENT.jar</comment>
		<comment id="3" date="2004-10-21 04:30:55 EDT" author="Adrian Colyer">Fix released as part of AspectJ 1.2.1</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="6beb43faeecff249a33e7d7e2489c6a92a4700fd" author="aclement" date="2004-10-19 07:37:31"/>
          <file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/problem/AjProblemReporter.java">
          </file>
          <file name="tests/bugs/pr76096/ConcreteClassA.java">
          </file>
          <file name="tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java">
              <method name="test063_cflowOptimization_countersWithAbstractPcuts" returnType="void" parameters=""/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="73433" opendate="2004-9-8 5:46:00" fixdate="2004-09-08 11:17:46">
    <buginformation>
      <summary>AspectJ does not correctly support -cp</summary>
      <description>Discovered by Andy Brodie.

-cp is a shorthand for -classpath supported by the JDT compiler.  AspectJ does
not correctly support -cp option.  Look at this example:

C:\aspectj1.2&gt;ajc -inpath injar.jar -outjar outjar.jar -cp lib\aspectjrt.jar
[error] can't find type org.aspectj.lang.JoinPoint


1 error

C:\aspectj1.2&gt;ajc -inpath injar.jar -outjar outjar.jar -classpath lib\aspectjrt.jar

This is due to the arg parser in AspectJ only recognizing -classpath.  It
doesn't fail when it encounters -cp, it just ignores it and passes it down to
JDT for processing.  The fix is to recognize -cp too.</description>
      <comments>
		<comment id="1" date="2004-09-08 06:20:29 EDT" author="Andrew Clement">Fix checked in - waiting for build.</comment>
		<comment id="2" date="2004-09-08 11:17:46 EDT" author="Andrew Clement">Fix available:

BUILD COMPLETE -  build.374
Date of build: 09/08/2004 14:21:24
Time to build: 105 minutes 21 seconds
Last changed: 09/08/2004 13:05:10
Latest good AspectJ jar available at:
download.eclipse.org/technology/ajdt/dev/aspectj-DEVELOPMENT.jar</comment>
		<comment id="3" date="2004-10-21 04:30:54 EDT" author="Adrian Colyer">Fix released as part of AspectJ 1.2.1</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="8e4d8980e45ba054e7d8e3e5e7ac3aca940d0758" author="aclement" date="2004-09-08 07:14:44"/>
          <file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java">
              <method name="parseOption" returnType="void" parameters="String LinkedList"/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="42573" opendate="2003-9-4 18:40:00" fixdate="2004-08-06 08:26:40">
    <buginformation>
      <summary>".lst file entries not resolved relative to list file: {boot}classpath, extdirs,"</summary>
      <description>My -classpath entry in a config/.lst file was resolved relative to the working
directory rather than to the config/.lst file.  BuildArgParser.java looks like
this would also be true for bootclasspath and extdirs, but not for injars,
aspectpath, or sourceroots.</description>
      <comments>
		<comment id="1" date="2004-01-29 11:29:47 EST" author="Adrian Colyer">I'll look at this whilst considering what changes to make wrt. the larger ajdt.
core extension for AJDT building.</comment>
		<comment id="2" date="2004-08-05 11:38:47 EDT" author="Adrian Colyer">Hmmm... it looks to me like any relative file or path specified in a .lst file 
(be it source file name, entry in any path - even injars etc..) is resolved 
relative to the working directory, not to the config file. 

I could change it (for everything) to make this behaviour relative - which 
should be backwards compatible because any relative path in such an .lst file 
now is either (a) broken, or (b) in a .lst file that is in the working 
directory.

Should I switch it?</comment>
		<comment id="3" date="2004-08-05 12:27:48 EDT" author="Adrian Colyer">We discussed this on the call today. Consensus is that everything should indeed 
be relative. I will fix....</comment>
		<comment id="4" date="2004-08-05 12:29:52 EDT" author="Mik Kersten">Yup the change to make it relative to the .lst file sounds right.  It's too 
inconsistent and confusing otherwise.</comment>
		<comment id="5" date="2004-08-05 13:44:50 EDT" author="Adrian Colyer">Fix committed to tree. Will close bug once this is available in a build.</comment>
		<comment id="6" date="2004-08-06 08:26:40 EDT" author="Adrian Colyer">Fix now available in the latest jar from the download page.</comment>
		<comment id="7" date="2004-10-21 04:30:54 EDT" author="Adrian Colyer">Fix released as part of AspectJ 1.2.1</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="648c0f4d15d9ab6bac9deef010a1b66824cd8da1" author="acolyer" date="2004-08-06 02:31:56"/>
          <file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java">
              <method name="parseOption" returnType="void" parameters="String LinkedList"/>
          </file>
          <file name="org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/ajc/BuildArgParserTestCase.java">
              <method name="genBuildConfig" returnType="AjBuildConfig" parameters="String[] IMessageHandler"/>
          </file>
          <file name="util/src/org/aspectj/util/ConfigParser.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="70008" opendate="2004-7-14 7:16:00" fixdate="2004-07-14 16:14:32">
    <buginformation>
      <summary>problem with ajdoc -public</summary>
      <description>Using the spacewar example, the following works fine:
    ajdoc -private -d doc spacewar coordination
but the following breaks:
    ajdoc -public -d doc spacewar coordination

The end of the failing output is below. Display.html and
Display.DisplayAspect.html were not generated as the types are not public, so
presumably the decorator shouldn't be looking for them in this case.

&gt; Decorating html files...
&gt; Decorating C:\aspectj1.2\doc\examples\doc\spacewar\Debug.html...
&gt; Decorating C:\aspectj1.2\doc\examples\doc\spacewar\Display.DisplayAspect.html.
..
An internal error occured in ajdoc
Please copy the following text into an email message and send it,
along with any additional information you can add to:

       aspectj-dev@eclipse.org


java.io.FileNotFoundException: C:\aspectj1.2\doc\examples\doc\spacewar\Display.D
isplayAspect.html (The system cannot find the file specified)
java.io.FileNotFoundException: C:\aspectj1.2\doc\examples\doc\spacewar\Display.D
isplayAspect.html (The system cannot find the file specified)
        at java.io.FileInputStream.open(Native Method)
        at java.io.FileInputStream.&lt;init&gt;(FileInputStream.java:106)
        at java.io.FileReader.&lt;init&gt;(FileReader.java:55)
        at org.aspectj.tools.ajdoc.HtmlDecorator.decorateHTMLFile(HtmlDecorator.java:142)
        at org.aspectj.tools.ajdoc.HtmlDecorator.decorateHTMLFromDecl(HtmlDecorator.java:115)
        at org.aspectj.tools.ajdoc.HtmlDecorator.decorateHTMLFromDecls(HtmlDecorator.java:54)
        at org.aspectj.tools.ajdoc.HtmlDecorator.decorateHTMLFromInputFiles(HtmlDecorator.java:43)
        at org.aspectj.tools.ajdoc.Main.main(Main.java:210)</description>
      <comments>
		<comment id="1" date="2004-07-14 16:14:32 EDT" author="Mik Kersten">Fixed.

This turned out to be a trickier problem, and I expanded the CoverageTestCase 
and SpacewarTestCase tests to cover it more thoroughly.  In a nutshell, the 
compiler's AST makes any nested aspect "public" accessiblity, whether it is 
declared "package" or "private" visibility.  This results in a mismmatch 
between the structure model and the source code.

I was tempted to fix this by making the structure model treat those aspects as 
private.  However, this would be a somewhat time consuming operation since it 
would need to parse the original source code rather than relying on the AST.  
So instead I made ajdoc treat this case correctly.

PLEASE NOTE THE SIDE-EFFECT of keeping this behavior: the outline view will 
continue to show private/package nested aspects as public, sine that's what's 
in the bytecode.</comment>
		<comment id="2" date="2004-07-15 04:38:49 EDT" author="Andrew Clement">Matt - I've just checked in a new org.aspectj.ajde with Miks fix in it - can you
test it?</comment>
		<comment id="3" date="2004-07-15 04:58:59 EDT" author="Matt Chapman">I've verified the fix from AJDT. Thanks guys.</comment>
		<comment id="4" date="2004-10-21 04:30:48 EDT" author="Adrian Colyer">Fix released as part of AspectJ 1.2.1</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="8dc08453232f9b4c1572ad0feb60979fb07336fe" author="mkersten" date="2004-07-15 05:36:00"/>
          <file name="ajdoc/src/org/aspectj/tools/ajdoc/HtmlDecorator.java">
              <method name="decorateHTMLFromDecl" returnType="void" parameters="Declaration String String boolean"/>
          </file>
          <file name="ajdoc/testdata/coverage/foo/PkgVisibleClass.java">
          </file>
          <file name="ajdoc/testsrc/org/aspectj/tools/ajdoc/CoverageTestCase.java">
          </file>
          <file name="ajdoc/testsrc/org/aspectj/tools/ajdoc/SpacewarTestCase.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="71811" opendate="2004-8-11 13:40:00" fixdate="2004-08-19 21:01:07">
    <buginformation>
      <summary>AJDoc: should be able to set encoding like javadoc</summary>
      <description>ajdoc doesn't support the -encoding -docencoding and -charset options of javadoc.

Especially, it doesn't pass on the -encoding to ajc.
If your project uses a source file encoding (e.g. UTF-8) 
differing form the platform standard, and some java identifiers 
use characters byond the standard ASCII range, you won't be able 
to use ajdoc at all.</description>
      <comments>
		<comment id="1" date="2004-08-19 21:01:07 EDT" author="Mik Kersten">Fixed.  The following flags now work:
  - encoding &lt;name&gt;
  - docencoding &lt;name&gt;
  - charset &lt;name&gt;
 </comment>
		<comment id="2" date="2004-10-21 04:30:50 EDT" author="Adrian Colyer">Fix released as part of AspectJ 1.2.1</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="5f80c8cd8de6ab532fbe3e267cca45b749331d98" author="mkersten" date="2004-08-20 10:01:45"/>
          <file name="ajdoc/src/org/aspectj/tools/ajdoc/Main.java">
              <method name="parseArgs" returnType="void" parameters="List File"/>
          </file>
          <file name="ajdoc/testsrc/org/aspectj/tools/ajdoc/CoverageTestCase.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="72699" opendate="2004-8-26 11:46:00" fixdate="2004-08-28 12:34:10">
    <buginformation>
      <summary>Bogus error message: The abstract method ajc$pointcut$$tracingScope$a2 in type Tracing can only be defined by an abstract class</summary>
      <description>When attempting to compile the following aspect the resulting error message 
should say something like "The abstract method pointcut tracingScope in type 
Tracing can only be defined by an abstract aspect"

public aspect Tracing {
	public abstract pointcut tracingScope();

}</description>
      <comments>
		<comment id="1" date="2004-08-27 07:22:00 EDT" author="Andrew Clement">I have fixed this case and the related case of

public class Tracing
  public abstract pointcut tracingScope();
}

Which was also resulting in crap error messages.  I haven't fixed the message as
proposed in the bug report, I have fixed it properly to be

"The abstract pointcut tracingScope can only be defined in an abstract aspect"

This involved:

In pointcutdeclaration.postParse() I had to produce the correct error message.

In AjProblemReporter I have to override abstractMethodInAbstractClass and make
sure we don't report problems on methods arising from pointcut declarations
(since postParse is already putting out the right message).

Fix checked in, waiting for build.</comment>
		<comment id="2" date="2004-08-28 12:34:10 EDT" author="Andrew Clement">Fix available: 

BUILD COMPLETE -  build.364
Date of build: 08/27/2004 22:17:38
Time to build: 95 minutes 15 seconds
Last changed: 08/27/2004 17:02:18
Latest good AspectJ jar available at:
download.eclipse.org/technology/ajdt/dev/aspectj-DEVELOPMENT.jar</comment>
		<comment id="3" date="2004-10-21 04:30:46 EDT" author="Adrian Colyer">Fix released as part of AspectJ 1.2.1</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="5e0876580b0e95dd06ca4342e233f9a5dceb33a5" author="aclement" date="2004-08-27 08:18:01"/>
          <file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/PointcutDeclaration.java">
              <method name="postParse" returnType="void" parameters="TypeDeclaration"/>
          </file>
          <file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/problem/AjProblemReporter.java">
          </file>
          <file name="tests/bugs/BogusMessage.java">
          </file>
          <file name="tests/bugs/BogusMessage2.java">
          </file>
          <file name="tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java">
              <method name="test051_arrayCloningInJava5" returnType="void" parameters=""/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="74238" opendate="2004-9-19 5:51:00" fixdate="2004-10-19 04:37:34 ">
    <buginformation>
      <summary>Applet which uses cflow pointcut gets AccessControlException</summary>
      <description>When I used cflow pointcut for my applet, I couldn't launch the Applet.

java.lang.ExceptionInInitializerError
        at SandAspect.ajc$preClinit(SandAspect.aj)
        at SandAspect.&lt;clinit&gt;(SandAspect.aj)
        at SandApplet.init(SandApplet.java)
        at sun.applet.AppletPanel.run(AppletPanel.java:353)
        at java.lang.Thread.run(Thread.java:534)
Caused by: java.security.AccessControlException: access denied (java.util.PropertyPermission aspectj.runtime.cflowstack.usethreadlocal read)
        at java.security.AccessControlContext.checkPermission(AccessControlContext.java:269)
        at java.security.AccessController.checkPermission(AccessController.java:401)
        at java.lang.SecurityManager.checkPermission(SecurityManager.java:524)
        at java.lang.SecurityManager.checkPropertyAccess(SecurityManager.java:1276)
        at java.lang.System.getProperty(System.java:612)
        at org.aspectj.runtime.internal.CFlowStack.selectFactoryForVMVersion(CFlowStack.java:124)
        at org.aspectj.runtime.internal.CFlowStack.&lt;clinit&gt;(CFlowStack.java:59)
        ... 5 more

It because CFlowStack uses System.getProperty method with no try..catch block. 
Applet doesn't have permission to read system property:
"aspectj.runtime.cflowstack.usethreadlocal".

workaround:
modify CFlowStack.java(1.5) line 123,124 like this
-----
private static String getSystemPropertyWithNoSecurityException(
  String aPropertyName, String aDefaultValue){
  try{
    return System.getProperty(aPropertyName, aDefaultValue);
  } catch(java.lang.SecurityException e){
    return aDefaultValue;
  }
}

private static void selectFactoryForVMVersion() {
  String override = getSystemPropertyWithNoSecurityException(
    "aspectj.runtime.cflowstack.usethreadlocal"
    , "unspecified"
  );
-----
I think defining getSystemPropertyWithNoSecurityException(or more
simple name :-)) method in some utility class and using it where you call
System.getProperty are better way.</description>
      <comments>
		<comment id="1" date="2004-09-29 09:57:18 EDT" author="Andrew Clement">Assigning to Matthew.  The proposed solution looks good.  See related bug 71527.
 In that bug the raiser wanted a way to switch off the use of threadlocal - but
after reading this bug I think what they really meant in bug 71527 was they
wanted a way to use cflow and not hit the security exception.  </comment>
		<comment id="2" date="2004-09-29 10:02:31 EDT" author="Matthew Webster">In the runtime we use 2 other access controlled APIs but do so safely:
- Class.forName(): use of String argument version and avoid use of "null" 
class loader (see comment in SigantureImpl.makeClass()).
- Class.getClassLoader(): use on self or class defining static join point 
object (which must be defined by a classloader at or below that used by the 
runtime which is OK).

Should explore option to enclose calls to System.getProperty() in privileged 
blocks so that full function is availble when correct permissions granted. 
However must first explore implications for J2ME (which is the reason for the 
property query in the first place).</comment>
		<comment id="3" date="2004-09-30 16:05:03 EDT" author="Matthew Webster">Created attachment 14938 [details]
Suggested fix and Ant-based test

The java.class.version property is not protected so only the first getProperty
call is replaced. The test can be replaced with a harness-based version when
"fork" is supported.</comment>
		<comment id="4" date="2004-10-14 04:33:21 EDT" author="Andrew Clement">Fix checked in.  I've added Charles Zhang to the CC list as he was having
problems with this same bit of property checking code failing on J2ME.  Catching
the security exception will now allow the code to proceed, it will be
interesting  whether it enables Charles' code to now run successfully on J2ME. 
I know ThreadLocal isn't available there but the cflow stuff in aspectjrt.jar
should be able to cope with that and fall back on the old non-threadlocal
implementation.

Matthew do you want to migrate your test into the new forking harness?

waiting for build ....</comment>
		<comment id="5" date="2004-10-19 04:37:34 EDT" author="Andrew Clement">Build available:

BUILD COMPLETE -  build.383
Date of build: 10/18/2004 23:39:49
Time to build: 113 minutes 41 seconds
Last changed: 10/18/2004 13:04:09
Latest good AspectJ jar available at:
download.eclipse.org/technology/ajdt/dev/aspectj-DEVELOPMENT.jar</comment>
		<comment id="6" date="2004-10-21 04:31:16 EDT" author="Adrian Colyer">Fix released as part of AspectJ 1.2.1</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="6e155a6b9b78ec64f2fd4dc08152698277f1e7b7" author="aclement" date="2004-10-14 05:12:09"/>
          <file name="ajde/testdata/SecurityManagerTest/src/HelloWorld.java">
          </file>
          <file name="runtime/src/org/aspectj/runtime/internal/CFlowCounter.java">
          </file>
          <file name="runtime/src/org/aspectj/runtime/internal/CFlowStack.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="59208" opendate="2004-4-20 5:23:00" fixdate="2004-08-10 12:03:17">
    <buginformation>
      <summary>Weaver fails in BCEL for large classes</summary>
      <description>This problem was first observed when weaving large binary legacy classes with 
the ajc 1.2 rc1 candidate. It turns out that BCEL fails with different error 
messages dependent on whether we are doing a binary weave or a straight ajc 
compile. In the latter case, the error message is rather confusing.

To reproduce:
1. Compile and run the following code to produce Foo.java
// File FooProducer.java
public class FooProducer
{
  public static final int N_METHODS = 50;
  public static final int N_STATEMENTS = Short.MAX_VALUE/(2 * N_METHODS);
  public static void main(String[] args) {
  	System.out.println("public class Foo {");
  	System.out.println("static java.util.Set hs = new java.util.HashSet
();");
  	for (int i = 0; i &lt; N_METHODS; i++) {		
  	  System.out.println("public void test" + i + "() { ");
            for (int j = 0; j &lt; N_STATEMENTS; j++) {
    	        System.out.println("hs.add(new Object());");
            }
          System.out.println("}");
        }
    System.out.println("}");
  }
}// End of FooProducer.java

2. Create the following Aspect:
// File a.aj
aspect a  {
 boolean around() : (target(java.util.HashSet) &amp;&amp; call(boolean add(..) ) )
    {
      return false;
    }
}
// End of a.aj

*** 3.a - straight compile and weave:
ajc -
sourceroots .                                                                   
          
ABORT
        
Exception thrown from AspectJ 1.2rc1

This might be logged as a bug already -- find current bugs at
  http://bugs.eclipse.org/bugs/buglist.cgi?product=AspectJ&amp;component=Compiler

Bugs for exceptions thrown have titles File:line from the top stack, 
e.g., "SomeFile.java:243"

If you don't find the exception below in a bug, please add a new bug
at http://bugs.eclipse.org/bugs/enter_bug.cgi?product=AspectJ
To make the bug a priority, please include a test program
that can reproduce this exception.
Expected class `CONSTANT_Utf8' at index 25700 and got CONSTANT_NameAndType[12]
(name_index = 25696, signature_index = 81)
Expected class `CONSTANT_Utf8' at index 25700 and got CONSTANT_NameAndType[12]
(name_index = 25696, signature_index = 81)
org.apache.bcel.classfile.ClassFormatException: Expected class `CONSTANT_Utf8' 
at index 25700 and got CONSTANT_NameAndType[12](name_index = 25696, 
signature_index = 81)
        at org.apache.bcel.classfile.ConstantPool.getConstant(ConstantPool.java:271)
        at org.apache.bcel.classfile.Attribute.readAttribute(Attribute.java:163)
        at org.apache.bcel.classfile.FieldOrMethod.&lt;init&gt;(FieldOrMethod.java:98)
        at org.apache.bcel.classfile.Field.&lt;init&gt;(Field.java:83)
        at org.apache.bcel.classfile.ClassParser.readFields(ClassParser.java:270)
        at org.apache.bcel.classfile.ClassParser.parse(ClassParser.java:172)
        at org.aspectj.weaver.bcel.Utility.makeJavaClass(Utility.java:358)
        at org.aspectj.weaver.bcel.UnwovenClassFile.getJavaClass(UnwovenClassFile.java:63)
        at org.aspectj.weaver.bcel.UnwovenClassFile.getClassName(UnwovenClassFile.java:147)
        at org.aspectj.ajdt.internal.compiler.WeaverAdapter.acceptResult(WeaverAdapter.java:177)
        at org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify(BcelWeaver.java:621)
        at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:563)
        at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave(AjCompilerAdapter.java:239)
        at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling(AjCompilerAdapter.java:114)
        at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:376)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:600)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:160)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:94)
        at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:102)
        at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:53)
        at org.aspectj.tools.ajc.Main.run(Main.java:280)
        at org.aspectj.tools.ajc.Main.runMain(Main.java:217)
        at org.aspectj.tools.ajc.Main.main(Main.java:79)


1 fail|abort
Signal 127

*** 3b - binary weave
 ajc -noweave -outjar test.jar a.aj
 javac -d classes Foo.java
  ajc  -aspectpath test.jar -inpath classes         
ABORT
        
Exception thrown from AspectJ 1.2rc1

This might be logged as a bug already -- find current bugs at
  http://bugs.eclipse.org/bugs/buglist.cgi?product=AspectJ&amp;component=Compiler

Bugs for exceptions thrown have titles File:line from the top stack, 
e.g., "SomeFile.java:243"

If you don't find the exception below in a bug, please add a new bug
at http://bugs.eclipse.org/bugs/enter_bug.cgi?product=AspectJ
To make the bug a priority, please include a test program
that can reproduce this exception.
Class can't be both final and abstract
Class can't be both final and abstract
org.apache.bcel.classfile.ClassFormatException: Class can't be both final and 
abstract
        at org.apache.bcel.classfile.ClassParser.readClassInfo(ClassParser.java:242)
        at org.apache.bcel.classfile.ClassParser.parse(ClassParser.java:165)
        at org.aspectj.weaver.bcel.Utility.makeJavaClass(Utility.java:358)
        at org.aspectj.weaver.bcel.UnwovenClassFile.getJavaClass(UnwovenClassFile.java:63)
        at org.aspectj.weaver.bcel.UnwovenClassFile.getClassName(UnwovenClassFile.java:147)
        at org.aspectj.ajdt.internal.compiler.WeaverAdapter.acceptResult(WeaverAdapter.java:177)
        at org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify(BcelWeaver.java:621)
        at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:563)
        at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave(AjCompilerAdapter.java:239)
        at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling(AjCompilerAdapter.java:114)
        at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:376)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:600)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:160)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:94)
        at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:102)
        at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:53)
        at org.aspectj.tools.ajc.Main.run(Main.java:280)
        at org.aspectj.tools.ajc.Main.runMain(Main.java:217)
        at org.aspectj.tools.ajc.Main.main(Main.java:79)


1 fail|abort
Signal 127</description>
      <comments>
		<comment id="1" date="2004-04-22 15:39:17 EDT" author="Per S Hustad">Seems like the bug is caused by a truncation of the ConstantPool unsigned short 
limit of 65535 when BcelClassWeaver writes the bytecode after weaving. I.e. 
this happens when the ConstantPool size is larger than 65535.

There is not much ajc can do about that limit but I propose that a more 
meaningful error message is generated by the weaver in this case.</comment>
		<comment id="2" date="2004-08-10 07:15:34 EDT" author="Adrian Colyer">In both scenarios the compilation will now fail cleanly with an error message:

The class Foo exceeds the maximum class size supported by the JVM (constant pool 
too big).

Will close this bug once the fix is available in a published build.
Thanks for the clear test case.</comment>
		<comment id="3" date="2004-08-10 12:03:17 EDT" author="Adrian Colyer">Fix now available in latest build on AspectJ download page.</comment>
		<comment id="4" date="2004-10-21 04:31:45 EDT" author="Adrian Colyer">Fix released as part of AspectJ 1.2.1</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="44a92e1a04f8f2f1a862f15f9d0b9ed761d05fd4" author="acolyer" date="2004-08-10 08:08:56"/>
          <file name="tests/bugs/pr59208/Foo.java">
          </file>
          <file name="tests/bugs/pr59208/FooProducer.java">
          </file>
          <file name="tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/WeaverMessages.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/bcel/LazyClassGen.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="49743" opendate="2004-1-8 17:37:00" fixdate="2004-09-07 09:40:01">
    <buginformation>
      <summary>performance improvements for runtime library</summary>
      <description>I am heavily using the runtime signature information from
thisJoinPoint.getSignature() and the toString() method of it. This causes heavy
String operations each time the toString method is called. Would it be possible
to cache the resulting string for example in MethodSignatureImpl and similar
classes for other signatures?</description>
      <comments>
		<comment id="1" date="2004-01-14 11:50:31 EST" author="Jim Hugunin">We will try to do this change after the benchmark suite is implemented so we 
will have a better grasp on the runtime performance gain and the static memory 
usage overhead of the change.</comment>
		<comment id="2" date="2004-08-10 04:32:49 EDT" author="Adrian Colyer">Matthew, do we have a suite to understand the possible footprint / performance 
trade-offs here? If this enhancement makes sense under test, then let's put it 
in...</comment>
		<comment id="3" date="2004-08-13 12:43:43 EDT" author="Matthew Webster">The "toString()" cache will add a new reference to every Signature object. 
There are concerns about footprint in large systems: bug 59076. Therefore the 
reference must be shared by each of the toString implementations: short, 
middle, long. Also the cache must be soft so that GC can collect the String 
when no need.

We should also endeavour to make this feature footprint-neutral by saving some 
memory elsewhere. Each SJP has a SourceLocation as well as a Signature. The 
column property is deprecated. Removing it and always returning -1 will save 
an "int".</comment>
		<comment id="4" date="2004-08-24 10:54:07 EDT" author="Matthew Webster">Created attachment 14146 [details]
toString caching

1. For Signature objects the results of to/toShort/toLongString are cached
softly.
2. Simple testcase
3. Performance testcase
4. Redundant/deprecated "col" field removed from SourceLocation</comment>
		<comment id="5" date="2004-09-01 06:35:04 EDT" author="Andrew Clement">Matthews code integrated.  I will close the bug when it is available in a build.</comment>
		<comment id="6" date="2004-09-07 09:40:01 EDT" author="Andrew Clement">fix available:

BUILD COMPLETE -  build.371
Date of build: 09/07/2004 12:33:43
Time to build: 101 minutes 39 seconds
Last changed: 09/07/2004 11:47:45
Latest good AspectJ jar available at:
download.eclipse.org/technology/ajdt/dev/aspectj-DEVELOPMENT.jar</comment>
		<comment id="7" date="2004-10-21 04:31:02 EDT" author="Adrian Colyer">Fix released as part of AspectJ 1.2.1</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="438e61c998298b48830d5be76668df45629a1eb0" author="aclement" date="2004-09-01 07:30:07"/>
          <file name="runtime/src/org/aspectj/runtime/reflect/AdviceSignatureImpl.java">
              <method name="getReturnType" returnType="Class" parameters=""/>
          </file>
          <file name="runtime/src/org/aspectj/runtime/reflect/CatchClauseSignatureImpl.java">
              <method name="getParameterName" returnType="String" parameters=""/>
          </file>
          <file name="runtime/src/org/aspectj/runtime/reflect/ConstructorSignatureImpl.java">
          </file>
          <file name="runtime/src/org/aspectj/runtime/reflect/Factory.java">
          </file>
          <file name="runtime/src/org/aspectj/runtime/reflect/FieldSignatureImpl.java">
              <method name="getFieldType" returnType="Class" parameters=""/>
          </file>
          <file name="runtime/src/org/aspectj/runtime/reflect/InitializerSignatureImpl.java">
              <method name="getName" returnType="String" parameters=""/>
          </file>
          <file name="runtime/src/org/aspectj/runtime/reflect/MethodSignatureImpl.java">
              <method name="getReturnType" returnType="Class" parameters=""/>
          </file>
          <file name="runtime/src/org/aspectj/runtime/reflect/SignatureImpl.java">
          </file>
          <file name="runtime/src/org/aspectj/runtime/reflect/SourceLocationImpl.java">
          </file>
          <file name="runtime/src/org/aspectj/runtime/reflect/StringMaker.java">
          </file>
          <file name="runtime/testsrc/RuntimeModuleTests.java">
          </file>
          <file name="runtime/testsrc/org/aspectj/runtime/reflect/RuntimePerformanceTest.java">
          </file>
          <file name="runtime/testsrc/org/aspectj/runtime/reflect/SignatureTest.java">
              <method name="testGetDeclaringTypeName" returnType="void" parameters=""/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="53981" opendate="2004-3-6 22:43:00" fixdate="2004-08-10 12:05:02">
    <buginformation>
      <summary>proceed used as method name in around advice</summary>
      <description>Using a method named proceed(..) in around advice confuses the compiler (in at
least the 2-3 ways shown below).  

True of the current tree (untested in 1.1.1).  Workaround for now is to rename
the method.  

---- first problem: NPE in compiler
java.lang.NullPointerException
	at
org.aspectj.ajdt.internal.compiler.ast.MakeDeclsPublicVisitor.endVisit(MakeDeclsPublicVisitor.java:44)

public class Proceeding {
    public static void main(String[] args) { }
    static aspect A {
        interface IProceed {
            void proceed(Runnable next);
        }
        IProceed decorator;
        void around() : execution(void main(String[])) {
            decorator.proceed(new Runnable() {
                public void run() {
                    proceed();
                }
            });
        }
    }
}

---- second problem: incorrect error wrt number of arguments

public class Proceeding {
    public static void main(String[] args) {
    }
    static aspect A {
        void around() : execution(void main(String[])) {
            Proceeding.proceed(null); // BUG: treated as proceed(Object);
        }
    }
    static void proceed(Object o) {}
}

---- third hypothetical: we should document how ambiguity is resolved

public class Proceeding {
    public static void main(String[] args) {
    }
    static aspect A {
        void around() : execution(void main(String[])) {
            proceed(); // special form or Proceeding.proceed()?
        }
    }
    void proceed() {}
}</description>
      <comments>
		<comment id="1" date="2004-03-06 22:44:16 EST" author="Wes Isberg">Sorry - last hypo should be

  static void proceed() {}
  ^^^^^^</comment>
		<comment id="2" date="2004-03-18 14:12:19 EST" author="Jim Hugunin">To maintain a simple specification the rule should be that a bare proceed in 
an aspect is always the special form and can never refer to a method even if 
one is defined by the aspect.  However, we should support calling proceed with 
a receiver as in examples 1 and 2 as this is clearly unambiguous.

This can probably be fixed fairly easily by modifying the method 
Proceed.findEnclosingAround to check if Proceed.receiver exists and if so to 
claim the proceed is not inside an around and therefore should be treated as a 
normal method.</comment>
		<comment id="3" date="2004-03-18 14:12:57 EST" author="Jim Hugunin">Raising to a P2 bug to increase visibility, but not marking 1.2 as I don't 
think this should delay a 1.2 release.</comment>
		<comment id="4" date="2004-08-09 15:23:53 EDT" author="Adrian Colyer">marked as target 1.2.1</comment>
		<comment id="5" date="2004-08-10 09:18:10 EDT" author="Adrian Colyer">Fixed following Jim's suggestion. Had to make one refinement which is to treat 
the proceed as the special form in the case when the receiver is null, OR the 
receiver is non-null and receiver.isThis() returns true.

All three of the cases below now work correctly. 

I also added the following to the semantics appendix:

=============

Any occurence of proceed(..) within the body of around advice is treated as the 
special proceed form (even if the aspect defines a method named proceed) unless 
a target other than the aspect instance is specified as the recipient of the 
call. For example, in the following program the first call to proceed will be 
treated as a method call to the ICanProceed instance, whereas the second call to 
proceed is treated as the special proceed form. 

  aspect A {
     Object around(ICanProceed canProceed) : execution(* *(..)) &amp;&amp; 
this(canProceed) {
        canProceed.proceed();         // a method call
        return proceed(canProceed);   // the special proceed form
     }
     
     private Object proceed(ICanProceed canProceed) {
        // this method cannot be called from inside the body of around advice in
        // the aspect
     }
  }

==============

The wording is slightly cumbersome, but it was very hard to phrase this 
accurately.</comment>
		<comment id="6" date="2004-08-10 12:05:02 EDT" author="Adrian Colyer">Fix now available in latest development jar from AspectJ download page.</comment>
		<comment id="7" date="2004-10-21 04:31:13 EDT" author="Adrian Colyer">Fix released as part of AspectJ 1.2.1</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="05dabd1821fffd9f353d1e965a56658b962c82d7" author="acolyer" date="2004-08-10 10:22:08"/>
          <file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/Proceed.java">
          </file>
          <file name="tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="60015" opendate="2004-4-26 16:49:00" fixdate="2004-08-11 12:40:40">
    <buginformation>
      <summary>"NPE, Incorrect XLint:unmatchedSuperTypeInCall warning"</summary>
      <description>(This is an incomplete bug report -- sorry no time not to further isolate.)

Running AJDT 1.1.6, I get dozens of these warnings:

----------
Warning does not match because declaring type is java.lang.Object, if match
desired use target(st.ata.mc.exim.DatastoreReader)
[Xlint:unmatchedSuperTypeInCall] Blah.aj project/src/package/dir line 22
----------

for something like this code:

----------
import pack.Interface;
...
pointcut dsrCall() : call(* Interface.*(..)); // WARNING HERE
...
----------

Each warning points to the pointcut (not the join point shadow).

NPE running from the command-line with the latest tree (will attach).</description>
      <comments>
		<comment id="1" date="2004-04-26 16:50:30 EDT" author="Wes Isberg">Created attachment 9980 [details]
Command and NPE trace

NPE running from the command-line with the current tree.</comment>
		<comment id="2" date="2004-04-26 16:51:56 EDT" author="Wes Isberg">Created attachment 9981 [details]
initial attempt to reproduce

.zip file with initial test case attempt that does not reproduce the bug but
does reflect the basic structure of the code I'm using (and can't submit).</comment>
		<comment id="3" date="2004-04-26 16:52:49 EDT" author="Wes Isberg">P2 for investigation as NPE</comment>
		<comment id="4" date="2004-04-27 04:42:51 EDT" author="Andrew Clement">Great!
I put this line in bug 59596:
"I give up!  I can't create a minimal library equivalent to rt.jar that 
 contains an unresolvable member - so I can't create a testcase in CVS"

It turns out that any kind of lint warning would do for showing up the NPE 
covered in bug 59596.  In this bug report Wes has shown another way to 
demonstrate the same NPE, and I've played about a bit with his code to create 
a testcase.  The NPE is due to the same thing as in 59596 - we attempt to make 
a source context when we don't have a compilation unit.  The source context we 
are trying to make is the one that gives us information like:

public static void main(Bananas[] args) {
                        ^^^^^^^

which highlights the area of the source at fault.

This means the fix for the 59596 NPE that I checked in yesterday covers this 
bug too.  The important requirement for surfacing this bug is that you are 
attempting to create a source context for something that came in as binary.  
In the case here we are attempting to attach a lint warning.

I'm going to attach the zip of my testcase setup.  The key difference between 
what Wes attached and what I have attached is that I've moved the 
UnmatchedCallSupertype code so that it comes in as binary when we compile the 
aspect.  (Incremental compilation is the other way it could come into the 
system in binary form, on the 2nd compile).  
Oh and I added the line:

 System.err.println(this.toString());

to UnmatchedCallSupertype - this is what will cause the lint warning to 
trigger.  Because toString() is declared on java.lang.Object but inherited by 
interface ILib - this means a pointcut call(* ILib.*(..)) will warn you 
because toString() calls won't be matched even though you have said '*' for 
the method name.  Am I making sense?  I think thats whats happening.

If you unzip the attached zip and run:

ajc -d out src\*.java

ajc -inpath out A.java

You get (with 1.2rc1):

java.lang.NullPointerException
        at 
org.aspectj.ajdt.internal.core.builder.EclipseAdapterUtils.makeLocationContext
(EclipseAdapterUtils.java:50)
        at 
org.aspectj.ajdt.internal.core.builder.EclipseAdapterUtils.makeSourceLocation
(EclipseAdapterUtils.java:120)
        at 
org.aspectj.ajdt.internal.core.builder.EclipseAdapterUtils.makeMessage
(EclipseAdapterUtils.java:129)

I'll attach the zip then follow up with more explanation ...</comment>
		<comment id="5" date="2004-04-27 04:48:06 EDT" author="Andrew Clement">Created attachment 9996 [details]
Testcase zip, shows NPE.</comment>
		<comment id="6" date="2004-04-27 05:25:55 EDT" author="Andrew Clement">But ... that is not quite the end of the story.

With the latest from HEAD which fixes the NPE, I can run that code from 
60015.zip and get:

C:\temp\wes\bugs2\unmatchedCallSupertype\A.java:6 warning does not match 
because declaring type is java.lang.Object, if match desired use target
(lib.ILib) [Xlint:unmatchedSuperTypeInCall]
(no source information available)
 
see also: UnmatchedCallSupertype.java:11
see also: C:\temp\wes\bugs2
\unmatchedCallSupertype\out\UnmatchedCallSupertype.class
1 warning

This is giving us all the information we need, but as Wes has noticed, AJDT is 
only paying attention to the first source location (the pointcut definition).  
The new AJDT will need to support the notion of multiple locations for 
messages.

The real problem though is if I compile all the source together:

ajc A.java src\*.java

because that gives an entirely different message:

C:\temp\wes\bugs2\unmatchedCallSupertype\src\UnmatchedCallSupertype.java:6 
warning does not match because declaring type is java.lang.Object, if match 
desired use target(lib.ILib) [Xlint:unmatchedSuperTypeInCall]
public static void main(String[] args) {
^^^^^^^^^^^^^^^^
 
 see also: C:\temp\wes\bugs2
\unmatchedCallSupertype\src\UnmatchedCallSupertype.java:11

1 warning

The first location is wrong.  It points at line 6 of UnmatchedCallSupertype.  
What it should say is line 6 of A.java (to match the other variant of the 
message).  And because that location is wrong, when it prints the source 
context out, it says:

public static void main(String[] args) {
^^^^^^^^^^^^^^^^

which is nonsense, line 6 of UnmatchedCallSupertype is nothing to do with the 
pointcut or the shadow.  This is messy.  It is relatively straightforward to 
adjust the filename used in the 2nd message to be correct (A.java) but because 
the error arose whilst processing shadows in UnmatchedCallSupertype then when 
the logic goes looking through the compilation unit for the source context, it 
still looks at line 6 in UnmatchedCallSupertype which is wrong.  We could swap 
the locations, so the first argument of this lint warning is the shadow that 
doesn't get matched.  But then I'm not sure if the message still makes perfect 
sense.  let me try it...</comment>
		<comment id="7" date="2004-04-27 05:46:46 EDT" author="Andrew Clement">With the switch in locations, here is the output when doing an 'all source' 
build:

C:\temp\wes\bugs2\unmatchedCallSupertype\src\UnmatchedCallSupertype.java:11 
warning does not match because declaring type is java.lang.Object, if match 
desired use target(lib.ILib) [Xlint:unmatchedSuperTypeInCall]
System.err.println(this.toString());
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 
 see also: C:\temp\wes\bugs2\unmatchedCallSupertype\A.java:6

(with a lovely correct source context, although maybe it could have just 
underlined toString())

And here is the output doing a 'binary input' build:

UnmatchedCallSupertype.java:11 warning does not match because declaring type 
is java.lang.Object, if match desired use target(lib.ILib) 
[Xlint:unmatchedSuperTypeInCall]
(no source information available)
 
 see also: C:\temp\wes\bugs2\unmatchedCallSupertype\A.java:6
 see also: C:\temp\wes\bugs2
\unmatchedCallSupertype\out\UnmatchedCallSupertype.class

Comments?  I'll attach the patch to create this alternative behavior.

At the time we create the lint warning we also have the actual shadow 
signature, in this case:

  method-call(java.lang.String java.lang.Object.toString())

I wonder if something can be done with that to improve the message because 
from all the information above (including the source context), it would still 
take some thinking to work out which shadow on that line wouldn't match.

Does anyone think I write too much in these bug reports?</comment>
		<comment id="8" date="2004-04-27 06:05:32 EDT" author="Andrew Clement">Created attachment 9997 [details]
Patch for the weaver that reverses source locations.</comment>
		<comment id="9" date="2004-04-27 08:14:18 EDT" author="Wes Isberg">(1) IMHO you don't write too much.  It's *very* helpful to understand and
encouraging to see things dealt with in their messy complexity, and it raises
the bar for communications.

(2) I am not sure I agree with the xlint message in this context. 

   warning does not match because declaring type 
   is java.lang.Object, if match desired use target(lib.ILib)

It sounds like we're saying that using the declaring type is
required, when AFAIK it is not.

I assume that (i.e., I thought it used to be that)

  call(* Foo.*(..))

(where Foo is defined) would result in picking out any call where the
compile-time type of the reference is a subtype of Foo, regardless of the
declaring type of the method -- e.g.,

  Foo foo = null;
  foo.toString();  // here, though toString declared by Object

i.e., while the careful programmer can specify the declaring type, s/he might
want to specify a subtype and limit the calls accordingly.  (There is no
requirement to use the declaring type.  This was the suggested workaround before
Java 1.4 compilers because earlier compilers were setting up the call site with
the declaring type of the method rather than the compile-time type of the
reference.)

Which means that given

  class Bar { void bar(){}}
  class Foo extends Bar { void foo() {}}

, the pointcut

    call(* Foo.bar())

will not match the shadows

   new Bar().bar()
   ((Bar)(new Foo()).bar()

, though

    call(* Bar.bar())

would match the shadow

   new Foo().bar()

. 

The problem with the type in call(* type.*()) is that people think it refers to
the object being pointed at, not the reference doing the pointing.  Which is why
(I think?) we have an xlint warning for this:

    call(* Bar.foo())
    call(* Bar.unmatched())

Where the member is not defined on the reference type, this will never match,
even though it could match if you did this (for some subtype of Bar):

   target(Bar) &amp;&amp; call(* foo())

So in the test case (2004-04-27 04:48), where lib.ILib is in fact defined on the
classpath and properly imported by the aspect, I see no reason to issue this
warning for any join point, and the before advice on call(* ILib.*(..)) in
A.java should apply to this Client.java shadow:

  new Lib().run();

(And btw, I agree that the compile-time type of the reference is not the kind of
thing that should matter to a programmer when writing aspects.  A small change
(e.g., a perfectly safe cast) could result in the pointcut not matching any
more.  Nonetheless, I believe that's what the semantics say, and coupled with
cast join points it could be quite useful.)

So back to when the warning (bug 41952) should be issued: it seems applicable
when there is a literal method signature definitely matched and that method is
defined by a supertype.  Then either (a) at the specific method call join points
where there is a reference with the compile-time type of a supertype causing the
pointcut not to match, the warning would be issued that the advice/pointcut is
not matching because of the specified type, and suggesting target instead; or
(b) (once at the pointcut definition only) there should be a warning that it
won't pick out references even to that type if they have a compile-time type of
some supertype which is itself a subtype of the declaring type.  I personally
prefer (b).</comment>
		<comment id="10" date="2004-08-03 11:06:37 EDT" author="Andrew Clement">What I've just checked solves the basic annoyance of producing the warning for
something like toString() that is inherited from Object when you have clearly
specified an interface.

This program used to produce the warning on the indicated line:
  public void run();
}

aspect P implements I {
  public void run() { }

  public static void main(String[]argv) {
    aspectOf().run();
    aspectOf().toString();  // XLINT WARNING HERE
  }
  before(): call(* I.*(..)) {}
}

But with the fix, it doesnt.

AJDTs ability to cope with messages that have multiple source locations
(discussed in this bug) is being dealt with under bug 71059 and will be in AJDT
1.1.12.  That makes me feel more comfortable about the fact that we are still
producing messages with locations that could be considered to be *the wrong way
round*.</comment>
		<comment id="11" date="2004-08-11 09:36:58 EDT" author="Andrew Clement">Hi Wes,

Are you ok if we close this bug now - I've done as much as I currently plan to
do.  The original unhelpful warning no longer comes out.  You can download the
most recent development driver to test it out.

thanks,
Andy.</comment>
		<comment id="12" date="2004-08-11 12:40:40 EDT" author="Wes Isberg">Silence is consent!</comment>
		<comment id="13" date="2004-10-21 04:31:44 EDT" author="Adrian Colyer">Fix released as part of AspectJ 1.2.1</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="ef7885fd1269261aec9cb1265f0e15472fdb03bb" author="aclement" date="2004-08-03 11:53:38"/>
          <file name="tests/bugs/IncorrectXlintOnInterface.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/patterns/KindedPointcut.java">
              <method name="warnOnConfusingSig" returnType="void" parameters="Shadow"/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="61411" opendate="2004-5-7 12:00:00" fixdate="2004-05-28 11:34:23">
    <buginformation>
      <summary>AJDoc launch script on Windows can lose arguments</summary>
      <description>Using AspectJ 1.2rc1 on Windows XP

This report highlights a problem that I've seen using ajdoc.bat on Windows but
the issue applies equally to the ajc.bat and ajbrowser.bat files as well.

The %ASPECTJ_HOME%\bin\ajdoc.bat file that users run to launch the ajdoc tool
imposes a limit of only 9 command line arguments that may be passed to the
class org.aspectj.tools.ajdoc.Main. In scenarios where there the -sourcepath,
-classpath, -d etc options are used it is easy for these to "eat up" the list
of arguments that are passed into the JVM. A long list of packages entered
at the end of the ajdoc.bat command can be truncated or possibly even ignored
(in which case an error message will be output telling the user that no
classes or packages have been specified).

In order to prevent a limit being put on the number of arguments passed to
the launched JVM, the invocation line needs to end with %* rather than the
%1 %2 %3 %4 %5 %6 %7 %8 %9 list it currently uses.

The proposed fix also *seems* (could somebody else confirm this ?) to sort
out another problem regarding the ajdoc.bat file which is this : long semi-
colon delimited paths supplied as the arguments for the -sourcepath and 
-classpath options seem to get split apart and passed into the JVM as separate 
arguments unless the entire path list is supplied inside quotes. This should
not be necessary. It seems that the batch file processor interprets the
semi-colons in a path list as delimiters between arguments. Consequently
each element in the path list is treated as a separate argument instead
of being part of one big string representing the sourcepath or classpath.</description>
      <comments>
		<comment id="1" date="2004-05-07 12:49:45 EDT" author="George Harley">Created attachment 10400 [details]
One line change to include WinXP in the definition of a "new" Windows platform.

Will need a replacement build.jar to be built for lib/build .</comment>
		<comment id="2" date="2004-05-28 11:34:23 EDT" author="Andrew Clement">Fix checked in and verified.</comment>
		<comment id="3" date="2004-10-21 04:31:09 EDT" author="Adrian Colyer">Fix released as part of AspectJ 1.2.1</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="39c3a3bb4a0c939c1dfbc33b0ba560614b43d8a2" author="aclement" date="2004-05-29 12:19:14"/>
          <file name="build/src/$installer$/org/aspectj/Main.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="61536" opendate="2004-5-9 12:50:00" fixdate="2004-07-30 03:29:57">
    <buginformation>
      <summary>"Front-end bug, shouldn't allow patterns of the form foo.., should be foo..*"</summary>
      <description>See following code:

public class Test2 {
  public static void main(String args[])
    { System.out.println("Hi");
    }
}

aspect Aspect2 {
  // shouldn't one have to say,  java..* instead of java.. in the following??
  // Note that the first advice (incorrect one) passes the front-end, but does
  // not match,  whereas the second one does match.   I believe the front-end
  // should reject the first one.
  before () : call( * java..(..)) &amp;&amp; within(Test2)
    { System.out.println(
        "Incorrect One: Before a call of method in a java package ");
    }

  before () : call( * java..*(..)) &amp;&amp; within(Test2)
    { System.out.println(
        "Correct One: Before a call of method in a java package ");
    }
}</description>
      <comments>
		<comment id="1" date="2004-05-10 13:54:27 EDT" author="Jim Hugunin">Thanks for another clear bug report.  This is also a valid bug, but not a 
super serious one.  This should be fixed after the emminent 1.2 release.

This should be an easy bug to fix from the code in 
org.aspectj.weaver.patterns.PatternParser.  That's a fairly simple hand-coded 
LL(k) recursive decent parser for pointcut patterns.  Fixing this bug should 
be a straightforward process and completely contained within that single file.</comment>
		<comment id="2" date="2004-05-11 01:43:24 EDT" author="Laurie Hendren">I think this a potentially dangerous bug because I did find some old examples
or documentation around that seemed to use the form  java.. (sorry I don't
remember where I saw it).  

It is a minor bug to accept something like "java.." when the programmer
really means "java..*".  However, if it "java.." is silently accepted by the
front-end,  but not matched by the back-end (as my example bug report shows),
then I think it is more serious.

If it is simple to fix, I think you should fix it for 1.2.</comment>
		<comment id="3" date="2004-07-29 08:59:01 EDT" author="Andrew Clement">Fixed in CVS, waiting for build then I'll close the bug.

I also fixed the case of ending a name pattern with a '.' that isn't included in
the original bug report.  That is less common as you typically get a message
about not finding a type that matches.  (You now get a message saying its an
badly formed pattern).

Parser errors that can come out now include:

"name pattern cannot finish with .." 
                         
"name pattern cannot finish with ."</comment>
		<comment id="4" date="2004-07-30 03:29:57 EDT" author="Andrew Clement">Fixed in developer build available from our download page.

BUILD COMPLETE -  build.320
Date of build: 07/29/2004 17:22:44
Time to build: 120 minutes 38 seconds
Last changed: 07/29/2004 16:51:45
Latest good AspectJ jar available at: 
download.eclipse.org/technology/ajdt/dev/aspectj-DEVELOPMENT.jar</comment>
		<comment id="5" date="2004-10-21 04:31:58 EDT" author="Adrian Colyer">Fix released as part of AspectJ 1.2.1</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="45bce91f642a86ca3db7238d9e4cfb81d85e4f5b" author="aclement" date="2004-07-29 09:39:42"/>
          <file name="tests/bugs/EllipsesStar.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/patterns/PatternParser.java">
              <method name="parseDottedNamePattern" returnType="List" parameters=""/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="53999" opendate="2004-3-7 22:07:00" fixdate="2004-07-28 11:00:35">
    <buginformation>
      <summary>"""can't bind type"" message has $ for . in type name for declare soft"</summary>
      <description>cosmetic mistake in error message...

expected: can't bind type name 'unknown.Error'
  actual: can't bind type name 'unknown$Error'

(not sure why it would ever be munged with $)

public class Test {
	public static void main(String[] args) {
		test();
	}
	static void test() {
		throw new Error("hello");
	}
	static aspect A {
		declare soft : unknown.Error : call(void test()); // CE
	}
}</description>
      <comments>
		<comment id="1" date="2004-03-18 14:15:17 EST" author="Jim Hugunin">This error message is caused by first looking for a type Error in the unknown 
package and then looking for the inner type Error in the class unknown.  This 
second check uses the binary format for inner type names of unknown$Error.

I'm leaving as a bug until the cosmetic error is fixed.</comment>
		<comment id="2" date="2004-07-27 09:28:38 EDT" author="Andrew Clement">fix integrated - waiting for build.</comment>
		<comment id="3" date="2004-07-28 11:00:35 EDT" author="Andrew Clement">Fixed as of:

BUILD COMPLETE -  build.317
Date of build: 07/28/2004 12:16:33
Time to build: 121 minutes 44 seconds
Last changed: 07/27/2004 18:38:25
Latest good AspectJ jar available at:
download.eclipse.org/technology/ajdt/dev/aspectj-DEVELOPMENT.jar</comment>
		<comment id="4" date="2004-10-21 04:31:17 EDT" author="Adrian Colyer">Fix released as part of AspectJ 1.2.1</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="936459c28229321deb0b09d076193be32cd9754e" author="aclement" date="2004-07-27 07:34:41"/>
          <file name="tests/bugs/Cosmetic.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java">
              <method name="resolveBindings" returnType="TypePattern" parameters="IScope Bindings boolean boolean"/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="65319" opendate="2004-6-2 10:29:00" fixdate="2004-08-11 03:25:47">
    <buginformation>
      <summary>ajc crashes when compiling the following program (binding this() and target())</summary>
      <description>class Test
{  
	public static void main(String args[])
	{		
		new Test().method();
	}
	public void method()
	{
		new Test2().method2();
	}
}
class Test2 {
	public void method2() {}
}
aspect Plain {
	before(Test x):  call(void *.* (..)) &amp;&amp; (this(x) || target(x))
	{
	}
}</description>
      <comments>
		<comment id="1" date="2004-08-09 12:35:19 EDT" author="Andrew Clement">For this bug I propose the same solution we used for args() (bug 61568) which
will make this a proper compile time error.  Fundamentally we are saying that
you aren't allowed to bind more than once to a formal - this doesn't seem *too*
unreasonable.

Current proposal for the message is:

C:\temp\ajcSandbox\ajcTest16749.tmp\PR65319.java:9:0 
  Cannot use target() to match at this location and bind a formal to type
'Test2' - the formal is already bound to type 'Test'.  The secondary source
location points to the problematic target().
 see also: C:\temp\ajcSandbox\ajcTest16749.tmp\PR65319.java:16

If there is a compelling use case we could look at perhaps supporting this
properly, but without one we'll stick to outputting an error.</comment>
		<comment id="2" date="2004-08-10 12:25:30 EDT" author="Andrew Clement">Proposed fix checked in.  Message isn't great but its better than a crash at
weave time.</comment>
		<comment id="3" date="2004-08-11 03:25:47 EDT" author="Andrew Clement">Fix available in:

BUILD COMPLETE -  build.334
Date of build: 08/10/2004 18:17:11
Time to build: 92 minutes 34 seconds
Last changed: 08/10/2004 17:33:42
Latest good AspectJ jar available at:
download.eclipse.org/technology/ajdt/dev/aspectj-DEVELOPMENT.jar</comment>
		<comment id="4" date="2004-10-21 04:31:59 EDT" author="Adrian Colyer">Fix released as part of AspectJ 1.2.1</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="b75cd93e0de66996397e9f18809973abec91fe46" author="aclement" date="2004-08-11 01:22:01"/>
          <file name="tests/bugs/oxford/PR65319.java">
          </file>
          <file name="tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java">
              <method name="getAdviceArgSetup" returnType="InstructionList" parameters="BcelShadow BcelVar InstructionList"/>
          </file>
          <file name="weaver/src/org/aspectj/weaver/patterns/ArgsPointcut.java">
              <method name="findResidueNoEllipsis" returnType="Test" parameters="Shadow ExposedState TypePattern[]"/>
          </file>
          <file name="weaver/src/org/aspectj/weaver/patterns/ExposedState.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/patterns/ThisOrTargetPointcut.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="68991" opendate="2004-6-30 7:51:00" fixdate="2004-08-12 03:11:14">
    <buginformation>
      <summary>intertype initialisers should match field set pointcuts</summary>
      <description>/* initialisers of intertype fields should match field set pointcuts.

   In the example below, the output should be

set field set(int C.n)
set field set(int C.m)
get field get(int C.n)
set field set(int C.n)

   but the first field set (of C.n) is not picked up.
*/



aspect Aspect {

    private int C.n = 13;

    before() : get(* C.*) {
	System.out.println("get field "+thisJoinPointStaticPart);
    }

    before() : set(* C.*)  {
	System.out.println("set field "+thisJoinPointStaticPart);
    }

    public void C.foo() {
	n++;
    }

}

class C {
    int m = 20;
}

public class ITFieldsAdvice {

    public static void main(String[] args) {
	C c = new C();
	c.foo();
    }

}</description>
      <comments>
		<comment id="1" date="2004-08-09 15:28:19 EDT" author="Adrian Colyer">marked as target 1.2.1</comment>
		<comment id="2" date="2004-08-11 08:54:24 EDT" author="Andrew Clement">Fix checked in, waiting for build.

Some AspectJ facts.

- When the ITD is a private ITD, the field generated has a 'special' "ajc$XXX" name.

- *No* ajc$XXX field references are considered join points.

- Join points for references to these fields are surfaced as follows.  Each
field has a set and a get dispatcher method generated.  These methods are tagged
with the 'effective signature' attribute of a FIELD_GET or FIELD_SET shadow. 
This means when a call to the dispatcher method is found in the code, it is
matched upon as if it was a field get or set join point.

- When ITD field initializers are generated, they normally directly set the
named field.  Field initializer methods are *not* tagged with the effective
signature attribute.

The fix is to change the body of the generated field initializer so that it
delegates to the field set dispatcher method - the call to this method will
ensure the right field set join point surfaces for the match.</comment>
		<comment id="3" date="2004-08-12 03:11:14 EDT" author="Andrew Clement">Fix available now:

BUILD COMPLETE -  build.337
Date of build: 08/11/2004 17:19:19
Time to build: 91 minutes 45 seconds
Last changed: 08/11/2004 14:18:49
Latest good AspectJ jar available at:
download.eclipse.org/technology/ajdt/dev/aspectj-DEVELOPMENT.jar</comment>
		<comment id="4" date="2004-10-21 04:31:41 EDT" author="Adrian Colyer">Fix released as part of AspectJ 1.2.1</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="64183c38266114bce7aa60ff743b4b9eda5cbe2d" author="aclement" date="2004-08-11 09:24:27"/>
          <file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/InterTypeFieldDeclaration.java">
              <method name="resolve" returnType="void" parameters="ClassScope"/>
          </file>
          <file name="tests/bugs/PR68991/Oxford.java">
          </file>
          <file name="tests/bugs/PR68991/Simple.java">
          </file>
          <file name="tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="69011" opendate="2004-6-30 10:22:00" fixdate="2004-07-05 14:16:48">
    <buginformation>
      <summary>ajdoc fails when using default package</summary>
      <description>When trying to document classes that are in the default package, the following 
error occurs:

&gt; Calling ajc...
&gt; Building signature files...
&gt; Calling javadoc...
Loading source file C:\eclipse_RC3\eclipse\ajdocworkingdir\A.java...
C:\eclipse_RC3\eclipse\ajdocworkingdir\A.java:1: &lt;identifier&gt; expected
package ;
        ^
1 error
&gt; Decorating html files...
&gt; Decorating C:\doc\classX.html...
An internal error occured in ajdoc
Please copy the following text into an email message and send it,
along with any additional information you can add to:            
                                                                 
       aspectj-dev@eclipse.org                           
                                                                 

java.io.FileNotFoundException: C:\doc\classX.html (The system cannot find the 
file specified)
java.io.FileNotFoundException: C:\doc\classX.html (The system cannot find the 
file specified)
	at java.io.FileInputStream.open(Native Method)
	at java.io.FileInputStream.&lt;init&gt;(FileInputStream.java:106)
	at java.io.FileReader.&lt;init&gt;(FileReader.java:55)
	at org.aspectj.tools.ajdoc.HtmlDecorator.decorateHTMLFile(HtmlDecorator.java:142)
	at org.aspectj.tools.ajdoc.HtmlDecorator.decorateHTMLFromDecl(HtmlDecorator.java:115)
	at org.aspectj.tools.ajdoc.HtmlDecorator.decorateHTMLFromDecls(HtmlDecorator.java:54)
	at org.aspectj.tools.ajdoc.HtmlDecorator.decorateHTMLFromInputFiles(HtmlDecorator.java:43)
	at org.aspectj.tools.ajdoc.Main.main(Main.java:210)</description>
      <comments>
		<comment id="1" date="2004-07-05 14:16:48 EDT" author="Mik Kersten">Fixed.  The problem was in the generation of the stub files, which created an 
improper package declaration for compilation units in the default package.

org.aspectj.tools.ajdoc/CoverageTestCase.java has been expanded to test for 
this.</comment>
		<comment id="2" date="2004-10-21 04:31:15 EDT" author="Adrian Colyer">Fix released as part of AspectJ 1.2.1</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="2cc4826419d8c08e3879e600b82354fac2596241" author="mkersten" date="2004-07-06 03:19:15"/>
          <file name="ajdoc/src/org/aspectj/tools/ajdoc/StubFileGenerator.java">
              <method name="processFile" returnType="void" parameters="SymbolManager File File"/>
          </file>
          <file name="ajdoc/testdata/coverage/InDefaultPackage.java">
          </file>
          <file name="ajdoc/testsrc/org/aspectj/tools/ajdoc/CoverageTestCase.java">
              <method name="testCoverage" returnType="void" parameters=""/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="46298" opendate="2003-11-7 14:40:00" fixdate="2004-09-07 09:41:27">
    <buginformation>
      <summary>Aspectj generate code does not de-compile cleanly.</summary>
      <description>Under certain condition you can not cleanly decompile code generated by the 
aspectj compiler/byte code weaver.

package com.regular;

public class ExceptionCatcher
{
	public ExceptionCatcher()
	{
		super();
	}
	
	public void catchException()
	{
		try
		{
			ExceptionThrower throwUp = new ExceptionThrower();
			throwUp.throwException();
		}
		catch(Exception e)
		{
			System.out.println("Inside my catch block");
		}
	}
	
	public static void main(String[] args)
	{
		ExceptionCatcher catcher = new ExceptionCatcher();
		catcher.catchException();	
	}
}

package com.aop;

import org.aspectj.lang.JoinPoint;

public aspect ExceptionHandler
{
	pointcut classList() : 
		within(com.regular..*);
	
	before(Throwable e) : 
		classList() 
		&amp;&amp; handler(*)
		&amp;&amp; args(e)
	{
		System.out.println("Starting before block");
		log(thisJoinPointStaticPart, e);
		System.out.println("End of before block");
	}
		
	private void log(JoinPoint.StaticPart jp, Throwable e)
	{
		System.out.println("Class Name: " + jp.getSignature
().getDeclaringType());
		System.out.println("Error Message" + e.getMessage() );
	}
}

Runing JAD:

jad ExceptionCatcher.class
Parsing ExceptionCatcher.class... Generating ExceptionCatcher.jad
Couldn't fully decompile method catchException
Couldn't resolve all exception handlers in method catchException

Now the JAD Output:

// Decompiled by Jad v1.5.7. Copyright 1997-99 Pavel Kouznetsov.
// Jad home page: http://www.geocities.com/SiliconValley/Bridge/8617/jad.html
// Decompiler options: packimports(3) 
// Source File Name:   ExceptionCatcher.java

package com.regular;

import com.aop.ExceptionHandler;
import com.capitalone.risk.aop.ITestInterface;
import com.capitalone.risk.aop.ITestInterfaceAspect;
import java.io.PrintStream;
import org.aspectj.runtime.reflect.Factory;

// Referenced classes of package com.regular:
//            ExceptionThrower

public class ExceptionCatcher
    implements com.aop.IntroductionPointCut.IPhilipsTarget
{

    public ExceptionCatcher()
    {
    }

    public void catchException()
    {
        if(this instanceof ITestInterface)
            ITestInterfaceAspect.aspectOf
().ajc$before$com_capitalone_risk_aop_ITestInterfaceAspect$113((ITestInterface)
this);
        ExceptionThrower throwUp = new ExceptionThrower();
        throwUp.throwException();
        break MISSING_BLOCK_LABEL_77;
        Exception exception;
        exception;
        ExceptionHandler.aspectOf().ajc$before$com_aop_ExceptionHandler$1f8
(exception, ajc$tjp_0);
        Exception e = exception;
        System.out.println("Inside my catch block");
        break MISSING_BLOCK_LABEL_77;
        Throwable throwable;
        throwable;
        if(this instanceof ITestInterface)
            ITestInterfaceAspect.aspectOf
().ajc$after$com_capitalone_risk_aop_ITestInterfaceAspect$172((ITestInterface)
this);
        throw throwable;
        if(this instanceof ITestInterface)
            ITestInterfaceAspect.aspectOf
().ajc$after$com_capitalone_risk_aop_ITestInterfaceAspect$172((ITestInterface)
this);
        return;
    }

    public static void main(String args[])
    {
        ExceptionCatcher catcher = new ExceptionCatcher();
        catcher.catchException();
    }

    public static final org.aspectj.lang.JoinPoint.StaticPart ajc$tjp_0;

    static 
    {
        Factory factory = new Factory("ExceptionCatcher.java", Class.forName
("com.regular.ExceptionCatcher"));
        ajc$tjp_0 = factory.makeSJP("exception-handler", 
factory.makeCatchClauseSig("0--com.regular.ExceptionCatcher-
java.lang.Exception-&lt;missing&gt;-"), 33);
    }
}

The aspect class:

jad ExceptionHandler.class
Parsing ExceptionHandler.class... Generating ExceptionHandler.jad
Couldn't fully decompile method aspectOf

// Decompiled by Jad v1.5.7. Copyright 1997-99 Pavel Kouznetsov.
// Jad home page: http://www.geocities.com/SiliconValley/Bridge/8617/jad.html
// Decompiler options: packimports(3) 
// Source File Name:   ExceptionHandler.java

package com.aop;

import java.io.PrintStream;
import org.aspectj.lang.NoAspectBoundException;
import org.aspectj.lang.Signature;

public class ExceptionHandler
{

    public ExceptionHandler()
    {
    }

    public void ajc$before$com_aop_ExceptionHandler$1f8(Throwable e, 
org.aspectj.lang.JoinPoint.StaticPart thisJoinPointStaticPart)
    {
        System.out.println("Starting before block");
        log(thisJoinPointStaticPart, e);
        System.out.println("End of before block");
    }

    private void log(org.aspectj.lang.JoinPoint.StaticPart jp, Throwable e)
    {
        System.out.println("Class Name: " + jp.getSignature().getDeclaringType
());
        System.out.println("Error Message" + e.getMessage());
    }

    public static ExceptionHandler aspectOf()
    {
        ajc$perSingletonInstance;
        JVM INSTR dup ;
        JVM INSTR ifnull 8;
           goto _L1 _L2
_L1:
        return;
_L2:
        throw new NoAspectBoundException();
    }

    public static boolean hasAspect()
    {
        return ajc$perSingletonInstance != null;
    }

    private static void ajc$postClinit()
    {
        ajc$perSingletonInstance = new ExceptionHandler();
    }

    public static final ExceptionHandler ajc$perSingletonInstance;

    static 
    {
        ajc$postClinit();
    }
}

Enjoy!

Ron</description>
      <comments>
		<comment id="1" date="2003-11-07 14:43:15 EST" author="Ronald R. DiFRango">Created attachment 6699 [details]
Source to re-produce problem.</comment>
		<comment id="2" date="2003-11-07 14:43:35 EST" author="Ronald R. DiFRango">Created attachment 6700 [details]
Source to re-prodcue problem.</comment>
		<comment id="3" date="2003-11-07 14:44:12 EST" author="Ronald R. DiFRango">Created attachment 6701 [details]
Decompiled output.</comment>
		<comment id="4" date="2003-11-07 14:44:51 EST" author="Ronald R. DiFRango">Created attachment 6702 [details]
Decompiled output.</comment>
		<comment id="5" date="2003-12-08 09:09:00 EST" author="Adrian Colyer">Adding this to 1.2 plan as a placeholder to spend some effort to see what we can 
do if anything to improve existing decompiler toleration of ajc generated code.

The long term solution is to build an AspectJ decompiler. This is not currently 
in plan (and wouldn't actually help Ron here since I recall from discussion that 
the reason for decompiling is to understand what ajc is generating, and an 
AspectJ decompiler should decompile back to AspectJ source).</comment>
		<comment id="6" date="2004-03-16 05:08:33 EST" author="Adrian Colyer">Anywhere we generate handlers, we need the load/store combo to keep the 
decompilers happy (see the JRocket fix)...</comment>
		<comment id="7" date="2004-03-16 11:34:18 EST" author="Andrew Clement">Yuck, this is a nasty problem - nastier than the JRockit issue as it isnt 
really related to *generating* new handlers so much as instrumenting existing 
ones.  Help, jim, can you tell me what you think about this...

Here is what I have found.

Here is a simple version of Rons code that shows the problem:

class ExceptionCatcher {

  RuntimeException re = new RuntimeException();

  public void catchException() {
    try {
      throw re;
    } catch (Exception e) { }
  }
 
  public static void main(String[] args) {
    new ExceptionCatcher().catchException();
  }
}

aspect ExceptionHandler {
  before(): handler(*) {
    System.out.println("Starting before block");
  }
}

If I compile this, I am basically adding advice to the start of the catch 
block.  If I jad the resulting ExceptionCatcher then it fails as Ron 
describes.  A javap -c ExceptionCatcher reports:

public void catchException();
  Code:
   0:   aload_0
   1:   getfield        #16; //Field re:Ljava/lang/RuntimeException;
   4:   athrow
   5:   nop
   6:   invokestatic    #38; //Method ExceptionHandler.aspectOf:()
LExceptionHandler;
   9:   invokevirtual   #41; //Method 
ExceptionHandler.ajc$before$ExceptionHandler$1$768387dd:()V
   12:  pop
   13:  return
  Exception table:
   from   to  target type
     0     5     5   Class java/lang/Exception

Notice where the 'pop' instruction is.

Now, if I try and create a piece of Java that simulates what ajc is doing:


class ExceptionCatcher {

  RuntimeException re = new RuntimeException();

  public void catchException() {
    try {
      throw re;
    } catch (Exception e) { 
      ExceptionHandler.aspectOf().ajc$before$ExceptionHandler$1$768387dd();
    }
  }
 
  public static void main(String[] args) {
    new ExceptionCatcher().catchException();
  }
}

And then I compile that with ajc (no aspect is included in the compilation 
step), then I get a new version of ExceptionCatcher that jads successfully.  
The bytecode is:
public void catchException();
  Code:
   0:   aload_0
   1:   getfield        #16; //Field re:Ljava/lang/RuntimeException;
   4:   athrow
   5:   pop
   6:   invokestatic    #27; //Method ExceptionHandler.aspectOf:()
LExceptionHandler;
   9:   invokevirtual   #30; //Method 
ExceptionHandler.ajc$before$ExceptionHandler$1$768387dd:()V
   12:  return
  Exception table:
   from   to  target type
     0     5     5   Class java/lang/Exception

Notice that the pop instruction in this case is before the call to the aspect 
method.

I had originally thought the fix might be to move the shadow start point for 
the handler by one instruction (over the pop) but that causes a bit of a mess 
in the harness tests.</comment>
		<comment id="8" date="2004-03-16 15:12:21 EST" author="Andrew Clement">Right, some progress - I think I can see that the method I'm interested in is 
BcelShadow.prepareForMungers() which messes with the exception handler code, 
inserting the NOP amongst other things.</comment>
		<comment id="9" date="2004-03-24 16:56:57 EST" author="Andrew Clement">After Miks demo earlier today at AOSD, I asked Erik what he thought about this 
bug.  He said:

proposed fix:

AspectJ should pattern match between 

START OF HANDLER
pop

START OF HANDLER
push

if we expose the exception, we need to delete the pop if it's there
if we don't, we should just insert code _after_ the pop.
=====
I *hope* to get this in before 1.2 final.</comment>
		<comment id="10" date="2004-04-01 11:43:15 EST" author="Andrew Clement">This turns out to be more complicated ... as these things do.

prepareForMungers() looks at the shape of the handler and inserts a NOP (I 
assume to use as the shadow to munge).  I can adjust prepareForMungers() to 
insert the NOP after the POP (using what Erik described and optionally 
including the POP instruction when identifying a handler join point).  But if 
I do that then at the point we do the munging, I need to perhaps delete the 
POP depending on whether the exception is being used in the advice being 
woven.  I can determine if the exception is being used, but deleting the POP 
seems tricky.  At the point we do the munging the start of the shadow is the 
NOP, and jumping to a previous instruction seems to move me outside of the 
shadow - and I don't think I want to start affecting code 'surrounding' the 
shadow ??  </comment>
		<comment id="11" date="2004-04-04 20:57:59 EDT" author="Jim Hugunin">I don't have a decompiler to play with, so all of these suggestions are 
untested.  You should be careful fixing this bug as the last thing we want is 
to generate truly invalid bytecode just to make broken decompilers happier.

The first thing that I'd try is to call initializeArgVars() at the end of 
the "else if (getKind() == ExceptionHandler) {" block in prepareForMungers().  
This call will force the use of a frame slot to hold the exception value and 
the added store instruction will mean that the value isn't kept on the stack 
during the advice.

After doing this, you'll still have an ALOAD/POP combo just outside the shadow 
for cases where the exception isn't used in the original handler.  If this 
still bothers the decompiler, you can try to remove it at the end of 
prepareMungers().  At the end of that method there's a block for "if (getKind
().argsOnStack() &amp;&amp; argVars != null) {".  You could add a special case to the 
beginning of this block to check for an ExceptionHandler shadow type AND a 
first instruction outside the shadow that's a POP.  In that case you want to 
remove the POP and NOT generate the args.</comment>
		<comment id="12" date="2004-09-01 11:31:54 EDT" author="Andrew Clement">Ok - I've implemented a fix based around what Jim was suggesting.  (I must say
this seemed easier to do having 3 months more compiler experience than when I
last posted on the bug!).  All changes in BcelShadow.prepareForMungers()

We currently shove in a 'NOP' when preparing an exception handler for munging. 
This is to give us an anchor when we insert extra instructions that expose
context for use in the advice.  This confuses the decompiler as it wants to
either see a POP or an ASTORE as the first instruction in the handler code.  So
I've removed the NOP and made it always do a STORE to stick the stack contents
into a local variable - which we may or may not use the value of.  Effectively
where we were optionally storing the value on the stack (the caught exception),
we now always store it but may not use it.

Once the STORE is in the right place we rework the exception ranges to include
our new instruction. (They need to point to it rather than to the instruction
after it).

The other piece of the fix is to repair the stack as we exit the handler. 
Normally we stick in an ALOAD after the advice so the stack is ready for use by
the actual code originally written in the catch block.  However, in the case we
are looking at here, the first instruction in the real catch block is a POP as
the exception is never used.  It is redundant to generate an ALOAD and then
execute a POP - and it confuses decompilers.  So in the case where we have done
this clever ASTORE business (i.e. we are a handler shadow), we check if the next
instruction is a POP.  if it is then we don't generate the ALOAD and splat the
POP with a NOP (easier to replace the POP than remove it with all the targeter
management that would be involved).

If we now compile the sample program:

class ExceptionCatcher {

  RuntimeException re = new RuntimeException();

  public void catchException() {
    try {
      throw re;
    } catch (Exception e) { }
  }
 
  public static void main(String[] args) {
    new ExceptionCatcher().catchException();
  }
}

aspect ExceptionHandler {
  before(): handler(*) {
    System.out.println("Starting before block");
  }
}

We get this bytecode:

public void catchException();
  org.aspectj.weaver.MethodDeclarationLineNumber: length = 0x4
   00 00 00 05
  Code:
   Stack=1, Locals=2, Args_size=1
   0:   aload_0
   1:   getfield        #16; //Field re:Ljava/lang/RuntimeException;
   4:   athrow
   5:   astore_1
   6:   invokestatic    #39; //Method ExceptionHandler.aspectOf:()LExceptionHandler;
   9:   invokevirtual   #42; //Method
ExceptionHandler.ajc$before$ExceptionHandler$1$768387dd:()V
   12:  nop
   13:  return
  Exception table:
   from   to  target type
     0     5     5   Class java/lang/Exception

At instruction #5 you can see the new ASTORE_1. 
At instruction #12 you can see where we replaced the POP with a NOP.
In the exception table you can see the target is our new ASTORE_1.

And it decompiles just fine.

(I also fixed the common singleton version of the aspectOf() method so that it
decompiles cleanly - I haven't investigated decompilation of the variants of
this method created when using per clauses)

I'll close the bug when the fix is available.</comment>
		<comment id="13" date="2004-09-07 09:41:27 EDT" author="Andrew Clement">Fix available:

BUILD COMPLETE -  build.371
Date of build: 09/07/2004 12:33:43
Time to build: 101 minutes 39 seconds
Last changed: 09/07/2004 11:47:45
Latest good AspectJ jar available at:
download.eclipse.org/technology/ajdt/dev/aspectj-DEVELOPMENT.jar</comment>
		<comment id="14" date="2004-10-21 04:31:37 EDT" author="Adrian Colyer">Fix released as part of AspectJ 1.2.1</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="4921f0c8f03353385d709bc79a7dd301c2caa5df" author="aclement" date="2004-09-02 12:26:43"/>
          <file name="weaver/src/org/aspectj/weaver/bcel/BcelShadow.java">
              <method name="prepareForMungers" returnType="void" parameters=""/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="70773" opendate="2004-7-23 21:07:00" fixdate="2004-08-03 06:14:43">
    <buginformation>
      <summary>AspectJ Error: ConncurrentModificationException thrown: null</summary>
      <description>In AspectJ 1.1.11 for Eclipse, build ID 1.2.0 (and also in the previous 1.1.10)
on Eclipse version 3.0.0, build ID 200406351208: If I enable incremental
compilation and make a change to a file (typing a space and deleting it, or
editing a comment), I get a "ConncurrentModificationException thrown: null" error.</description>
      <comments>
		<comment id="1" date="2004-07-23 21:17:05 EDT" author="Macneil Shonle">More information:

Internal compiler error
java.util.ConcurrentModificationException

 at java.util.AbstractList$Itr.checkForComodification(AbstractList.java:444)

 at java.util.AbstractList$Itr.next(AbstractList.java:421)

 at
org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.createBinaryTypeFrom(AjLookupEnvironment.java:465)

 at
org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.createBinaryTypeFrom(LookupEnvironment.java:299)

 at org.eclipse.jdt.internal.compiler.Compiler.accept(Compiler.java:208)

 at
org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.askForType(LookupEnvironment.java:111)

 at
org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.getType(LookupEnvironment.java:445)

 at
org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.makeTypeBinding1(EclipseFactory.java:249)

 at
org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.makeTypeBinding(EclipseFactory.java:218)

 at
org.aspectj.ajdt.internal.compiler.lookup.InterTypeMethodBinding.&lt;init&gt;(InterTypeMethodBinding.java:43)

 at
org.aspectj.ajdt.internal.compiler.lookup.EclipseTypeMunger.mungeNewMethod(EclipseTypeMunger.java:95)

 at
org.aspectj.ajdt.internal.compiler.lookup.EclipseTypeMunger.munge(EclipseTypeMunger.java:79)

 at
org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.weaveInterTypeDeclarations(AjLookupEnvironment.java:277)

 at
org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.weaveInterTypeDeclarations(AjLookupEnvironment.java:261)

 at
org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.createBinaryTypeFrom(AjLookupEnvironment.java:465)

 at
org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.createBinaryTypeFrom(LookupEnvironment.java:299)

 at org.eclipse.jdt.internal.compiler.Compiler.accept(Compiler.java:208)

 at
org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.askForType(LookupEnvironment.java:85)

 at
org.eclipse.jdt.internal.compiler.lookup.UnresolvedReferenceBinding.resolve(UnresolvedReferenceBinding.java:30)

 at
org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.getType(LookupEnvironment.java:451)

 at
org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.makeTypeBinding1(EclipseFactory.java:249)

 at
org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.makeTypeBinding(EclipseFactory.java:218)

 at
org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.makeTypeBindings(EclipseFactory.java:260)

 at
org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.makeMethodBinding(EclipseFactory.java:287)

 at
org.aspectj.ajdt.internal.compiler.lookup.InterTypeMethodBinding.&lt;init&gt;(InterTypeMethodBinding.java:39)

 at
org.aspectj.ajdt.internal.compiler.lookup.EclipseTypeMunger.mungeNewMethod(EclipseTypeMunger.java:95)

 at
org.aspectj.ajdt.internal.compiler.lookup.EclipseTypeMunger.munge(EclipseTypeMunger.java:79)

 at
org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.weaveInterTypeDeclarations(AjLookupEnvironment.java:277)

 at
org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.weaveInterTypeDeclarations(AjLookupEnvironment.java:261)

 at
org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.createBinaryTypeFrom(AjLookupEnvironment.java:465)

 at
org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.createBinaryTypeFrom(LookupEnvironment.java:299)

 at org.eclipse.jdt.internal.compiler.Compiler.accept(Compiler.java:208)

 at
org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.askForType(LookupEnvironment.java:111)

 at
org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.getType(LookupEnvironment.java:445)

 at
org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.makeTypeBinding1(EclipseFactory.java:249)

 at
org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.makeTypeBinding(EclipseFactory.java:218)

 at
org.aspectj.ajdt.internal.compiler.lookup.InterTypeMethodBinding.&lt;init&gt;(InterTypeMethodBinding.java:43)

 at
org.aspectj.ajdt.internal.compiler.lookup.EclipseTypeMunger.mungeNewMethod(EclipseTypeMunger.java:95)

 at
org.aspectj.ajdt.internal.compiler.lookup.EclipseTypeMunger.munge(EclipseTypeMunger.java:79)

 at
org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.weaveInterTypeDeclarations(AjLookupEnvironment.java:277)

 at
org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.weaveInterTypeDeclarations(AjLookupEnvironment.java:261)

 at
org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.createBinaryTypeFrom(AjLookupEnvironment.java:465)

 at
org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.createBinaryTypeFrom(LookupEnvironment.java:299)

 at org.eclipse.jdt.internal.compiler.Compiler.accept(Compiler.java:208)

 at
org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.askForType(LookupEnvironment.java:111)

 at
org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.getType(LookupEnvironment.java:445)

 at
org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.makeTypeBinding1(EclipseFactory.java:249)

 at
org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.makeTypeBinding(EclipseFactory.java:218)

 at
org.aspectj.ajdt.internal.compiler.lookup.InterTypeFieldBinding.&lt;init&gt;(InterTypeFieldBinding.java:41)

 at
org.aspectj.ajdt.internal.compiler.lookup.EclipseTypeMunger.mungeNewField(EclipseTypeMunger.java:120)

 at
org.aspectj.ajdt.internal.compiler.lookup.EclipseTypeMunger.munge(EclipseTypeMunger.java:77)

 at
org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.weaveInterTypeDeclarations(AjLookupEnvironment.java:277)

 at
org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.weaveInterTypeDeclarations(AjLookupEnvironment.java:261)

 at
org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.createBinaryTypeFrom(AjLookupEnvironment.java:465)

 at
org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.createBinaryTypeFrom(LookupEnvironment.java:299)

 at org.eclipse.jdt.internal.compiler.Compiler.accept(Compiler.java:208)

 at
org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.askForType(LookupEnvironment.java:111)

 at
org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.getType(LookupEnvironment.java:445)

 at
org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.makeTypeBinding1(EclipseFactory.java:249)

 at
org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.makeTypeBinding(EclipseFactory.java:218)

 at
org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.makeFieldBinding(EclipseFactory.java:278)

 at
org.aspectj.ajdt.internal.compiler.lookup.InterTypeFieldBinding.&lt;init&gt;(InterTypeFieldBinding.java:37)

 at
org.aspectj.ajdt.internal.compiler.lookup.EclipseTypeMunger.mungeNewField(EclipseTypeMunger.java:120)

 at
org.aspectj.ajdt.internal.compiler.lookup.EclipseTypeMunger.munge(EclipseTypeMunger.java:77)

 at
org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.weaveInterTypeDeclarations(AjLookupEnvironment.java:277)

 at
org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.weaveInterTypeDeclarations(AjLookupEnvironment.java:261)

 at
org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.createBinaryTypeFrom(AjLookupEnvironment.java:465)

 at
org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.createBinaryTypeFrom(LookupEnvironment.java:299)

 at org.eclipse.jdt.internal.compiler.Compiler.accept(Compiler.java:208)

 at
org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.askForType(LookupEnvironment.java:85)

 at
org.eclipse.jdt.internal.compiler.lookup.UnresolvedReferenceBinding.resolve(UnresolvedReferenceBinding.java:30)

 at
org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.getType(LookupEnvironment.java:451)

 at
org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.makeTypeBinding1(EclipseFactory.java:249)

 at
org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.makeTypeBinding(EclipseFactory.java:218)

 at
org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.makeFieldBinding(EclipseFactory.java:278)

 at
org.aspectj.ajdt.internal.compiler.lookup.InterTypeFieldBinding.&lt;init&gt;(InterTypeFieldBinding.java:37)

 at
org.aspectj.ajdt.internal.compiler.lookup.EclipseTypeMunger.mungeNewField(EclipseTypeMunger.java:120)

 at
org.aspectj.ajdt.internal.compiler.lookup.EclipseTypeMunger.munge(EclipseTypeMunger.java:77)

 at
org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.weaveInterTypeDeclarations(AjLookupEnvironment.java:277)

 at
org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.weaveInterTypeDeclarations(AjLookupEnvironment.java:261)

 at
org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.createBinaryTypeFrom(AjLookupEnvironment.java:465)

 at
org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.createBinaryTypeFrom(LookupEnvironment.java:299)

 at org.eclipse.jdt.internal.compiler.Compiler.accept(Compiler.java:208)

 at
org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.askForType(LookupEnvironment.java:111)

 at
org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.getType(LookupEnvironment.java:445)

 at
org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.makeTypeBinding1(EclipseFactory.java:249)

 at
org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.makeTypeBinding(EclipseFactory.java:218)

 at
org.aspectj.ajdt.internal.compiler.lookup.InterTypeFieldBinding.&lt;init&gt;(InterTypeFieldBinding.java:41)

 at
org.aspectj.ajdt.internal.compiler.lookup.EclipseTypeMunger.mungeNewField(EclipseTypeMunger.java:120)

 at
org.aspectj.ajdt.internal.compiler.lookup.EclipseTypeMunger.munge(EclipseTypeMunger.java:77)

 at
org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.weaveInterTypeDeclarations(AjLookupEnvironment.java:277)

 at
org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.weaveInterTypeDeclarations(AjLookupEnvironment.java:261)

 at
org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.createBinaryTypeFrom(AjLookupEnvironment.java:465)

 at
org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.createBinaryTypeFrom(LookupEnvironment.java:299)

 at org.eclipse.jdt.internal.compiler.Compiler.accept(Compiler.java:208)

 at
org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.askForType(LookupEnvironment.java:85)

 at
org.eclipse.jdt.internal.compiler.lookup.UnresolvedReferenceBinding.resolve(UnresolvedReferenceBinding.java:30)

 at
org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.getType(LookupEnvironment.java:451)

 at
org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.makeTypeBinding1(EclipseFactory.java:249)

 at
org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.makeTypeBinding(EclipseFactory.java:218)

 at
org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.makeFieldBinding(EclipseFactory.java:278)

 at
org.aspectj.ajdt.internal.compiler.lookup.InterTypeFieldBinding.&lt;init&gt;(InterTypeFieldBinding.java:37)

 at
org.aspectj.ajdt.internal.compiler.lookup.EclipseTypeMunger.mungeNewField(EclipseTypeMunger.java:120)

 at
org.aspectj.ajdt.internal.compiler.lookup.EclipseTypeMunger.munge(EclipseTypeMunger.java:77)

 at
org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.weaveInterTypeDeclarations(AjLookupEnvironment.java:277)

 at
org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.weaveInterTypeDeclarations(AjLookupEnvironment.java:261)

 at
org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.createBinaryTypeFrom(AjLookupEnvironment.java:465)

 at
org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.createBinaryTypeFrom(LookupEnvironment.java:299)

 at org.eclipse.jdt.internal.compiler.Compiler.accept(Compiler.java:208)

 at
org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.askForType(LookupEnvironment.java:111)

 at
org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.getType(LookupEnvironment.java:445)

 at
org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.makeTypeBinding1(EclipseFactory.java:249)

 at
org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.makeTypeBinding(EclipseFactory.java:218)

 at
org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.makeFieldBinding(EclipseFactory.java:278)

 at
org.aspectj.ajdt.internal.compiler.lookup.InterTypeFieldBinding.&lt;init&gt;(InterTypeFieldBinding.java:37)

 at
org.aspectj.ajdt.internal.compiler.lookup.EclipseTypeMunger.mungeNewField(EclipseTypeMunger.java:120)

 at
org.aspectj.ajdt.internal.compiler.lookup.EclipseTypeMunger.munge(EclipseTypeMunger.java:77)

 at
org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.weaveInterTypeDeclarations(AjLookupEnvironment.java:335)

 at
org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.weaveInterTypeDeclarations(AjLookupEnvironment.java:253)

 at
org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.completeTypeBindings(AjLookupEnvironment.java:127)

 at org.eclipse.jdt.internal.compiler.Compiler.beginToCompile(Compiler.java:324)

 at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:341)

 at
org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:717)

 at
org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:193)

 at
org.aspectj.ajdt.internal.core.builder.AjBuildManager.incrementalBuild(AjBuildManager.java:107)

 at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:103)

 at
org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:169)</comment>
		<comment id="2" date="2004-07-24 21:53:18 EDT" author="Macneil Shonle">Update, this happens with the command line AJC in incremental mode:

~&gt; gmake ineb
(cd "c:\Documents and Settings\Macneil Shonle\eclipse\workspace\Nebulous"; \
/cygdrive/c/aspectj1.2/bin/ajc -g -source 1.4 -preserveAllLocals -classpath
"c:\Documents and Settings\Macneil
Shonle\eclipse\workspace\edu.ucsd.aspectbrowser\aspectbrowser.jar;c:\Documents
and Settings\Macneil
Shonle\eclipse\workspace\edu.ucsd.aspectbrowser\gnu-regexp-1.1.4.jar;c:\Documents
and Settings\Macneil
Shonle\eclipse/workspace/Stub-AspectBrowser/Stub-AspectBrowser.jar;c:\Documents
and Settings\Macneil
Shonle\eclipse/plugins/org.eclipse.core.resources_3.0.0/resources.jar;c:\Documents
and Settings\Macneil
Shonle\eclipse/plugins/org.eclipse.jface.text_3.0.0/jfacetext.jar;c:\Documents
and Settings\Macneil
Shonle\eclipse/plugins/org.eclipse.text_3.0.0/text.jar;c:\Documents and
Settings\Macneil
Shonle\eclipse/plugins/org.eclipse.swt.win32_3.0.0/ws/win32/swt.jar;c:\Documents
and Settings\Macneil
Shonle\eclipse/plugins/org.eclipse.ui_3.0.0/ui.jar;c:\Documents and
Settings\Macneil
Shonle\eclipse/plugins/org.eclipse.jface_3.0.0/jface.jar;c:\Documents and
Settings\Macneil
Shonle\eclipse/plugins/org.eclipse.ui.workbench_3.0.0/workbench.jar;c:\Documents
and Settings\Macneil
Shonle\eclipse/plugins/org.eclipse.ui.editors_3.0.0/editors.jar;c:\Documents and
Settings\Macneil
Shonle\eclipse/plugins/org.eclipse.core.filebuffers_3.0.0/filebuffers.jar;c:\Documents
and Settings\Macneil
Shonle\eclipse/plugins/org.eclipse.ui.ide_3.0.0/ide.jar;c:\Documents and
Settings\Macneil
Shonle\eclipse/plugins/org.eclipse.ui.workbench.texteditor_3.0.0/texteditor.jar;c:\Documents
and Settings\Macneil
Shonle\eclipse/plugins/org.eclipse.core.runtime.compatibility_3.0.0/compatibility.jar;c:\Documents
and Settings\Macneil
Shonle\eclipse/plugins/org.eclipse.core.runtime_3.0.0/runtime.jar;c:\Documents
and Settings\Macneil
Shonle\eclipse/plugins/org.eclipse.osgi_3.0.0/osgi.jar;c:\Documents and
Settings\Macneil
Shonle\eclipse/plugins/org.eclipse.osgi_3.0.0/core.jar;c:\Documents and
Settings\Macneil
Shonle\eclipse/plugins/org.eclipse.osgi_3.0.0/console.jar;c:\Documents and
Settings\Macneil
Shonle\eclipse/plugins/org.eclipse.osgi_3.0.0/defaultAdaptor.jar;c:\Documents
and Settings\Macneil
Shonle\eclipse/plugins/org.eclipse.osgi_3.0.0/eclipseAdaptor.jar;c:\Documents
and Settings\Macneil
Shonle\eclipse/plugins/org.eclipse.osgi_3.0.0/resolver.jar;c:\Documents and
Settings\Macneil
Shonle\eclipse/plugins/org.eclipse.update.configurator_3.0.0/configurator.jar;C:\aspectj1.2\lib\aspectjrt.jar"
-incremental -d bin -sourceroots src)
 press enter to recompile, r to rebuild, q to quit: 

 press enter to recompile, r to rebuild, q to quit: 

 press enter to recompile, r to rebuild, q to quit: 

 press enter to recompile, r to rebuild, q to quit: 

C:\Documents and Settings\Macneil
Shonle\eclipse\workspace\Nebulous\src\edu\ucsd\nebulous\SourceFileDescriptor.java
error Internal compiler error
java.util.ConcurrentModificationException
        at java.util.AbstractList$Itr.checkForComodification(AbstractList.java:444)
        at java.util.AbstractList$Itr.next(AbstractList.java:421)
        at
org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.createBinaryTypeFrom(AjLookupEnvironment.java:416)
        at
org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.createBinaryTypeFrom(LookupEnvironment.java:299)
        at org.eclipse.jdt.internal.compiler.Compiler.accept(Compiler.java:208)
        at
org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.askForType(LookupEnvironment.java:111)
        at
org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.getType(LookupEnvironment.java:445)
        at
org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.makeTypeBinding1(EclipseFactory.java:249)
        at
org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.makeTypeBinding(EclipseFactory.java:218)
        at
org.aspectj.ajdt.internal.compiler.lookup.InterTypeMethodBinding.&lt;init&gt;(InterTypeMethodBinding.java:43)
        at
org.aspectj.ajdt.internal.compiler.lookup.EclipseTypeMunger.mungeNewMethod(EclipseTypeMunger.java:94)
        at
org.aspectj.ajdt.internal.compiler.lookup.EclipseTypeMunger.munge(EclipseTypeMunger.java:78)
        at
org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.weaveInterTypeDeclarations(AjLookupEnvironment.java:260)
        at
org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.weaveInterTypeDeclarations(AjLookupEnvironment.java:244)
        at
org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.createBinaryTypeFrom(AjLookupEnvironment.java:416)
        at
org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.createBinaryTypeFrom(LookupEnvironment.java:299)
        at org.eclipse.jdt.internal.compiler.Compiler.accept(Compiler.java:208)
        at
org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.askForType(LookupEnvironment.java:85)
        at
org.eclipse.jdt.internal.compiler.lookup.UnresolvedReferenceBinding.resolve(UnresolvedReferenceBinding.java:30)
        at
org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.getType(LookupEnvironment.java:451)
        at
org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.makeTypeBinding1(EclipseFactory.java:249)
        at
org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.makeTypeBinding(EclipseFactory.java:218)
        at
org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.makeTypeBindings(EclipseFactory.java:260)
        at
org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.makeMethodBinding(EclipseFactory.java:287)
        at
org.aspectj.ajdt.internal.compiler.lookup.InterTypeMethodBinding.&lt;init&gt;(InterTypeMethodBinding.java:39)
        at
org.aspectj.ajdt.internal.compiler.lookup.EclipseTypeMunger.mungeNewMethod(EclipseTypeMunger.java:94)
        at
org.aspectj.ajdt.internal.compiler.lookup.EclipseTypeMunger.munge(EclipseTypeMunger.java:78)
        at
org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.weaveInterTypeDeclarations(AjLookupEnvironment.java:260)
        at
org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.weaveInterTypeDeclarations(AjLookupEnvironment.java:244)
        at
org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.createBinaryTypeFrom(AjLookupEnvironment.java:416)
        at
org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.createBinaryTypeFrom(LookupEnvironment.java:299)
        at org.eclipse.jdt.internal.compiler.Compiler.accept(Compiler.java:208)
        at
org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.askForType(LookupEnvironment.java:111)
        at
org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.getType(LookupEnvironment.java:445)
        at
org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.makeTypeBinding1(EclipseFactory.java:249)
        at
org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.makeTypeBinding(EclipseFactory.java:218)
        at
org.aspectj.ajdt.internal.compiler.lookup.InterTypeMethodBinding.&lt;init&gt;(InterTypeMethodBinding.java:43)
        at
org.aspectj.ajdt.internal.compiler.lookup.EclipseTypeMunger.mungeNewMethod(EclipseTypeMunger.java:94)
        at
org.aspectj.ajdt.internal.compiler.lookup.EclipseTypeMunger.munge(EclipseTypeMunger.java:78)
        at
org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.weaveInterTypeDeclarations(AjLookupEnvironment.java:260)
        at
org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.weaveInterTypeDeclarations(AjLookupEnvironment.java:244)
        at
org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.createBinaryTypeFrom(AjLookupEnvironment.java:416)
        at
org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.createBinaryTypeFrom(LookupEnvironment.java:299)
        at org.eclipse.jdt.internal.compiler.Compiler.accept(Compiler.java:208)
        at
org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.askForType(LookupEnvironment.java:111)
        at
org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.getType(LookupEnvironment.java:445)
        at
org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.makeTypeBinding1(EclipseFactory.java:249)
        at
org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.makeTypeBinding(EclipseFactory.java:218)
        at
org.aspectj.ajdt.internal.compiler.lookup.InterTypeFieldBinding.&lt;init&gt;(InterTypeFieldBinding.java:41)
        at
org.aspectj.ajdt.internal.compiler.lookup.EclipseTypeMunger.mungeNewField(EclipseTypeMunger.java:119)
        at
org.aspectj.ajdt.internal.compiler.lookup.EclipseTypeMunger.munge(EclipseTypeMunger.java:76)
        at
org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.weaveInterTypeDeclarations(AjLookupEnvironment.java:260)
        at
org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.weaveInterTypeDeclarations(AjLookupEnvironment.java:244)
        at
org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.createBinaryTypeFrom(AjLookupEnvironment.java:416)
        at
org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.createBinaryTypeFrom(LookupEnvironment.java:299)
        at org.eclipse.jdt.internal.compiler.Compiler.accept(Compiler.java:208)
        at
org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.askForType(LookupEnvironment.java:111)
        at
org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.getType(LookupEnvironment.java:445)
        at
org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.makeTypeBinding1(EclipseFactory.java:249)
        at
org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.makeTypeBinding(EclipseFactory.java:218)
        at
org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.makeFieldBinding(EclipseFactory.java:278)
        at
org.aspectj.ajdt.internal.compiler.lookup.InterTypeFieldBinding.&lt;init&gt;(InterTypeFieldBinding.java:37)
        at
org.aspectj.ajdt.internal.compiler.lookup.EclipseTypeMunger.mungeNewField(EclipseTypeMunger.java:119)
        at
org.aspectj.ajdt.internal.compiler.lookup.EclipseTypeMunger.munge(EclipseTypeMunger.java:76)
        at
org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.weaveInterTypeDeclarations(AjLookupEnvironment.java:260)
        at
org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.weaveInterTypeDeclarations(AjLookupEnvironment.java:244)
        at
org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.createBinaryTypeFrom(AjLookupEnvironment.java:416)
        at
org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.createBinaryTypeFrom(LookupEnvironment.java:299)
        at org.eclipse.jdt.internal.compiler.Compiler.accept(Compiler.java:208)
        at
org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.askForType(LookupEnvironment.java:85)
        at
org.eclipse.jdt.internal.compiler.lookup.UnresolvedReferenceBinding.resolve(UnresolvedReferenceBinding.java:30)
        at
org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.getType(LookupEnvironment.java:451)
        at
org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.makeTypeBinding1(EclipseFactory.java:249)
        at
org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.makeTypeBinding(EclipseFactory.java:218)
        at
org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.makeFieldBinding(EclipseFactory.java:278)
        at
org.aspectj.ajdt.internal.compiler.lookup.InterTypeFieldBinding.&lt;init&gt;(InterTypeFieldBinding.java:37)
        at
org.aspectj.ajdt.internal.compiler.lookup.EclipseTypeMunger.mungeNewField(EclipseTypeMunger.java:119)
        at
org.aspectj.ajdt.internal.compiler.lookup.EclipseTypeMunger.munge(EclipseTypeMunger.java:76)
        at
org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.weaveInterTypeDeclarations(AjLookupEnvironment.java:260)
        at
org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.weaveInterTypeDeclarations(AjLookupEnvironment.java:244)
        at
org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.createBinaryTypeFrom(AjLookupEnvironment.java:416)
        at
org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.createBinaryTypeFrom(LookupEnvironment.java:299)
        at org.eclipse.jdt.internal.compiler.Compiler.accept(Compiler.java:208)
        at
org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.askForType(LookupEnvironment.java:111)
        at
org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.getType(LookupEnvironment.java:445)
        at
org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.makeTypeBinding1(EclipseFactory.java:249)
        at
org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.makeTypeBinding(EclipseFactory.java:218)
        at
org.aspectj.ajdt.internal.compiler.lookup.InterTypeFieldBinding.&lt;init&gt;(InterTypeFieldBinding.java:41)
        at
org.aspectj.ajdt.internal.compiler.lookup.EclipseTypeMunger.mungeNewField(EclipseTypeMunger.java:119)
        at
org.aspectj.ajdt.internal.compiler.lookup.EclipseTypeMunger.munge(EclipseTypeMunger.java:76)
        at
org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.weaveInterTypeDeclarations(AjLookupEnvironment.java:260)
        at
org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.weaveInterTypeDeclarations(AjLookupEnvironment.java:244)
        at
org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.createBinaryTypeFrom(AjLookupEnvironment.java:416)
        at
org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.createBinaryTypeFrom(LookupEnvironment.java:299)
        at org.eclipse.jdt.internal.compiler.Compiler.accept(Compiler.java:208)
        at
org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.askForType(LookupEnvironment.java:85)
        at
org.eclipse.jdt.internal.compiler.lookup.UnresolvedReferenceBinding.resolve(UnresolvedReferenceBinding.java:30)
        at
org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.getType(LookupEnvironment.java:451)
        at
org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.makeTypeBinding1(EclipseFactory.java:249)
        at
org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.makeTypeBinding(EclipseFactory.java:218)
        at
org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.makeFieldBinding(EclipseFactory.java:278)
        at
org.aspectj.ajdt.internal.compiler.lookup.InterTypeFieldBinding.&lt;init&gt;(InterTypeFieldBinding.java:37)
        at
org.aspectj.ajdt.internal.compiler.lookup.EclipseTypeMunger.mungeNewField(EclipseTypeMunger.java:119)
        at
org.aspectj.ajdt.internal.compiler.lookup.EclipseTypeMunger.munge(EclipseTypeMunger.java:76)
        at
org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.weaveInterTypeDeclarations(AjLookupEnvironment.java:260)
        at
org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.weaveInterTypeDeclarations(AjLookupEnvironment.java:244)
        at
org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.createBinaryTypeFrom(AjLookupEnvironment.java:416)
        at
org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.createBinaryTypeFrom(LookupEnvironment.java:299)
        at org.eclipse.jdt.internal.compiler.Compiler.accept(Compiler.java:208)
        at
org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.askForType(LookupEnvironment.java:111)
        at
org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.getType(LookupEnvironment.java:445)
        at
org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.makeTypeBinding1(EclipseFactory.java:249)
        at
org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.makeTypeBinding(EclipseFactory.java:218)
        at
org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.makeFieldBinding(EclipseFactory.java:278)
        at
org.aspectj.ajdt.internal.compiler.lookup.InterTypeFieldBinding.&lt;init&gt;(InterTypeFieldBinding.java:37)
        at
org.aspectj.ajdt.internal.compiler.lookup.EclipseTypeMunger.mungeNewField(EclipseTypeMunger.java:119)
        at
org.aspectj.ajdt.internal.compiler.lookup.EclipseTypeMunger.munge(EclipseTypeMunger.java:76)
        at
org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.weaveInterTypeDeclarations(AjLookupEnvironment.java:317)
        at
org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.weaveInterTypeDeclarations(AjLookupEnvironment.java:236)
        at
org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.completeTypeBindings(AjLookupEnvironment.java:110)
        at
org.eclipse.jdt.internal.compiler.Compiler.beginToCompile(Compiler.java:324)
        at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:341)
        at
org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:601)
        at
org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:175)
        at
org.aspectj.ajdt.internal.core.builder.AjBuildManager.incrementalBuild(AjBuildManager.java:101)
        at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:102)
        at org.aspectj.ajdt.ajc.AjdtCommand.repeatCommand(AjdtCommand.java:68)
        at org.aspectj.tools.ajc.Main.run(Main.java:288)
        at org.aspectj.tools.ajc.Main.runMain(Main.java:217)
        at org.aspectj.tools.ajc.Main.main(Main.java:79)

(no source information available)
ABORT
        
Exception thrown from AspectJ 1.2

This might be logged as a bug already -- find current bugs at
  http://bugs.eclipse.org/bugs/buglist.cgi?product=AspectJ&amp;component=Compiler

Bugs for exceptions thrown have titles File:line from the top stack, 
e.g., "SomeFile.java:243"

If you don't find the exception below in a bug, please add a new bug
at http://bugs.eclipse.org/bugs/enter_bug.cgi?product=AspectJ
To make the bug a priority, please include a test program
that can reproduce this exception.
null
java.util.ConcurrentModificationException
        at java.util.AbstractList$Itr.checkForComodification(AbstractList.java:444)
        at java.util.AbstractList$Itr.next(AbstractList.java:421)
        at
org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.createBinaryTypeFrom(AjLookupEnvironment.java:416)
        at
org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.createBinaryTypeFrom(LookupEnvironment.java:299)
        at org.eclipse.jdt.internal.compiler.Compiler.accept(Compiler.java:208)
        at
org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.askForType(LookupEnvironment.java:111)
        at
org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.getType(LookupEnvironment.java:445)
        at
org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.makeTypeBinding1(EclipseFactory.java:249)
        at
org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.makeTypeBinding(EclipseFactory.java:218)
        at
org.aspectj.ajdt.internal.compiler.lookup.InterTypeMethodBinding.&lt;init&gt;(InterTypeMethodBinding.java:43)
        at
org.aspectj.ajdt.internal.compiler.lookup.EclipseTypeMunger.mungeNewMethod(EclipseTypeMunger.java:94)
        at
org.aspectj.ajdt.internal.compiler.lookup.EclipseTypeMunger.munge(EclipseTypeMunger.java:78)
        at
org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.weaveInterTypeDeclarations(AjLookupEnvironment.java:260)
        at
org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.weaveInterTypeDeclarations(AjLookupEnvironment.java:244)
        at
org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.createBinaryTypeFrom(AjLookupEnvironment.java:416)
        at
org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.createBinaryTypeFrom(LookupEnvironment.java:299)
        at org.eclipse.jdt.internal.compiler.Compiler.accept(Compiler.java:208)
        at
org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.askForType(LookupEnvironment.java:85)
        at
org.eclipse.jdt.internal.compiler.lookup.UnresolvedReferenceBinding.resolve(UnresolvedReferenceBinding.java:30)
        at
org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.getType(LookupEnvironment.java:451)
        at
org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.makeTypeBinding1(EclipseFactory.java:249)
        at
org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.makeTypeBinding(EclipseFactory.java:218)
        at
org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.makeTypeBindings(EclipseFactory.java:260)
        at
org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.makeMethodBinding(EclipseFactory.java:287)
        at
org.aspectj.ajdt.internal.compiler.lookup.InterTypeMethodBinding.&lt;init&gt;(InterTypeMethodBinding.java:39)
        at
org.aspectj.ajdt.internal.compiler.lookup.EclipseTypeMunger.mungeNewMethod(EclipseTypeMunger.java:94)
        at
org.aspectj.ajdt.internal.compiler.lookup.EclipseTypeMunger.munge(EclipseTypeMunger.java:78)
        at
org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.weaveInterTypeDeclarations(AjLookupEnvironment.java:260)
        at
org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.weaveInterTypeDeclarations(AjLookupEnvironment.java:244)
        at
org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.createBinaryTypeFrom(AjLookupEnvironment.java:416)
        at
org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.createBinaryTypeFrom(LookupEnvironment.java:299)
        at org.eclipse.jdt.internal.compiler.Compiler.accept(Compiler.java:208)
        at
org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.askForType(LookupEnvironment.java:111)
        at
org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.getType(LookupEnvironment.java:445)
        at
org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.makeTypeBinding1(EclipseFactory.java:249)
        at
org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.makeTypeBinding(EclipseFactory.java:218)
        at
org.aspectj.ajdt.internal.compiler.lookup.InterTypeMethodBinding.&lt;init&gt;(InterTypeMethodBinding.java:43)
        at
org.aspectj.ajdt.internal.compiler.lookup.EclipseTypeMunger.mungeNewMethod(EclipseTypeMunger.java:94)
        at
org.aspectj.ajdt.internal.compiler.lookup.EclipseTypeMunger.munge(EclipseTypeMunger.java:78)
        at
org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.weaveInterTypeDeclarations(AjLookupEnvironment.java:260)
        at
org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.weaveInterTypeDeclarations(AjLookupEnvironment.java:244)
        at
org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.createBinaryTypeFrom(AjLookupEnvironment.java:416)
        at
org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.createBinaryTypeFrom(LookupEnvironment.java:299)
        at org.eclipse.jdt.internal.compiler.Compiler.accept(Compiler.java:208)
        at
org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.askForType(LookupEnvironment.java:111)
        at
org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.getType(LookupEnvironment.java:445)
        at
org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.makeTypeBinding1(EclipseFactory.java:249)
        at
org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.makeTypeBinding(EclipseFactory.java:218)
        at
org.aspectj.ajdt.internal.compiler.lookup.InterTypeFieldBinding.&lt;init&gt;(InterTypeFieldBinding.java:41)
        at
org.aspectj.ajdt.internal.compiler.lookup.EclipseTypeMunger.mungeNewField(EclipseTypeMunger.java:119)
        at
org.aspectj.ajdt.internal.compiler.lookup.EclipseTypeMunger.munge(EclipseTypeMunger.java:76)
        at
org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.weaveInterTypeDeclarations(AjLookupEnvironment.java:260)
        at
org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.weaveInterTypeDeclarations(AjLookupEnvironment.java:244)
        at
org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.createBinaryTypeFrom(AjLookupEnvironment.java:416)
        at
org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.createBinaryTypeFrom(LookupEnvironment.java:299)
        at org.eclipse.jdt.internal.compiler.Compiler.accept(Compiler.java:208)
        at
org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.askForType(LookupEnvironment.java:111)
        at
org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.getType(LookupEnvironment.java:445)
        at
org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.makeTypeBinding1(EclipseFactory.java:249)
        at
org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.makeTypeBinding(EclipseFactory.java:218)
        at
org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.makeFieldBinding(EclipseFactory.java:278)
        at
org.aspectj.ajdt.internal.compiler.lookup.InterTypeFieldBinding.&lt;init&gt;(InterTypeFieldBinding.java:37)
        at
org.aspectj.ajdt.internal.compiler.lookup.EclipseTypeMunger.mungeNewField(EclipseTypeMunger.java:119)
        at
org.aspectj.ajdt.internal.compiler.lookup.EclipseTypeMunger.munge(EclipseTypeMunger.java:76)
        at
org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.weaveInterTypeDeclarations(AjLookupEnvironment.java:260)
        at
org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.weaveInterTypeDeclarations(AjLookupEnvironment.java:244)
        at
org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.createBinaryTypeFrom(AjLookupEnvironment.java:416)
        at
org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.createBinaryTypeFrom(LookupEnvironment.java:299)
        at org.eclipse.jdt.internal.compiler.Compiler.accept(Compiler.java:208)
        at
org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.askForType(LookupEnvironment.java:85)
        at
org.eclipse.jdt.internal.compiler.lookup.UnresolvedReferenceBinding.resolve(UnresolvedReferenceBinding.java:30)
        at
org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.getType(LookupEnvironment.java:451)
        at
org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.makeTypeBinding1(EclipseFactory.java:249)
        at
org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.makeTypeBinding(EclipseFactory.java:218)
        at
org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.makeFieldBinding(EclipseFactory.java:278)
        at
org.aspectj.ajdt.internal.compiler.lookup.InterTypeFieldBinding.&lt;init&gt;(InterTypeFieldBinding.java:37)
        at
org.aspectj.ajdt.internal.compiler.lookup.EclipseTypeMunger.mungeNewField(EclipseTypeMunger.java:119)
        at
org.aspectj.ajdt.internal.compiler.lookup.EclipseTypeMunger.munge(EclipseTypeMunger.java:76)
        at
org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.weaveInterTypeDeclarations(AjLookupEnvironment.java:260)
        at
org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.weaveInterTypeDeclarations(AjLookupEnvironment.java:244)
        at
org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.createBinaryTypeFrom(AjLookupEnvironment.java:416)
        at
org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.createBinaryTypeFrom(LookupEnvironment.java:299)
        at org.eclipse.jdt.internal.compiler.Compiler.accept(Compiler.java:208)
        at
org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.askForType(LookupEnvironment.java:111)
        at
org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.getType(LookupEnvironment.java:445)
        at
org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.makeTypeBinding1(EclipseFactory.java:249)
        at
org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.makeTypeBinding(EclipseFactory.java:218)
        at
org.aspectj.ajdt.internal.compiler.lookup.InterTypeFieldBinding.&lt;init&gt;(InterTypeFieldBinding.java:41)
        at
org.aspectj.ajdt.internal.compiler.lookup.EclipseTypeMunger.mungeNewField(EclipseTypeMunger.java:119)
        at
org.aspectj.ajdt.internal.compiler.lookup.EclipseTypeMunger.munge(EclipseTypeMunger.java:76)
        at
org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.weaveInterTypeDeclarations(AjLookupEnvironment.java:260)
        at
org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.weaveInterTypeDeclarations(AjLookupEnvironment.java:244)
        at
org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.createBinaryTypeFrom(AjLookupEnvironment.java:416)
        at
org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.createBinaryTypeFrom(LookupEnvironment.java:299)
        at org.eclipse.jdt.internal.compiler.Compiler.accept(Compiler.java:208)
        at
org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.askForType(LookupEnvironment.java:85)
        at
org.eclipse.jdt.internal.compiler.lookup.UnresolvedReferenceBinding.resolve(UnresolvedReferenceBinding.java:30)


1 fail|abort, 1 error
Signal 127
make: *** [ineb] Error 255</comment>
		<comment id="3" date="2004-07-24 21:55:18 EDT" author="Macneil Shonle">(BTW, in the direct above comment, the first three [enter]s were with no
changes. The final error, which caused the execption, was when I modified a pure
Java file by typing a space and deleting it, and then saved it (and then hit the
[enter])).</comment>
		<comment id="4" date="2004-07-26 06:19:12 EDT" author="Andrew Clement">I can half-see what the issue is.  I'd just like to put a testcase in before I
fix it.  Is there any way you can share this code with me?  My tiny testcases
won't exercise the codepath that is failing.  It is something to do with the
incremental compilation logic noticing that it needs to recompile other types
than the one you modified.</comment>
		<comment id="5" date="2004-07-26 14:43:04 EDT" author="Macneil Shonle">My project has ~150 files, so it's difficult to effectively make a smaller test
case, however we could set something up where I can send you the whole thing.
-Macneil</comment>
		<comment id="6" date="2004-07-29 09:27:53 EDT" author="Andrew Clement">Thanks for the offer.  Can you possibly send me a zip of the project so I can
look at debugging it on my machine?  (send the zip to clemas@uk.ibm.com)

Andy.</comment>
		<comment id="7" date="2004-07-30 04:23:46 EDT" author="Andrew Clement">Hi, thanks for sending me your code.  I have recreated the failure (hurray!).

Now I just have to understand it ....</comment>
		<comment id="8" date="2004-07-30 12:25:55 EDT" author="Andrew Clement">Right... I recreated the bug and I have fixed the bug... what I don't have is 
a nice simple testcase.  It requires changing a type that pulls in other types 
that pulls in other types that pulls in other types (etc...) - so I'll work on 
knocking something up (might trim down Macneils code if I can, into something 
that fails).

The fix was to avoid locking a list with an iterator.  If we move to a queue 
based approach where I just take the first entry of the list whilst it has 
something on it and process it, the infrastructure is free to add more entries 
to the list which will be processed eventually.</comment>
		<comment id="9" date="2004-07-30 16:05:11 EDT" author="Macneil Shonle">Well, I'm glad I gave up early on the idea of coming up with a minimal test case
to show it. :-)</comment>
		<comment id="10" date="2004-08-02 06:27:02 EDT" author="Andrew Clement">I want to move on to the next bug, so I'm committing my fix for this one.

FYI, using Macneils application, I put a trace statement in the 
AjLookupEnvironment.createBinaryTypeFrom() method that indicates the type for 
which we are creating a binary type binding.  So, if I do an incremental build 
of his project, it then waits with the usual incremental prompt.  If I make a 
change to Menus.java (just adding or deleting a blank line) and save it, then 
press enter against the incremental prompt, I get this list of types:

javax/swing/JMenuBar
javax/swing/JComponent
java/awt/Container
java/awt/Component
java/lang/Object
java/io/Serializable
java/awt/MenuContainer
java/awt/image/ImageObserver
javax/swing/MenuElement
javax/accessibility/Accessible
java/awt/event/ActionListener
java/util/EventListener
javax/swing/JMenuBar$AccessibleJMenuBar
javax/swing/JComponent$ReadObjectCallback
javax/swing/JComponent$KeyboardState
javax/swing/JComponent$IntVector
javax/swing/JComponent$EnableSerializationFocusListener
javax/swing/JComponent$ActionStandin
javax/swing/JComponent$AccessibleJComponent
java/awt/Container$MouseEventTargetFilter
java/awt/Container$EventTargetFilter
java/awt/Container$DropTargetEventTargetFilter
java/awt/Container$AccessibleAWTContainer
java/awt/Component$SingleBufferStrategy
java/awt/Component$NativeInLightFixer
java/awt/Component$FlipBufferStrategy
java/awt/Component$BltBufferStrategy
java/awt/Component$AccessibleAWTComponent
java/awt/Component$AWTTreeLock
javax/swing/AbstractAction
java/lang/Cloneable
javax/swing/Action
javax/swing/AbstractAction$ArrayTable
java/awt/Event
java/util/Vector
javax/swing/JMenuItem
javax/swing/JCheckBoxMenuItem
edu/ucsd/nebulous/Session
edu/ucsd/nebulous/SessionEvents
edu/ucsd/nebulous/SessionEventRouting
java/util/List
edu/ucsd/nebulous/TraversalTypeComboBox
edu/ucsd/nebulous/TraversalTypeComboBoxMediating
edu/ucsd/nebulous/FileViewRootCursorMediating
edu/ucsd/nebulous/AtlasButtonPanel
edu/ucsd/nebulous/AtlasButtonPanelMediating
edu/ucsd/nebulous/NFileViewRoot
edu/ucsd/nebulous/NFileViewRootSessionMediating
edu/ucsd/nebulous/TreePanel
edu/ucsd/nebulous/TreePanelMediating
edu/ucsd/nebulous/ExternalEditorMediator
edu/ucsd/nebulous/ExternalEditorMediating
edu/ucsd/nebulous/ExternalEditor
edu/ucsd/nebulous/SessionMediating
java/awt/Color
edu/ucsd/nebulous/ColorSequenceGeneration
java/util/Random
java/io/PrintWriter
edu/ucsd/nebulous/ProjectIO
java/util/Set

At the point 'Set' is printed we are making that concurrentmodification to the 
list we are iterating over and we go bang.  As you can see, it is not a small 
list that lends itself easily to recreation - there are inner aspects/inner 
classes and awt/swing dependencies that all seem to complicate the situation.

I will update this bug when there has been a successful build with my fix in - 
can you then try it Macneil and let me know if it definetly fixes the problem 
for you? (And that the application when built incremenally, continues to run 
correctly?).

thanks.</comment>
		<comment id="11" date="2004-08-02 06:30:27 EDT" author="Andrew Clement">*** Bug 68483 has been marked as a duplicate of this bug. ***</comment>
		<comment id="12" date="2004-08-02 10:08:13 EDT" author="Andrew Clement">Fixed and available in build:

BUILD COMPLETE -  build.323
Date of build: 08/02/2004 12:13:46
Time to build: 115 minutes 29 seconds
Last changed: 08/02/2004 11:14:39
Last log entry: Fix for Bugzilla Bug 70773 AspectJ Error:
ConncurrentModificationException thrown: null
Latest good AspectJ jar available at:
download.eclipse.org/technology/ajdt/dev/aspectj-DEVELOPMENT.jar

Macneil, can you give that version of AJ a try? thanks.</comment>
		<comment id="13" date="2004-08-03 06:14:43 EDT" author="Andrew Clement">I'm closing this bug just to try and get my bug list under control ;)  Feel free
to reopen if it turns out that it does not fix the problem.</comment>
		<comment id="14" date="2004-10-21 04:31:54 EDT" author="Adrian Colyer">Fix released as part of AspectJ 1.2.1</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="9aed31d18e3848c72c6963dc3a6ee4661a79add9" author="aclement" date="2004-08-02 07:14:39"/>
          <file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="71723" opendate="2004-8-10 13:32:00" fixdate="2004-08-18 11:44:29">
    <buginformation>
      <summary>Inconsistency in scoping of protected members in ITDs</summary>
      <description>When introducing new member functions to existing classes via inter-type
declarations, the scoping rules that apply to the ITD bodies are the same as for
the aspect - for example, private members of the target class cannot be accessed
unless the aspect is privileged.

Similarly, protected members of classes in different packages should not be
visible in ITDs unless the aspect is privileged.

This rule is only enforced for protected members declared in the target class -
protected members that are inherited are visible from ITDs in aspects in
different packages.

The following is an example of this:

----------------------
package foo;

public class Foo extends AncientFoo {
    protected int i() { return 42; }
    public static void main(String[] args) {
	new Foo().doStuff();
    }
    public void doStuff() { }
    protected int ancientI() { return 42; }
}

class AncientFoo {
    protected int ancientI() { return -42; }
    protected int ancientJ() { return 0; }
}
----------

package bar;
import foo.Foo;

aspect Bar {
    public void Foo.doing() {
	try {
	    System.out.println(i()); // fails in ajc
	    System.out.println(ancientI()); // fails in ajc
	    System.out.println(ancientJ()); // succeeds
	    System.out.println(clone()); // succeeds
	}
	catch(Throwable t) { }
    }
    before(Foo f) : call(* doStuff(..)) &amp;&amp; target(f) {
	f.doing();
    }
}
-------------------

All four calls in Foo.doing() should fail, as they refer to protected members of
foo.Foo from package bar. However, only the first 2 - the ones directly
declared/overridden in foo.Foo - are detected as errors, and removing them makes
the rest compile and execute.

Best wishes,
Pavel</description>
      <comments>
		<comment id="1" date="2004-08-10 15:00:27 EDT" author="Adrian Colyer">adding to my list of fun raised-by-oxford-inter-type-declaration-scoping-bugs to 
be looked at for 1.2.1 :)</comment>
		<comment id="2" date="2004-08-18 08:44:37 EDT" author="Adrian Colyer">Fix committed in tree. Will close bug once this is available in a published 
build.</comment>
		<comment id="3" date="2004-08-18 11:44:29 EDT" author="Adrian Colyer">Fix now available for download.</comment>
		<comment id="4" date="2004-10-21 04:31:11 EDT" author="Adrian Colyer">Fix released as part of AspectJ 1.2.1</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="dfb15c1777ab6995528a0a0d49faf0ef74578db6" author="acolyer" date="2004-08-18 09:39:40"/>
          <file name="tests/bugs/pr71723/foo/Foo.java">
          </file>
          <file name="tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java">
              <method name="test043_pr62642_ExceptionInInitializerError" returnType="void" parameters=""/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="44191" opendate="2003-10-4 20:23:00" fixdate="2004-09-08 12:42:52">
    <buginformation>
      <summary>"Need better error message for ""can't find type"""</summary>
      <description>I have experienced situations where IAJC outputs a message like this at the 
end of compilation.

    [iajc] can't find type org.xxx.SomeTest

In my case this was one time highly confusing since I did not expect the class 
in question to be referred anywhere in the project (I have to date still not 
located the reference). 

For such cases, it would be extremely nice if the error message would display 
WHY it need the class (i.e. the name of the refering class(es) or aspect(es) 
possibly with a reasonable cutoff as there is seldom need to list all 
referals). So I would like a message like this:

    [iajc] can't find type org.xxx.SomeTest referred by 
org.yyy.SomeClass,org.yy.SomeOtherClass ...</description>
      <comments>
		<comment id="1" date="2003-10-04 20:59:06 EDT" author="Wes Isberg">This is a good suggestion.  Reassigning as such to compiler.</comment>
		<comment id="2" date="2004-03-03 05:12:03 EST" author="Andrew Clement">"can't find type" is displayed by World.resolve(TypeX,boolean).  The boolean 
flag specifies if the caller of resolve() can handle the fact that a type is 
missing - if it can then 'cant find type' is not displayed and instead the 
caller gets a ResolvedTypeX.MISSING object.  

So the problem scenario where we would like more info is when the boolean is 
false.  Currently there is only one route into this method where the boolean 
is false, that is through World.resolve(TypeX) where the caller hasn't 
specified whether they can handle a missing type.

Unfortunately there are 63 callers of World.resolve(TypeX).  The options seem 
to be:
1) Modify those 63 places to use the resolve(TypeX,boolean) variant and ensure 
they cope with ResolvedTypeX.MISSING correctly.
2) Pass some 'context' along as an extra parameter on every resolve() call so 
that 'cant find type' can give more information about what was happening when 
it attempted to find a type.

Neither is ideal ... still thinking ... maybe there is a sensible subset of 
the 63 cases which are the most common and we can change them to 'resolve
(TypeX,true)' and print better messages when ResolvedTypeX.MISSING is returned.</comment>
		<comment id="3" date="2004-03-04 16:35:58 EST" author="Jim Hugunin">It's always hard to deal with 63 method calls.  My quick pass reveals 5 kinds 
of uses that should be considered separately.

1. resolve(TypeX.OBJECT) or some other core runtime type.  I'd suggest 
changing these either by adding specific methods to world, i.e. getObjectType
() or a general getCoreType(TypeX.OBJECT).  If one of these types is missing 
there's a basic configuration error.

2. resolve used in test cases.  There are a fair number of these, and I don't 
think you need to worry about them.  To simplify the analysis you might want 
to change these to use resolve(TypeX, true) followed by an assertion that 
ResolvedTypeX.MISSING wasn't returned.

3. A small number of cases where resolve is used where it doesn't really need 
to be.  i.e. The API for Shadow.getEnclosingType() should probably return a 
ResolvedTypeX since this is what BcelShadow is already holding onto.  These 
calls will never fail, but fixing them up will make it easier to see the other 
calls.

4. resolve used in implemention of actual weaving.  These calls usually have 
an easy context to provide and would be useful to let the user know where the 
problem is, i.e. can't find type Foo while weaving around advice X into join 
point shadow Y.  This is a great use of our multiple source locations support 
in 1.2.

5. Once you've done the ones above, there will still be a good number (~20?) 
remaining that are harder.  These are probably the actual ones leading to the 
confusing error messages.  These need to be looked at one by one to see where 
context can be easily supplied.  Most of these calls are used to see if a 
given join point shadow matches a given pcd.  This is a case where it would 
sometimes be nice to handle MISSING more carefully.</comment>
		<comment id="4" date="2004-08-06 05:36:55 EDT" author="Andrew Clement">*** Bug 71045 has been marked as a duplicate of this bug. ***</comment>
		<comment id="5" date="2004-08-06 10:52:50 EDT" author="Andrew Clement">I've finally gotten round to starting on this.  I've removed the rogue calls in
the testcases that confuse the situation and added a new method to world that
should be used when looking for really important types like java.lang.Object
which fails with an error other than 'cant find type' to let you know you are
really in trouble.  That seems to have taken me down to around 50 calls to
resolve without a boolean.  The quest continues ...</comment>
		<comment id="6" date="2004-08-10 04:30:36 EDT" author="Adrian Colyer">for the 1.2.1 release (or as many of the cases as we can)</comment>
		<comment id="7" date="2004-09-08 12:42:52 EDT" author="Andrew Clement">I've fixed a bunch of cases of 'cant find type'.  The rest that remain are hard
to fix as they require a lot of state to be passed around in order to say why we
cant find it.  Adding all this state to the relevant methods would really
complicate the implementation.  I would rather target specific problematic 'cant
find type' scenarios and fix them one-by-one.  The reason I originally tried to
fix them *all* is that we don't know which were the problematic ones, but now we
have the AspectJ dump support.  Here is a comment I put in another bug:

------------------
We have just built a version of AspectJ that includes some rudimentary dump
support - this allows us to collect diagnostic information when things go wrong.
 I'd like to try it out for the first time on this bug.  The version of AspectJ
required is available here (the usual place):

BUILD COMPLETE -  build.356
Date of build: 08/23/2004 16:06:44
Time to build: 125 minutes 0 seconds
Last changed: 08/23/2004 14:40:33
Latest good AspectJ jar available at:
download.eclipse.org/technology/ajdt/dev/aspectj-DEVELOPMENT.jar

Please can you retry your failing Java 1.5 scenario with this version.  AND in
order to cause it to dump on error (it normally just dumps on abort), you will
need to set this property:

org.aspectj.weaver.Dump.condition=error

If that works then when the compiler finishes after reporting your 'Cant find
type' message it will produce an ajcore.XXX file on the disk (XXX is a date/time
stamp).  Can you send me the ajcore file?  That will enable me to tell which
route to can't find type is having problems
------

So - in future - if anyone hits a really unhelpful 'cant find type' message, we
should tell them to set org.aspectj.weaver.Dump.condition=error and re-run.  If
they then send us the ajcore.* file that comes out, we can target that
particular path to 'cant find type' and fix it with better diagnostics.</comment>
		<comment id="8" date="2004-10-21 04:31:31 EDT" author="Adrian Colyer">Fix released as part of AspectJ 1.2.1</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="061395c8c7fe681ab40ab53a7d1bfeb8e17c1028" author="aclement" date="2004-08-07 12:04:45"/>
          <file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectDeclaration.java">
              <method name="checkSpec" returnType="void" parameters="ClassScope"/>
          </file>
          <file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseSourceType.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/ResolvedTypeX.java">
              <method name="getDeclaredInterfaces" returnType="ResolvedTypeX[]" parameters=""/>
          </file>
          <file name="weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java">
              <method name="collectCheckedExceptions" returnType="Collection" parameters="TypeX[]"/>
          </file>
          <file name="weaver/src/org/aspectj/weaver/bcel/BcelShadow.java">
              <method name="createThisJoinPoint" returnType="InstructionList" parameters=""/>
          </file>
          <file name="weaver/src/org/aspectj/weaver/patterns/DeclareParents.java">
              <method name="maybeGetNewParent" returnType="ResolvedTypeX" parameters="ResolvedTypeX TypePattern World"/>
          </file>
          <file name="weaver/src/org/aspectj/weaver/patterns/DeclareSoft.java">
              <method name="resolve" returnType="void" parameters="IScope"/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="72157" opendate="2004-8-18 6:39:00" fixdate="2004-09-08 11:56:00">
    <buginformation>
      <summary>declare soft can cause programs with invalid exception behaviour to be generated</summary>
      <description>Compiling the program below results in the constructor for the class SCE2
throwing Exception, which it is not declared to throw either in the source code
or in the generated bytecode. If the 'declare soft' statement is removed, then
the super() call in the SCE2 constructor is correctly reported as throwing an
undeclared exception; it seems that the 'declare soft' statement turns off the
exception checking of the super() call despite there being no join point which
covers this call that would actually soften the exception.

I'm using 'DEVELOPMENT built on Monday Aug 16, 2004 at 13:50:47 GMT'.

public class SuperConsExc {
    public SuperConsExc() throws Exception {
	throw new Exception();
    }

    public static void main(String[] args) {
	new SCE2();
    }
}

class SCE2 extends SuperConsExc {
    public SCE2() {
	super();
    }
}

aspect SCEAspect {
    declare soft: Exception: within(SCE2);
}</description>
      <comments>
		<comment id="1" date="2004-08-25 03:15:40 EDT" author="Adrian Colyer">marked as target 1.2.1</comment>
		<comment id="2" date="2004-09-07 12:06:28 EDT" author="Adrian Colyer">This program looks like it is behaving correctly to me?

within(SCE2) matches the execution join point for SCE2.new(), and softens 
exceptions that occur during its execution.

Consider the analogous program (which eliminates the super() call confusion):

class Foo {

  public void foo() throws Exception {
    throw new Exception();
  }

  public void goo() {
    foo();
  }

}

This will give an unhandled exception compilation error as is, but if you add
declare soft : Exception : execution(* goo(..));
it will compile happily.</comment>
		<comment id="3" date="2004-09-07 12:17:31 EDT" author="Ganesh Sittampalam">In your example, the thrown Exception actually does get softened; but in my
example it doesn't, leading to a checked exception being thrown at runtime by a
method not declared to throw it.

The super() call is crucial to my example, because the problem is that the
execution join point for a constructor does not cover the super() call.</comment>
		<comment id="4" date="2004-09-07 12:30:17 EDT" author="Adrian Colyer">Got it, thanks. Should have read more carefully. Have re-opened bug.

Interesting problem since:

class Foo {

  Foo() {}

}

class Boo extends Foo {

  Boo() {
   try {
     super();
   } catch(Error e) {}
  }
}

is not a valid program. Therefore the correct behaviour must be to NOT soften 
the exception, which is consistent with the definition of execution join points 
as beginning after the super call.</comment>
		<comment id="5" date="2004-09-08 08:11:20 EDT" author="Adrian Colyer">Fix in tree. Waiting for development build before closing.</comment>
		<comment id="6" date="2004-09-08 11:56:00 EDT" author="Adrian Colyer">Fix now available for download.</comment>
		<comment id="7" date="2004-10-21 04:31:33 EDT" author="Adrian Colyer">Fix released as part of AspectJ 1.2.1</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="eca1429e79b3dc55c1f93ffbadb3e50eb9808d9c" author="acolyer" date="2004-09-08 09:04:49"/>
          <file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/problem/AjProblemReporter.java">
          </file>
          <file name="tests/bugs/ConvertToUnchecked.java">
          </file>
          <file name="tests/bugs/PR72157.java">
          </file>
          <file name="tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java">
              <method name="test056_arrayCloning" returnType="void" parameters=""/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="57666" opendate="2004-4-6 17:22:00" fixdate="2004-08-02 15:16:00">
    <buginformation>
      <summary>duplicate manifests cause resource-copying to gack</summary>
      <description>(Ah, the joy of build infrastructure...)

Mostly self-explanatory trace, from a build Monday Apr 5, 2004 at 08:46:01 GMT:

duplicate entry: META-INF/MANIFEST.MF
duplicate entry: META-INF/MANIFEST.MF
java.util.zip.ZipException: duplicate entry: META-INF/MANIFEST.MF
	at java.util.zip.ZipOutputStream.putNextEntry(ZipOutputStream.java:163)
	at java.util.jar.JarOutputStream.putNextEntry(JarOutputStream.java:90)
	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.writeResource(AjBuildManager.java:344)
	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.copyResourcesFromJarFile(AjBuildManager.java:288)
	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.copyResourcesToDestination(AjBuildManager.java:253)
	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:195)
	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:94)
	at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:102)
	at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:53)
	at org.aspectj.tools.ajc.Main.run(Main.java:280)
	at org.aspectj.tools.ajc.Main.runMain(Main.java:217)
	at org.aspectj.tools.ajc.Main.main(Main.java:79)</description>
      <comments>
		<comment id="1" date="2004-04-07 05:49:05 EDT" author="Matthew Webster">There are several routes into this code. Could you attach a testcase or 
describe what you were doing when the failure occured.

Thanks</comment>
		<comment id="2" date="2004-04-09 08:08:23 EDT" author="Wes Isberg">Sorry, no time now to try to create a test case.  Perhaps the manifest file
automatically included when the zip is created is not added to the list of known
resources in AjState.  </comment>
		<comment id="3" date="2004-07-30 09:08:50 EDT" author="Matthew Webster">*** Bug 66267 has been marked as a duplicate of this bug. ***</comment>
		<comment id="4" date="2004-07-30 09:17:36 EDT" author="Matthew Webster">Using a JarInputStream is a bit of a minefield. Its behaviour, especially 
WRT "getManifest()", varies accounding to how the JAR file was build: ZIP vs 
JAR. To ensure the first orginal manfiest encountered is copied injars/inpath 
to outjar:
1. Use JarFile rather than JarInputStream
2. Explicitly test for "META-INF/MANIFEST.MF" entry
3. Add DiplicateManifestTest to weave a JAR built using ZIP</comment>
		<comment id="5" date="2004-07-30 09:47:32 EDT" author="Matthew Webster">Created attachment 13683 [details]
Testcase and fix

ajde: testcase &amp; data
ajdt: AjBuildManager &amp; BcweaverJarMaker
weaver: BcelWeaver

1. Apply 3 patches and import ZIP
2. Run BcweaverJarMaker and run
"ajde/testdata/DuplicateManifestTest/update-injar.xml (Ant) to create injar.jar
and aspectjar.jar</comment>
		<comment id="6" date="2004-08-02 11:59:46 EDT" author="Andrew Clement">Matthews fix integrated.  Waiting for build note before closing bug.</comment>
		<comment id="7" date="2004-08-02 15:16:00 EDT" author="Andrew Clement">Fix available:

BUILD COMPLETE -  build.325
Date of build: 08/02/2004 17:56:01
Time to build: 89 minutes 54 seconds
Last changed: 08/02/2004 16:47:52
Last log entry: Fix for Bugzilla Bug 57666 duplicate manifests cause
resource-copying to gack(Contributed by Matthew Webster)
Latest good AspectJ jar available at:
download.eclipse.org/technology/ajdt/dev/aspectj-DEVELOPMENT.jar</comment>
		<comment id="8" date="2004-10-21 04:31:30 EDT" author="Adrian Colyer">Fix released as part of AspectJ 1.2.1</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="2b8fa314f21eddf8551715fdd571da2b611411d0" author="aclement" date="2004-08-03 12:47:02"/>
          <file name="ajde/testsrc/org/aspectj/ajde/AjdeTests.java">
              <method name="suite" returnType="Test" parameters=""/>
          </file>
          <file name="ajde/testsrc/org/aspectj/ajde/DuplicateManifestTest.java">
          </file>
          <file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java">
              <method name="copyResourcesFromJarFile" returnType="void" parameters="File"/>
          </file>
          <file name="org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/BcweaverJarMaker.java">
              <method name="main" returnType="void" parameters="String[]"/>
          </file>
          <file name="weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="58681" opendate="2004-4-15 12:19:00" fixdate="2004-07-27 11:56:40">
    <buginformation>
      <summary>#NAME?</summary>
      <description>ajc should emit the available -X options on -help or -X request (the latter like
java) to get more traffic and feedback on the experimental options.</description>
      <comments>
		<comment id="1" date="2004-07-27 11:56:40 EDT" author="Adrian Colyer">Fixed following java compiler conventions.


==&gt; ajc -?

AspectJ Compiler

 Usage: &lt;options&gt; &lt;source file | @argfile&gt;..

AspectJ-specific options:
 -inpath &lt;list&gt;      use classes in dirs and jars/zips in &lt;list&gt; as source
                     (&lt;list&gt; uses platform-specific path delimiter)
 -injars &lt;jarList&gt;   use classes in &lt;jarList&gt; zip files as source
                     (&lt;jarList&gt; uses classpath delimiter)
                     deprecated - use inpath instead.
 -aspectpath &lt;list&gt;  weave aspects from &lt;list&gt; zip files into sources
                     (&lt;list&gt; uses classpath delimiter)
 -outjar &lt;file&gt;      put output classes in zip file &lt;file&gt;
 -argfile &lt;file&gt;     specify line-delimited list of source files
 -incremental        continuously-running compiler, needs -sourceroots
                     (reads stdin: enter to recompile and 'q' to quit)
 -sourceroots &lt;dirs&gt; compile all .aj and .java files in &lt;dirs&gt;
                     (&lt;dirs&gt; uses classpath delimiter)
 -emacssym           generate .ajesym symbol files for emacs support
 -Xlint              same as '-Xlint:warning'
 -Xlint:&lt;level&gt;      set default level for crosscutting messages
                     (&lt;level&gt; may be ignore, warning, or error)
 -Xlintfile &lt;file&gt;   specify properties file to set per-message levels
                     (cf org/aspectj/weaver/XlintDefault.properties)
 -X                  print help on non-standard options

Standard Eclipse compiler options:
 Options enabled by default are prefixed with '+'
... 


==&gt; ajc -X

AspectJ Compiler non-standard options:

 -XnoInline          don't inline advice
 -XlazyTjp           create thisJoinPoint objects lazily
 -Xreweavable        create class files that can be subsequently rewoven
                     by AspectJ
 -Xreweavable:compress as above, but also compress the reweaving information
 -XnoWeave           compile classes but do not weave. Deprecated, use
                     reweavable instead.

 </comment>
		<comment id="2" date="2004-07-27 12:09:29 EDT" author="Adrian Colyer">and I even managed to mess it up. -XserializableAspects now added too...</comment>
		<comment id="3" date="2004-10-21 04:31:43 EDT" author="Adrian Colyer">Fix released as part of AspectJ 1.2.1</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="6ea830044009af2991178f1833b6386143f2cc1b" author="acolyer" date="2004-07-28 12:44:24"/>
          <file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/AjdtCommand.java">
              <method name="runCommand" returnType="boolean" parameters="String[] IMessageHandler"/>
          </file>
          <file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java">
              <method name="getUsage" returnType="String" parameters=""/>
          </file>
          <file name="org.aspectj.ajdt.core/src/org/aspectj/tools/ajc/Main.java">
              <method name="run" returnType="void" parameters="String[] IMessageHolder"/>
          </file>
          <file name="org.aspectj.ajdt.core/testsrc/EajcModuleTests.java">
          </file>
          <file name="org.aspectj.ajdt.core/testsrc/org/aspectj/tools/ajc/MainTest.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="48990" opendate="2003-12-17 6:29:00" fixdate="2004-07-29 06:19:46">
    <buginformation>
      <summary>Special case if(false) to not require a dynamic test</summary>
      <description>FastMatch, the efficient pattern matching for pointcuts on the constant pool, is
currrently only implemented for the within pointcut. I am planning to provide
further oimplementations for other pointcuts by release 1.2.</description>
      <comments>
		<comment id="1" date="2004-02-19 09:41:06 EST" author="Adrian Colyer">I've marked this bug as target 1.2 so that we remember to track anything you can 
do here as part of the 1.2 release.</comment>
		<comment id="2" date="2004-02-23 18:14:32 EST" author="Eric Bodden">Created attachment 8114 [details]
Implements recognition of if(false) during FastMatch

With this patch if(false) is evaluated to FuzzyBoolean.NEVER during FastMatch.</comment>
		<comment id="3" date="2004-02-23 18:17:11 EST" author="Eric Bodden">I submitted a small patch for FastMatch of IfPointcut. This adresses the idiom 
"somePointcut() &amp;&amp; if(false)" which is often used to temporarily exclude certain 
pointcuts for debug purposes. Such a pointcut is now automatically evaluated to  
"NEVER" match.</comment>
		<comment id="4" date="2004-02-24 03:53:57 EST" author="Eric Bodden">Created attachment 8118 [details]
Part two of the patch for handling of if(false)

This prevents a method to be generated at all for if(false).</comment>
		<comment id="5" date="2004-03-18 14:38:35 EST" author="Jim Hugunin">First off I've renamed this bug to reflect what you're working on.  This is 
not a fast match issue and that's somewhat confused your solution.

The right way to implement this feature is to modify IfPseudoToken to return a 
Pointcut.MatchesNothing object for the special case of if(false).  This will 
produce a pointcut that has all of its methods correctly implemented to handle 
a pcd that can matches no join points.

There are several problems with your solution.  Starting with the fastMatch 
change:

FuzzyBoolean.NEVER is a very special value that isn't correct here.  You 
should just use FuzzyBoolean.NO as is used in the WithinPointcut that I 
pointed you at as the canonical example for fastmatch.  This is important for 
the case where someone uses !if(false) either directly or through a named 
pointcut.

You also can't just modify fastMatch without making similar modifications to 
the core match routine.  Because of things like !if(false) you need to be 
prepared to handle a normal match call -- I believe your solution would create 
a call to a non-existant method in this case.

I can't believe that you wrote this code:
  if (this.expr.getClass()==FalseLiteral.class) return;

Reflection should be used sparingly and only when really needed.  
Use "this.expr instanceof FalseLiteral" if you must test for type.  Even 
better would be to use methods on Expression if those are available.</comment>
		<comment id="6" date="2004-07-28 11:27:11 EDT" author="Adrian Colyer">I've implemented a variation on Jim's suggestion for if(false) and if(true).
Will resolve the bug as fixed once these are available in a build.</comment>
		<comment id="7" date="2004-07-29 06:19:46 EDT" author="Adrian Colyer">Fix available in latest build from www.eclipse.org/aspectj.</comment>
		<comment id="8" date="2004-10-21 04:32:22 EDT" author="Adrian Colyer">Fix released as part of AspectJ 1.2.1</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="10c6de6fbc8a0b9eb07801f4ac19bea8304a9cb3" author="acolyer" date="2004-07-29 12:13:09"/>
          <file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/IfPseudoToken.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/patterns/IfPointcut.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/patterns/Pointcut.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="64331" opendate="2004-5-27 9:58:00" fixdate="2004-07-29 06:21:30">
    <buginformation>
      <summary>java.lang.NullPointerException in WeaverMessageHandler class</summary>
      <description>I've got an java.lang.NullPointerException while running the aspectJ 1.2
compiler. That's the stack trace:
     [iajc] If you don't find the exception below in a bug, please add a new bug
     [iajc] at http://bugs.eclipse.org/bugs/enter_bug.cgi?product=AspectJ
     [iajc] To make the bug a priority, please include a test program
     [iajc] that can reproduce this exception.
     [iajc] null
     [iajc] java.lang.NullPointerException
     [iajc]     at org.aspectj.ajdt.internal.compiler.WeaverMessageHandler.buildSeeAlsoProblems(WeaverMessageHandler.java:172)
     [iajc]     at org.aspectj.ajdt.internal.compiler.WeaverMessageHandler.handleMessage(WeaverMessageHandler.java:100)
     [iajc]     at org.aspectj.weaver.ResolvedTypeX.checkInterTypeMungers(ResolvedTypeX.java:989)
     [iajc]     at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:716)
     [iajc]     at org.aspectj.weaver.bcel.BcelWeaver.weaveWithoutDump(BcelWeaver.java:689)
     [iajc]     at org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify(BcelWeaver.java:615)
     [iajc]     at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:563)
     [iajc]     at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave(AjCompilerAdapter.java:239)
     [iajc]     at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling(AjCompilerAdapter.java:114)
     [iajc]     at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:376)
     [iajc]     at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:601)
     [iajc]     at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:160)
     [iajc]     at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:94)
     [iajc]     at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:102)
     [iajc]     at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:53)
     [iajc]     at org.aspectj.tools.ajc.Main.run(Main.java:280)
     [iajc]     at org.aspectj.tools.ajc.Main.runMain(Main.java:217)
     [iajc]     at org.aspectj.tools.ant.taskdefs.AjcTask.executeInSameVM(AjcTask.java:1157)
     [iajc]     at org.aspectj.tools.ant.taskdefs.AjcTask.execute(AjcTask.java:954)
     [iajc]     at org.apache.tools.ant.Task.perform(Task.java:341)
     [iajc]     at org.apache.tools.ant.taskdefs.Sequential.execute(Sequential.java:117)
     [iajc]     at org.apache.tools.ant.Task.perform(Task.java:341)
     [iajc]     at net.sf.antcontrib.logic.IfTask.execute(Unknown Source)
     [iajc]     at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
     [iajc]     at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
     [iajc]     at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
     [iajc]     at java.lang.reflect.Method.invoke(Method.java:324)
     [iajc]     at org.apache.tools.ant.TaskAdapter.execute(TaskAdapter.java:147)
     [iajc]     at org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:193)
     [iajc]     at org.apache.tools.ant.Task.perform(Task.java:341)
     [iajc]     at org.apache.tools.ant.Target.execute(Target.java:309)
     [iajc]     at org.apache.tools.ant.Target.performTasks(Target.java:336)
     [iajc]     at org.apache.tools.ant.Project.executeTarget(Project.java:1339)
     [iajc]     at org.apache.tools.ant.Project.executeTargets(Project.java:1255)
     [iajc]     at org.apache.tools.ant.Main.runBuild(Main.java:609)
     [iajc]     at org.apache.tools.ant.Main.start(Main.java:196)
     [iajc]     at org.apache.tools.ant.Main.main(Main.java:235)

       [if] Error in class net.sf.antcontrib.logic.IfTask


Sorry, i have no simple test case for that problem...</description>
      <comments>
		<comment id="1" date="2004-07-28 10:58:31 EDT" author="Andrew Clement">This error occurs because type mungers don't remember their source location.

In this particular case, a type munger is ITDing an abstract method onto a class
and then a subclass of that class is not implementing the ITDed method.  The NPE
occurs if, at the point the subclass is compiled, the aspect containing the
inter type declaration is in binary source form rather than real source form. 
When it is in binary source form the ITD doesn't know its originating source
location and when we want to put out an error message that says 'subclass needs
to implement abtract intertype declaration' we pass a null location as the 'see
also' location.

Until type mungers remember their source location, the fix is to say that if we
have no source location for the munger, use the source location of the
containing aspect.

I have also put some code in the message handling code that will barf if anyone
passes a null location again, so it will be more obvious what the problem is in
future bugs.

fix checked in - waiting for build.</comment>
		<comment id="2" date="2004-07-29 06:21:30 EDT" author="Andrew Clement">Fix available in latest dev build from www.eclipse.org/aspectj.</comment>
		<comment id="3" date="2004-07-30 08:33:34 EDT" author="Andrew Clement">*** Bug 71148 has been marked as a duplicate of this bug. ***</comment>
		<comment id="4" date="2004-10-21 04:32:44 EDT" author="Adrian Colyer">Fix released as part of AspectJ 1.2.1</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="573741c8081c6b6b45921cafaae39f37eede2302" author="aclement" date="2004-07-28 11:43:40"/>
          <file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/WeaverMessageHandler.java">
          </file>
          <file name="tests/bugs/abstractITDs/A.java">
          </file>
          <file name="tests/bugs/abstractITDs/C.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/ResolvedTypeX.java">
              <method name="checkInterTypeMungers" returnType="void" parameters=""/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="70241" opendate="2004-7-16 11:41:00" fixdate="2004-08-18 03:18:02">
    <buginformation>
      <summary>outline view shows anonymous inner classes in different way than jdt outline</summary>
      <description>See screenshots.</description>
      <comments>
		<comment id="1" date="2004-07-16 11:41:51 EDT" author="Luzius Meisser">Created attachment 13368 [details]
ajdt outline

ajdt outline</comment>
		<comment id="2" date="2004-07-16 11:42:21 EDT" author="Luzius Meisser">Created attachment 13369 [details]
jdt outline

jdt outline</comment>
		<comment id="3" date="2004-07-19 15:10:59 EDT" author="Mik Kersten">Assuming that AJDT is not changing the IHierarchy that it gets for this, this 
fix should happen in the ASM.  I'm moving to AspectJ, reassigning to me and 
planning on doing it this week.</comment>
		<comment id="4" date="2004-08-17 05:47:35 EDT" author="Andrew Clement">Sorry I've stolen your bug Mik.  Fix checked in, from the testcase in ajde:

Left hand side is before the fix, right hand side is after:

&lt;root&gt;
  InnerClasses.java
    import declarations
    InnerClasses
      A     A
        method      method
        1        new Runnable() {..}
          run          run
      main    main
      2       new Runnable() {..}
         run        run
      3       new Object() {..}
        toString       toString
      4       new Runnable
        run        run

which matches the JDT and looks much nicer :)

Waiting for build before closing bug (and then Luzius to confirm it is OK).</comment>
		<comment id="5" date="2004-08-18 03:18:02 EDT" author="Andrew Clement">Fix available:

BUILD COMPLETE -  build.343
Date of build: 08/17/2004 14:25:48
Time to build: 93 minutes 22 seconds
Last changed: 08/17/2004 11:16:03
Latest good AspectJ jar available at:
download.eclipse.org/technology/ajdt/dev/aspectj-DEVELOPMENT.jar

Luzius - I will put a new AJDE update in for AJDT sometime today that includes
the fix.</comment>
		<comment id="6" date="2004-08-18 12:50:41 EDT" author="Mik Kersten">Definitely better.  The number convention was something I did to match the way 
Eclipse worked waaaaay back.</comment>
		<comment id="7" date="2004-10-21 04:32:55 EDT" author="Adrian Colyer">Fix released as part of AspectJ 1.2.1</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="a2469c733c9f65514c3949cb1cc7254495011894" author="aclement" date="2004-08-17 06:37:46"/>
          <file name="ajde/testdata/extensions/InnerClasses.java">
          </file>
          <file name="ajde/testsrc/org/aspectj/ajde/ExtensionTests.java">
          </file>
          <file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmHierarchyBuilder.java">
              <method name="visit" returnType="boolean" parameters="TypeDeclaration BlockScope"/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="69459" opendate="2004-7-7 9:10:00" fixdate="2004-07-28 10:59:44">
    <buginformation>
      <summary>Hiding of Instance Methods by static methods</summary>
      <description>Using Introduction it is possible to hide instance methods by static methods.
Example:

class Super {
  public void m(){};
}
class Sub {}

aspect A {
  public static void Sub.m(){}
}

Acccording to the Java Language Specification this is not allowed. Is this
behaviour desired ??

It is also possible to override static methods by instance methods, wich causes
a compile time error in java.</description>
      <comments>
		<comment id="1" date="2004-07-27 10:28:33 EDT" author="Andrew Clement">Fix checked in - waiting for build.</comment>
		<comment id="2" date="2004-07-28 10:59:44 EDT" author="Andrew Clement">Fixed 

BUILD COMPLETE -  build.317
Date of build: 07/28/2004 12:16:33
Time to build: 121 minutes 44 seconds
Last changed: 07/27/2004 18:38:25
Latest good AspectJ jar available at:
download.eclipse.org/technology/ajdt/dev/aspectj-DEVELOPMENT.jar</comment>
		<comment id="3" date="2004-10-21 04:32:00 EDT" author="Adrian Colyer">Fix released as part of AspectJ 1.2.1</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="b18436307ecfed63c8995fd35013ffa07e5116e7" author="aclement" date="2004-07-27 11:17:32"/>
          <file name="tests/bugs/intertypeOverrides/Aspect1.java">
          </file>
          <file name="tests/bugs/intertypeOverrides/Aspect2.java">
          </file>
          <file name="tests/bugs/intertypeOverrides/IntertypeOverrides.java">
          </file>
          <file name="tests/bugs/intertypeOverrides/IntertypeOverrides2.java">
          </file>
          <file name="tests/bugs/intertypeOverrides/Subclass.java">
          </file>
          <file name="tests/bugs/intertypeOverrides/Superclass.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/ResolvedTypeX.java">
              <method name="compareToExistingMembers" returnType="boolean" parameters="ConcreteTypeMunger Iterator"/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="30439" opendate="2003-1-28 16:20:00" fixdate="2004-07-30 03:21:37">
    <buginformation>
      <summary>"spurious ""circular dependency"" error"</summary>
      <description>AspectJ Compiler 1.1beta4
This program:

aspect Foo { 
  pointcut p1(): execution(void f()) &amp;&amp; cflow(execution(void f1()));
  pointcut p2(): execution(void f()) &amp;&amp; cflow(execution(void f2()));

  before(): p1() { }
  after():  p1() { }
  before(): p2() { }
  after():  p2() { }
}

class A {
  void f1() { f(); }
  void f2() { f(); }
  void f() { }
}

results in these errors:

circular dependency at method-execution(void A.f())
circular dependency at method-execution(void A.f())
circular dependency at method-execution(void A.f())
circular dependency at method-execution(void A.f())

4 errors

If I comment out any one of the four pieces of advice, all the errors go away.
Also, assuming that there is a valid reason for printing this error sometimes, how come there's no line number?

--Doug</description>
      <comments>
		<comment id="1" date="2003-01-28 16:22:36 EST" author="Doug Orleans">*** Bug 30438 has been marked as a duplicate of this bug. ***</comment>
		<comment id="2" date="2003-01-29 12:06:30 EST" author="Jim Hugunin">The error message needs much work.  It should say something closer to:
  can't determine precedence between two pieces of advice that apply to the 
same join point (method-execution(void A.f()))
  after@2 &gt; before@1 &gt; before@3 &gt; after@2
I'll leave this as a bug until the error message is improved; however, 
otherwise the compiler is correct to prohibit this particular aspect

You should be able to fix this problem by grouping both of your after advice 
together lexically, i.e.
before p1
before p2
after p1
after p2

The reasons for this are fairly complicated, but have to do with the rules for
ordering multiple pieces of advice that can apply to the same join point.  See 
the section on "Advice precedence" in the semantics secton of the programming 
guide for what might be an explanation.  If you still don't fully understand 
or agree with the issue, please send a message to aspectj-users and either 
Erik or I will explain in more detail.</comment>
		<comment id="3" date="2003-02-13 12:39:10 EST" author="Jim Hugunin">Lowering priority and severity as this is only about a better error message.</comment>
		<comment id="4" date="2003-07-23 13:20:53 EDT" author="Jim Hugunin">*** Bug 40655 has been marked as a duplicate of this bug. ***</comment>
		<comment id="5" date="2004-07-29 10:55:09 EDT" author="Adrian Colyer">This program now outputs the following:

/home/colyer/tmp/Doug.java:5 error can't determine precedence between two or 
more pieces of advice that apply the same join point: method-execution(void A.
f())
before(): p1() { }
^^^^^^^^^^^
 
/home/colyer/tmp/Doug.java:6 error can't determine precedence between two or 
more pieces of advice that apply the same join point: method-execution(void A.
f())
after():  p1() { }
^^^^^^^^^^^
 
/home/colyer/tmp/Doug.java:7 error can't determine precedence between two or 
more pieces of advice that apply the same join point: method-execution(void A.
f())
before(): p2() { }
^^^^^^^^^^^
 
/home/colyer/tmp/Doug.java:8 error can't determine precedence between two or 
more pieces of advice that apply the same join point: method-execution(void A.
f())
after():  p2() { }
^^^^^^^^^^^
 

4 errors

Will close the defect once this is available in a published build.</comment>
		<comment id="6" date="2004-07-29 11:17:19 EDT" author="Adrian Colyer">*** Bug 57993 has been marked as a duplicate of this bug. ***</comment>
		<comment id="7" date="2004-07-29 13:12:26 EDT" author="Adrian Colyer">The even better version...

/home/colyer/tmp/Doug.java:5 [error] can't determine precedence between two or 
more pieces of advice that apply to the same join point: method-execution(void 
A.f())
before(): p1() { }
^^^^^^^^^^^
 
/home/colyer/tmp/Doug.java:6 [error] can't determine precedence between two or 
more pieces of advice that apply to the same join point: method-execution(void 
A.f())
after():  p1() { }
^^^^^^^^^^^
 
/home/colyer/tmp/Doug.java:7 [error] can't determine precedence between two or 
more pieces of advice that apply to the same join point: method-execution(void 
A.f())
before(): p2() { }
^^^^^^^^^^^
 
/home/colyer/tmp/Doug.java:8 [error] can't determine precedence between two or 
more pieces of advice that apply to the same join point: method-execution(void 
A.f())
after():  p2() { }
^^^^^^^^^^^
 

4 errors


Thanks :)</comment>
		<comment id="8" date="2004-07-30 03:21:37 EDT" author="Adrian Colyer">Fix now available from AspectJ download page.</comment>
		<comment id="9" date="2004-10-21 04:32:39 EDT" author="Adrian Colyer">Fix released as part of AspectJ 1.2.1</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="4feb835a5339c3f63d73fbd6db2fe307e1f08ed1" author="acolyer" date="2004-07-30 12:04:00"/>
          <file name="weaver/src/org/aspectj/weaver/Advice.java">
              <method name="match" returnType="boolean" parameters="Shadow World"/>
          </file>
          <file name="weaver/src/org/aspectj/weaver/Lint.java">
              <method name="setFromProperties" returnType="void" parameters="File"/>
          </file>
          <file name="weaver/src/org/aspectj/weaver/NewConstructorTypeMunger.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/ResolvedTypeX.java">
              <method name="compareToExistingMembers" returnType="boolean" parameters="ConcreteTypeMunger Iterator"/>
          </file>
          <file name="weaver/src/org/aspectj/weaver/Shadow.java">
              <method name="checkCanThrow" returnType="boolean" parameters="ShadowMunger ResolvedTypeX"/>
          </file>
          <file name="weaver/src/org/aspectj/weaver/WeaverMessages.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/WeaverStateInfo.java">
              <method name="getTypeMungers" returnType="List" parameters="ResolvedTypeX"/>
          </file>
          <file name="weaver/src/org/aspectj/weaver/World.java">
              <method name="resolve" returnType="ResolvedTypeX" parameters="TypeX boolean"/>
          </file>
          <file name="weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/bcel/ClassPathManager.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/bcel/LazyClassGen.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/patterns/ArgsPointcut.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/patterns/CflowPointcut.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/patterns/DeclareParents.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/patterns/DeclarePrecedence.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/patterns/DeclareSoft.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/patterns/IfPointcut.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/patterns/PerFromSuper.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/patterns/ReferencePointcut.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/patterns/ThisOrTargetPointcut.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/patterns/TypePattern.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java">
          </file>
          <file name="weaver/testsrc/org/aspectj/weaver/BcweaverTests.java">
              <method name="suite" returnType="Test" parameters=""/>
          </file>
          <file name="weaver/testsrc/org/aspectj/weaver/WeaverMessagesTestCase.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="71377" opendate="2004-8-4 10:21:00" fixdate="2004-08-09 09:07:14">
    <buginformation>
      <summary>Cannot advise private method call in around advice</summary>
      <description>Pointcuts should match call joint points in advice. However AspectJ does not 
match calls to _private_ methods in around advice. The same applies to get/set 
pointcuts for _private fields. This is probably because in the testcase below 
a call to "privateMethod()" in the body of the around advice is a call to an 
accessor method:

        
ajc$inlineAccessMethod$bug_nnnn_JoinPointInAroundAdvice$bug_nnnn_JoinPointInAro
undAdvice$privateMethod("around");

public aspect JoinPointInAroundAdvice {

	private static Set privateCalls = new HashSet();
	private static Set publicCalls = new HashSet();
	
	pointcut internalCall () :
		call(* JoinPointInAroundAdvice.privateMethod(..));
	
	before () : internalCall () {
		privateCalls.add(thisJoinPoint);
	}

	pointcut externalCall () :
		call(* JoinPointInAroundAdvice.publicMethod(..));
	
	before () : externalCall () {
		publicCalls.add(thisJoinPoint);
	}
	
	pointcut execTest () :
		execution(* JoinPointInAroundAdvice.test());
	
	before () : execTest () {
		privateMethod("before");
		publicMethod("before");
	}
	
	void around () : execTest () {
		privateMethod("around");
		publicMethod("around");
		proceed();
	}
	
//	void around () : execTest () {
//		Runnable runnable = new Runnable () {
//			public void run () {
//				privateMethod("around closure");
//				publicMethod;
//				proceed();
//			}
//		};
//		runnable.run();
//	}
	
	after () : execTest () {
		privateMethod("after");
		publicMethod("after");
	}
	
	private static void privateMethod (String from) {
		System.out.println("? privateMethod() " + from);
	}
	
	public static void publicMethod (String from) {
		System.out.println("? publicMethod() " + from);
	}
	
	public static void test () {
		System.out.println("? test()");
		privateMethod("test");
		publicMethod("test");
	}
	
	public static void main (String[] args) {
		test();
		
		if (privateCalls.size() != publicCalls.size()) {
			throw new RuntimeException("Missing join point");
		}
		else {
			System.out.println("Success.");
		}
	}
}</description>
      <comments>
		<comment id="1" date="2004-08-06 13:04:13 EDT" author="Andrew Clement">I better write up where I am before I forget!!!

I thought this was going to be one of those bugs where you start diagnosing it
and discover there is a fatal flaw in AspectJ.  I think like this about most
hard bugs, but every single time (including this one) I discover that there is a
perfectly ideal framework for solving the bug, someone just forgot to fill in
this piece of it.

The compiler has a notion of an effective signature which is used for inter type
declarations - it enables you to do something clever (like call an accessor
method on another class) but pretend it casts an entirely different join point
shadow (like a field access).

As Matthew points out, the problem is that there is a grotty generated accessor
method:

ajc$inlineAccessMethod$bug_nnnn_JoinPointInAroundAdvice$bug_nnnn_JoinPointInAro
undAdvice$privateMethod("around");

that is being called which just delegates to the real 'privateMethod()'.

My first plan of attack was to work purely in the weaver and when I saw
something like this I'd try and undo the generated name (i know, i know) and
create an effective signature of 'privateMethod()' which would then be matched.
Yes, it was insane, I was young and foolish yesterday when I was trying that. 
Little did I know there was a grotty testcase in the suite that would never let
me do it that way.  Look at this:

aspect EnsureShipIsAlive {
    void around (Ship ship): Ship.helmCommandsCut(ship) {
        if ( ship.isAlive() ) {
            proceed(ship);
        }
    }
}

in SpaceWar.  The call 'ship.isAlive()' is another example of a missing shadow
that we haven't been able to match on.  That kind of call created a *ReAlLy*
horrible accessor, and isAlive() isn't even declared on ship, it is on the
superclass of ship, SpaceObject.

So, forget that, what I need to do is remember what the accessor was generated
for at compilation time and use that at weave time when trying to create this
'fake shadow'.  All I have to do to make this work is create an
effectivesignature attribute against the generated accessor method and then the
magic in BcelClassWeaver.matchInvokeInstruction() will pick up the attribute I
stuffed into the file and use it to create a shadow we can match against.

This worked perfectly ...

and then ...

I hit a problem with thisJoinPoint.  Objects that represent TJPs throughout the
code are usually created PRIVATE STATIC FINAL.  The problem is that I had now
surfaced some new join points in code that might get inlined, and if you advised
those join points and used thisJoinPoint then in the advice, we attempted to
reference a PRIVATE STATIC FINAL TJP instance in the class where the shadow
existed before inlining.  Usually resulting in a verify error.

So I modified the code that generates TJP instances to allow them to be public
if the enclosing method for the shadow is inside around advice (I didn't do
before and after advice as well, because that broke more tests and I believe we
don't inline before or after advice).

Was that it?

Well, that covers calls to private methods from around advice...

what it doesnt cover is sets or gets of private fields in around advice.  Aha, I
thought, this will be easy, I just create an effectivesignature at compile time
and the backend will do the right thing.

But no ... at compile time I haven't quite found a way (at the point we generate
the attribute) to know if it is a set or a get.  I know it is a field access but
not what kind.  How about I put in a compile time flag so you can choose which
you want?  ... only joking - I will get this fixed soon as I can.</comment>
		<comment id="2" date="2004-08-09 06:40:59 EDT" author="Andrew Clement">Fixed.

I rejiggled the fix in AspectDeclaration.  Rather than generating new attributes
in the generateMethod() method, you can pass an optional set of additional
attributes when you call generateMethod() and these will be attached to the
generated code.

If the method being generated is an inlineAccessMethod for a private method
call, we have a MethodCall effective signature attribute.  For
inlineAccessMethods that represent field accesses we add either the field_set or
field_get attribute.  Creating the attributes outside of the generateMethod()
attribute enabled me to know enough to differentiate between field set and field
get.

Fix checked in, waiting for build before closing.</comment>
		<comment id="3" date="2004-08-09 09:07:14 EDT" author="Andrew Clement">Fix available:

BUILD COMPLETE -  build.331
Date of build: 08/09/2004 11:57:04
Time to build: 117 minutes 38 seconds
Last changed: 08/09/2004 11:27:04
Last log entry: Fix for Bug 71377: Cannot advise private method call in around
advice
Latest good AspectJ jar available at:
download.eclipse.org/technology/ajdt/dev/aspectj-DEVELOPMENT.jar</comment>
		<comment id="4" date="2004-10-21 04:32:54 EDT" author="Adrian Colyer">Fix released as part of AspectJ 1.2.1</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="851da68a07bcbfac4414fadc1b9f3bc02fa810a5" author="aclement" date="2004-08-09 07:26:53"/>
          <file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectDeclaration.java">
          </file>
          <file name="tests/bugs/AroundAdviceJPs/FieldGetJoinPointsInAroundAdvice.java">
          </file>
          <file name="tests/bugs/AroundAdviceJPs/FieldJoinPointsInAroundAdvice.java">
          </file>
          <file name="tests/bugs/AroundAdviceJPs/JoinPointInAroundAdvice.java">
          </file>
          <file name="tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/bcel/LazyClassGen.java">
              <method name="getTjpField" returnType="Field" parameters="BcelShadow"/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="67592" opendate="2004-6-17 4:06:00" fixdate="2004-08-09 15:13:15">
    <buginformation>
      <summary>value in the args[] array of thisjoinpoint can be changed by one advice decl and updated values seen in another advice decl</summary>
      <description>In ajc a use of thisJoinPoint corresponds to an object of type JoinPoint, where
a JoinPoint object has four components, which can be retrieved using
accessor methods.

  this                   getThis()
  target                 getTarget()
  args                   getArgs()
  staticJoinPoint        getStaticPart()

In the case of args, the object returned is an Object array.  This means
that an advice decl can overwrite the args,  and then another advice which
shares the same JoinPoint will see the changed args.   Here is a
small example.  In this aspect the
before advice changes arg[0] to always be "Laurie" and then the after
advice will always say that "Laurie won a million pounds".

Is this the behaviour that is intended?   I would have thought that the
interface to args[] should be such that the values can only be read.  Otherwise
very strange interactions between advice decls could occur.

---------------------------------------------------------------------

public class Main {

  public static Main v = new Main();

  void lottery ( String arg )
    { System.out.println("The arg in lottery is " + arg);
    }

  public static void main (String args[])
    { v.lottery("Oege");
      v.lottery("Ganesh");
    }

}

---------------------------------------------------------------------

public aspect Aspect {

  // This pair of advice decls demonstrates that an advice can change to
  //   the args of a join point.

  before () : call(* lottery(java.lang.String)) &amp;&amp; !within(Aspect)
    { System.out.println("BEFORE " + thisJoinPoint +
                         " at " + thisJoinPointStaticPart.getSourceLocation());
      Object args[] = thisJoinPoint.getArgs();
      System.out.println("arg[0] is " + args[0]);
      args[0] = "Laurie";
      System.out.println("... now it is " + thisJoinPoint.getArgs()[0]);
    }


  after ()  : call(* lottery(java.lang.String)) &amp;&amp; !within(Aspect)
    { System.out.println("AFTER " + thisJoinPoint +
                         " at " + thisJoinPointStaticPart.getSourceLocation());
      if (thisJoinPoint.getArgs()[0].equals("Laurie"))
        System.out.println("Laurie wins 1 million pounds!");
    }

}</description>
      <comments>
		<comment id="1" date="2004-08-06 08:45:58 EDT" author="Adrian Colyer">will fix this on Monday... simple matter of taking a defensive copy of the args before handing them out.</comment>
		<comment id="2" date="2004-08-09 09:03:12 EDT" author="Adrian Colyer">getArgs() now returns an Object[] with the same behaviour as arguments in a 
method or in advice parameters: any change to an object reference in the array 
is not visible outside of the advice body, but any change to the state of an 
argument (calling a method on a referenced arg object) is visible.

Will close the defect once this fix is available in a published build.</comment>
		<comment id="3" date="2004-08-09 15:13:15 EDT" author="Adrian Colyer">fix now available in latest jar published from the Aspectj download page.</comment>
		<comment id="4" date="2004-10-21 04:32:56 EDT" author="Adrian Colyer">Fix released as part of AspectJ 1.2.1</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="f6436e3fc84f7e140acb3a250a29fe38f9c20c35" author="acolyer" date="2004-08-09 09:48:11"/>
          <file name="runtime/src/org/aspectj/runtime/reflect/JoinPointImpl.java">
          </file>
          <file name="runtime/testsrc/RuntimeModuleTests.java">
          </file>
          <file name="runtime/testsrc/org/aspectj/runtime/reflect/JoinPointImplTest.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="67774" opendate="2004-6-18 4:54:00" fixdate="2004-08-02 12:06:47">
    <buginformation>
      <summary>Nullpointer-exception in pointcuts using withincode() clause</summary>
      <description>Hi,
I am getting null-pointer-exceptions whenever I try to specify a pointcut with 
a "withincode(Signature)" clause. E.g.:

public aspect DetectSystemOutErrorUsage 
{
pointcut allSystemOutAndSystemErrAccesses(): 
	(get(* System.out) || get(* System.err))
	;

declare warning: 
	allSystemOutAndSystemErrAccesses() 
	&amp;&amp; !adviceexecution()
	&amp;&amp; !within(com.tivoli.act..Test*)
	&amp;&amp; !within(com.tivoli.act.log..*)
	&amp;&amp; !execution(* com.tivoli.act..*.main(..))
	&amp;&amp; !execution(* com.tivoli.act..*.usage())
	// &amp;&amp; !withincode(* com.tivoli.act..*.main(..))
	// &amp;&amp; !withincode(* com.tivoli.act..*.usage())
	: "Warning: use of System.out or System.err - consider logging 
instead!";
}

In the above example excluding main() and usage() methods from the pointcut 
using an execution(...)-clause (shows) works but using a withincode()-clause 
(as commented) always yields an NPE:

trouble in:
null
java.lang.NullPointerException
        at org.aspectj.weaver.patterns.SignaturePattern.matches
(SignaturePattern.java:87)
        at org.aspectj.weaver.patterns.WithincodePointcut.match
(WithincodePointcut.java:42)
        at org.aspectj.weaver.patterns.NotPointcut.match(NotPointcut.java:45)
        at org.aspectj.weaver.patterns.AndPointcut.match(AndPointcut.java:42)
        at org.aspectj.weaver.patterns.AndPointcut.match(AndPointcut.java:42)
        at org.aspectj.weaver.patterns.AndPointcut.match(AndPointcut.java:42)
        at org.aspectj.weaver.patterns.AndPointcut.match(AndPointcut.java:42)
        at org.aspectj.weaver.patterns.AndPointcut.match(AndPointcut.java:42)
        at org.aspectj.weaver.patterns.AndPointcut.match(AndPointcut.java:42)
        at org.aspectj.weaver.patterns.AndPointcut.match(AndPointcut.java:42)
        at org.aspectj.weaver.ShadowMunger.match(ShadowMunger.java:62)
        at org.aspectj.weaver.Checker.match(Checker.java:48)
        at org.aspectj.weaver.bcel.BcelClassWeaver.match(BcelClassWeaver.java:1121)
        at org.aspectj.weaver.bcel.BcelClassWeaver.matchInit(BcelClassWeaver.java:895)
        at org.aspectj.weaver.bcel.BcelClassWeaver.match(BcelClassWeaver.java:793)
        at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:343)
        at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:80)
        at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:724)
        at org.aspectj.weaver.bcel.BcelWeaver.weaveWithoutDump(BcelWeaver.java:689)
        at org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify(BcelWeaver.java:615)
        at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:563)
        at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave(AjCompilerAdapter.java:239)
        at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling(AjCompilerAdapter.java:114)
        at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:376)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:601)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:160)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:94)
        at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:108)
        at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:165)
!SESSION Jun 18, 2004 10:49:48.666 ---------------------------------------------
eclipse.buildId=I200406110010
java.version=1.4.2_03
java.vendor=Sun Microsystems Inc.
BootLoader constants: OS=win32, ARCH=x86, WS=win32, NL=de_CH

!ENTRY org.eclipse.ajdt.ui 4 0 Jun 18, 2004 10:49:48.666
!MESSAGE NullPointerException thrown: null
!STACK 0
java.lang.NullPointerException
        at org.aspectj.weaver.patterns.SignaturePattern.matches(SignaturePattern.java:87)
        at org.aspectj.weaver.patterns.WithincodePointcut.match(WithincodePointcut.java:42)
        at org.aspectj.weaver.patterns.NotPointcut.match(NotPointcut.java:45)
        at org.aspectj.weaver.patterns.AndPointcut.match(AndPointcut.java:42)
        at org.aspectj.weaver.patterns.AndPointcut.match(AndPointcut.java:42)
        at org.aspectj.weaver.patterns.AndPointcut.match(AndPointcut.java:42)
        at org.aspectj.weaver.patterns.AndPointcut.match(AndPointcut.java:42)
        at org.aspectj.weaver.patterns.AndPointcut.match(AndPointcut.java:42)
        at org.aspectj.weaver.patterns.AndPointcut.match(AndPointcut.java:42)
        at org.aspectj.weaver.patterns.AndPointcut.match(AndPointcut.java:42)
        at org.aspectj.weaver.ShadowMunger.match(ShadowMunger.java:62)
        at org.aspectj.weaver.Checker.match(Checker.java:48)
        at org.aspectj.weaver.bcel.BcelClassWeaver.match(BcelClassWeaver.java:1121)
        at org.aspectj.weaver.bcel.BcelClassWeaver.matchInit(BcelClassWeaver.java:895)
        at org.aspectj.weaver.bcel.BcelClassWeaver.match(BcelClassWeaver.java:793)
        at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:343)
        at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:80)
        at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:724)
        at org.aspectj.weaver.bcel.BcelWeaver.weaveWithoutDump(BcelWeaver.java:689)
        at org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify(BcelWeaver.java:615)
        at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:563)
        at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave(AjCompilerAdapter.java:239)
        at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling(AjCompilerAdapter.java:114)
        at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:376)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:601)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:160)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:94)
        at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:108)
        at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:165)


Michael</description>
      <comments>
		<comment id="1" date="2004-07-26 10:25:17 EDT" author="Andrew Clement">Thanks Michael for privately sending me your source... from all that source I've
finally recreated the problem with this tiny program:

aspect B {
  public A.new(String s) { }
  declare warning: withincode(void main(..)): "X";
}

class A {
  private final static String name = A.class.getName();
}

I suspected it was an initialization issue but I couldn't recreate it myself. 
Then I learned from your application that an ITD'd ctor was also in the mix.

Anyway, I'll now work on fixing it ...</comment>
		<comment id="2" date="2004-07-28 12:20:54 EDT" author="Andrew Clement">*** Bug 65688 has been marked as a duplicate of this bug. ***</comment>
		<comment id="3" date="2004-08-02 09:55:59 EDT" author="Andrew Clement">Ok.  The problem is to do with the preinitialization join point shadow not
correctly returning the right signature for the ctor that contains it.  It
returns null when asked 'where are you?' - which results in an NPE.  Although
the pointcuts we are discussing in this bug are looking for other shadows (not
in ctors), we still attempt to match against preinitialization shadows from ITDd
ctors.  The fix is to simply get it to return the signature for the ctor
containing it.

Fix checked in, waiting for build before closing this bug.</comment>
		<comment id="4" date="2004-08-02 12:06:47 EDT" author="Andrew Clement">Fixed, available in dev build:

BUILD COMPLETE -  build.324
Date of build: 08/02/2004 15:14:37
Time to build: 100 minutes 0 seconds
Last changed: 08/02/2004 14:43:47
Last log entry: Fix for Bugzilla Bug 67774 Nullpointer-exception in pointcuts
using withincode() clause
Latest good AspectJ jar available at:
download.eclipse.org/technology/ajdt/dev/aspectj-DEVELOPMENT.jar</comment>
		<comment id="5" date="2004-10-21 04:32:23 EDT" author="Adrian Colyer">Fix released as part of AspectJ 1.2.1</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="7f19ab47a3df5327c6246420354089d1db1c765f" author="aclement" date="2004-08-02 10:43:43"/>
          <file name="tests/bugs/WithincodeNPE01.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/bcel/BcelShadow.java">
              <method name="getEnclosingCodeSignature" returnType="Member" parameters=""/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="71878" opendate="2004-8-12 12:24:00" fixdate="2004-08-15 05:16:34">
    <buginformation>
      <summary>Bad injar aspect name on Linux</summary>
      <description>If you checkout the "JarUsingProject" project from "org.eclipse.ajdt.test/manual
testing" in the AJDT 1.1.12 tree, and look at the advised-by entries in the
outline view and the context menu of the gutter annotation, on Windows you get
"injar aspect: AbstractAspect.aj", but on Linux you get "injar aspect:
C:\eclipse30AJDTPluginTest\eclipse\workspace\JarGeneratingProject\src\p1\AbstractAspect.aj".
The Windows-style path indicates the location of the original class files in the
JAR file, which was clearly built on Windows.</description>
      <comments>
		<comment id="1" date="2004-08-13 03:20:11 EDT" author="Andrew Clement">I suspect this is the same path issue we hit the other day.  When utilising an
input jar for anything, if the jar contains debug info then it will contain
paths to source files based on the platform on which it was built.  We have to
be careful when processing these paths on a difference platform.  Basically it
means trying to be platform independent using File.separator isn't enough - you
have to allow for slashes either way around wherever you are !</comment>
		<comment id="2" date="2004-08-15 05:16:34 EDT" author="Andrew Clement">Fixed.  Fix available in: 

BUILD COMPLETE -  build.340
Date of build: 08/14/2004 10:57:39
Time to build: 92 minutes 0 seconds
Last changed: 08/14/2004 09:08:57
Latest good AspectJ jar available at:
download.eclipse.org/technology/ajdt/dev/aspectj-DEVELOPMENT.jar

It has been tested in AJDT and will be in 1.1.13.</comment>
		<comment id="3" date="2004-10-21 04:32:17 EDT" author="Adrian Colyer">Fix released as part of AspectJ 1.2.1</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="2dfc73855a1d7ab7652476729e6575f9116e12b8" author="aclement" date="2004-08-13 11:49:39"/>
          <file name="asm/src/org/aspectj/asm/internal/AspectJElementHierarchy.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="72154" opendate="2004-8-18 6:00:00" fixdate="2004-08-27 12:30:24">
    <buginformation>
      <summary>Support for simple dump file</summary>
      <description>When the compiler terminates abnormally (exception) or behaves unexpectedly 
(warning/error/abort) a simple dump of the compiler state should be produced 
to aid problem diagnosis. The content and conditions under which the dump is 
produced should be configurable by the user but the facility should be enabled 
by default for exceptions. Consequently its inclusion should have negligible 
impact on compiler performance and footprint. The file should be attached to 
bug reports to give a complete and objective description of the user's 
environment and support problem resolution where a testcase cannot be provided.

One approach is to write a uniquely name file (using date &amp; time) in the 
current directory e.g "ajcore.20040818.105200.txt" which should be human 
readable (it can be zipped if large) to allow the user to potentially diagnose 
their own problems or remove potentially sensitive data before submission. It 
should contain basic information such as AspectJ version, system properties 
and command line as well as failure information such as _full_ exception stack 
trace, compiler messages and internal compiler state.</description>
      <comments>
		<comment id="1" date="2004-08-19 13:04:53 EDT" author="Matthew Webster">Created attachment 14077 [details]
Dump class and testcases

A new Dump facility consisting of a single org.aspectj.weaver.Dump class with
static methods to generate dump files. Configuration methods and system
properties determine whether a file is produced. By default the file contains
the AspectJ version, system properties, command line, full classpath and
compiler messages. An extensible visitor mechanism allows classes to provide
additional state information.</comment>
		<comment id="2" date="2004-08-27 12:30:24 EDT" author="Andrew Clement">Matthews code is now fully integrated.</comment>
		<comment id="3" date="2004-10-21 04:32:08 EDT" author="Adrian Colyer">Fix released as part of AspectJ 1.2.1</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="f5035234ee878003515413fee5e7e6bfa7a2228d" author="aclement" date="2004-08-23 10:40:31"/>
          <file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/AjdtCommand.java">
          </file>
          <file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java">
          </file>
          <file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java">
          </file>
          <file name="org.aspectj.ajdt.core/src/org/aspectj/tools/ajc/Main.java">
          </file>
          <file name="org.aspectj.ajdt.core/testdata/DumpTestCase/src/HelloWorld.java">
          </file>
          <file name="org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/AjdtBatchTests.java">
              <method name="suite" returnType="Test" parameters=""/>
          </file>
          <file name="org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/CompilerDumpTestCase.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/Dump.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/World.java">
          </file>
          <file name="weaver/testsrc/org/aspectj/weaver/BcweaverTests.java">
              <method name="suite" returnType="Test" parameters=""/>
          </file>
          <file name="weaver/testsrc/org/aspectj/weaver/DumpTestCase.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="68494" opendate="2004-6-24 12:04:00" fixdate="2004-06-24 18:16:24">
    <buginformation>
      <summary>ajdoc does not support .aj files</summary>
      <description>In addition to accepting .java source files ajdoc needs to accept .aj files.</description>
      <comments>
		<comment id="1" date="2004-06-24 18:16:24 EDT" author="Mik Kersten">Fixed.  Someone should verify that this works in AJDT.</comment>
		<comment id="2" date="2004-06-25 05:17:13 EDT" author="Andrew Clement">Luzius has confirmed this is fixed in AJDT 1.1.11, well done Mik !</comment>
		<comment id="3" date="2004-06-25 06:27:16 EDT" author="Adrian Colyer">cool :) that's a great piece of team work. thanks for the speedy turnaround mik</comment>
		<comment id="4" date="2004-10-21 04:32:02 EDT" author="Adrian Colyer">Fix released as part of AspectJ 1.2.1</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="3707411c2b5fdd0294c2ab5305c32766644241f1" author="mkersten" date="2004-06-25 07:11:53"/>
          <file name="ajdoc/src/org/aspectj/tools/ajdoc/Main.java">
              <method name="main" returnType="void" parameters="String[]"/>
          </file>
          <file name="ajdoc/src/org/aspectj/tools/ajdoc/StructureUtil.java">
              <method name="isAnonymous" returnType="boolean" parameters="IProgramElement"/>
          </file>
          <file name="ajdoc/src/org/aspectj/tools/ajdoc/StubFileGenerator.java">
          </file>
          <file name="ajdoc/testsrc/org/aspectj/tools/ajdoc/CoverageTestCase.java">
              <method name="testCoverage" returnType="void" parameters=""/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="72531" opendate="2004-8-24 14:42:00" fixdate="2004-08-25 03:10:41">
    <buginformation>
      <summary>declare warning warns at wrong points</summary>
      <description>I have a "declare warning" declaration that warns on usage of any method that
returns an array of any POJO type, this should point to the methods that in
reality return an array, but i see warnings at points other than these array
returning methods, and also those that have void in their signature. In the
attached files i get a warning at statements like:

&gt;        PrinterWorld p = new PrinterWorld();[in main()method]
&gt;        System.out.println("Hello World!"); 
&gt;    	 return new Integer(3);

and these being the first/only lines in their respective methods.</description>
      <comments>
		<comment id="1" date="2004-08-24 14:42:44 EDT" author="Rohith Ajjampur">Created attachment 14156 [details]
Contains all the classes to reproduce this bug</comment>
		<comment id="2" date="2004-08-24 15:46:16 EDT" author="Adrian Colyer">With the fix for bug 37020, the declare warning statements at least now report 
the correct lines (the previous behaviour was to report the line number of the 
first bytecodes in the body of the method), giving the output below:

C:\temp\de\rohith\HelloWorld.java:4 [warning] *[] returning method called
public static void main(String[] args) {
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        method-execution(void de.rohith.HelloWorld.main(java.lang.String[]))
        see also: C:\temp\de\rohith\HelloWorldAspect.java:17
C:\temp\de\rohith\PrinterWorld.java:7 [warning] *[] returning method called
public void print() {
^^^^^^^^^^^^^^^^^^^^^
        method-execution(void de.rohith.PrinterWorld.print())
        see also: C:\temp\de\rohith\HelloWorldAspect.java:17
C:\temp\de\rohith\PrinterWorld.java:11 [warning] *[] returning method called
public Integer returnInt() {
^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        method-execution(java.lang.Integer de.rohith.PrinterWorld.returnInt())
        see also: C:\temp\de\rohith\HelloWorldAspect.java:17
C:\temp\de\rohith\PrinterWorld.java:15 [warning] *[] returning method called
public Integer[] returnArrayWithCloning() {
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        method-execution(java.lang.Integer[] de.rohith.PrinterWorld.returnArrayW
ithCloning())
        see also: C:\temp\de\rohith\HelloWorldAspect.java:17
C:\temp\de\rohith\PrinterWorld.java:22 [warning] *[] returning method called
public Integer[] returnArrayWithoutCloning() {
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        method-execution(java.lang.Integer[] de.rohith.PrinterWorld.returnArrayW
ithoutCloning())
        see also: C:\temp\de\rohith\HelloWorldAspect.java:17

5 warnings

There remains the issue that the pattern (*[]) seems to be matching any type, 
not any array type. I will look at this tomorrow.</comment>
		<comment id="3" date="2004-08-24 17:15:27 EDT" author="Adrian Colyer">Fixed in tree. Will close bug report once this fix is available in a public 
build. The bug involved the processing of a "*" pattern when postfixed with one 
or more array dimensions. Type patterns other than "*[]" were unaffected by this 
bug.</comment>
		<comment id="4" date="2004-08-25 03:10:41 EDT" author="Adrian Colyer">Fix now available from the AspectJ download page.</comment>
		<comment id="5" date="2004-10-21 04:32:34 EDT" author="Adrian Colyer">Fix released as part of AspectJ 1.2.1</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="82eae551311afbd3a942d54e55b1c569c5f975b8" author="acolyer" date="2004-08-25 06:10:56"/>
          <file name="tests/bugs/pr72531/de/rohith/HelloWorld.java">
          </file>
          <file name="tests/bugs/pr72531/de/rohith/HelloWorldAspect.java">
          </file>
          <file name="tests/bugs/pr72531/de/rohith/PrinterWorld.java">
          </file>
          <file name="tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java">
              <method name="test049_interfaceITD_pr70794_4" returnType="void" parameters=""/>
          </file>
          <file name="weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java">
              <method name="matchesExactlyByName" returnType="boolean" parameters="String"/>
          </file>
          <file name="weaver/testsrc/org/aspectj/weaver/patterns/TypePatternTestCase.java">
              <method name="testInstanceofMatch" returnType="void" parameters=""/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="54421" opendate="2004-3-11 3:00:00" fixdate="2004-08-12 03:10:42">
    <buginformation>
      <summary>Compile time declarations (warning and error) do not accept string concatenation (with +)</summary>
      <description>The following code does not compile because the message uses string 
concatenation (the + operator). 


public class WarningSample {

  public void method() {}
  public void anotherMethod() {
    this.method();
  }

}

aspect WarningAspect {

  pointcut illegalCall(): call(* WarningSample.method())
                &amp;&amp; within(WarningSample);

  // the same thing happens with declare error
  declare warning: illegalCall() : "Hey, don't " +
      "do that, that is not nice. You should do something else";

}</description>
      <comments>
		<comment id="1" date="2004-08-09 15:29:14 EDT" author="Adrian Colyer">marked as target 1.2.1</comment>
		<comment id="2" date="2004-08-11 09:20:04 EDT" author="Andrew Clement">Fixed.  Changed Jims home grown parser to allow for '+' and multi-line strings.

Here is a sick example that now works:

declare warning: call(* *(..)): "abc" +
 "def" + // 'def' was here
 "ghijklmnopqrstuv" /* silly
place
for a 
comment */ +
/* oops */
 "wxyz";

Waiting for build before closing bug.</comment>
		<comment id="3" date="2004-08-12 03:10:42 EDT" author="Andrew Clement">Fix available now:

BUILD COMPLETE -  build.337
Date of build: 08/11/2004 17:19:19
Time to build: 91 minutes 45 seconds
Last changed: 08/11/2004 14:18:49
Last log entry: Tests and fix for Bugzilla Bug 54421 Compile time declarations
(warning and error) do not accept string concatenation (with +)
Latest good AspectJ jar available at:
download.eclipse.org/technology/ajdt/dev/aspectj-DEVELOPMENT.jar</comment>
		<comment id="4" date="2004-10-21 04:32:18 EDT" author="Adrian Colyer">Fix released as part of AspectJ 1.2.1</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="d43a39103f476d95cade6b87b604ee4578de25b3" author="aclement" date="2004-08-11 10:18:24"/>
          <file name="tests/bugs/decwStrings.java">
          </file>
          <file name="tests/bugs/decwStringsErroneous.java">
          </file>
          <file name="tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java">
              <method name="test025_proceedInAround3" returnType="void" parameters=""/>
          </file>
          <file name="weaver/src/org/aspectj/weaver/patterns/PatternParser.java">
              <method name="parseErrorOrWarning" returnType="Declare" parameters="boolean"/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="49657" opendate="2004-1-7 17:27:00" fixdate="2004-08-20 08:24:29">
    <buginformation>
      <summary>Weaver results in rt error if affected base class not exposed</summary>
      <description>I was weaving a 3rd party library and wrote an aspect that should affect both a 
base class and a derived class, but inadvertently wove only the derived class.  
This resulted in the following error. I would like the weaver to catch this 
kind of error at weave (link) time, rather than creating code that results in a 
rt error... I get this error in 1.1.1 final and in a fairly recent version from 
CVS HEAD:

java.lang.AbstractMethodError
	at ajee.logging.LogManager.ajc$interMethodDispatch1
$ajee_logging_LogManager$ajee_logging_Loggable$getLogger(LogManager.java)
	at 
ajee.tracing.ExecutionTracer.ajc$before$ajee_tracing_ExecutionTracer$926
(ExecutionTracer.java:62)
	at library.Derived.&lt;init&gt;(Derived.java:46)

This line is a call to super();

I've attached a small example that reproduces another error that I think is 
related:
C:\devel\test\ctors\twoPass&gt;build

C:\devel\test\ctors\twoPass&gt;call ajc -outjar fullBase.jar sample\Base.java sampl
e\Derived.java
Exception in thread "main" java.lang.ExceptionInInitializerError
        at sample.Derived.&lt;init&gt;(Derived.java:6)
        at sample.Derived.main(Derived.java:13)
Caused by: org.aspectj.lang.NoAspectBoundException
        at sample.Trace.aspectOf(Trace.aj)
        at sample.Trace.&lt;init&gt;(Trace.aj:5)
        at sample.Trace.ajc$postClinit(Trace.aj)
        at sample.Trace.&lt;clinit&gt;(Trace.aj:5)
        ... 2 more</description>
      <comments>
		<comment id="1" date="2004-01-07 17:28:08 EST" author="Ron Bodkin">Created attachment 7354 [details]
test case</comment>
		<comment id="2" date="2004-01-08 10:21:58 EST" author="Matthew Webster">I can reproduce the failure in the testcase however the NoAspectBoundException 
is because the Trace aspect is advising itself (it is also in the sample 
package). If a "!within(Trace)" is used the testcase runs.

We need a more representative testcase.</comment>
		<comment id="3" date="2004-01-21 14:52:58 EST" author="Ron Bodkin">Here's a revised version that replicates the bug by adding in an interface that 
is woven and that the abstract class implements (which isn't woven). I also 
excluded the aspect from affecting itself so the real error is visible:

Exception in thread "main" java.lang.AbstractMethodError: sample.Derived.getLogg
er()Ljava/util/logging/Logger;
        at sample.Trace.ajc$interMethodDispatch1$sample_Trace$sample_Trace$Trace
d$getLogger(Trace.aj)
        at sample.Trace.ajc$before$sample_Trace$d2(Trace.aj:12)
        at sample.Derived.&lt;init&gt;(Derived.java:6)
        at sample.Derived.main(Derived.java:13)</comment>
		<comment id="4" date="2004-01-21 14:53:57 EST" author="Ron Bodkin">Created attachment 7511 [details]
revised test case that exposes the actual bug</comment>
		<comment id="5" date="2004-02-27 10:18:47 EST" author="Andrew Clement">Some notes on this bug ... I think there is something that needs fixing, 
possibly with a compiler error message.
 
Explaining Rons program:
an interface 'Iface' is implemented by an abstract class 'Base' which is then 
extended with a class 'Derived'.

All three are compiled into a jar.  We then take 'Base.class' out of that jar.
The resulting jar with just two classes in it is woven against a Trace aspect. 
(The compiler/weaver can still find Base.class because it is accessible on the 
CLASSPATH). The 'Trace' aspect includes an inner Traced interface onto which 
it ITDs a field and a method.  The aspect declares that all the classes apart 
from itself implement 'Trace'.

We then execute the Derived class which blows up trying to find an 
implementation of the method that was introduced to the interface (getLogger).

I *think* that because getLogger is introduced onto an interface, its 
implementation would normally be introduced into top-most implementors.  
During the compilation that involved the aspect, Base.class was on CLASSPATH 
so not a target for weaving.  This means getLogger() was not introduced onto 
it, even though the abstract method getLogger was introduced upon the 
Trace.Traced interface (so at runtime this manifests as an 
AbstractMethodError).  It seems that in the inheritance hierarchy we 
considered Base.class to be the top most implementor of Traced - even though 
it couldn't be woven?

Tracing the compile that involved the 2 class jar and the aspect, I see a 
mungeNewMethod() for the getLogger ITD on the interface Traced and I see a 
mungeNewField() for the ITDd field on Traced.  I don't see (obviously) the 
mungeNewMethod() for the getLogger implementation on Base.class.

I think we should have thrown an error on this compile when we couldn't 
introduce the method implementation into the right place?

However... it is possibly more subtle than that because if I take the 
interface Iface entirely out of the frame, so I simply have an abstract class 
Base and its subclass Derived and I repeat the steps above, it works - in this 
situation the getLogger() implementation is put into Derived ?!?

phew.</comment>
		<comment id="6" date="2004-03-04 21:38:20 EST" author="Jim Hugunin">This bug has strong similarities to #52107.  In this case it seems that the 
compiler isn't checking that it has access to the top-most implementors of an 
interface that has a concrete introduction on it.  My guess is that you want 
to modify the same ResolvedTypeMunger.matches method to also do this check for 
the top-most implementors when the target type is an interface.</comment>
		<comment id="7" date="2004-03-16 04:56:02 EST" author="Adrian Colyer">updated to milestone 1.2</comment>
		<comment id="8" date="2004-08-09 15:25:07 EDT" author="Adrian Colyer">marked as target 1.2.1</comment>
		<comment id="9" date="2004-08-19 10:28:07 EDT" author="Andrew Clement">Progress. And it explains my confused comment made a couple of months back.

We have interface 'Iface' and implementor of that 'Base' and subclass of Base
called 'Derived'.  Iface and Derived are accessible for weaving.

An aspect makes a non-abstract ITD onto an interface called 'Traced' and also a
declare parents statement for everything (Iface/Base/Derived) to implement 'Traced'.

The problem arises due to an ordering issue - our approach is to go through each
type and for each one apply all type mungers then all shadow mungers.  I think
this is still right.  The problem here is that we match the munger for the ITD
against the 'Derived' class and correctly discover (at that point in time) that
it is indeed the top most implementor of 'Traced' because 'Base' wasn't touched
by the declare parents statement.  However ... just after we discover it is
'Derived' we then move on to 'IFace' and apply the declare parents statement to
it.  This means IFace implements Traced and therefore Base now implements Traced
even though we didn't actually touch Base.  What happens later on is that we
make this check:

if (onInterface &amp;&amp;                             // The ITD was on an interface 
    !Modifier.isAbstract(signature.getModifiers()) &amp;&amp; // It was not abstract
    gen.genType().isTopmostImplementor(onType)) { // we are looking at the
                                                  // top most implementor.
 // Stick the body of the ITD method in.

This fails because isTopmostImplementor now returns false for 'Derived' at the
point we do the weave - in this situation we quietly do nothing and so you don't
get an implementation of the ITD put anywhere!  

I have changed this slightly so that if we are processing a type that is no
longer the top most implementor (when it used to be) then report an error that
we need access to the proper top most implementor for weaving:

type sample.Base must be accessible for weaving interface inter type declaration
from aspect sample.Trace


It is an unusual situation because you are giving some of the top and bottom of
an inheritance hierarchy to AspectJ but not the middle bit.</comment>
		<comment id="10" date="2004-08-19 12:45:08 EDT" author="Andrew Clement">Fix checked in - waiting for build.</comment>
		<comment id="11" date="2004-08-20 08:24:29 EDT" author="Andrew Clement">Fix available:

BUILD COMPLETE -  build.349
Date of build: 08/20/2004 10:22:41
Time to build: 93 minutes 15 seconds
Last changed: 08/20/2004 08:18:14
Latest good AspectJ jar available at:
download.eclipse.org/technology/ajdt/dev/aspectj-DEVELOPMENT.jar</comment>
		<comment id="12" date="2004-10-21 04:32:46 EDT" author="Adrian Colyer">Fix released as part of AspectJ 1.2.1</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="dbe1024f852c600d2752e5f39eb31ca4f5d72de9" author="aclement" date="2004-08-20 01:38:16"/>
          <file name="org.aspectj.ajdt.core/testdata/partialHierarchy/sample/Base.java">
          </file>
          <file name="org.aspectj.ajdt.core/testdata/partialHierarchy/sample/Derived.java">
          </file>
          <file name="org.aspectj.ajdt.core/testdata/partialHierarchy/sample/Iface.java">
          </file>
          <file name="org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/AjdtBatchTests.java">
              <method name="suite" returnType="Test" parameters=""/>
          </file>
          <file name="org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/PartiallyExposedHierarchyTestCase.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/ResolvedTypeX.java">
              <method name="isTopmostImplementor" returnType="boolean" parameters="ResolvedTypeX"/>
          </file>
          <file name="weaver/src/org/aspectj/weaver/WeaverMessages.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="62642" opendate="2004-5-18 10:23:00" fixdate="2004-08-18 08:09:34">
    <buginformation>
      <summary>proper handling of ExceptionInIntializer inside &lt;clinit&gt; in presence of after throwing advice</summary>
      <description>When a &lt;clinit&gt; of a class contains after throwing advice that may catch
ExceptionInInitializer errors due to an embedded advice aspectOf() that
fails,  the ExceptionInIntializer error does not get properly reported.

For the example below:

public class Main {
  static int x = 13;
  int y;

  public Main() {
     y= 14;
  }

  public static void main(String args[])
    { Main m = new Main();
      m.y = 3;
      System.out.println("hi");
    }
}


aspect Aspect {

  before () :  within(*)
    { System.out.println("BEFORE " + thisJoinPointStaticPart.getKind() +
                         " at " + thisJoinPointStaticPart.getSourceLocation());
    }

  after ()  : within(*)
    { System.out.println("AFTER " + thisJoinPointStaticPart.getKind() +
                         " at " + thisJoinPointStaticPart.getSourceLocation());
    }
}


....  

when compiled with ajc, and then run,  the following exception is given,

Exception in thread "main" java.lang.NoClassDefFoundError
        at Main.&lt;clinit&gt;(Main.java:1)

when really one wants the following:

Exception in thread "main" java.lang.ExceptionInInitializerError
        at Main. ...
Caused by: org.aspectj.lang.NoAspectBoundException: Aspect
        at Aspect.aspectOf ..
        

-------------

Here is a fix ... I give the decompiled &lt;clinit&gt; for Main.java and indicate with
comments,
  look for ***LJH ****,  what can be woven to fix it.   Basically, the catch
block for after throwing,  when in &lt;clinit&gt;,  should first check if the
caught exception if a ExceptionInInitializerError, and if so just throw it.

----------- static
    {
        org.aspectj.runtime.reflect.Factory r1;
        java.lang.Throwable r2, r31;
        int $i0;

        r1 = new Factory("Main.java", Class.forName("Main"));
        ajc$tjp_0 = r1.makeSJP("field-set", r1.makeFieldSig("8-x-Main-int-"), 2);
        ajc$tjp_1 = r1.makeSJP("staticinitialization",
r1.makeInitializerSig("8--Main-"), 2);
        ajc$tjp_10 = r1.makeSJP("preinitialization",
r1.makeConstructorSig("1--Main----"), 5);
        ajc$tjp_2 = r1.makeSJP("field-set", r1.makeFieldSig("0-y-Main-int-"), 6);
        ajc$tjp_3 = r1.makeSJP("constructor-execution",
r1.makeConstructorSig("1--Main----"), 6);
        ajc$tjp_4 = r1.makeSJP("constructor-call",
r1.makeConstructorSig("1--Main----"), 10);
        ajc$tjp_5 = r1.makeSJP("field-set", r1.makeFieldSig("0-y-Main-int-"), 11);
        ajc$tjp_6 = r1.makeSJP("field-get",
r1.makeFieldSig("19-out-java.lang.System-java.io.PrintStream-"), 12);
        ajc$tjp_7 = r1.makeSJP("method-call",
r1.makeMethodSig("1-println-java.io.PrintStream-java.lang.String:-arg0:--void-"),
12);
        ajc$tjp_8 = r1.makeSJP("method-execution",
r1.makeMethodSig("9-main-Main-[Ljava.lang.String;:-args:--void-"), 10);
        ajc$tjp_9 = r1.makeSJP("initialization",
r1.makeConstructorSig("1--Main----"), 6);

 try
        {
            Aspect.aspectOf().ajc$before$Aspect$1$36f01b1c(ajc$tjp_1);
            $i0 = 13;

            try
            {
                Aspect.aspectOf().ajc$before$Aspect$1$36f01b1c(ajc$tjp_0);
                x = $i0;
            }
            catch (Throwable $r30)
            {
                /*** LJH insert here *****/
                if ($r30 instanceof ExceptionInIntializerError) //***
                  throw($r30); //***
                /***********/
                r31 = $r30;
                Aspect.aspectOf().ajc$after$Aspect$2$36f01b1c(ajc$tjp_0);
                throw r31;
            }

            Aspect.aspectOf().ajc$after$Aspect$2$36f01b1c(ajc$tjp_0);
        }
        catch (Throwable $r36)
        {
           /*** LJH insert here *****/
           if ($r36 instanceof ExceptionInIntializerError) //***
           throw($r36); //***
           /***********/
            r2 = $r36;
            Aspect.aspectOf().ajc$after$Aspect$2$36f01b1c(ajc$tjp_1);
            throw r2;
        }

        Aspect.aspectOf().ajc$after$Aspect$2$36f01b1c(ajc$tjp_1);
    }</description>
      <comments>
		<comment id="1" date="2004-08-09 15:25:38 EDT" author="Adrian Colyer">marked as target 1.2.1</comment>
		<comment id="2" date="2004-08-17 10:07:17 EDT" author="Andrew Clement">argh!  bcel is a nightmare.  It has taken me ages to program BCEL to generate:

 if ($r36 instanceof ExceptionInInitializerError) 
   throw($r36);

This is the final incantation for BCEL:

        if (this.getEnclosingMethod().getName().equals("&lt;clinit&gt;")) {
            ResolvedTypeX eiieType =
              world.resolve("java.lang.ExceptionInInitializerError");
            ObjectType eiieBcelType = 
              (ObjectType)BcelWorld.makeBcelType(eiieType);
            InstructionList ih = new InstructionList(InstructionConstants.NOP);
            handler.append(exceptionVar.createLoad(fact));
            handler.append(fact.createInstanceOf(eiieBcelType));
            BranchInstruction bi = 
                InstructionFactory.createBranchInstruction(
                Constants.IFEQ,ih.getStart());
            handler.append(bi);
            handler.append(exceptionVar.createLoad(fact));
            handler.append(fact.createCheckCast(eiieBcelType));
            handler.append(InstructionConstants.ATHROW);
            handler.append(ih);
        }

I put that in the BcelShadow.weaveAfterThrowing() method.  You can see it does a
check to determine if it is in the &lt;clinit&gt; before generating this extra check.

Here is the extra bytecode that appears in the method:

447: aload_1
448: instanceof      #101; //class ExceptionInInitializerError
451: ifeq    459
454: aload_1
455: checkcast       #101; //class ExceptionInInitializerError
458: athrow
459: nop

Yes, there is one extra NOP but I don't want to fight with BCEL to remove it.

I've put Lauries test program into the test suite to verify it behaves and we
get the ExceptionInInitializerError rather than the NoClassDefFoundError.

Thanks Laurie for describing the right fix :)

fix checked in, waiting for build.</comment>
		<comment id="3" date="2004-08-18 08:09:34 EDT" author="Andrew Clement">Fix available:

BUILD COMPLETE -  build.344
Date of build: 08/18/2004 11:27:31
Time to build: 92 minutes 31 seconds
Last changed: 08/18/2004 10:55:59
Latest good AspectJ jar available at:
download.eclipse.org/technology/ajdt/dev/aspectj-DEVELOPMENT.jar</comment>
		<comment id="4" date="2004-10-21 04:32:59 EDT" author="Adrian Colyer">Fix released as part of AspectJ 1.2.1</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="84e4e53608871ab3ad0381d19abd8fa2e1bc4533" author="aclement" date="2004-08-17 11:04:29"/>
          <file name="tests/bugs/pr62642.java">
          </file>
          <file name="tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java">
              <method name="test042_ITDaccessingPrivateMethod_pr67578_2" returnType="void" parameters=""/>
          </file>
          <file name="weaver/src/org/aspectj/weaver/bcel/BcelShadow.java">
              <method name="weaveAfterThrowing" returnType="void" parameters="BcelAdvice TypeX"/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="70619" opendate="2004-7-22 10:11:00" fixdate="2004-07-27 03:53:38">
    <buginformation>
      <summary>"compiler aborts with ""conflicting dominates orders"" with circular declare precedences"</summary>
      <description>The following program causes ajc 1.2 to abort:

public class Conflict { public static void main(String[] args) { } }

aspect Conflict1 {
  declare precedence: Conflict1, Conflict2;

   before(): execution(* *(..)) { }
}

aspect Conflict2 {
  declare precedence: Conflict2, Conflict1;


  after(): execution(* *(..)) { }
}</description>
      <comments>
		<comment id="1" date="2004-07-26 09:44:30 EDT" author="Andrew Clement">The code was actually throwing a BCException() in this case (very unhelpful). 
The exception on compiling the supplied testcase was:

C:\Eclipse\212\eclipse\aspectj_ws2\tests\bugs\bug70619&gt;ajc Precedence.java
trouble in:
ABORT

Exception thrown from AspectJ DEVELOPMENT

This might be logged as a bug already -- find current bugs at
  http://bugs.eclipse.org/bugs/buglist.cgi?product=AspectJ&amp;component=Compiler

Bugs for exceptions thrown have titles File:line from the top stack,
e.g., "SomeFile.java:243"

If you don't find the exception below in a bug, please add a new bug
at http://bugs.eclipse.org/bugs/enter_bug.cgi?product=AspectJ
To make the bug a priority, please include a test program
that can reproduce this exception.
conflicting dominates orders
conflicting dominates orders
org.aspectj.weaver.BCException: conflicting dominates orders
        at org.aspectj.weaver.World.compareByDominates(World.java:309)
        at org.aspectj.weaver.bcel.BcelAdvice.compareTo(BcelAdvice.java:379)
        at
org.aspectj.util.PartialOrder$SortObject.addDirectedLinks(PartialOrder.java:68)
        at
org.aspectj.util.PartialOrder.addNewPartialComparable(PartialOrder.java:88)
        at org.aspectj.util.PartialOrder.sort(PartialOrder.java:121)
        at org.aspectj.weaver.Shadow.sortMungers(Shadow.java:330)
        at org.aspectj.weaver.Shadow.implement(Shadow.java:323)
        at
org.aspectj.weaver.bcel.BcelClassWeaver.implement(BcelClassWeaver.java:1153)
        at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:361)
        at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:82)
        at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:726)
        at org.aspectj.weaver.bcel.BcelWeaver.weaveWithoutDump(BcelWeaver.java:691)
        at org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify(BcelWeaver.java:617)
        at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:565)
        at
org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave(AjCompilerAdapter.java:239)
        at
org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling(AjCompilerAdapter.java:114)
        at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:376)
        at
org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:717)
        at
org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:170)
        at
org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:100)
        at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:102)
        at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:53)
        at org.aspectj.tools.ajc.Main.run(Main.java:287)
        at org.aspectj.tools.ajc.Main.runMain(Main.java:224)
        at org.aspectj.tools.ajc.Main.main(Main.java:79)


1 fail|abort

I've now fixed it to do correct error handling.  When you get these kinds of
conflict it now says:

C:\Eclipse\212\eclipse\aspectj_ws2\tests\bugs\bug70619\Precedence.java error
conflicting declare precedence orderings for aspects: Conflict1 and Conflict2
(no source information available)
 
see also: C:\Eclipse\212\eclipse\aspectj_ws2\tests\bugs\bug70619\Precedence.java:10
see also: C:\Eclipse\212\eclipse\aspectj_ws2\tests\bugs\bug70619\Precedence.java:4

1 error

The 'see also' locations are the conflicting locations of the declare precedence
statements.  We cannot use one of these locations as the primary location in the
error message because the primary error location for a message must be in the
file that was being processed when the error occurred.  In the case of having
everything in one file this is not an issue, but if the class was in A, and the
aspects were in B and C - we cannot add an error message to B or C whilst
processing A - just in case we have already dealt with B/C and have already
reported all of its errors.</comment>
		<comment id="2" date="2004-07-27 03:53:38 EDT" author="Andrew Clement">fixed:

BUILD COMPLETE -  build.315
Date of build: 07/26/2004 21:28:08
Time to build: 305 minutes 55 seconds
Last changed: 07/26/2004 14:30:19
Last log entry: Fix for Bug 70619 compiler aborts with "conflicting dominates
orders" with circular declare precedences
Latest good AspectJ jar available at:
download.eclipse.org/technology/ajdt/dev/aspectj-DEVELOPMENT.jar</comment>
		<comment id="3" date="2004-10-21 04:33:00 EDT" author="Adrian Colyer">Fix released as part of AspectJ 1.2.1</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="75852d7b1915cddfd4ba3dea272324617abdaa60" author="aclement" date="2004-07-26 10:28:20"/>
          <file name="tests/bugs/bug70619/Conflict.java">
          </file>
          <file name="tests/bugs/bug70619/Precedence.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/World.java">
              <method name="compareByDominates" returnType="int" parameters="ResolvedTypeX ResolvedTypeX"/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="72150" opendate="2004-8-18 3:27:00" fixdate="2004-09-01 03:29:41">
    <buginformation>
      <summary>AJC possible bug with static nested classes</summary>
      <description>AJC fails to find nested static classes during binary-weaving analysis if the 
classes have been previously compiled with J2SE5.0 javac compiler with 
options: -source 1.5/ - target 1.5
Note, that the nested static classes are not necessarily subject to bytecode 
weaving - AJC merely fails to detect them in the JARS for its analysis.

This issue disappears when the .java sources are pre-compiled with -
source/target 1.4, regardless if the javac compiler comes from the J2SE1.4 or 
J2SE5.0 distribution.

This issue is distinct form Bug #71548, since no 5.0 source code processing is 
required from AJC ever.

Thanks,
Hristo</description>
      <comments>
		<comment id="1" date="2004-08-18 03:30:26 EDT" author="Andrew Clement">Hristo, can you send me a built jar that fails binary weaving?  I will try and
recreate it here too.

Andy.</comment>
		<comment id="2" date="2004-08-24 03:21:59 EDT" author="Andrew Clement">Hi,

We have just built a version of AspectJ that includes some rudimentary dump
support - this allows us to collect diagnostic information when things go wrong.
 I'd like to try it out for the first time on this bug.  The version of AspectJ
required is available here (the usual place):

BUILD COMPLETE -  build.356
Date of build: 08/23/2004 16:06:44
Time to build: 125 minutes 0 seconds
Last changed: 08/23/2004 14:40:33
Latest good AspectJ jar available at:
download.eclipse.org/technology/ajdt/dev/aspectj-DEVELOPMENT.jar

Please can you retry your failing Java 1.5 scenario with this version.  AND in
order to cause it to dump on error (it normally just dumps on abort), you will
need to set this property:

org.aspectj.weaver.Dump.condition=error

If that works then when the compiler finishes after reporting your 'Cant find
type' message it will produce an ajcore.XXX file on the disk (XXX is a date/time
stamp).  Can you send me the ajcore file?  That will enable me to tell which
route to can't find type is having problems with the 1.5 generated code.

many thanks.</comment>
		<comment id="3" date="2004-08-26 03:22:29 EDT" author="Andrew Clement">Thanks to Hristo for trying out the brand new dump support in AspectJ.  We got
the following ajcore which tells me the route we took to the 'cant find type'
problem :)

AspectJ Compiler DEVELOPMENT built on Wednesday Aug 25, 2004 at 17:18:41 GMT
---- Dump Properties ---
Dump file: ajcore.20040825.134402.453.txt
Dump reason: error
Dump on exception: true
Dump at exit condition: error
---- System Properties ---
java.runtime.name=Java(TM) 2 Runtime Environment, Standard Edition
sun.boot.library.path=c:\java\j2sdk5\jre\bin
java.vm.version=1.5.0-beta3-b59
ant.library.dir=C:\java\apache-ant\lib
java.vm.vendor=Sun Microsystems Inc.
java.vendor.url=http://java.sun.com/
path.separator=;
java.vm.name=Java HotSpot(TM) Client VM
file.encoding.pkg=sun.io
user.country=US
sun.os.patch.level=Service Pack 2
java.vm.specification.name=Java Virtual Machine Specification
user.dir=C:\projects\marketedge
java.runtime.version=1.5.0-beta3-b59
java.awt.graphicsenv=sun.awt.Win32GraphicsEnvironment
java.endorsed.dirs=c:\java\j2sdk5\jre\lib\endorsed
os.arch=x86
java.io.tmpdir=C:\DOCUME~1\hristo\LOCALS~1\Temp\
line.separator=

java.vm.specification.vendor=Sun Microsystems Inc.
user.variant=
os.name=Windows XP
ant.home=c:\java\apache-ant
sun.jnu.encoding=Cp1252
java.library.path=c:\java\j2sdk5\bin;.;C:\WINDOWS\system32;C:\WINDOWS;C:\WINDOWS\system32;C:\WINDOWS;C:\WINDOWS\System32\Wbem;C:\Program
Files\ATI Technologies\ATI Control
Panel;C:\util\cvsnt;C:\util\xp-tools\;C:\Program
Files\Rational\common;C:\Program Files\Common Files\Roxio Shared\DLLShared
java.specification.name=Java Platform API Specification
java.class.version=49.0
sun.management.compiler=HotSpot Client Compiler
os.version=5.1
org.aspectj.weaver.Dump.condition=error
user.home=C:\Documents and Settings\hristo
user.timezone=America/Los_Angeles
java.awt.printerjob=sun.awt.windows.WPrinterJob
file.encoding=Cp1252
java.specification.version=1.5
java.class.path=c:\java\apache-ant\lib\ant-launcher.jar;C:\java\apache-ant\lib\ant-antlr.jar;C:\java\apache-ant\lib\ant-apache-bcel.jar;C:\java\apache-ant\lib\ant-apache-bsf.jar;C:\java\apache-ant\lib\ant-apache-log4j.jar;C:\java\apache-ant\lib\ant-apache-oro.jar;C:\java\apache-ant\lib\ant-apache-regexp.jar;C:\java\apache-ant\lib\ant-apache-resolver.jar;C:\java\apache-ant\lib\ant-commons-logging.jar;C:\java\apache-ant\lib\ant-commons-net.jar;C:\java\apache-ant\lib\ant-icontract.jar;C:\java\apache-ant\lib\ant-jai.jar;C:\java\apache-ant\lib\ant-javamail.jar;C:\java\apache-ant\lib\ant-jdepend.jar;C:\java\apache-ant\lib\ant-jmf.jar;C:\java\apache-ant\lib\ant-jsch.jar;C:\java\apache-ant\lib\ant-junit.jar;C:\java\apache-ant\lib\ant-launcher.jar;C:\java\apache-ant\lib\ant-netrexx.jar;C:\java\apache-ant\lib\ant-nodeps.jar;C:\java\apache-ant\lib\ant-starteam.jar;C:\java\apache-ant\lib\ant-stylebook.jar;C:\java\apache-ant\lib\ant-swing.jar;C:\java\apache-ant\lib\ant-trax.jar;C:\java\a!
 pache-ant\lib\ant-vaj.jar;C:\java\apache-ant\lib\ant-weblogic.jar;C:\java\apache-ant\lib\ant-xalan1.jar;C:\java\apache-ant\lib\ant-xslp.jar;C:\java\apache-ant\lib\ant.jar;C:\java\apache-ant\lib\commons-net.jar;C:\java\apache-ant\lib\jakarta-oro.jar;C:\java\apache-ant\lib\xercesImpl.jar;C:\java\apache-ant\lib\xml-apis.jar;c:\java\j2sdk5\lib\tools.jar
user.name=hristo
java.vm.specification.version=1.0
java.home=c:\java\j2sdk5\jre
sun.arch.data.model=32
user.language=en
java.specification.vendor=Sun Microsystems Inc.
awt.toolkit=sun.awt.windows.WToolkit
java.vm.info=mixed mode
java.version=1.5.0-beta3
java.ext.dirs=c:\java\j2sdk5\jre\lib\ext
sun.boot.class.path=c:\java\j2sdk5\jre\lib\rt.jar;c:\java\j2sdk5\jre\lib\i18n.jar;c:\java\j2sdk5\jre\lib\sunrsasign.jar;c:\java\j2sdk5\jre\lib\jsse.jar;c:\java\j2sdk5\jre\lib\jce.jar;c:\java\j2sdk5\jre\lib\charsets.jar;c:\java\j2sdk5\jre\classes
java.vendor=Sun Microsystems Inc.
file.separator=\
java.vendor.url.bug=http://java.sun.com/cgi-bin/bugreport.cgi
sun.io.unicode.encoding=UnicodeLittle
sun.cpu.endian=little
sun.desktop=windows
sun.cpu.isalist=
---- Command Line ---
-preserveAllLocals
-g
-target
1.4
-XlazyTjp
-verbose
-outjar
C:\projects\marketedge\build\netbeans\modules\me_exceedsoft.map-1.0.jar
-classpath
C:\projects\marketedge\build\classes;C:\projects\marketedge\netbeans\modules\me_com.vividsolutions.jts-1.4.0.jar;C:\projects\marketedge\netbeans\modules\me_exceedsoft.aspects-1.0.jar;C:\projects\marketedge\netbeans\modules\me_exceedsoft.map-1.0.jar;C:\projects\marketedge\netbeans\modules\me_javax.units-0.01.jar;C:\projects\marketedge\netbeans\modules\me_javax.vectmath-1.3.jar;C:\projects\marketedge\netbeans\modules\me_org.apache.batik-1.5.1.jar;C:\projects\marketedge\netbeans\modules\me_org.garret.perst-231.jar;C:\projects\marketedge\netbeans\modules\me_org.geotools-2.0.jar;C:\projects\marketedge\netbeans\modules\me_org.geotools.shp-2.0.jar;C:\projects\marketedge\netbeans\modules\me_org.geotools.tiger-2.0.jar;C:\projects\marketedge\netbeans\modules\me_org.opengis-1.1.jar;C:\java\netbeans-3_6-platform\lib\core.jar;C:\java\netbeans-3_6-platform\lib\ext\boot.jar;C:\java\netbeans-3_6-platform\lib\openide-loaders.jar;C:\java\netbeans-3_6-platform\lib\openide.jar;C:\java\netbeans-!
 3_6-platform\lib\updater.jar;C:\java\netbeans-3_6-platform\modules\autoload\core-output.jar;C:\java\netbeans-3_6-platform\modules\autoload\core-settings.jar;C:\java\netbeans-3_6-platform\modules\autoload\ext\jh-2.0_01.jar;C:\java\netbeans-3_6-platform\modules\autoload\javahelp-api.jar;C:\java\netbeans-3_6-platform\modules\autoload\openide-io.jar;C:\java\netbeans-3_6-platform\modules\autoload\terminalemulator.jar;C:\java\netbeans-3_6-platform\modules\autoupdate.jar;C:\java\netbeans-3_6-platform\modules\core-ui.jar;C:\java\netbeans-3_6-platform\modules\core-windows.jar;C:\java\netbeans-3_6-platform\modules\text.jar;C:\java\aspectj\lib\aspectjrt.jar;C:\java\aspectj\lib\aspectjtools.jar;C:\java\junit\junit.jar;C:\java\j2sdk5\jre\lib\ext
-aspectpath
C:\projects\marketedge\netbeans\modules\me_exceedsoft.aspects-1.0.jar;C:\projects\marketedge\netbeans\modules\me_org.geotools-2.0.jar;C:\projects\marketedge\netbeans\modules\me_com.vividsolutions.jts-1.4.0.jar
-inpath
C:\projects\marketedge\netbeans\modules\me_exceedsoft.map-1.0.jar
---- Full Classpath ---
C:\projects\marketedge\netbeans\modules\me_exceedsoft.map-1.0.jar(60506 bytes)
C:\projects\marketedge\netbeans\modules\me_exceedsoft.aspects-1.0.jar(11065 bytes)
C:\projects\marketedge\netbeans\modules\me_org.geotools-2.0.jar(2354305 bytes)
C:\projects\marketedge\netbeans\modules\me_com.vividsolutions.jts-1.4.0.jar(251132
bytes)
c:\java\j2sdk5\jre\lib\rt.jar(37556071 bytes)
c:\java\j2sdk5\jre\lib\i18n.jar(missing)
c:\java\j2sdk5\jre\lib\sunrsasign.jar(missing)
c:\java\j2sdk5\jre\lib\jsse.jar(548670 bytes)
c:\java\j2sdk5\jre\lib\jce.jar(81615 bytes)
c:\java\j2sdk5\jre\lib\charsets.jar(8627539 bytes)
c:\java\j2sdk5\jre\classes(missing)
c:\java\j2sdk5\jre\lib\ext\clibwrapper_jiio.jar(36136 bytes)
c:\java\j2sdk5\jre\lib\ext\dnsns.jar(8179 bytes)
c:\java\j2sdk5\jre\lib\ext\jai_codec.jar(213581 bytes)
c:\java\j2sdk5\jre\lib\ext\jai_core.jar(1576540 bytes)
c:\java\j2sdk5\jre\lib\ext\jai_imageio.jar(927714 bytes)
c:\java\j2sdk5\jre\lib\ext\localedata.jar(802505 bytes)
c:\java\j2sdk5\jre\lib\ext\mlibwrapper_jai.jar(41239 bytes)
c:\java\j2sdk5\jre\lib\ext\sunjce_provider.jar(153036 bytes)
c:\java\j2sdk5\jre\lib\ext\sunpkcs11.jar(173235 bytes)
C:\projects\marketedge\build\classes(3 entries)
C:\projects\marketedge\netbeans\modules\me_com.vividsolutions.jts-1.4.0.jar(251132
bytes)
C:\projects\marketedge\netbeans\modules\me_exceedsoft.aspects-1.0.jar(11065 bytes)
C:\projects\marketedge\netbeans\modules\me_exceedsoft.map-1.0.jar(60506 bytes)
C:\projects\marketedge\netbeans\modules\me_javax.units-0.01.jar(25418 bytes)
C:\projects\marketedge\netbeans\modules\me_javax.vectmath-1.3.jar(289947 bytes)
C:\projects\marketedge\netbeans\modules\me_org.apache.batik-1.5.1.jar(4619743 bytes)
C:\projects\marketedge\netbeans\modules\me_org.garret.perst-231.jar(188745 bytes)
C:\projects\marketedge\netbeans\modules\me_org.geotools-2.0.jar(2354305 bytes)
C:\projects\marketedge\netbeans\modules\me_org.geotools.shp-2.0.jar(66907 bytes)
C:\projects\marketedge\netbeans\modules\me_org.geotools.tiger-2.0.jar(15113 bytes)
C:\projects\marketedge\netbeans\modules\me_org.opengis-1.1.jar(163110 bytes)
C:\java\netbeans-3_6-platform\lib\core.jar(2754600 bytes)
C:\java\netbeans-3_6-platform\lib\ext\boot.jar(99458 bytes)
C:\java\netbeans-3_6-platform\lib\openide-loaders.jar(1049966 bytes)
C:\java\netbeans-3_6-platform\lib\openide.jar(3626032 bytes)
C:\java\netbeans-3_6-platform\lib\updater.jar(123818 bytes)
C:\java\netbeans-3_6-platform\modules\autoload\core-output.jar(321351 bytes)
C:\java\netbeans-3_6-platform\modules\autoload\core-settings.jar(207743 bytes)
C:\java\netbeans-3_6-platform\modules\autoload\ext\jh-2.0_01.jar(500623 bytes)
C:\java\netbeans-3_6-platform\modules\autoload\javahelp-api.jar(104813 bytes)
C:\java\netbeans-3_6-platform\modules\autoload\openide-io.jar(9252 bytes)
C:\java\netbeans-3_6-platform\modules\autoload\terminalemulator.jar(289602 bytes)
C:\java\netbeans-3_6-platform\modules\autoupdate.jar(581745 bytes)
C:\java\netbeans-3_6-platform\modules\core-ui.jar(64094 bytes)
C:\java\netbeans-3_6-platform\modules\core-windows.jar(1955608 bytes)
C:\java\netbeans-3_6-platform\modules\text.jar(58277 bytes)
C:\java\aspectj\lib\aspectjrt.jar(35619 bytes)
C:\java\aspectj\lib\aspectjtools.jar(6045745 bytes)
C:\java\junit\junit.jar(121070 bytes)
C:\java\j2sdk5\jre\lib\ext(9 entries)
---- Compiler Messages ---
info zipfile classpath entry does not exist: c:\java\j2sdk5\jre\lib\i18n.jar
info zipfile classpath entry does not exist: c:\java\j2sdk5\jre\lib\sunrsasign.jar
info directory classpath entry does not exist: c:\java\j2sdk5\jre\classes
error at (no source information available)
C:\projects\marketedge\netbeans\modules\me_exceedsoft.map-1.0.jar:0 can't find
type [Lorg.geotools.data.DataStoreFactorySpi$Param;
---- org.aspectj.weaver.bcel.BcelWorld ----
Shadow mungers:
(around(extraFlags: 1):
(persingleton(org.garret.perst.aspectj.PersistenceAspect) &amp;&amp; (execution(boolean
org.garret.perst.aspectj.AutoPersist+.equals(java.lang.Object)) &amp;&amp;
(args(BindingTypePattern(java.lang.Object, 1)) &amp;&amp;
target(BindingTypePattern(org.garret.perst.aspectj.AutoPersist, 0)))))-&gt;boolean
org.garret.perst.aspectj.PersistenceAspect.ajc$around$org_garret_perst_aspectj_PersistenceAspect$5$589ee725(org.garret.perst.aspectj.AutoPersist,
java.lang.Object, org.aspectj.runtime.internal.AroundClosure))
(around(extraFlags: 1):
(persingleton(org.garret.perst.aspectj.PersistenceAspect) &amp;&amp; (execution(int
org.garret.perst.aspectj.AutoPersist+.hashCode()) &amp;&amp;
target(BindingTypePattern(org.garret.perst.aspectj.AutoPersist, 0))))-&gt;int
org.garret.perst.aspectj.PersistenceAspect.ajc$around$org_garret_perst_aspectj_PersistenceAspect$6$3f2d89d4(org.garret.perst.aspectj.AutoPersist,
org.aspectj.runtime.internal.AroundClosure))
(around(extraFlags: 1): (persingleton(org.garret.perst.aspectj.SafeHashAspect)
&amp;&amp; (execution(int org.garret.perst.aspectj.SafeHashCode+.hashCode()) &amp;&amp;
target(BindingTypePattern(org.garret.perst.aspectj.SafeHashCode, 0))))-&gt;int
org.garret.perst.aspectj.SafeHashAspect.ajc$around$org_garret_perst_aspectj_SafeHashAspect$1$7206641f(org.garret.perst.aspectj.SafeHashCode,
org.aspectj.runtime.internal.AroundClosure))
(before: (persingleton(org.garret.perst.aspectj.PersistenceAspect) &amp;&amp;
((execution( !static * ((org.garret.perst.Persistent+ &amp;&amp;
!org.garret.perst.Persistent) || (org.garret.perst.aspectj.AutoPersist+ &amp;&amp;
(!org.garret.perst.aspectj.StrictAutoPersist+ &amp;&amp;
!org.garret.perst.aspectj.AutoPersist))).*(..)) &amp;&amp; !execution(void
recursiveLoading())) &amp;&amp; this(BindingTypePattern(org.garret.perst.IPersistent,
0))))-&gt;void
org.garret.perst.aspectj.PersistenceAspect.ajc$before$org_garret_perst_aspectj_PersistenceAspect$1$272d304b(org.garret.perst.IPersistent))
(before: (persingleton(org.garret.perst.aspectj.PersistenceAspect) &amp;&amp; (get(
!static transient * org.garret.perst.aspectj.StrictAutoPersist+.*) &amp;&amp;
((!within(org.garret.perst.*) &amp;&amp; (!within(org.garret.perst.impl.*) &amp;&amp;
!within(org.garret.perst.aspectj.*))) &amp;&amp;
target(BindingTypePattern(org.garret.perst.aspectj.StrictAutoPersist,
0)))))-&gt;void
org.garret.perst.aspectj.PersistenceAspect.ajc$before$org_garret_perst_aspectj_PersistenceAspect$2$f74b759f(org.garret.perst.aspectj.StrictAutoPersist))
(before: (persingleton(org.garret.perst.aspectj.PersistenceAspect) &amp;&amp; (set(
!static transient * (org.garret.perst.aspectj.AutoPersist+ &amp;&amp;
!org.garret.perst.aspectj.StrictAutoPersist+).*) &amp;&amp;
((!within(org.garret.perst.*) &amp;&amp; (!within(org.garret.perst.impl.*) &amp;&amp;
!within(org.garret.perst.aspectj.*))) &amp;&amp; (!withincode(new(..)) &amp;&amp;
target(BindingTypePattern(org.garret.perst.aspectj.AutoPersist, 0))))))-&gt;void
org.garret.perst.aspectj.PersistenceAspect.ajc$before$org_garret_perst_aspectj_PersistenceAspect$4$83a0862a(org.garret.perst.aspectj.AutoPersist))
(before: (persingleton(org.garret.perst.aspectj.PersistenceAspect) &amp;&amp; (set(
!static transient * org.garret.perst.aspectj.StrictAutoPersist+.*) &amp;&amp;
((!within(org.garret.perst.*) &amp;&amp; (!within(org.garret.perst.impl.*) &amp;&amp;
!within(org.garret.perst.aspectj.*))) &amp;&amp;
target(BindingTypePattern(org.garret.perst.aspectj.StrictAutoPersist,
0)))))-&gt;void
org.garret.perst.aspectj.PersistenceAspect.ajc$before$org_garret_perst_aspectj_PersistenceAspect$3$4d3610ab(org.garret.perst.aspectj.StrictAutoPersist))
Type mungers:
(BcelTypeMunger ResolvedTypeMunger(PrivilegedAccess, void
org.garret.perst.IPersistent.()))
(BcelTypeMunger ResolvedTypeMunger(PrivilegedAccess, void
org.garret.perst.aspectj.StrictAutoPersist.()))
(BcelTypeMunger ResolvedTypeMunger(PrivilegedAccess, void
org.garret.perst.aspectj.StrictAutoPersist.()))
(BcelTypeMunger ResolvedTypeMunger(PrivilegedAccess, void
org.garret.perst.aspectj.AutoPersist.()))
(BcelTypeMunger ResolvedTypeMunger(PrivilegedAccess, void java.lang.Object.()))
(BcelTypeMunger ResolvedTypeMunger(PrivilegedAccess, void
org.garret.perst.aspectj.AutoPersist.()))
(BcelTypeMunger ResolvedTypeMunger(PrivilegedAccess, void
org.garret.perst.aspectj.AutoPersist.()))
(BcelTypeMunger ResolvedTypeMunger(Field, int
org.garret.perst.aspectj.AutoPersist.state))
(BcelTypeMunger ResolvedTypeMunger(Field, int
org.garret.perst.aspectj.AutoPersist.oid))
(BcelTypeMunger ResolvedTypeMunger(Field, org.garret.perst.Storage
org.garret.perst.aspectj.AutoPersist.storage))
(BcelTypeMunger ResolvedTypeMunger(Method, void
org.garret.perst.aspectj.AutoPersist.writeExternal(java.io.ObjectOutput)))
(BcelTypeMunger ResolvedTypeMunger(Method, void
org.garret.perst.aspectj.AutoPersist.readExternal(java.io.ObjectInput)))
(BcelTypeMunger ResolvedTypeMunger(Method, void
org.garret.perst.aspectj.AutoPersist.finalize()))
(BcelTypeMunger ResolvedTypeMunger(Method, void
org.garret.perst.aspectj.AutoPersist.invalidate()))
(BcelTypeMunger ResolvedTypeMunger(Method, void
org.garret.perst.aspectj.AutoPersist.onLoad()))
(BcelTypeMunger ResolvedTypeMunger(Method, org.garret.perst.Storage
org.garret.perst.aspectj.AutoPersist.getStorage()))
(BcelTypeMunger ResolvedTypeMunger(Method, boolean
org.garret.perst.aspectj.AutoPersist.recursiveLoading()))
(BcelTypeMunger ResolvedTypeMunger(Method, void
org.garret.perst.aspectj.AutoPersist.deallocate()))
(BcelTypeMunger ResolvedTypeMunger(Method, int
org.garret.perst.aspectj.AutoPersist.getOid()))
(BcelTypeMunger ResolvedTypeMunger(Method, void
org.garret.perst.aspectj.AutoPersist.modify()))
(BcelTypeMunger ResolvedTypeMunger(Method, void
org.garret.perst.aspectj.AutoPersist.store()))
(BcelTypeMunger ResolvedTypeMunger(Method, void
org.garret.perst.aspectj.AutoPersist.makePersistent(org.garret.perst.Storage)))
(BcelTypeMunger ResolvedTypeMunger(Method, boolean
org.garret.perst.aspectj.AutoPersist.isPersistent()))
(BcelTypeMunger ResolvedTypeMunger(Method, boolean
org.garret.perst.aspectj.AutoPersist.isModified()))
(BcelTypeMunger ResolvedTypeMunger(Method, boolean
org.garret.perst.aspectj.AutoPersist.isRaw()))
(BcelTypeMunger ResolvedTypeMunger(Method, void
org.garret.perst.aspectj.AutoPersist.loadAndModify()))
(BcelTypeMunger ResolvedTypeMunger(Method, void
org.garret.perst.aspectj.AutoPersist.load()))
(BcelTypeMunger ResolvedTypeMunger(Method, void
org.garret.perst.aspectj.AutoPersist.commit()))
(BcelTypeMunger ResolvedTypeMunger(Method, void
org.garret.perst.aspectj.AutoPersist.assignOid(org.garret.perst.Storage, int,
boolean)))
(BcelTypeMunger ResolvedTypeMunger(PrivilegedAccess, void
org.garret.perst.IPersistent.()))
(BcelTypeMunger ResolvedTypeMunger(PrivilegedAccess, void
org.garret.perst.aspectj.SafeHashCode.()))
(BcelTypeMunger ResolvedTypeMunger(PrivilegedAccess, void
org.garret.perst.aspectj.AutoPersist.()))
Cant find type problems:
java.lang.RuntimeException: Can't find type
[Lorg.geotools.data.DataStoreFactorySpi$Param;
  at org.aspectj.weaver.World.resolve(World.java:133)
  at org.aspectj.weaver.World.resolve(World.java:105)
  at org.aspectj.weaver.TypeX.resolve(TypeX.java:538)
  at
org.aspectj.weaver.patterns.ThisOrTargetPointcut.match(ThisOrTargetPointcut.java:71)
  at org.aspectj.weaver.patterns.AndPointcut.match(AndPointcut.java:43)
  at org.aspectj.weaver.patterns.AndPointcut.match(AndPointcut.java:43)
  at org.aspectj.weaver.patterns.AndPointcut.match(AndPointcut.java:43)
  at org.aspectj.weaver.ShadowMunger.match(ShadowMunger.java:62)
  at org.aspectj.weaver.Advice.match(Advice.java:91)
  at org.aspectj.weaver.bcel.BcelClassWeaver.match(BcelClassWeaver.java:1126)
  at
org.aspectj.weaver.bcel.BcelClassWeaver.matchInvokeInstruction(BcelClassWeaver.java:1115)
  at org.aspectj.weaver.bcel.BcelClassWeaver.match(BcelClassWeaver.java:987)
  at org.aspectj.weaver.bcel.BcelClassWeaver.match(BcelClassWeaver.java:827)
  at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:348)
  at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:83)
  at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:740)
  at org.aspectj.weaver.bcel.BcelWeaver.weaveWithoutDump(BcelWeaver.java:705)
  at org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify(BcelWeaver.java:632)
  at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:575)
  at
org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave(AjCompilerAdapter.java:239)
  at
org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling(AjCompilerAdapter.java:114)
  at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:383)
  at
org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:678)
  at
org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:168)
  at
org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:102)
  at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:109)
  at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:60)
  at org.aspectj.tools.ajc.Main.run(Main.java:291)
  at org.aspectj.tools.ajc.Main.runMain(Main.java:227)
  at org.aspectj.tools.ant.taskdefs.AjcTask.executeInSameVM(AjcTask.java:1158)
  at org.aspectj.tools.ant.taskdefs.AjcTask.execute(AjcTask.java:955)
  at org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:275)
  at org.apache.tools.ant.Task.perform(Task.java:364)
  at org.apache.tools.ant.taskdefs.Sequential.execute(Sequential.java:64)
  at org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:275)
  at org.apache.tools.ant.Task.perform(Task.java:364)
  at org.apache.tools.ant.taskdefs.MacroInstance.execute(MacroInstance.java:377)
  at org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:275)
  at org.apache.tools.ant.Task.perform(Task.java:364)
  at org.apache.tools.ant.Target.execute(Target.java:341)
  at org.apache.tools.ant.Target.performTasks(Target.java:369)
         at org.apache.tools.ant.Project.executeTarget(Project.java:1214)
  at org.apache.tools.ant.taskdefs.Ant.execute(Ant.java:386)
  at org.apache.tools.ant.taskdefs.CallTarget.execute(CallTarget.java:106)
  at org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:275)
  at org.apache.tools.ant.Task.perform(Task.java:364)
  at org.apache.tools.ant.Target.execute(Target.java:341)
  at org.apache.tools.ant.Target.performTasks(Target.java:369)
  at org.apache.tools.ant.Project.executeTarget(Project.java:1214)
  at org.apache.tools.ant.Project.executeTargets(Project.java:1062)
  at org.apache.tools.ant.Main.runBuild(Main.java:673)
  at org.apache.tools.ant.Main.startAnt(Main.java:188)
  at org.apache.tools.ant.launch.Launcher.run(Launcher.java:196)
  at org.apache.tools.ant.launch.Launcher.main(Launcher.java:55)</comment>
		<comment id="4" date="2004-08-26 06:58:47 EDT" author="Andrew Clement">Thanks for that ajcore Hristo, it really helped!

Some progress.  The problem appears to be the bytecode generated for a call to
clone() on an array type.  I notice that you make a call:

return (DataStoreFactorySpi.Param[])PARAMS_ARRAY.clone() 

in 

PERSTDataStoreFactory.getParametersInfo()

The bytecode generated differs between 1.4 and 1.5.  Under 1.4 it becomes an

invokevirtual #50: //Method java/lang/Object.clone():()Ljava/lang/Object;

Under 1.5 it becomes:

invokevirtual #45: //Method
"[Lorg/geotools/data/DataStoreFactorySpi$Param;".clone:()Ljava/lang/Object;</comment>
		<comment id="5" date="2004-08-27 06:08:04 EDT" author="Andrew Clement">Without suitable documentation available on what the changes are from 1.4/1.5 -
we believe this is a bug fix that sun has made.  In 1.4 they were incorrectly
making the clone call against type Object.  In 1.5 they now make the clone call
against the array type.

The fix is as follows. In TypeX where we convert a name to a signature
(nameToSignature()) - we were incorrectly converting "[LB$D;" into "L[LB$D;;". 
We weren't checking if it was already valid (in fact there is a comment in
nameToSignature() that said it ought to be doing more checking).  It now does
not incorrectly alter the array signature - this fixes the cant find type message.

Yesterday, Erik talked about whether getDeclaredMethods() on ResolvedTypeX.Array
should return the clone() method (it doesn't at the moment).  I have not needed
to change it in order for my testcase to pass. 

Fix checked in - waiting for build.

many thanks to Hristo for using a few development builds to help track down this
bug.</comment>
		<comment id="6" date="2004-08-28 12:32:56 EDT" author="Andrew Clement">Fix available:

BUILD COMPLETE -  build.364
Date of build: 08/27/2004 22:17:38
Time to build: 95 minutes 15 seconds
Last changed: 08/27/2004 17:02:18
Latest good AspectJ jar available at:
download.eclipse.org/technology/ajdt/dev/aspectj-DEVELOPMENT.jar</comment>
		<comment id="7" date="2004-09-01 03:29:41 EDT" author="Andrew Clement">Closing bug as fixed - please reopen Hristo if the fix doesn't work for you ...</comment>
		<comment id="8" date="2004-10-21 04:33:06 EDT" author="Adrian Colyer">Fix released as part of AspectJ 1.2.1</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="b5e6307a63b0513cb058e8d6e56ff87287bdfa15" author="aclement" date="2004-08-27 07:03:54"/>
          <file name="tests/bugs/java5/arrayCloning/A.java">
          </file>
          <file name="tests/bugs/java5/arrayCloning/C.java">
          </file>
          <file name="tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java">
              <method name="test050_typePatternMatchingWithArrays" returnType="void" parameters=""/>
          </file>
          <file name="weaver/src/org/aspectj/weaver/TypeX.java">
              <method name="nameToSignature" returnType="String" parameters="String"/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="74952" opendate="2004-9-24 11:04:00" fixdate="2004-10-22 6:43:00">
    <buginformation>
      <summary>"before,after !(cflow(within(Trace*))) prints nothing"</summary>
      <description>Reference: "cflow(within(C)) vs (within(C)||cflowbelow(within(C)) in
aspectj-users mailing list.

The aspect TraceClass below doesn't print any message when the pointcut is
defined to "!cflow(within(Trace*))". The other defintion "!(within(Trace*) ||
cflowbelow(within(Trace*)))" works fine. Wes Isberg in his reply explained that
cflow should never be used alone but he thought "there is a bug or two in here"

class SomeClass 
{
    static public void main (String [] args) {
    }
} // SomeClass

aspect TraceClass {

    // members
    static private int level = 0;

    static private void offset() {
        int i;
        for (i = 0; i &lt; level; ++i) {
            System.out.print("  ");
        }
    } // offset

    pointcut pc() : 
        !cflow(within(Trace*))
//        !(within(Trace*) || cflowbelow(within(Trace*)))
        ;
    before () : pc() {
        offset();
        System.out.println("-&gt; " + thisJoinPoint);
        ++level;
    }
    after  () : pc() {
        --level;
        offset();
        System.out.println("&lt;- " + thisJoinPoint);
    }
} // TraceClass

In order to try to figure out what is happening within TraceClass, I added a
second aspect, TraceTrace, just to trace TraceClass.

aspect TraceTrace {

    // members
    static private int level = 0;

    static private void offset() {
        int i;
        for (i = 0; i &lt; level; ++i) {
            System.out.print("  ");
        }
    } // offset

    pointcut pc() : within(TraceClass);
    before () : pc() {
        offset();
        System.out.println("=&gt; " + thisJoinPoint);
        ++level;
    }
    after  () : pc() {
        --level;
        offset();
        System.out.println("&lt;= " + thisJoinPoint);
    }
} // TraceTrace

Here is what TraceTrace prints when TraceClass uses "!cflow(within(Trace*))"

=&gt; staticinitialization(TraceClass.&lt;clinit&gt;)
  =&gt; set(int TraceClass.level)
  &lt;= set(int TraceClass.level)
  =&gt; preinitialization(TraceClass())
    =&gt; initialization(TraceClass())
      =&gt; execution(TraceClass())
      &lt;= execution(TraceClass())
    &lt;= initialization(TraceClass())
  &lt;= staticinitialization(TraceClass.&lt;clinit&gt;)

The after advice is not executed for preinitialization.</description>
      <comments>
		<comment id="1" date="2004-09-24 11:06:48 EDT" author="Chi-Hua Chen">I use 

AspectJ Compiler 1.2 built on Friday May 21, 2004 at 15:06:22 GMT

and 

java version "1.4.2_01"
Java(TM) 2 Runtime Environment, Standard Edition (build 1.4.2_01-b06)
Java HotSpot(TM) Client VM (build 1.4.2_01-b06, mixed mode)</comment>
		<comment id="2" date="2004-10-21 09:08:24 EDT" author="Andrew Clement">Ok.  There is a real bug here.  It is to do with how cflow entry is applied to
preinitialization join points.  We manage the cflow with a counter at various
join points we will check this counter and if the number is &gt;0 we are in a
particular cflow.  We apply logic at the top of the cflow to increment and
decrement the counter around the join point that matches the pointcut inside the
cflow() statement.  This example program produces a class file that doesn't
always decrement the counter when it should.  

The problem is actually because when working with the preinitialization shadow
it is in an odd state in that it contains a branch that jumps off the end of the
shadow, when in fact all branches inside it should jump to the end of the
shadow.  Because it doesn't exit normally, we fail to apply the 'counter
decrement' logic correctly.

The fix is to attach a NOP to the end of the preinitialization shadow before
weaving - the branches inside the shadow then jump to this NOP rather than off
the end of the shadow.  We can then apply the 'counter decrement' logic (which
is actually woven in as after() advice).

Without the fix, the output is only a few lines long, missing all sorts of join
points.  With the fix in place, the program outputs this :)

=&gt; staticinitialization(TraceClass.&lt;clinit&gt;)
  =&gt; set(int TraceClass.level)
  &lt;= set(int TraceClass.level)
  =&gt; preinitialization(TraceClass())
  &lt;= preinitialization(TraceClass())
  =&gt; initialization(TraceClass())
    =&gt; execution(TraceClass())
    &lt;= execution(TraceClass())
  &lt;= initialization(TraceClass())
&lt;= staticinitialization(TraceClass.&lt;clinit&gt;)
=&gt; execution(ADVICE: void TraceClass.ajc$before$TraceClass$1$346234(JoinPoint))
  =&gt; call(void TraceClass.offset())
    =&gt; execution(void TraceClass.offset())
      =&gt; get(int TraceClass.level)
      &lt;= get(int TraceClass.level)
    &lt;= execution(void TraceClass.offset())
  &lt;= call(void TraceClass.offset())
  =&gt; get(PrintStream java.lang.System.err)
  &lt;= get(PrintStream java.lang.System.err)
  =&gt; call(java.lang.StringBuffer(String))
  &lt;= call(java.lang.StringBuffer(String))
  =&gt; call(StringBuffer java.lang.StringBuffer.append(Object))
  &lt;= call(StringBuffer java.lang.StringBuffer.append(Object))
  =&gt; call(String java.lang.StringBuffer.toString())
  &lt;= call(String java.lang.StringBuffer.toString())
  =&gt; call(void java.io.PrintStream.println(String))
-&gt; staticinitialization(WhatsGoingOn.&lt;clinit&gt;)
  &lt;= call(void java.io.PrintStream.println(String))
  =&gt; get(int TraceClass.level)
  &lt;= get(int TraceClass.level)
  =&gt; set(int TraceClass.level)
  &lt;= set(int TraceClass.level)
&lt;= execution(ADVICE: void TraceClass.ajc$before$TraceClass$1$346234(JoinPoint))
=&gt; execution(ADVICE: void TraceClass.ajc$after$TraceClass$2$346234(JoinPoint))
  =&gt; get(int TraceClass.level)
  &lt;= get(int TraceClass.level)
  =&gt; set(int TraceClass.level)
  &lt;= set(int TraceClass.level)
  =&gt; call(void TraceClass.offset())
    =&gt; execution(void TraceClass.offset())
      =&gt; get(int TraceClass.level)
      &lt;= get(int TraceClass.level)
    &lt;= execution(void TraceClass.offset())
  &lt;= call(void TraceClass.offset())
  =&gt; get(PrintStream java.lang.System.err)
  &lt;= get(PrintStream java.lang.System.err)
  =&gt; call(java.lang.StringBuffer(String))
  &lt;= call(java.lang.StringBuffer(String))
  =&gt; call(StringBuffer java.lang.StringBuffer.append(Object))
  &lt;= call(StringBuffer java.lang.StringBuffer.append(Object))
  =&gt; call(String java.lang.StringBuffer.toString())
  &lt;= call(String java.lang.StringBuffer.toString())
  =&gt; call(void java.io.PrintStream.println(String))
&lt;- staticinitialization(WhatsGoingOn.&lt;clinit&gt;)
  &lt;= call(void java.io.PrintStream.println(String))
&lt;= execution(ADVICE: void TraceClass.ajc$after$TraceClass$2$346234(JoinPoint))
=&gt; execution(ADVICE: void TraceClass.ajc$before$TraceClass$1$346234(JoinPoint))
  =&gt; call(void TraceClass.offset())
    =&gt; execution(void TraceClass.offset())
      =&gt; get(int TraceClass.level)
      &lt;= get(int TraceClass.level)
    &lt;= execution(void TraceClass.offset())
  &lt;= call(void TraceClass.offset())
  =&gt; get(PrintStream java.lang.System.err)
  &lt;= get(PrintStream java.lang.System.err)
  =&gt; call(java.lang.StringBuffer(String))
  &lt;= call(java.lang.StringBuffer(String))
  =&gt; call(StringBuffer java.lang.StringBuffer.append(Object))
  &lt;= call(StringBuffer java.lang.StringBuffer.append(Object))
  =&gt; call(String java.lang.StringBuffer.toString())
  &lt;= call(String java.lang.StringBuffer.toString())
  =&gt; call(void java.io.PrintStream.println(String))
-&gt; execution(void WhatsGoingOn.main(String[]))
  &lt;= call(void java.io.PrintStream.println(String))
  =&gt; get(int TraceClass.level)
  &lt;= get(int TraceClass.level)
  =&gt; set(int TraceClass.level)
  &lt;= set(int TraceClass.level)
&lt;= execution(ADVICE: void TraceClass.ajc$before$TraceClass$1$346234(JoinPoint))
=&gt; execution(ADVICE: void TraceClass.ajc$after$TraceClass$2$346234(JoinPoint))
  =&gt; get(int TraceClass.level)
  &lt;= get(int TraceClass.level)
  =&gt; set(int TraceClass.level)
  &lt;= set(int TraceClass.level)
  =&gt; call(void TraceClass.offset())
    =&gt; execution(void TraceClass.offset())
      =&gt; get(int TraceClass.level)
      &lt;= get(int TraceClass.level)
    &lt;= execution(void TraceClass.offset())
  &lt;= call(void TraceClass.offset())
  =&gt; get(PrintStream java.lang.System.err)
  &lt;= get(PrintStream java.lang.System.err)
  =&gt; call(java.lang.StringBuffer(String))
  &lt;= call(java.lang.StringBuffer(String))
  =&gt; call(StringBuffer java.lang.StringBuffer.append(Object))
  &lt;= call(StringBuffer java.lang.StringBuffer.append(Object))
  =&gt; call(String java.lang.StringBuffer.toString())
  &lt;= call(String java.lang.StringBuffer.toString())
  =&gt; call(void java.io.PrintStream.println(String))
&lt;- execution(void WhatsGoingOn.main(String[]))
  &lt;= call(void java.io.PrintStream.println(String))
&lt;= execution(ADVICE: void TraceClass.ajc$after$TraceClass$2$346234(JoinPoint))

Fix checked in, waiting on build.</comment>
		<comment id="3" date="2004-10-22 06:43:23 EDT" author="Andrew Clement">Fix available:

BUILD COMPLETE -  build.387
Date of build: 10/21/2004 21:05:26
Time to build: 128 minutes 30 seconds
Last changed: 10/21/2004 16:41:04
Latest good AspectJ jar available at:
download.eclipse.org/technology/ajdt/dev/aspectj-DEVELOPMENT.jar</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="a303a09bbdbee8ce39e2ba00a3a33e54df92c24f" author="aclement" date="2004-10-21 09:55:49"/>
          <file name="tests/bugs/WhatsGoingOn.java">
          </file>
          <file name="tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/bcel/BcelShadow.java">
              <method name="prepareForMungers" returnType="void" parameters=""/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="77799" opendate="2004-11-4 1:48:00" fixdate="2004-11-4 10:59:00">
    <buginformation>
      <summary>NullPointerException in StructureSearchManager</summary>
      <description>Calling Ajde.getDefault().getStructureSearchManager().findMatches(...)
for an AspectJ project that has not been built results in a NullPointerException
in StructureSearchManager.findMatchesHelper(...) (line 58)

Simple patch is attached.</description>
      <comments>
		<comment id="1" date="2004-11-04 01:50:03 EST" author="Juergen Graf">Created attachment 15650 [details]
Simple patch that tests if var is null before accessing it</comment>
		<comment id="2" date="2004-11-04 10:59:46 EST" author="Mik Kersten">Thanks for the patch Jurgen!  I have applied it and committed to CVS, so you 
should be able to see it if you update now.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="aab9c2c57db1c014e03720676d7e3cac14a761aa" author="mkersten" date="2004-11-05 12:44:51"/>
          <file name="ajde/src/org/aspectj/ajde/ui/StructureSearchManager.java">
              <method name="findMatchesHelper" returnType="List" parameters="IProgramElement String IProgramElement.Kind List"/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="77163" opendate="2004-10-27 20:09:00" fixdate="2004-11-5 11:51:00">
    <buginformation>
      <summary>Load time weaver default verbose setting</summary>
      <description>The default setting for the load time weaver is (as of 1.2.1rc1) to produce
weaving messages rather than ignore them.  I think the default should be changed
to ignore them.  

Also, I cannot override the default setting with -Daj.weaver.versose="False". 
This is the implied syntax from docs/examples/build.xml.  If this has changed
then build.xml should be updated.  Otherwise, the weaver should be fixed to use it!</description>
      <comments>
		<comment id="1" date="2004-10-27 20:11:32 EDT" author="david.pearce">Correction.  I used -Daj.weaving.verbose="False"</comment>
		<comment id="2" date="2004-11-03 12:58:46 EST" author="Matthew Webster">Created attachment 15623 [details]
Fix to WeavingAdaptor and new tests

1. New message handler which ignores WEAVEINFO messages by default
2. New org.aspectj.weaver.showWeaveInfo system property to show WEAVEINFO
messages
3. Replace all syserr/sysout with info/warning/error messages
4. Improved exception handling
5. New tests</comment>
		<comment id="3" date="2004-11-05 11:50:06 EST" author="Andrew Clement">Patch integrated, waiting for build....</comment>
		<comment id="4" date="2004-11-05 11:51:38 EST" author="Andrew Clement">Fix available:

BUILD COMPLETE -  build.391
Date of build: 11/05/2004 14:19:22
Time to build: 132 minutes 36 seconds
Last changed: 11/05/2004 11:00:43
Last log entry: Matthews fix for Bugzilla Bug 77163: Load time weaver default
verbose setting
Latest good AspectJ jar available at:
download.eclipse.org/technology/ajdt/dev/aspectj-DEVELOPMENT.jar

Also available in 1.2.1 final which will be released in about an hour...</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="edd6539e53d96e60f257952e582783c7d8aac25c" author="aclement" date="2004-11-05 08:00:41"/>
          <file name="weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java">
          </file>
          <file name="weaver/testsrc/org/aspectj/weaver/WeavingURLClassLoaderTest.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="80249" opendate="2004-12-6 5:20:00" fixdate="2004-12-6 12:31:00">
    <buginformation>
      <summary>Order of types passed to compiler determines weaving behavior</summary>
      <description>Currently, the order in which you specify types when passing them to the
compiler can affect how they are woven:

For example, if we have class A and class B extends A - Also, an aspect that
'declare parents: A+ implements Serializable' then depending on whether we see A
first, we may or may not make B serializable.

The fix is that when we weave a type, we first weave its supertype then its
superinterfaces (if they were also passed to the compiler).

The problematic construct is declare parents - so we only process the types in a
special order if there are declare parents around.  Also, because we can't
currently do decp when binary weaving, the order processing logic is only being
put into the source weaving pipeline.</description>
      <comments>
		<comment id="1" date="2004-12-06 05:41:20 EST" author="Andrew Clement">Fix checked in (see AJLookupEnvironment) - waiting on build.</comment>
		<comment id="2" date="2004-12-06 12:31:32 EST" author="Andrew Clement">Fix available.

BUILD COMPLETE -  build.406
Date of build: 12/06/2004 13:43:55
Time to build: 135 minutes 21 seconds
Last changed: 12/06/2004 10:38:45
Last log entry: Fixes for Bug 80249: Order of types passed to compiler
determines weaving behavior
Latest good AspectJ jar available at:
download.eclipse.org/technology/ajdt/dev/aspectj-DEVELOPMENT.jar</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="9052d5d86cfcdeb9a64ed903beea53d077f0de08" author="aclement" date="2004-12-06 07:38:07"/>
          <file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java">
          </file>
          <file name="tests/decp/A.java">
          </file>
          <file name="tests/decp/AspectX.java">
          </file>
          <file name="tests/decp/B.java">
          </file>
          <file name="tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java">
              <method name="getSpecFile" returnType="File" parameters=""/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="80916" opendate="2004-12-14 6:01:00" fixdate="2005-1-5 6:01:00">
    <buginformation>
      <summary>"In some cases the structure model doesn't contain the ""matches declare"" relationship"</summary>
      <description>With a project containing one class and one aspect:

public class HelloClass {

	public static void main(String[] args) {
		new HelloClass().sayHello();
	}
	
	public void sayHello() {
		System.out.println("Hello");
	}
	
}


public aspect A1 {

	pointcut test() : get(* System.out);
	
	declare warning : test() &amp;&amp; !within(A1)
		 : "test warning";
	
	pointcut anotherTest() : 
		execution(void HelloClass.sayHello(..));
	
	after() returning : anotherTest() {
		System.out.println("returning....");
	}
		
}

The following is returned from the structure model:

asmRelMap entry: HelloClass.sayHello(), relationship: advised by, target: 
A1.afterReturning(): anotherTest..
asmRelMap entry: A1.afterReturning(): anotherTest.., relationship: uses 
pointcut, target: A1.anotherTest()
asmRelMap entry: A1.afterReturning(): anotherTest.., relationship: advises, 
target: HelloClass.sayHello()
asmRelMap entry: HelloClass.sayHello(), relationship: advised by, target: 
A1.afterReturning(): anotherTest..
asmRelMap entry: A1.anotherTest(), relationship: pointcut used by, target: 
A1.afterReturning(): anotherTest..
asmRelMap entry: A1.declare warning: "test warning", relationship: matched by, 
target: HelloClass.sayHello()

In other words, the model is saying that there are two entries the same:

asmRelMap entry: HelloClass.sayHello(), relationship: advised by, target: 
A1.afterReturning(): anotherTest..

whereas one of these should be the "matches declare" relationship relating to 
the declare warning.

Changing the aspect to be:


public aspect A1 {

	pointcut test() : get(* System.out);
	
	declare warning : test() &amp;&amp; !within(A1)
		 : "test warning";
	
	pointcut anotherTest() : 
		execution(void HelloClass.sayHello(..));
	
	after() returning : anotherTest() {
		System.out.println("returning....");
	}
	
	after() returning : test() {
		System.out.println("returning again!");
	}
	
}

means that the IRelationshipMap does now contain the "matches declare" 
relationship.

This is all with AspectJ 5 M1.</description>
      <comments>
		<comment id="1" date="2004-12-14 10:14:17 EST" author="Mik Kersten">I'll take a look at fixing this when I do the "concretizes pointcut" additions.</comment>
		<comment id="2" date="2004-12-14 10:22:03 EST" author="Helen Beeken">Just as a note, this may have something to do with the changes Andy put in 
recently - he added the capability to get at the offset aswell as the line 
number (we needed this for AJDT). Plus there's the changes which have gone in 
for AspectJ 5. Yesterday we didn't have declare soft in the model, and that 
was fixed - it might be something in the same area.

Thanks, Helen</comment>
		<comment id="3" date="2004-12-17 04:29:34 EST" author="Andrew Clement">It could well be related to what I did as I'm not sure how many tests there are
in existence around my changes.  Helen, can you tell me what you call to get
your output: (Matt mentioned some API with annotation in the name the other day
but I can't remember what it was)


asmRelMap entry: HelloClass.sayHello(), relationship: advised by, target: 
A1.afterReturning(): anotherTest..
asmRelMap entry: A1.afterReturning(): anotherTest.., relationship: uses 
pointcut, target: A1.anotherTest()
asmRelMap entry: A1.afterReturning(): anotherTest.., relationship: advises, 
target: HelloClass.sayHello()
asmRelMap entry: HelloClass.sayHello(), relationship: advised by, target: 
A1.afterReturning(): anotherTest..
asmRelMap entry: A1.anotherTest(), relationship: pointcut used by, target: 
A1.afterReturning(): anotherTest..
asmRelMap entry: A1.declare warning: "test warning", relationship: matched by, 
target: HelloClass.sayHello()

I have other ways of looking at the structure model - I'm trying to work out if
the data structure is incorrect inside AJ or just processed incorrectly by the
method you are calling.</comment>
		<comment id="4" date="2004-12-17 05:24:50 EST" author="Helen Beeken">The way we get the relationships map is using:

AsmManager.getDefault().getRelationshipMap();

We then iterate through the entries.</comment>
		<comment id="5" date="2004-12-17 06:50:42 EST" author="Andrew Clement">This turns out to be a long standing bug.

The structure model relationships data is correct.
The structure model node tree structure is missing a node.

It should look like this:

HelloClass.java  [java source file] 
[C:\temp\ajcSandbox\ajcTest55158.tmp\HelloClass.java|1|0|0]
    import declarations  [import reference]
    HelloClass  [class]  
      main(String[])  [method]
      sayHello()  [method]  
        field-get(java.io.PrintStream java.lang.System.out) 

But the field-get node is missing at the moment.  Without that in there, the
processRelationships code isn't doing what you think it is:

String sourceOfRel = (String) iter.next();
IProgramElement sourcePE = AsmManager.getDefault().getHierarchy()
    .findElementForHandle(sourceOfRel);   
List relationships = asmRelMap.get(sourcePE);

In the case of the matched declare, the first call to iter.next() gets hold of
the handle of the place matching the declare (which is inside the sayHello()
method).  Then it calls findElementForHandle() which returns *the nearest
matching node* - so without the field-get node existing in the node structure,
it gives you back the sayHello() method node - and then asmRelMap.get()
retrieves the relationships for that node.  So twice you will be asking for the
relationships on the sayHello() method and getting back the advised_by information.

The rewritten aspect works because the 2nd piece of advice on the get(*
System.out) method causes the field-get node to be created.

I'm just testing the fix.

You should be careful looking for the IJavaElement for a code node that you get
back as the end of a relationship, like 'field-get(java.io.PrintStream
java.lang.System.out)' - i'm not sure how you are currently handling them.</comment>
		<comment id="6" date="2004-12-17 12:16:59 EST" author="Mik Kersten">Looks like you got this one Andy.

This reminds me... we seem to be getting onto the golden path of transitioning 
from the ASM IHierarchy to the JavaModel.  I'll post a note about we might 
make our life easier with that to ajdt-dev.</comment>
		<comment id="7" date="2004-12-20 09:47:28 EST" author="Andrew Clement">Fix checked in, waiting on build.</comment>
		<comment id="8" date="2005-01-05 06:01:32 EST" author="Andrew Clement">fix available.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="427c0d3dfdcc6a74c7e0bc6fcf1f55206ee04a8e" author="aclement" date="2004-12-20 11:44:07"/>
          <file name="weaver/src/org/aspectj/weaver/AsmRelationshipProvider.java">
              <method name="checkerMunger" returnType="void" parameters="IHierarchy Shadow Checker"/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="76798" opendate="2004-10-22 7:04:00" fixdate="2005-1-5 6:03:00">
    <buginformation>
      <summary>Add versions to woven class files - enabling better backwards compatibility.</summary>
      <description>We don't currently include a version in the class files that come out of the
weaver.  This can cause problems.  For example, if we add a new attribute to a
class file in a future version of AspectJ, then that attribute will cause older
versions of AspectJ to blow up if they encounter it.  If we include a version in
the class file we can rev the version number when we add attributes (or change
the class file form in another way), and by checking that version number in the
weaver we can better determine whether we should fail if we encounter a new
attribute (or other change), or if it is safe to continue processing.

I will add a new WeaverVersion attribute that includes 2 shorts.  Major and Minor.

Encountering a major version in a class file that is greater than the version a
particular weaver is designed to understand will cause compilation to fail.

Encountering a minor version in a class file that is greater than the minor
version a particular weaver is designed to understand will not cause compilation
to fail - we will assume it is safe to continue.</description>
      <comments>
		<comment id="1" date="2004-10-22 07:06:04 EDT" author="Andrew Clement">fix checked in - waiting for build.</comment>
		<comment id="2" date="2005-01-05 06:03:59 EST" author="Andrew Clement">fix available.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="6aa75169a769a19b3f7f26acc03a5ad81f092bb0" author="aclement" date="2004-10-22 07:53:11"/>
          <file name="weaver/src/org/aspectj/weaver/AjAttribute.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/bcel/BcelAttributes.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/bcel/BcelField.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/bcel/BcelMethod.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/bcel/BcelObjectType.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/bcel/LazyClassGen.java">
              <method name="writeBack" returnType="void" parameters="BcelWorld"/>
          </file>
          <file name="weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java">
              <method name="printAspectAttributes" returnType="void" parameters="PrintStream"/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="82062" opendate="2005-1-1 15:07:00" fixdate="2005-1-5 14:27:00">
    <buginformation>
      <summary>WeaveMessage should provide more information</summary>
      <description>It would be wonderful if the WeaveMessage object would provide two additional
things:

- the affected class name
- the aspect name

I could use this to determine which aspect is woven into which class during
load-time weaving (need this for dependency management).</description>
      <comments>
		<comment id="1" date="2005-01-01 15:20:07 EST" author="Martin Lippert">Created attachment 16883 [details]
weavemessage-bridge-patch

Patch that adds several things to WeaveMessage:
- getter for aspectname
- getter for affectedtypename
- additional static factory method to provide aspectname and affectedtypename
- two new parameters for constructor (for aspectname and affectedtypename)</comment>
		<comment id="2" date="2005-01-01 15:21:41 EST" author="Martin Lippert">Created attachment 16884 [details]
weavemessage-weaver-patch

Patch that makes use of new WeaveMessage factory method to provide additional
information via WeaveMessage objects (aspectname and affectedtypename).</comment>
		<comment id="3" date="2005-01-04 08:19:14 EST" author="Andrew Clement">Both patches implemented - i see the second one also includes your change from
private to protected for a method in BcelWorld.

(and sorry I hadn't gotten round to improving WeaveMessages earlier - I know
you've wanted changes like this for a while!!)

Waiting for build before closing bug report.</comment>
		<comment id="4" date="2005-01-05 03:12:32 EST" author="Andrew Clement">Fixes available:

BUILD COMPLETE -  build.426
Date of build: 01/05/2005 02:54:21
Time to build: 100 minutes 4 seconds
Last changed: 01/04/2005 21:08:48
Latest good AspectJ jar available at:
download.eclipse.org/technology/ajdt/dev/aspectj-DEVELOPMENT.jar</comment>
		<comment id="5" date="2005-01-05 14:27:49 EST" author="Martin Lippert">Perfect. I am just waiting for bug 82134 to be fixed before I can check this
out. Thanks again for the quick reaction!!!</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="98976598593e8a1f89e9628e8fc11c7822b8e3d4" author="aclement" date="2005-01-04 10:15:57"/>
          <file name="bridge/src/org/aspectj/bridge/WeaveMessage.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/Advice.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/Shadow.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java">
              <method name="munge" returnType="boolean" parameters="BcelClassWeaver"/>
          </file>
          <file name="weaver/src/org/aspectj/weaver/bcel/BcelWorld.java">
              <method name="resolveObjectType" returnType="ResolvedTypeX.ConcreteName" parameters="ResolvedTypeX.Name"/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="81863" opendate="2004-12-23 10:54:00" fixdate="2005-1-12 4:08:00">
    <buginformation>
      <summary>Annotation matching using within() PCD doesn't appear to be working.</summary>
      <description>From discussion on aspectj list:

Hi,

Well, having just done some testing, I think this even simpler case shows 
within() is not behaving correctly for annotations:

@Entity
public class myClass1 {...}

public class myClass2 {...}

public aspect myAspect {
  before():call(* *(..)) &amp;&amp; within(@Entity *) {
  }
}

The pointcut matches all the method calls in myClass1 and myClass2 
(effectively it is parsing but then ignoring the annotation specified
in the within()).

So, what you want to do is valid but AspectJ is misbehaving - you get a 
stack overflow because the perthis() clause is also matching on your aspect 
type when obviously that doesnt have the annotation and shouldnt be matched.



Andy.
---
Andy Clement
AspectJ Development



Rifflard Micka? &lt;Mickael.Rifflard@atosorigin.com&gt; 
Sent by: aspectj-users-admin@eclipse.org
22/12/2004 16:56
Please respond to
aspectj-users@eclipse.org
	
To
&lt;aspectj-users@eclipse.org&gt;
cc

Subject
[aspectj-users] Aspect instance on JDK 1.5 annotation
	

	


Hi all, 
I'm currently trying to get an aspect instance for an object instance with
specific JDK 1.5 annotation. 
Exemple : 
        Create an aspect instance for all object like that : 
        @Entity 
        public class myClass { ... } 
I try 
        public aspect myAspect perthis(within(@Entity *)) {...} 
but this aspect execution lead to a java.lang.StackOverflowError exception. 
Is it possible ? 
Thanks. 
        Micka? 
        
_______________________________________________ aspectj-users mailing list
aspectj-users@eclipse.org http://dev.eclipse.org/mailman/listinfo/aspectj-users</description>
      <comments>
		<comment id="1" date="2005-01-12 04:08:14 EST" author="Andrew Clement">Fixed, build available:

BUILD COMPLETE -  build.429
Date of build: 01/11/2005 11:52:16
Time to build: 103 minutes 38 seconds
Last changed: 01/11/2005 11:22:16
Latest good AspectJ jar available at:
download.eclipse.org/technology/ajdt/dev/aspectj-DEVELOPMENT.jar</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="8a8930fd9808b03e3c117086d7ba0eaa654a2438" author="acolyer" date="2005-01-06 12:15:28"/>
          <file name="tests/java5/annotations/within/PlainWithin.java">
          </file>
          <file name="tests/src/org/aspectj/systemtest/ajc150/AnnotationPointcutsTests.java">
              <method name="test002_AtAnnotationMatching" returnType="void" parameters=""/>
          </file>
          <file name="tests/src/org/aspectj/systemtest/ajc150/AnnotationRuntimeTests.java">
              <method name="test006_CantUseinDecEoW" returnType="void" parameters=""/>
          </file>
          <file name="weaver/src/org/aspectj/weaver/patterns/AnnotationTypePattern.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/patterns/ExactAnnotationTypePattern.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/patterns/ExactTypePattern.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/patterns/HandlerPointcut.java">
              <method name="matchInternal" returnType="FuzzyBoolean" parameters="Shadow"/>
          </file>
          <file name="weaver/src/org/aspectj/weaver/patterns/TypePattern.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java">
              <method name="matchesExactly" returnType="boolean" parameters="ResolvedTypeX"/>
          </file>
          <file name="weaver/src/org/aspectj/weaver/patterns/WithinPointcut.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="82218" opendate="2005-1-5 4:49:00" fixdate="2005-1-12 23:27:00">
    <buginformation>
      <summary>fails to doc spacewar using AJDT 1.2.0M2</summary>
      <description>Using AJDT 1.2.0M2 {with Java 5 JRE on XP SP2}, install Spacewar example and
generate to Spacewar/docs.  
Result: output has no cross-references (and displays special AJDT tags), and
stderr lists this exception:

java.lang.StringIndexOutOfBoundsException: String index out of range: -1
	at java.lang.AbstractStringBuilder.insert(AbstractStringBuilder.java:980)
	at java.lang.StringBuffer.insert(StringBuffer.java:447)
	at org.aspectj.tools.ajdoc.HtmlDecorator.insertDeclarationsDetails(HtmlDecorator.java:350)
	at org.aspectj.tools.ajdoc.HtmlDecorator.addAspectDocumentation(HtmlDecorator.java:234)
	at org.aspectj.tools.ajdoc.HtmlDecorator.decorateHTMLFile(HtmlDecorator.java:188)
	at org.aspectj.tools.ajdoc.HtmlDecorator.decorateHTMLFromDecl(HtmlDecorator.java:116)
	at org.aspectj.tools.ajdoc.HtmlDecorator.decorateHTMLFromDecls(HtmlDecorator.java:54)
	at org.aspectj.tools.ajdoc.HtmlDecorator.decorateHTMLFromInputFiles(HtmlDecorator.java:43)
	at org.aspectj.tools.ajdoc.Main.main(Main.java:210)</description>
      <comments>
		<comment id="1" date="2005-01-12 23:27:39 EST" author="Mik Kersten">Fix committed to CVS.

The problem was that ajdoc wasn ot parsing the HTML files generated by Javadoc 
in the 1.5 JDK properly.  I've updated it to support JDKs up to 1.5, so it's 
successfully generating all documentation now.  However, there seem to be some 
classes missing from the "all classes" listing when running on 1.5, so I added 
bug#82730 for that.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="f70b383d6292995c1e0521e7312e827022fe8fc9" author="mkersten" date="2005-01-13 01:22:51"/>
          <file name="ajdoc/src/org/aspectj/tools/ajdoc/HtmlDecorator.java">
              <method name="findSummaryIndex" returnType="int" parameters="StringBuffer int"/>
          </file>
          <file name="ajdoc/src/org/aspectj/tools/ajdoc/Util.java">
          </file>
          <file name="ajdoc/testdata/coverage/foo/ModelCoverage.java">
              <method name="illegalNewFigElt" returnType="pointcut" parameters=""/>
          </file>
          <file name="ajdoc/testdata/coverage/foo/NoMembers.java">
          </file>
          <file name="ajdoc/testsrc/org/aspectj/tools/ajdoc/CoverageTestCase.java">
          </file>
          <file name="ajdoc/testsrc/org/aspectj/tools/ajdoc/JDKVersionTest.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="83303" opendate="2005-1-20 8:47:00" fixdate="2005-1-21 3:06:00">
    <buginformation>
      <summary>"complier error when mixing inheritance, overriding and polymorphism"</summary>
      <description>Given this scenario:
- class A define method m1 (with proteceted visibility)
- class B extends class A and implements interface I and override method m1 (but
with public visibility)
- interface I define method m1 (with public  visibility)

The code is correct and compile using java 1.4

Let's modify the scenario:
move the method B.m1 into a method introduction on aspect C, such that
- class B extends class A
- apsect C intosuces method m1 into B (with public visibility) and makes B
implemts I (declare parents)
- A and I as before

The compiler reports this error:
B.java:1 [error] The inherited method A.m1() cannot hide the public abstract
method in I
class B extends A {</description>
      <comments>
		<comment id="1" date="2005-01-20 08:49:39 EST" author="mariano">Created attachment 17330 [details]
class A which define protected method m1</comment>
		<comment id="2" date="2005-01-20 08:50:22 EST" author="mariano">Created attachment 17331 [details]
class B which extends A (and inherits m1)</comment>
		<comment id="3" date="2005-01-20 08:50:52 EST" author="mariano">Created attachment 17332 [details]
interface I which define method m1</comment>
		<comment id="4" date="2005-01-20 08:51:39 EST" author="mariano">Created attachment 17333 [details]
aspect C which crosscut B</comment>
		<comment id="5" date="2005-01-20 09:50:28 EST" author="Andrew Clement">Thanks for the test programs.  I've added them as a testcase and checked in the
fix.  We intercept the Java compiler error reporting mechanism in a few places
and check if ITDs satisfy what the compiler thinks is an error.  This bug
highlights a missing case - I just made the ITD check and the program compiles fine.

I will close the bug report when a build with the fix in becomes available
(about 3 hours time).</comment>
		<comment id="6" date="2005-01-21 03:06:16 EST" author="Andrew Clement">Fix available:

BUILD COMPLETE -  build.442
Date of build: 01/20/2005 19:14:23
Time to build: 117 minutes 4 seconds
Last changed: 01/20/2005 14:44:46
Last log entry: Fix for Bug 83303: complier error when mixing inheritance,
overriding and polymorphism
Latest good AspectJ jar available at:
download.eclipse.org/technology/ajdt/dev/aspectj-DEVELOPMENT.jar</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="5d281fd8e98c5c2bec4365d3fc340e2d5f04becc" author="aclement" date="2005-01-20 11:44:39"/>
          <file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/problem/AjProblemReporter.java">
          </file>
          <file name="tests/bugs150/PR83303.java">
          </file>
          <file name="tests/src/org/aspectj/systemtest/ajc150/Ajc150TestsNoHarness.java">
              <method name="testMissingDebugInfoForGeneratedMethods_pr82570" returnType="void" parameters=""/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="83563" opendate="2005-1-24 14:59:00" fixdate="2005-1-26 3:23:00">
    <buginformation>
      <summary>pertypewithin() handing of inner classes</summary>
      <description>It seems that pertypewithin() aspect association does not handle nested classes
correctly. Here is a test class that exhibits the problem:

package test;

public class Test {
    public static void main(String[] args) {
        new NestedTest().run();
    }
	
    static class NestedTest implements Runnable {
        public void run() {
            System.out.println("Running...");
        }
    }
}
 
aspect PertypewithinTest pertypewithin(Test) {
    before() : execution(* *.*(..)) {
        System.out.println(thisJoinPointStaticPart);
    }	
}

&gt; ajc -version
AspectJ Compiler DEVELOPMENT built on Monday Jan 24, 2005 at 17:07:00 GMT

&gt; ajc test\Test.java

&gt; java test.Test
execution(void test.Test.main(String[]))
execution(void test.Test.bar())
Exception in thread "main" java.lang.NoSuchMethodError: test.Test$1.ajc$test_Per
typewithinTest$localAspectOf()Ltest/PertypewithinTest;
        at test.Test$1.run(Test.java)
        at test.Test.bar(Test.java:9)
        at test.Test.main(Test.java:13)

The same problem is seen for anonymous inner classes, as well:
package test;

public class Test {
    public void bar() {
        new Runnable() {
            public void run() {
                System.out.println("Running...");
            }
        }.run();
    }
        
    public static void main(String[] args) {
        new Test().bar();
    }
}
 
aspect PertypewithinTest pertypewithin(Test) {
    before() : execution(* *.*(..)) {
        System.out.println(thisJoinPoint);
    }    
}

&gt; ajc test\Test.java
&gt; java test.Test
execution(void test.Test.main(String[]))
execution(void test.Test.bar())
Exception in thread "main" java.lang.NoSuchMethodError: test.Test$1.ajc$test_Per
typewithinTest$localAspectOf()Ltest/PertypewithinTest;
        at test.Test$1.run(Test.java)
        at test.Test.bar(Test.java:9)
        at test.Test.main(Test.java:13)</description>
      <comments>
		<comment id="1" date="2005-01-25 15:20:24 EST" author="Andrew Clement">Bug fixed.  The problem was in two parts, in order to implement pertypewithin we
'generate' a special type munger and a special shadow munger.  The special type
munger adds the necessary local methods and state to the target matched type. 
The special shadow munger ensures the aspect instance in the target matched type
is initialized.  Both of these new mungers have associated generated
pointcuts/matching logic.

The shadow munger pointcut was wrong and the special type munger matching logic
was wrong with respect to including nested types.

For the shadow munger the pointcut was 'staticinitalization(Test)', when it
should have been 'staticinitialization(*) &amp;&amp; within(Test)' - within(Test)
correctly matches the nested type. (Fix is in PerTypeWithin.java)

For the special type munger (PerTypeWithinTargetTypeMunger.java), the matches()
logic was changed to allow for nested types just like the within pointcut.

thanks for the testcases ramnivas, both added to the test suite. (and please
don't ask me to implement pertype(&lt;pcut&gt;) - that will be a nightmare!!)

waiting for build.</comment>
		<comment id="2" date="2005-01-26 03:23:05 EST" author="Andrew Clement">Fix available:

BUILD COMPLETE -  build.449
Date of build: 01/25/2005 20:48:44
Time to build: 102 minutes 1 second
Last changed: 01/25/2005 20:18:44
Last log entry: Fix for Bug 83563: pertypewithin() handling of inner classes
Latest good AspectJ jar available at:
download.eclipse.org/technology/ajdt/dev/aspectj-DEVELOPMENT.jar</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="1b01255892ef222c14fea25b5db77208f1f6bb13" author="aclement" date="2005-01-26 05:18:42"/>
          <file name="tests/bugs150/PR83563_1.java">
          </file>
          <file name="tests/bugs150/PR83563_2.java">
          </file>
          <file name="tests/src/org/aspectj/systemtest/ajc150/Ajc150TestsNoHarness.java">
              <method name="testCanOverrideProtectedMethodsViaITDandDecp_pr83303" returnType="void" parameters=""/>
          </file>
          <file name="weaver/src/org/aspectj/weaver/PerTypeWithinTargetTypeMunger.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/patterns/PerTypeWithin.java">
              <method name="concretize" returnType="PerClause" parameters="ResolvedTypeX"/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="76055" opendate="2004-10-12 3:43:00" fixdate="2005-3-23 8:47:00">
    <buginformation>
      <summary>Some Pointcut PatternNodes are missing getters to traverse syntax tree</summary>
      <description>In order to find out which other pointcuts are referenced by a pointcut definition  
i need to access the private members of the CflowPointcut, IfPointcut and
NotPointcut PatternNodes found in the weaver module.

Unlike the OrPointcut and AndPointcut classes, they are missing the appropriate
getter methods.</description>
      <comments>
		<comment id="1" date="2004-10-12 03:45:23 EDT" author="Juergen Graf">Created attachment 15105 [details]
This is the proposed patch that adds the needed getters</comment>
		<comment id="2" date="2004-11-18 16:13:08 EST" author="Mik Kersten">Adrian: I don't see a problem with adding these getters, as long as we make it 
clear that this is not API.  And it would make these classes consistent with 
the other ones.

Let me know if you have concerns about this, otherwise I will add the methods.</comment>
		<comment id="3" date="2005-03-23 08:47:00 EST" author="Adrian Colyer">committed to tree.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="b0f270ee1090daf7b5aec3b534b98d28955f77bd" author="acolyer" date="2005-03-23 10:45:09"/>
          <file name="weaver/src/org/aspectj/weaver/patterns/CflowPointcut.java">
              <method name="couldMatchKinds" returnType="Set" parameters=""/>
          </file>
          <file name="weaver/src/org/aspectj/weaver/patterns/IfPointcut.java">
              <method name="alwaysTrue" returnType="boolean" parameters=""/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="82134" opendate="2005-1-4 9:40:00" fixdate="2005-3-23 9:10:00">
    <buginformation>
      <summary>AspectJ 5 M2 should implement backwards compatibility for binary aspect form</summary>
      <description>Hi Adrian,

thanks for the detailed explanation of the compatibility questions. That 
explains the problem I observed.

&gt; * An AspectJ program should always be run with the aspectjrt.jar runtime 
&gt; library that accompanies the distribution containing the compiler/weaver 
&gt; used to build it. 

Interesting point. Which one? The one that is used to compile it or the 
one that is used to weave it?

&gt; However, instead of some IOException, what you should see is a nice 
&gt; message saying that the aspect was produced by a more recent version of 
&gt; AspectJ and cannot be read. Likewise, if you load a pre-aspectj 5 aspect 
&gt; into the AspectJ 5 weaver right now, you'll also see an IOException 
&gt; (odds-on). In M2 we'll detect that and use the back-level loaders to read 
&gt; it in.

Okay. Is there a bug to track this? I really would like to update the 
weaver of my weaving runtime but only if it allows to load/weave 
asepects that are compiled with any of the AJDT versions that are out 
right now (AJDT 1.1.x and AJDT 1.2.0Mx).</description>
      <comments>
		<comment id="1" date="2005-01-07 09:22:25 EST" author="Andrew Clement">I have just checked in the fix for this.  AspectJ5 will now read in 1.2.1 built
aspects.  I have:

1. Updated the version number for the WeaverVersionInfo attribute that exists in
files generated by AspectJ releases since 1.2.1 onwards.  1.2.1 had version 1.0
in the attribute.  AspectJ 5 has version 2.0

2. Rebuilt all the jar files used by testcases so they include the new version
number.

3. Introduced a VersionedDataInputStream subclass of DataInputStream that knows
the weaver version that was used to build the contents of the data in the stream.  

4. Modified all read() methods in the org.aspectj.weaver.patterns package to use
 a VersionedDataInputStream rather than a DataInputStream, they are then able to
check the version before determining what data they should read.

5. Fixed the TypePattern and SignaturePattern read methods to allow for the old
version number (1.0) which wouldn't include varargs info or annotation patterns.

6. Added a testcase that takes 1.2.1 generated code as input for a weave by
AspectJ 5.

Basically, the VersionedDataInputStream defaults to assuming the latest version,
and some changes in the attribute unpacking code modify the version if they come
across a WeaverVersionInfo attribute.  

We can't (without a lot of messy messy work) get AspectJ 5 to accept pre-1.2.1
built aspects as input.

waiting for build ...</comment>
		<comment id="2" date="2005-01-07 11:28:18 EST" author="Andrew Clement">Build available:

BUILD COMPLETE -  build.428
Date of build: 01/07/2005 14:46:31
Time to build: 100 minutes 19 seconds
Last changed: 01/07/2005 14:14:51
Last log entry: Fix for Bug 82134: AspectJ 5 M2 should implement backwards
compatibility for binary aspect form
Latest good AspectJ jar available at:
download.eclipse.org/technology/ajdt/dev/aspectj-DEVELOPMENT.jar</comment>
		<comment id="3" date="2005-03-23 09:10:59 EST" author="Adrian Colyer">Should have been closed on Jan. 7th...</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="797b6a6afb75b14dc530bc0831566e110da3ae91" author="aclement" date="2005-01-07 11:14:45"/>
          <file name="tests/src/org/aspectj/systemtest/ajc150/AllTestsJava5_binaryWeaving.java">
              <method name="suite" returnType="Test" parameters=""/>
          </file>
          <file name="tests/src/org/aspectj/systemtest/ajc150/MigrationTests.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/AdviceKind.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/AjAttribute.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/ResolvedPointcutDefinition.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/VersionedDataInputStream.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/WeaverStateInfo.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/bcel/BcelAttributes.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/bcel/BcelField.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/bcel/BcelMethod.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/bcel/BcelObjectType.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java">
              <method name="printAspectAttributes" returnType="void" parameters="PrintStream"/>
          </file>
          <file name="weaver/src/org/aspectj/weaver/patterns/AndAnnotationTypePattern.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/patterns/AndPointcut.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/patterns/AndTypePattern.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/patterns/AnnotationPatternList.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/patterns/AnnotationPointcut.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/patterns/AnnotationTypePattern.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/patterns/ArgsAnnotationPointcut.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/patterns/ArgsPointcut.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/patterns/BindingAnnotationTypePattern.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/patterns/BindingTypePattern.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/patterns/CflowPointcut.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/patterns/Declare.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/patterns/DeclareErrorOrWarning.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/patterns/DeclareParents.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/patterns/DeclarePrecedence.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/patterns/DeclareSoft.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/patterns/ExactAnnotationTypePattern.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/patterns/ExactTypePattern.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/patterns/HandlerPointcut.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/patterns/IfPointcut.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/patterns/KindedPointcut.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/patterns/ModifiersPattern.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/patterns/NamePattern.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/patterns/NotAnnotationTypePattern.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/patterns/NotPointcut.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/patterns/NotTypePattern.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/patterns/OrAnnotationTypePattern.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/patterns/OrPointcut.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/patterns/OrTypePattern.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/patterns/PerCflow.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/patterns/PerClause.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/patterns/PerFromSuper.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/patterns/PerObject.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/patterns/PerSingleton.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/patterns/Pointcut.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/patterns/ReferencePointcut.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/patterns/SignaturePattern.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/patterns/ThisOrTargetAnnotationPointcut.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/patterns/ThisOrTargetPointcut.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/patterns/ThrowsPattern.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/patterns/TypePattern.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/patterns/TypePatternList.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/patterns/WildAnnotationTypePattern.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/patterns/WithinAnnotationPointcut.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/patterns/WithinCodeAnnotationPointcut.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/patterns/WithinPointcut.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/patterns/WithincodePointcut.java">
          </file>
          <file name="weaver/testsrc/org/aspectj/weaver/bcel/PatternWeaveTestCase.java">
              <method name="checkSerialize" returnType="void" parameters="Pointcut"/>
          </file>
          <file name="weaver/testsrc/org/aspectj/weaver/bcel/PointcutResidueTestCase.java">
              <method name="checkSerialize" returnType="void" parameters="Pointcut"/>
          </file>
          <file name="weaver/testsrc/org/aspectj/weaver/patterns/AndOrNotTestCase.java">
              <method name="checkSerialization" returnType="void" parameters="String"/>
          </file>
          <file name="weaver/testsrc/org/aspectj/weaver/patterns/DeclareErrorOrWarningTestCase.java">
          </file>
          <file name="weaver/testsrc/org/aspectj/weaver/patterns/ModifiersPatternTestCase.java">
              <method name="checkSerialization" returnType="void" parameters="String"/>
          </file>
          <file name="weaver/testsrc/org/aspectj/weaver/patterns/NamePatternTestCase.java">
          </file>
          <file name="weaver/testsrc/org/aspectj/weaver/patterns/SignaturePatternTestCase.java">
              <method name="checkSerialization" returnType="void" parameters="SignaturePattern"/>
          </file>
          <file name="weaver/testsrc/org/aspectj/weaver/patterns/TypePatternListTestCase.java">
              <method name="checkSerialization" returnType="void" parameters="String"/>
          </file>
          <file name="weaver/testsrc/org/aspectj/weaver/patterns/TypePatternTestCase.java">
              <method name="checkSerialization" returnType="void" parameters="String"/>
          </file>
          <file name="weaver/testsrc/org/aspectj/weaver/patterns/WithinTestCase.java">
              <method name="checkSerialization" returnType="void" parameters="Pointcut"/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="86789" opendate="2005-2-27 16:24:00" fixdate="2005-3-23 9:51:00">
    <buginformation>
      <summary>"annotations and ""circularity in declare precedence"""</summary>
      <description>The following example

    declare precedence : (@PremiumPartner *), *;

results in the error message

    circularity in declare precedence, ''*'' occurs more than once   

It is the same example (apart form the name) as in the developers notebook.
(see also http://dev.eclipse.org/mhonarc/lists/aspectj-dev/msg01326.html)</description>
      <comments>
		<comment id="1" date="2005-03-23 09:51:44 EST" author="Adrian Colyer">fixed in aj5m2</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="f90186cb8eac1b4abae4c9b8fd74828b98f534ab" author="acolyer" date="2005-03-09 11:13:14"/>
          <file name="weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java">
              <method name="matchesExactlyByName" returnType="boolean" parameters="String"/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="87376" opendate="2005-3-8 10:11:00" fixdate="2005-3-24 11:40:00">
    <buginformation>
      <summary>NPE when unresolved type of a bound var in a pointcut expression (EclipseFactory.java:224)</summary>
      <description>see attached mini-project to reproduce</description>
      <comments>
		<comment id="1" date="2005-03-08 10:12:16 EST" author="Adrian Colyer">Created attachment 18534 [details]
contents of an AJ project "Bug" with 2 source files that reproduce the problem.</comment>
		<comment id="2" date="2005-03-08 10:52:55 EST" author="Matt Chapman">I'm passing this back over the fence, as it happens from the command line
(although only when building the structure model):

E:\Bug&gt;ajc -emacssym @.generated.lst
E:\Bug\a\b\d\NPE.aj [error] Internal compiler error
java.lang.NullPointerException
        at org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.makeResolvedMember(EclipseFactory.java:224)
        at org.aspectj.ajdt.internal.core.builder.AsmHierarchyBuilder.getPointcutDeclaration(AsmHierarchyBuilder.java:384)
        at org.aspectj.ajdt.internal.core.builder.AsmHierarchyBuilder.addUsesPointcutRelationsForNode(AsmHierarchyBuilder.java:369)
        at org.aspectj.ajdt.internal.core.builder.AsmHierarchyBuilder.visit(AsmHierarchyBuilder.java:343)
        at org.aspectj.org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.traverse(MethodDeclaration.java:167)
        at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.traverse(TypeDeclaration.java:1133)
        at org.aspectj.org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.traverse(CompilationUnitDeclaration.java:314)
        at org.aspectj.ajdt.internal.core.builder.AsmHierarchyBuilder.internalBuild(AsmHierarchyBuilder.java:141)
        at org.aspectj.ajdt.internal.core.builder.AsmHierarchyBuilder.buildStructureForCompilationUnit(AsmHierarchyBuilder.java:81)
        at org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.finishedCompilationUnit(EclipseFactory.java:354)
        at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterProcessing(AjCompilerAdapter.java:139)
        at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:373)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:682)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:168)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:102)
        at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:109)
        at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:60)
        at org.aspectj.tools.ajc.Main.run(Main.java:291)
        at org.aspectj.tools.ajc.Main.runMain(Main.java:227)
        at org.aspectj.tools.ajc.Main.main(Main.java:80)

(no source information available)
E:\Bug\a\b\d\NPE.aj:9 [error] I cannot be resolved to a type
pointcut ii(I i) : execution(* I.*(..)) &amp;&amp; this(i);

E:\Bug\a\b\d\NPE.aj:11 [error] I cannot be resolved to a type
after(I i) returning : ii(i) {

ABORT

Exception thrown from AspectJ DEVELOPMENT



E:\Bug&gt;ajc -version
AspectJ Compiler DEVELOPMENT built on Friday Feb 18, 2005 at 17:12:57 GMT</comment>
		<comment id="3" date="2005-03-09 06:04:27 EST" author="Matt Chapman">*** Bug 86051 has been marked as a duplicate of this bug. ***</comment>
		<comment id="4" date="2005-03-10 08:33:39 EST" author="Adrian Colyer">fix committed in tree, will close bug once available in a published build.</comment>
		<comment id="5" date="2005-03-23 09:55:37 EST" author="Adrian Colyer">this will be in m2</comment>
		<comment id="6" date="2005-03-24 11:40:56 EST" author="Andrew Clement">Fix available, see download page:

aspectj-DEVELOPMENT-20050324155000.jar</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="85aa1520881e7271e658b9377dfd020fde28868c" author="acolyer" date="2005-03-10 10:34:55"/>
          <file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmHierarchyBuilder.java">
              <method name="getPointcutDeclaration" returnType="ResolvedMember" parameters="ReferencePointcut MethodDeclaration"/>
          </file>
          <file name="tests/bugs150/pr87376/I.java">
          </file>
          <file name="tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java">
              <method name="testBadASMforEnums" returnType="void" parameters=""/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="88652" opendate="2005-3-21 12:05:00" fixdate="2005-3-24 11:42:00">
    <buginformation>
      <summary>an array type as the last parameter in a signature does not match on the varargs declared method</summary>
      <description>I get this warning in my code, though I actually do not specify an array type.

The signature I want to match is the following constructor signature:

public Touple(Object formulaHandle, Object... propositions) {...}

Touple implements IRelation

The pointcut I use is the following:

pointcut p(): call(Touple.new(..));

This should actually match the signature, shouldn't it?
AspectJ however complains with this warning:

an array type as the last parameter in a signature does not match on the varargs 
declared method: void ltlrv.Touple.&lt;init&gt;(java.lang.Object, java.lang.Object[]) 
[Xlint:cantMatchArrayTypeOnVarargs]

Also, even if I *had* stated an array type, it should match even then IMHO, 
since arrays and varargs are actually the same in the Java implementation.</description>
      <comments>
		<comment id="1" date="2005-03-22 08:06:52 EST" author="Adrian Colyer">Fixed in tree. Will close bug once fix is available in a published build.

The pcut call(Touple.new(Object,Object[]) does *not* match against a signature

Touple(Object, Object...)

because call matches based on signature, and the signatures:

Touple(Object, Object...) and Touple(Object, Object[]) are different signatures
(try passing an Object[] to both as the second param in the call - the results
are *not* the same). 

However, args(Object, Object[]) matches calls made to both signatures since the
*run-time type* of the varargs argument is Object[].

Even "simple" Java 5 features can be quite confusing at times!</comment>
		<comment id="2" date="2005-03-22 15:33:54 EST" author="Adrian Colyer">to update this bug for the record, *I* was the confused one this afternoon (and
even documented contrary to my earlier entry in the notebook:
http://dev.eclipse.org/viewcvs/indextech.cgi/~checkout~/aspectj-home/doc/ajdk15notebook/varargs.html#d0e1849
). An Object[] can be passed to an Object... signature and acts exactly as if
the operation were called with each array element passed separately. new(..)
should clearly match regardless of my confusion, and now it does :)</comment>
		<comment id="3" date="2005-03-23 09:59:36 EST" author="Adrian Colyer">fix will be available in m2 build</comment>
		<comment id="4" date="2005-03-24 11:42:21 EST" author="Andrew Clement">Fix available, see download page:

aspectj-DEVELOPMENT-20050324155000.jar</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="b5f4d09e4f4e45943c6c8b3dc8dca0c05b90f27c" author="acolyer" date="2005-03-22 10:14:44"/>
          <file name="tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java">
              <method name="testSyntaxError" returnType="void" parameters=""/>
          </file>
          <file name="weaver/src/org/aspectj/weaver/patterns/ExactTypePattern.java">
              <method name="ExactTypePattern" returnType="null" parameters="TypeX boolean boolean"/>
          </file>
          <file name="weaver/src/org/aspectj/weaver/patterns/SignaturePattern.java">
              <method name="isNotMatchBecauseOfVarargsIssue" returnType="boolean" parameters="TypePatternList int"/>
          </file>
          <file name="weaver/src/org/aspectj/weaver/patterns/TypePattern.java">
              <method name="isStarAnnotation" returnType="boolean" parameters=""/>
          </file>
          <file name="weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java">
              <method name="getDimensions" returnType="int" parameters=""/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="96371" opendate="2005-5-23 17:22:00" fixdate="2005-5-30 5:59:00">
    <buginformation>
      <summary>Patch to support loading aop.xml properly</summary>
      <description>AspectJ 5 load-time weaving in CVS HEAD isn't loading aop.xml files properly 
from a jar file without specifying the global -D flag. The following patch 
fixes the problem for me so I can load aop.xml files from jars on the 
classpath without a global flag:

ClassLoaderWeavingAdaptor.java:109:
-             Enumeration xmls = loader.getResources("/META-INF/aop.xml");
+            Enumeration xmls = loader.getResources("META-INF/aop.xml");


I.e., getResources doesn't work with a leading separator, at least not on the 
Sun VM or JRockIt on Windows. Writing a unit test for this would require 
significant changes to the loadtime module, so I wrote a standalone test of 
the API:

public class TestApi extends TestCase {
    public void testLoadResource() throws Exception {
        URL urlList[] = { new URL
("file:testsrc/org/aspectj/weaver/loadtime/test/sample.jar") };
        ClassLoader loader = new URLClassLoader(urlList);	
          
        Enumeration xmls = loader.getResources("META-INF/aop.xml");
        //this version fails:
        //Enumeration xmls = loader.getResources("/META-INF/aop.xml");

        assertTrue(xmls.hasMoreElements());
    }
}</description>
      <comments>
		<comment id="1" date="2005-05-23 17:24:01 EDT" author="Ron Bodkin">Created attachment 21605 [details]
Sample jar to use with sample unit test case</comment>
		<comment id="2" date="2005-05-23 17:31:05 EDT" author="Adrian Colyer">Thanks Ron :)
I've assigned to Alex since I'm going to be out of contact for the next few days
and Andy is at a conference in Vegas...</comment>
		<comment id="3" date="2005-05-30 05:59:55 EDT" author="Alexandre Vasseur">done</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="f14646f57a93e7ec865416048c4491d9943064e5" author="avasseur" date="2005-05-30 07:00:21"/>
          <file name="loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java">
          </file>
          <file name="loadtime5/java5-src/org/aspectj/weaver/loadtime/ClassPreProcessorAgentAdapter.java">
          </file>
          <file name="tests/java5/ataspectj/ataspectj/SingletonAspectBindingsTest.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="83565" opendate="2005-1-24 17:13:00" fixdate="2005-6-3 11:34:00">
    <buginformation>
      <summary>"BCException ""bad type name"" thrown when compiling"</summary>
      <description>I just downloaded AJDT version 1.2.0.20050124144759 and I am running Eclipse
3.1M4.  I tried to use aspectJ on an existing Java 5 project.  There are no
aspects in it yet, just straight Java 5.  The project runs just fine as a
standard Java project. 

When add the AspectJ nature and I try to compile the project, no class files are
generated and I get this error generated on a type that is parameterized:

Internal compiler error
org.aspectj.weaver.BCException: Bad type name: 

	at org.aspectj.weaver.TypeX.nameToSignature(TypeX.java:634)

	at org.aspectj.weaver.TypeX.forName(TypeX.java:87)

	at org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.fromBinding(EclipseFactory.java:155)

	at org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.fromBindings(EclipseFactory.java:163)

	at org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.makeResolvedMember(EclipseFactory.java:229)

	at org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.makeResolvedMember(EclipseFactory.java:224)

	at org.aspectj.ajdt.internal.core.builder.AsmHierarchyBuilder.visit(AsmHierarchyBuilder.java:675)

	at org.aspectj.org.eclipse.jdt.internal.compiler.ast.ConstructorDeclaration.traverse(ConstructorDeclaration.java:447)

	at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.traverse(TypeDeclaration.java:1133)

	at org.aspectj.org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.traverse(CompilationUnitDeclaration.java:314)

	at org.aspectj.ajdt.internal.core.builder.AsmHierarchyBuilder.internalBuild(AsmHierarchyBuilder.java:171)

	at org.aspectj.ajdt.internal.core.builder.AsmHierarchyBuilder.buildStructureForCompilationUnit(AsmHierarchyBuilder.java:111)

	at org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.finishedCompilationUnit(EclipseFactory.java:354)

	at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterProcessing(AjCompilerAdapter.java:138)

	at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:373)

	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:682)

	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:168)

	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:102)

	at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:122)

	at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:165)


The source code of the file that generates this error is:

package mj.compiler.ast;

import java.util.Vector;

import mj.compiler.Driver;
import mj.compiler.Visitor;

public class Sequence&lt;T extends AST&gt; extends AST {
	
	private Vector&lt;T&gt; elements = new Vector&lt;T&gt;();
	
	public Sequence() {
		super(0, 0);
    }
	
	public Sequence(T element) {
		super(element);
		elements.add(element);
    }
    
	public int length()       { return elements.size(); }
	public T elementAt(int i) { return elements.elementAt(i); }

    public Sequence add(T element) {
    	elements.add(element);
		return this;
    }
    
    public Sequence add(int pos, T element) {
    	elements.add(pos, element);
    	return this;
    }
    
    public Sequence addAll(Sequence&lt;T&gt; others) {		
		if(  others == null ) return this;
		elements.addAll(others.elements);
		return this;
    }
    
    public void visitChildren(Visitor v) {
    	for( AST element : elements ) {
    		element.visit(v);
        }
    }
    
    public void replaceChild(AST old, AST gnu) {
    	T NEW = (T)gnu;
    	for(int i = 0; i &lt; elements.size(); i++ ) {
    		if( elements.get(i) == old ) {
    			elements.set(i, NEW);
    			return;
    		}
    	}
    	throw new Driver.CompileError("Can't find child in replaceChild.");
    }

	/*** START GENERATED VISITOR PROTOCOL ***///TODO
    public void visit(mj.compiler.Visitor v) {
        v.visitSequence(this);
    }
	/*** END GENERATED VISITOR PROTOCOL ***/
}


Hope this helps something.

ps- I am able to create and run a very simple AspectJ project with an aspect,
advice, and some Java 5 syntax.</description>
      <comments>
		<comment id="1" date="2005-01-24 17:21:37 EST" author="Adrian Colyer">This looks like the weaver code that builds the structure model for ajdt is
choking on some generic type name its not expecting to see. I'm reassigning to
Andy temporarily as I'm on a plane the next two days...</comment>
		<comment id="2" date="2005-01-25 03:57:53 EST" author="Andrew Clement">I've recreated from the command line by compiling that type with -emacssym
(which generated the ASM).  Adrian is correct that we choke on the generic
signature.

Although not all that helpful a temporary workaround is to turn off structure
model building in the project properties, it should then compile the code
successfully (but the xref view will be empty...)</comment>
		<comment id="3" date="2005-01-25 11:57:30 EST" author="Mik Kersten">I think I know what's going wrong here and will plan on fixing it this week.</comment>
		<comment id="4" date="2005-01-27 12:13:01 EST" author="Mik Kersten">Andy: the ASM part of this is fixed, but note the following caveat.

The problem was that the weaver's TypeX.nameToSignature(String name) can't 
handle generic return types, for example the "T" in:

public T elementAt(int i) {
  return elements.elementAt(i);
}

I've made the AsmHierarchyBuilder robust to that problem, which means that 
when building a signature it will put &lt;undefined&gt; whenever the weaver can't 
resolve a name.  I committed a minimal test of this to, which now passes (if 
the single test is uncommented and 1.5 is required).

/ajde/testsrc/org/aspectj/ajde/GenericsTest.java

Note that the hierarchy of the structure model is correct, although it would 
be nice to get the right type name in there for clients that make use the 
bytecode signature.  I'll leave this open in case you want to use this test 
case to experiment.  In that case you may also want to inspect the catch catch
(BCException) clause in AsmHierarchyBuilder.</comment>
		<comment id="5" date="2005-03-23 09:19:21 EST" author="Adrian Colyer">lets take one more look at this one before closing out m2...</comment>
		<comment id="6" date="2005-03-23 15:33:39 EST" author="Adrian Colyer">the fix for bug 843333 should ensure that TypeX.forName never sees a
parameterized type. This is certainly good enough for m2. Moving the bug to m3
where we will pass parameterized types through in all probability.</comment>
		<comment id="7" date="2005-05-03 17:15:42 EDT" author="Joshua Davis">(In reply to comment #4)
&gt; The problem was that the weaver's TypeX.nameToSignature(String name) can't 
&gt; handle generic return types, for example the "T" in:
&gt; 
&gt; public T elementAt(int i) {
&gt;   return elements.elementAt(i);
&gt; }
I've encountered the same problem using AJDT 1.2.0.200503135046 AND Eclipse
3.1M6, only my class has no methods with a generic return type or generic
parameters.

=== Source for my file ===
package com.merklenet.test.mock;

import java.rmi.MarshalledObject;
import java.rmi.RemoteException;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

import com.merklenet.knowledgelink.prototype.framework.Envelope;
import com.merklenet.knowledgelink.prototype.framework.ServiceIdentifier;

import net.jini.core.entry.Entry;
import net.jini.core.entry.UnusableEntryException;
import net.jini.core.event.EventRegistration;
import net.jini.core.event.RemoteEventListener;
import net.jini.core.lease.Lease;
import net.jini.core.transaction.Transaction;
import net.jini.core.transaction.TransactionException;
import net.jini.space.JavaSpace;

public class MockJavaSpaceForEnvelopes implements JavaSpace {
   private Map&lt;ServiceIdentifier, Set&lt;Envelope&gt;&gt; envelopes = 
      new HashMap&lt;ServiceIdentifier, Set&lt;Envelope&gt;&gt;();

   public MockJavaSpaceForEnvelopes() {
      super();
   }

   public Lease write(Entry entry, Transaction txn, long lease) 
      throws TransactionException, RemoteException 
   {
      return write((Envelope) entry, txn, lease);
   }

   public Lease write(Envelope entry, Transaction txn, long lease) 
         throws TransactionException, RemoteException 
   {
      synchronized (envelopes) {
         Set&lt;Envelope&gt; envelopesForService = getEnvelopeSetForTemplate(entry);
         envelopesForService.add(entry);
         envelopes.notify();
      }
      return null;
   }

   private Set&lt;Envelope&gt; getEnvelopeSetForTemplate(Envelope entry) {
      Set&lt;Envelope&gt; envelopesForService = envelopes.get(entry.currentAddressee);
      if (envelopesForService == null) {
         envelopesForService = new HashSet&lt;Envelope&gt;();
         envelopes.put(entry.currentAddressee, envelopesForService);
      }
      return envelopesForService;
   }

   public Entry read(Entry tmpl, Transaction txn, long timeout) 
         throws UnusableEntryException, TransactionException, 
            InterruptedException, RemoteException 
   {
      return read((Envelope) tmpl, txn, timeout);
   }

   public Entry read(Envelope tmpl, Transaction txn, long timeout) 
      throws UnusableEntryException, TransactionException, 
         InterruptedException, RemoteException 
   {
      synchronized (envelopes) {
         if (getEnvelopeSetForTemplate(tmpl).isEmpty()) {
            envelopes.wait(timeout);
         }
         return readIfExists(tmpl, txn, timeout);
      }
   }

   public Entry readIfExists(Entry tmpl, Transaction txn, long timeout) 
      throws UnusableEntryException, TransactionException, 
         InterruptedException, RemoteException 
   {
      return readIfExists((Envelope) tmpl, txn, timeout);
   }

   public Entry readIfExists(Envelope tmpl, Transaction txn, long timeout) 
      throws UnusableEntryException, TransactionException, 
         InterruptedException, RemoteException 
   {
      synchronized (envelopes) {
         Set&lt;Envelope&gt; envelopeSetForTemplate = getEnvelopeSetForTemplate(tmpl);
         if (envelopeSetForTemplate.isEmpty())
            return null;
         return envelopeSetForTemplate.iterator().next();
      }
   }

   public Entry take(Entry tmpl, Transaction txn, long timeout) 
      throws UnusableEntryException, TransactionException, 
         InterruptedException, RemoteException 
   {
      return take((Envelope) tmpl, txn, timeout);
   }

   public Entry take(Envelope tmpl, Transaction txn, long timeout) 
      throws UnusableEntryException, TransactionException, 
         InterruptedException, RemoteException 
   {
      synchronized (envelopes) {
         if (getEnvelopeSetForTemplate(tmpl).isEmpty()) {
            envelopes.wait(timeout);
         }
         return takeIfExists(tmpl, txn, timeout);
      }
   }

   public Entry takeIfExists(Entry tmpl, Transaction txn, long timeout) 
      throws UnusableEntryException, TransactionException, 
         InterruptedException, RemoteException 
   {
      return takeIfExists((Envelope) tmpl, txn, timeout);
   }

   public Entry takeIfExists(Envelope tmpl, Transaction txn, long timeout) 
      throws UnusableEntryException, TransactionException, 
         InterruptedException, RemoteException 
   {
      synchronized (envelopes) {
         Set&lt;Envelope&gt; envelopeSetForTemplate = getEnvelopeSetForTemplate(tmpl);
         if (envelopeSetForTemplate.isEmpty())
            return null;
         Entry result = envelopeSetForTemplate.iterator().next();
         envelopeSetForTemplate.remove(result);
         return result;
      }
   }

   public EventRegistration notify(Entry tmpl, Transaction txn, 
         RemoteEventListener listener, long lease, MarshalledObject handback) 
      throws TransactionException, RemoteException 
   {
      throw new UnsupportedOperationException("notify");
   }

   public Entry snapshot(Entry e) throws RemoteException {
      throw new UnsupportedOperationException("snapshot");
   }
}
======</comment>
		<comment id="8" date="2005-05-06 11:36:16 EDT" author="Andrew Clement">The failing code has now be upgraded to support basic generics - the use of
parameterized types and raw types *should* be ok... so this might be resolved in
the next version of AJDT...  unfortunately without a simple testcase I can't
confirm that right now...</comment>
		<comment id="9" date="2005-05-06 22:48:06 EDT" author="Joshua Davis">Created attachment 20796 [details]
AspectJ Eclipse project illustrating the bug</comment>
		<comment id="10" date="2005-05-06 22:58:57 EDT" author="Joshua Davis">(In reply to comment #8)
&gt; The failing code has now be upgraded to support basic generics - the use of
&gt; parameterized types and raw types *should* be ok... so this might be resolved in
&gt; the next version of AJDT...  unfortunately without a simple testcase I can't
&gt; confirm that right now...
Thank you for looking at this.

I created a simple testcase and attached it.  I discovered that the file where
the error was reported was *not* the file with the problem -- it just had the
bad luck of being the last file in the build path.

My test case has two java files, a parametized interface and a parametized type
implementing the interface.  If the parametized type does not implement the
interface, then there the error does not occur.</comment>
		<comment id="11" date="2005-06-01 12:30:25 EDT" author="Andrew Clement">This appears fixed with the work I've done for bug 97763.

Without my changes (actually with the dev build 20050510144051), on compiling
the attached test program I was getting:

[error] can't find type test.TroubleInterface&lt;java.lang.Object&gt;


1 error

Now with my changes, I don't get any errors at all.

Waiting on a dev build to be uploaded now...</comment>
		<comment id="12" date="2005-06-03 11:34:00 EDT" author="Andrew Clement">Fixed in latest dev build from http://eclipse.org/aspectj/downloads.php</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="5765d534a5437b624646ff20ca487346fa76a267" author="mkersten" date="2005-01-28 02:21:17"/>
          <file name="ajde/testdata/bug-83565/Bug.java">
          </file>
          <file name="ajde/testsrc/org/aspectj/ajde/AjdeTests.java">
              <method name="suite" returnType="Test" parameters=""/>
          </file>
          <file name="ajde/testsrc/org/aspectj/ajde/GenericsTest.java">
          </file>
          <file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmHierarchyBuilder.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="81846" opendate="2004-12-23 7:27:00" fixdate="2005-6-3 11:35:00">
    <buginformation>
      <summary>EclipseAdapterUtils.java:83</summary>
      <description>java.lang.ArrayIndexOutOfBoundsException: 3

Unfortunately I can't provide much more information, please see the attached 
compiler dump.</description>
      <comments>
		<comment id="1" date="2004-12-23 07:28:39 EST" author="attila lendvai">Created attachment 16822 [details]
Compiler dump</comment>
		<comment id="2" date="2004-12-23 07:36:14 EST" author="attila lendvai">Created attachment 16823 [details]
1.5.0 M1 dump without recompiling dependant projects</comment>
		<comment id="3" date="2004-12-23 07:44:46 EST" author="attila lendvai">Created attachment 16824 [details]
1.5.0 M1 dump after recompiling dependant projects with 1.5.0 M1</comment>
		<comment id="4" date="2004-12-23 07:55:40 EST" author="attila lendvai">btw, the warnings in the first dump like this one:

[warning] can not resolve this member: void com.netvisor.ttm.ui.HpsdCSVTask.
addUserMessage(java.lang.String, int) [Xlint:unresolvableMember]

are false warnings as far as i can understand what's going on. 
UserMessageCollectorMixin is defined in a jar file which is on the classpath, 
not aspectpath. therefore i have an aspect in the project like this:

public abstract aspect UserMessageCollectorMixin extends com.netvisor.common.
UserMessageCollectorMixin
{
 declare parents: (CSVTaskBase) implements UserMessageCollector;

 declare precedence: UserMessageCollectorMixin;
}

that "brings in" the aspect into the waeving. i had these warnings for a long 
time, so i doubt it's closely related.</comment>
		<comment id="5" date="2004-12-23 09:15:17 EST" author="attila lendvai">it IS connected to the warnings: it tires to issue a warning at an empty line, 
and while trimming the empty line goes out of the array...

i've modified the code like this around the lines where the exception happens:

        while ((((c = extract[trimLeftIndex++]) == TAB) || (c == SPACE)) &amp;&amp; 
trimLeftIndex &lt; extract.length) {
        };
        
        if (trimLeftIndex &gt;= extract.length)
            return new String(extract) + "\n"; //$NON-NLS-2$ //$NON-NLS-1$

unfortunately the warnings are still bugous. i've rearranged the build process 
to put the jar containing UserMessageCollectorMixin into the aspectpath, but i 
still get the warnings... </comment>
		<comment id="6" date="2004-12-23 09:17:13 EST" author="attila lendvai">Created attachment 16825 [details]
UserMessageCollector.java</comment>
		<comment id="7" date="2004-12-23 09:35:47 EST" author="attila lendvai">Created attachment 16826 [details]
UserMessageCollectorMixin.java</comment>
		<comment id="8" date="2004-12-23 10:19:33 EST" author="Andrew Clement">You could turn off the xlint warnings until I fix the bug, simplest way is:

ajc -Xlint:ignore &lt;.....&gt;

(that might be xlint="ignore" in an ant build.xml).

===
Those warnings are telling you that ajc couldn't resolve a member, you *may or
may not* be interested in the warning depending on whether the advice you have
written was intended to capture references to those members.  From some write up
I put into bug 59596:

===
An unresolvable member is a member (method declaration) we have found in some 
inheritance hierarchy (its on some interface somewhere) that has no 
implementation within that hierarchy, apparently due to the use of abstract 
classes that provide no implementation for it.
Without the concrete implementation it can't be successfully 'resolved' and so 
we can't match on it.
====

I've seen more unresolvablemember issues recently as we have moved to partially
supporting 1.5.  For example if some piece of code uses an API that only exists
on 1.5 (maybe Integer.valueOf(int) which was added in 1.5 for autoboxing) and
then AspectJ is asked to weave it, you are likely to get unresolvableMember
errors for calls to those members - I'm not saying this is what is happening
here but it is one cause of unresolvablemember problems.  Are you relying on
autoboxing in your app?

The possible solution is to put the rt.jar from a 1.5 JVM on your classpath
ahead of everything else (effectively running the AspectJ compiler on a 1.5 VM -
I can't vouch that this will work as we haven't done much testing of it yet).

It may also help to ensure you have 'debug="yes"' on the javac call to compile
your source code as the default is no and it looks like we are blowing up whilst
accessing some source context to put out a sensible message.

However, obviously there is something to fix, so I'll do that soon as I can.</comment>
		<comment id="9" date="2004-12-23 10:31:06 EST" author="attila lendvai">thanks for the quick answer, Andy!

since then i've compiled an 1.2.1 with my patch in it which avoids a crash, so 
don't worry about this more then appropiate.

an idea: errors in nonessential parts of the system (like messaging the user) 
should only generate a warning and go on with the execution.

about the warning: i don't use 1.5 vm. this warning was lingering around for a 
long time now, pre 1.5. please note that i use the aspect in question in other 
projects in similar setups, but the warnings appear only in this project.

also note that the aspect is privileged, so it should be woven before the 
others. well, i have other privileged aspects... so it would be helpful if the 
warning message contained what aspect is being woven while the method is not 
found, so i could take a look at declare precedence stuff.

thanks, and marry christmas! :)</comment>
		<comment id="10" date="2005-01-03 04:07:20 EST" author="attila lendvai">I meant declare precedence, not privileged. Bah, too much work...</comment>
		<comment id="11" date="2005-03-23 09:09:39 EST" author="Adrian Colyer">oops, this patch should have been integrated long ago. scheduling for aj5m3...</comment>
		<comment id="12" date="2005-06-01 10:55:40 EDT" author="attila lendvai">I'm hit by this bug again as we are moving to java 1.5. Could you please add at 
least the check not to access the array out of bounds? I've tried xlint="ignore" 
but id didn't help...

I know I could compile a locally patched version, but I've already driven mad my 
collegues with having custom versions of all kind of OSS stuff... :)</comment>
		<comment id="13" date="2005-06-01 12:13:42 EDT" author="Andrew Clement">I've just integrated your patch - it will appear in a dev build shortly.  sorry
for the long delay!!

Out of interest, with your patch in place, what kind of strange messages do you
see for these empty lines?  Is there any way you can paste a sample of them into
here?</comment>
		<comment id="14" date="2005-06-03 11:35:44 EDT" author="Andrew Clement">Patch integrated.

See latest dev build from http://eclipse.org/aspectj/downloads.php</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="a675b659cdc4da45383551e75c9472556c095f94" author="aclement" date="2005-06-02 01:12:58"/>
          <file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/EclipseAdapterUtils.java">
              <method name="makeLocationContext" returnType="String" parameters="ICompilationUnit IProblem"/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="99168" opendate="2005-6-9 11:20:00" fixdate="2005-6-14 12:04:00">
    <buginformation>
      <summary>[generics][itds] ITD on generic inner class crashes ajc</summary>
      <description>inter-type declaration on a generic inner class crashes the compiler:

class Outer {
  class Inner {}
  class Generic_Inner&lt;T&gt; {}
}

class Generic_Outer&lt;T&gt; {
}

aspect Injector {
  int Outer.outer; // works
  int Outer.Inner.inner; // works
  int Generic_Outer.outer; // works
  int Outer.Generic_Inner.inner; // crashes
}


/home/user/sgelin3/dev/java/ajc/new_bug/Bug.java [error] Internal compiler error
java.lang.RuntimeException: can't handle: class Generic_Inner#RAW
        extends NULL TYPENULL SUPERINTERFACES
        enclosing type : OuterNULL FIELDSNULL METHODS


        at org.aspectj.ajdt.internal.compiler.lookup.InterTypeScope.makeSourceTypeBinding(InterTypeScope.java:35)
        at org.aspectj.ajdt.internal.compiler.lookup.InterTypeScope.&lt;init&gt;(InterTypeScope.java:28)
        at org.aspectj.ajdt.internal.compiler.ast.InterTypeDeclaration.resolve(InterTypeDeclaration.java:101)
        at org.aspectj.ajdt.internal.compiler.ast.InterTypeFieldDeclaration.resolve(InterTypeFieldDeclaration.java:141)
        at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1076)
        at org.aspectj.ajdt.internal.compiler.ast.AspectDeclaration.resolve(AspectDeclaration.java:110)
        at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1125)
...</description>
      <comments>
		<comment id="1" date="2005-06-09 11:59:45 EDT" author="Andrew Clement">fix for M3.</comment>
		<comment id="2" date="2005-06-14 07:11:49 EDT" author="Andrew Clement">Bug occurs because InterTypeScope.makeSourceTypeBinding() doesn't acknowledge
that it may be passed a ParameterizedTypeBinding or a RawTypeBinding (the latter
is a subclass of the former).  Neither of these are SourceTypeBindings *however*
both of them contain a field called 'type' that refers to the generic type which
they are based upon.  The fix is to recognize the PTB hierarchy and if it is
being used return the type field.  Bit more testing, then I'll check in the fix.</comment>
		<comment id="3" date="2005-06-14 10:53:22 EDT" author="Andrew Clement">Fix checked in, waiting on build before closing.</comment>
		<comment id="4" date="2005-06-14 12:04:45 EDT" author="Andrew Clement">Fix available, see aspectj download page: aspectj-DEVELOPMENT-20050614164300.jar</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="588023e3beb9f861405f4f9a580122993d2dbb47" author="aclement" date="2005-06-14 11:53:37"/>
          <file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/InterTypeScope.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="98320" opendate="2005-6-3 12:54:00" fixdate="2005-6-14 12:05:00">
    <buginformation>
      <summary>[generics][itds] intertype with nested generic type</summary>
      <description>import java.util.*;

class C {
  Set&lt;String&gt; simple_local;
  Set&lt;Set&lt;String&gt;&gt; nested_local;
}

aspect Inter_Type_Injector {
  Set&lt;String&gt; C.simple_intertype;
  Set&lt;Set&lt;String&gt;&gt; C.nested_intertype;

  public void test() {
    Set&lt;String&gt; simple_local = new C().simple_local; // works
    Set&lt;String&gt; simple_intertype = new C().simple_intertype; // works
    Set&lt;Set&lt;String&gt;&gt; nested_local = new C().nested_local; // works
    Set&lt;Set&lt;String&gt;&gt; nested_intertype = new C().nested_intertype; // fails
  }
}


zipfile classpath entry does not exist: /opt/sun-jdk-1.5.0/jre/lib/i18n.jar
        
zipfile classpath entry does not exist: /opt/sun-jdk-1.5.0/jre/lib/sunrsasign.jar
        
directory classpath entry does not exist: /opt/sun-jdk-1.5.0/jre/classes
        
compiling /home/user/sgelin3/shared/dev/java/ajc/Bug.java
        
/home/user/sgelin3/shared/dev/java/ajc/Bug.java:16 [error] Type mismatch: cannot
convert from Set&lt;Set&lt;E&gt;&gt; to Set&lt;Set&lt;String&gt;&gt;
Set&lt;Set&lt;String&gt;&gt; nested_intertype = new C().nested_intertype; // fails
                 ^^^^^^^^^^^

1 error</description>
      <comments>
		<comment id="1" date="2005-06-03 12:58:10 EDT" author="Andrew Clement">generics will be working for M3</comment>
		<comment id="2" date="2005-06-14 07:05:08 EDT" author="Andrew Clement">Problem here is our first stab at generics only copes with one level of nesting.
 I've enhanced our support so this now works by modifying the EclipseFactory
class.  Bit more testing and I'll be able to check it in.</comment>
		<comment id="3" date="2005-06-14 10:58:17 EDT" author="Andrew Clement">Fixed checking in, waiting on build before closing.</comment>
		<comment id="4" date="2005-06-14 12:05:49 EDT" author="Andrew Clement">Fix available, see aspectj download page: aspectj-DEVELOPMENT-20050614164300.jar</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="d6bfe97b4db7f2109a4a088ebd0898b3ef8740e9" author="aclement" date="2005-06-14 10:58:09"/>
          <file name="tests/bugs150/pr99089/DataClass.java">
          </file>
          <file name="tests/bugs150/pr99089/TracingAspect.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="100227" opendate="2005-6-15 12:24:00" fixdate="2005-6-20 5:37:00">
    <buginformation>
      <summary>[generics][itds] inner class with generic enclosing class</summary>
      <description>ajc crashes with a NullPointerException when an intertype declaration tries to
modify an inner class, if the enclosing (outer) class is generic:

class Outer {
  class Inner {}
}

class Generic_Outer&lt;T&gt; {
  class Inner {}
}

aspect Injector {
  int Outer.outer; // works
  int Outer.Inner.inner; // works
  int Generic_Outer.outer; // works
  int Generic_Outer.Inner.inner; // crashes
}


/home/user/sgelin3/dev/java/ajc/new_bug/Bug.java [error] Internal compiler error
java.lang.NullPointerException
        at org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.fromBinding(EclipseFactory.java:202)
        at org.aspectj.ajdt.internal.compiler.ast.InterTypeFieldDeclaration.build(InterTypeFieldDeclaration.java:173)
        at org.aspectj.ajdt.internal.compiler.ast.AspectDeclaration.buildInterTypeAndPerClause(AspectDeclaration.java:1020)
        at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.buildInterTypeAndPerClause(AjLookupEnvironment.java:306)
        at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.completeTypeBindings(AjLookupEnvironment.java:122)
        at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.beginToCompile(Compiler.java:302)
        at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:316)
...</description>
      <comments>
		<comment id="1" date="2005-06-15 12:32:43 EDT" author="Samuel GÃ©lineau">I've sent quite a few bug reports on the interaction of ITD with generics, so by
now I know that they all get "1.5.0 M3" as a target. I'd save you the trouble of
setting that target every time but:

"You tried to change the Target Milestone field from --- to 1.5.0 M3, but only
the owner or submitter of the bug, or a sufficiently empowered user, may change
that field."

strange, since I _am_ the submitter of the bug!


anyway, sorry to bother you with so many similar looking bugs (98320, 98592,
99168, 99228 and now 100227), I know that I am not supposed to expect generics
to work completely until M3, and keep up the good work!</comment>
		<comment id="2" date="2005-06-16 04:15:04 EDT" author="Andrew Clement">Its great that you are spending time creating these minimal testcases for bugs
that I can work on, keep it up!  You are bound to hit something we've not
created testcases for yet.

In this case it appears there is a special form of ParameterizedTypeBinding
known to the compiler.  It is a PTB whose arguments (type parameters) are null -
this doesn't mean it is a raw type as raw type is a subtype of
ParameterizedTypeBinding.  From a quick look round the JDT compiler, it *looks*
like a PTB with null arguments represents an inner type of a parameterized type
that itself specifies no type parameters.  Presumably it 'inherits' any from the
enclosing type.

So, the fix is to allow for null type parameters - and ensure we don't
misintepret the null as a raw type ref.</comment>
		<comment id="3" date="2005-06-16 04:30:09 EDT" author="Andrew Clement">Fix checked in, waiting on build.</comment>
		<comment id="4" date="2005-06-20 05:37:14 EDT" author="Andrew Clement">Dev build available from the download page: 
aspectj-DEVELOPMENT-20050620091600.jar</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="7d5002ad52c86eefdf58535310fb41f042206d11" author="aclement" date="2005-06-16 05:30:14"/>
          <file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java">
              <method name="fromBinding" returnType="TypeX" parameters="TypeBinding"/>
          </file>
          <file name="tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/TypeX.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="82171" opendate="2005-1-4 14:13:00" fixdate="2005-08-17 15:03:30">
    <buginformation>
      <summary>enable ASM interoperability with JavaCore via uniform element handles</summary>
      <description>Proposal pasted from the following email discussion:
http://dev.eclipse.org/mhonarc/lists/ajdt-dev/msg00379.html

We finally seem to be both have more support for working directly with the
Java Model, and more need to do so.  Here's an idea for a light-weight
update to our architecture that will give us transparent access for working
with the relationship map using either the IJavaElements or
IProgramElements.

The idea is that we change the handle identifiers, used for storing entries
in the map, to be the same those used by the JavaModel, i.e.
IJavaElement.getHandleIdentifier().  That will allow us to ask for
relationships for IJavaElements, and get back a list of handles that an
adapter can turn into IJavaElements.  

Currently our identifiers are a source location including path, line, and
column number.  The Java model uses the handles that look like the
following, "=Project-l/src&lt;pkg1{Foo.java[Foo~m1", which uniquely identify
members, are stable across builds and Eclipse invocations, but don't go
below the member signature.  So our adapter will have to extend these by
appending either line/column or offset information to reach at "code"
elements (e.g. calls, handlers).  That's doable, and these handles should
just get ignored by JavaCore as desired.  But I'm wondering what they should
correspond to in our extended Java Model, perhaps a subtype of
SourceRefElement called ICodeElement?  We should get JDT Core to add
something like that anyway, but they'll probably want to call it
IUnknownElement or IGenericRefElement to provide other projects with the
same sort of extensibility.  Another challenge will be generating the
project part of the handle because our compiler doesn't know about
workspaces.  I hope that info can be extracted from the full path and source
path information.  Then for other IDEs we can simply use the same relative
path convention.</description>
      <comments>
		<comment id="1" date="2005-04-14 12:46:34 EDT" author="Mik Kersten">I've addressed this by allowing IDE clients to provide their own mechanism for 
creating ASM handles.  For AJDT to add a new that handles JavaCore style 
handles do the following:

1) Implement org.aspectj.asm.IElementHandleProvider and provide the four 
methods that map source location information to handles.

2) Somewhere in the plugin initialization call: 
     AsmManager.getDefault().setHandleProvider(..)

Doing (1) depends on being able to map source locations to 
IJavaElement.getHandleIdentifier() strings.  If that turns out to be a pain to 
do in a way that performs we can consider changing the AspectJElementHierarchy 
to not realy on line number information and instead do lookups based on member 
names.</comment>
		<comment id="2" date="2005-08-17 15:03:30 EDT" author="Adrian Colyer">It appears from Mik's comment as of April that this request should be closed out in the AspectJ database.</comment>
		<comment id="3" date="2005-08-17 15:39:19 EDT" author="Mik Kersten">Yes, the ASM part of this is now there.  I'm not sure if AJDT is actually using
a custom handle provider though, or whether it is still doing that translation step.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="df7fff4c8c073a3bbcfe749134d577299402d5fb" author="mkersten" date="2005-04-15 01:44:01"/>
          <file name="asm/src/org/aspectj/asm/AsmManager.java">
          </file>
          <file name="asm/src/org/aspectj/asm/IElementHandleProvider.java">
          </file>
          <file name="asm/src/org/aspectj/asm/internal/AspectJElementHierarchy.java">
              <method name="getElement" returnType="IProgramElement" parameters="String"/>
          </file>
          <file name="asm/src/org/aspectj/asm/internal/FullPathHandleProvider.java">
          </file>
          <file name="asm/src/org/aspectj/asm/internal/ProgramElement.java">
          </file>
          <file name="docs/sandbox/api-clients/org/aspectj/samples/AsmRelationshipMapExtensionTest.java">
              <method name="addDeclareParentsRelationship" returnType="void" parameters="ISourceLocation ResolvedTypeX List"/>
          </file>
          <file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AsmInterTypeRelationshipProvider.java">
              <method name="addRelationship" returnType="void" parameters="ResolvedTypeX EclipseTypeMunger"/>
          </file>
          <file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmHierarchyBuilder.java">
              <method name="addUsesPointcutRelationsForNode" returnType="void" parameters="IProgramElement List MethodDeclaration"/>
          </file>
          <file name="weaver/src/org/aspectj/weaver/AsmRelationshipProvider.java">
              <method name="checkerMunger" returnType="void" parameters="IHierarchy Shadow Checker"/>
          </file>
          <file name="weaver/src/org/aspectj/weaver/ShadowMunger.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="82752" opendate="2005-1-13 10:27:00" fixdate="2005-8-25 10:46:00">
    <buginformation>
      <summary>"ProgramElement.getSourceSignature returns ""public"" for ""private"" members"</summary>
      <description>This bug affects ajdoc, and could affect other tools relying on the ASM.</description>
      <comments>
		<comment id="1" date="2005-03-23 09:12:40 EST" author="Adrian Colyer">aj5m3.... since it affects ajdoc</comment>
		<comment id="2" date="2005-04-29 07:06:12 EDT" author="Andrew J Huff">I had a quick look through and couldn't find/reproduce this bug </comment>
		<comment id="3" date="2005-05-03 11:47:51 EDT" author="Andrew J Huff">while working on bug 82755 I ran into this in the dev version of aspectj...
With this file:
////////////////
aspect A{}
////////////////
ajdoc thinks that A is public.
I traced back where this publicness comes from to the typeDeclaration given to
boolean org.aspectj.ajdt.internal.core.builder.AsmHierarchyBuilder.visit
 (TypeDeclaration typeDeclaration, CompilationUnitScope scope)
This type declaration is:
public aspect A {
  &lt;clinit&gt;() {
  }
  A() {
    super();
  }
}
Where did that public come from?? Where is that visit method called from?</comment>
		<comment id="4" date="2005-05-03 12:18:25 EDT" author="Mik Kersten">Andrew, that visit method is called by code from the JDT compiler, via the 
ASTVisitor mechanism which walks the AST for each compilation unit.  So it 
looks like the accessiblity of that aspect (perhaps all package-visible 
aspects?) actually is public by the time we get it from the compiler.  

One way to check on that would be to set a breakpoint in that visit method 
while compiling a test case with some non-public aspects, and see if any of 
them actually turn out to be non-public.  If so, it would be worth 
investigating whether this actually is a problem, i.e. whether classes in a 
different package are able to access public members on package-visible aspects.</comment>
		<comment id="5" date="2005-08-23 01:01:29 EDT" author="Mik Kersten">Andrew, did this get resolved or is it still open?</comment>
		<comment id="6" date="2005-08-24 05:59:04 EDT" author="Andrew J Huff">its currently still open..</comment>
		<comment id="7" date="2005-08-24 11:50:20 EDT" author="Adrian Colyer">your wish is my command. I just checked in the fix for this. Basically we make
all aspects public during the generate code phase (after type checking etc. has
been done) so that advice can be called. AsmBuilder was visiting after the
modifiers had been switched. I added a declaredModifiers field to
AspectDeclaration to remember the modifiers specified in the source and then
switched the builder to use the declaredModifiers for aspect types instead. 

The testing strategy in AsmModuleTests and AsmBuilderTest leaves a little to be
desired ;), but I didn't have the time to take that on right now so I verified
the fix manually. Mik, if you have an easy way to write a test for this, please
add it, thks.</comment>
		<comment id="8" date="2005-08-24 13:01:29 EDT" author="Mik Kersten">Nice!  This has been an ASM bug since day one due to that mismatch between the
declared visibility and generated visibility.

Yup, the testing coverage leaves a lot to be desired.  For this particular case
there it is easy to write a test using the coverage example, so I'll reopen the
bug in order to do that.</comment>
		<comment id="9" date="2005-08-25 06:22:45 EDT" author="Andrew Clement">moving bug out of M3 but leaving open.</comment>
		<comment id="10" date="2005-08-25 10:46:46 EDT" author="Mik Kersten">Test added to AsmDeclarationsTest.  Fyi, this is the form such tests take:

 public
void testAspectAccessibility() {
  IProgramElement packageAspect = AsmManager.getDefault().getHierarchy().findElementForType(null,
"AdviceNamingCoverage");
  assertNotNull(packageAspect);
  assertEquals(IProgramElement.Accessibility.PACKAGE,
packageAspect.getAccessibility());
 }</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="8a772af970720dddbcae353a6e04bb19ba2962bf" author="acolyer" date="2005-08-25 12:47:22"/>
          <file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectDeclaration.java">
          </file>
          <file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmHierarchyBuilder.java">
              <method name="visit" returnType="boolean" parameters="TypeDeclaration CompilationUnitScope"/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="102459" opendate="2005-7-1 6:48:00" fixdate="2005-9-1 14:33:00">
    <buginformation>
      <summary>provide more detail in -showWeaveInfo messages</summary>
      <description>When advice is executed, the object you have to work with is the joinpoint. This
can then be queried to get various information out of it. It would be nice, if
as part of the weaving you could get hold of the same information. 

This is particularly useful in the case of writing a coverage tool. In order to
measure where you've been, you have to know all the places you could possibly
go. The introduction of the -showWeaveInfo option means that we can record these
places, however, this would be greatly enhanced by providing similar information
as to that which is collected as the program is running.

The information which would be good is the same as that obtained from

JoinPoint.StaticPart.getSignature().toLongString().</description>
      <comments>
		<comment id="1" date="2005-07-07 04:27:09 EDT" author="Andrew Clement">try and look at this for 1.5.0</comment>
		<comment id="2" date="2005-09-01 14:33:28 EDT" author="Adrian Colyer">weave info messages for advice execution now have the form:

Join point 'method-execution(void Simple.method())' in Type 'Simple' (Simple.java:17) advised by 
afterThrowing advice from aspect 'AspectAdvice' (AspectAdvice.aj:20)

etc.

The new part is the prefix containing the join point information. I didn't change the tail end of the 
message because it would have upset too many test cases.

I actually prefer this new message since it makes the primary abstraction one of join points being 
advised, and not source locations.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="c6bc7a2b2ee30b7647d3cb17fc323ebf96768fef" author="acolyer" date="2005-09-02 03:40:31"/>
          <file name="bridge/src/org/aspectj/bridge/WeaveMessage.java">
          </file>
          <file name="tests/java5/ataspectj/ataspectj/ltwlog/MainVerboseAndShow.java">
              <method name="main" returnType="void" parameters="String"/>
          </file>
          <file name="weaver/src/org/aspectj/weaver/Shadow.java">
              <method name="reportWeavingMessage" returnType="void" parameters="ShadowMunger"/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="109173" opendate="2005-9-9 12:49:00" fixdate="2005-9-23 10:41:00">
    <buginformation>
      <summary>"Weaving Adaptor enhancements for performance, configuration and diagnosis"</summary>
      <description>Here are some suggested enhancements as a result of exhaustive testing in the 
Eclipse/OSGi environment.

1.	If no aspects are declared for a particular class loader, either 
because there are no visible aop.xml files or they contain no aspect 
definitions, then we should short-circuit the implementation of weaveClass() 
so that byte-code is not unnecessarily passed to the weaver. This is 
especially important under OSGi where there may be hundreds of class bundles, 
each with their own class loader only some of which are being woven. We can 
use the existing "enabled" flag.
2.	As previously discussed on aspectj-dev the META-INF directory is 
considered private in OSGi and is therefore an inappropriate location for 
aop.xml files declaring shared aspects. I therefore propose a System property 
to set the a resource names for finding aop.xml files which would default 
to "META-INF/aop.xml" e.g. -Dorg.aspectj.weaver.loadtime.configuration=META-
INF/aop.xml;org/aspectj/aop.xml.
3.	We should not be catching Throwable  in Aj. Instead we should catch 
known exceptions e.g. BCException and issue messages while letting other 
runtime exceptions pass back to the class loader. A user provided 
IMessageHandler implementation can decide under what circumstances to abort. 
Alternatively if Aj is considered to be a "safe" interface for weaving agents 
e.g. JVMTI then the dump logic it contains should be moved to the 
WeavingAdaptor so that it can be used directly from a class loader.</description>
      <comments>
		<comment id="1" date="2005-09-16 10:09:39 EDT" author="David Knibb">Created attachment 27212 [details]
ClassLoaderWeavingAdaptor Patch for multiple aop.xml locations

Apply this patch to to the ClassLoaderWeavingAdaptor.java file in the loadtime
module of aspectj. It will enable the class to load up aop.xml files from
locations specified in the org.aspectj.weaver.loadtime.configuration system
property, or from the default location (META-INF/aop.xml) if this property is
not set. So for instance you could run with
-Dorg.aspectj.weaver.loadtime.configuration=META-INF/aop.xml;foo/bar/aop.xml</comment>
		<comment id="2" date="2005-09-20 12:02:15 EDT" author="David Knibb">Under OSGi, we have a problem with LTW in that the ClassLoader.getResources() 
call (used to load aop.xml files) may return results from more bundles than we 
want. 
Say you have three bundles, a, b and c. Each declares (and exports) an aop.xml 
file from some location (the same location within each bundle). Suppose also 
that bundle b requires a, and c requires b. Now we find that the aop.xml file 
from a is given to c by the ClassLoader.getResources() call, but as c has no 
dependancy on a, the aspects named in that file will not be visible to c, 
resulting in Runtime Exception("Cannot register non aspect @missing@").


One solution to this is to use a WeavingContext object, passed from OSGi world 
to AspectJ world, to perform some filtering on the results of 
ClassLoader.getResources(). In a standard (non-OSGi) environment, this can 
simply return the (unaltered) result of ClassLoader.getResources(). This would 
be done via a new interface in the loadtime module (so no dependency from 
AspectJ on OSGi).

I have a working implementation of this and will post a patch shortly.


This approach may also help us to define multiple aop.xml files to each 
weaver...</comment>
		<comment id="3" date="2005-09-20 12:44:26 EDT" author="David Knibb">Created attachment 27305 [details]
Patch to enable extra support for OSGi

see previous comment for explanation</comment>
		<comment id="4" date="2005-09-23 09:58:18 EDT" author="David Knibb">Created attachment 27437 [details]
Patch for the loadtime module to support AOSGi

This patch replaces both the patches above. It contains everything that they
contain, along with some additional code needed in order to allow a caching
service.</comment>
		<comment id="5" date="2005-09-23 10:41:02 EDT" author="Adrian Colyer">Patch successfully applied, thanks :)</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="03b20bc1129e03d5e8594262b89021e54ab017f9" author="acolyer" date="2005-09-23 11:40:27"/>
          <file name="loadtime/src/org/aspectj/weaver/loadtime/Aj.java">
          </file>
          <file name="loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java">
          </file>
          <file name="loadtime/src/org/aspectj/weaver/loadtime/DefaultWeavingContext.java">
          </file>
          <file name="loadtime/src/org/aspectj/weaver/loadtime/IWeavingContext.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="92880" opendate="2005-4-27 3:54:00" fixdate="2005-9-27 9:28:00">
    <buginformation>
      <summary>@AJ PTW</summary>
      <description>implement PTW for @AJ aspects
so far delayed to make sure PTW in code style was not evolving</description>
      <comments>
		<comment id="1" date="2005-04-29 06:25:05 EDT" author="Alexandre Vasseur">Spotted some defects in current impl - no matter the style (code or @AJ) when
impl. the @AJ side of it.

- PTW implies that the aspect has:
private [transient] Map instances;
public Set getInstances() {..}
I think we should not use "instances" but some mangled name to avoid clash with
a user field in the aspect (=&gt; compiler + weaver to align both style)

- the private static &lt;aspecttype&gt; ajc$getInstance(Class class1) throws Exception
method is catching Exception to simply rethrow it. The try catch is thus useless

- field     private static Throwable ajc$initFailureCause is added, while not
used (same for perCflow by the way)

Andy / Adrian I d like to hear your comments on those.</comment>
		<comment id="2" date="2005-05-04 04:08:10 EDT" author="Alexandre Vasseur">assign to Adrian for comments in the "instances" field name</comment>
		<comment id="3" date="2005-05-04 04:45:02 EDT" author="Andrew Clement">Hi Alex,

I can't quite tell if the first of your problems is because of how you have to
do @AJ weaving?

&gt; - PTW implies that the aspect has:
&gt; private [transient] Map instances;
&gt; public Set getInstances() {..}
&gt; I think we should not use "instances" but some mangled name
&gt; to avoid clash with a user field in the aspect (=&gt; compiler + weaver to 
&gt; align both style)

For code style, why does the aspect need to store a Map?  For pertypewithin the
aspect instance is stored in the static state of the object for which the
instance is created?
In the current impl, each 'matched' object gets something like this added to it:

public static X ajc$X$localAspectOf() {
  return ajc$X$ptwAspectInstance;
}

private static transient X ajc$X$ptwAspectInstance = 
  X.ajc$createAspectInstance("A");

The implementation of aspectOf in the aspect is then:

    public static X aspectOf(Class class1) {
        try {
            X x = ajc$getInstance(class1);
            if(x == null) throw new NoAspectBoundException("X", null);
            else          return x;
        } catch(Exception exception){
            throw new NoAspectBoundException();
        }
    }

I agree that all names should be mangled to prevent clashes - and so far they are.



&gt; - the private static &lt;aspecttype&gt; ajc$getInstance(Class class1) 
&gt; throws Exception method is catching Exception to simply rethrow 
&gt; it. The try catch is thus useless

I suspect the catch block should be returning null so the caller can report the
NoAspectBoundException rather than a grotty reflection exception.  good spot.

&gt; - field     private static Throwable ajc$initFailureCause is added, 
&gt; while not used (same for perCflow by the way)

ajc$initFailureCause is used to record the original reason why an 
aspect instance couldn't be created (see code for a singleton instance to 
see exactly how its used) - it is currently not set - it could be used in a
slightly different way for PTW - it *could* record any exception that occurs in
the ajc$getInstance() and then be passed as the 2nd param on the
NoAspectBoundException ctor in the aspectOf() method.


The remaining bit of impl that I know isn't finished is that:

private transient String ajc$withinType;

is set but isn't accessible to the end user - which they might want to get hold
of - it will tell them the type for which this aspect instance exists.</comment>
		<comment id="4" date="2005-05-04 05:06:04 EDT" author="Alexandre Vasseur">ha thanks. I actually impl my stuff based on the sample and did not see that
this instances / getInstances was actually a real method in the aspect source
(PerTypeWithinTests, AJDKExamples)
So I ended up generating this field and method for @AJ PTW aspect...

for the exception: let me know if we return null or just throw it again. I need
to miror that in the @AJ impl

for the ajc$initFailure: ok so right now it is not used in PTW and Percflow but
we keep it just in case as you say.</comment>
		<comment id="5" date="2005-05-04 05:21:15 EDT" author="Andrew Clement">Returning null would seem the right thing to do for the catch block - but I'm
not sure when I'll get a minute to fix it - you could leave this bug open to
track fixing it.  Maybe I'll get Andrew to do it - he could do with some
experience in that area...</comment>
		<comment id="6" date="2005-08-15 09:59:49 EDT" author="Andrew Clement">I've fixed the compiler layer to generate code that returns null if an exception
occurs in getInstance() - i've also modified the signature of getInstance() so
it no longer defines that it throws an exception.</comment>
		<comment id="7" date="2005-08-16 11:29:28 EDT" author="Alexandre Vasseur">todo align for @aj</comment>
		<comment id="8" date="2005-08-17 03:34:42 EDT" author="Alexandre Vasseur">done in @AJ for aj$getInstance
close when M3 ship</comment>
		<comment id="9" date="2005-09-27 09:27:31 EDT" author="Alexandre Vasseur">was M3 remind</comment>
		<comment id="10" date="2005-09-27 09:28:40 EDT" author="Alexandre Vasseur">was M3 remind</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="d2ab7c219daefa33aef2e934c1b1d660cdad401e" author="aclement" date="2005-08-15 10:56:59"/>
          <file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectDeclaration.java">
              <method name="generatePerTypeWithinGetInstanceMethod" returnType="void" parameters="ClassFile"/>
              <method name="generate" returnType="void" parameters="CodeStream"/>
          </file>
          <file name="weaver/src/org/aspectj/weaver/AjcMemberMaker.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="101047" opendate="2005-6-21 10:13:00" fixdate="2005-9-28 16:11:00">
    <buginformation>
      <summary>Weaver produces wrong local variable table bytecode</summary>
      <description>AspectJ version: DEVELOPMENT (also observed in 1.2.1)
When weaving with a before or after advice, the generated local variable table 
will, on branch instructions, offset the "length" field of a local variable 
wrongly by one instruction. Also, the weaver will mix up local variables with 
the same name, thus violating the java VM specification:

// Test.aj
aspect Test {
	before() : ( execution(* Foo.foo(..) ) ) {
		System.out.println("before");
		
	}
// Foo.java
public class Foo {
    private String myString = "A String";
    public static void main(String[] args) {
        new Foo().foo();  
    }
    private void foo() { 
        String myLocal = myString;
        if (myLocal.endsWith("X")) {
      	   String local1 = "local1";
             System.out.println(local1);
        } else if (myLocal.endsWith("Y")) {
             String local2 = "local2";
             System.out.println(local2);
        } else {
      	  String local1 = "local3";
            System.out.println(local1);
        }
      }
}
---
We compilw with ajc -sourceroots . and dumps Foo with javap:
javap -c -l -s -private Foo
....
....
private void foo();
  Signature: ()V
  Code:
   0:   invokestatic    #65; //Method Test.aspectOf:()LTest;
   3:   invokevirtual   #68; //Method Test.ajc$before$Test$1$f0485e90:()V
   6:   aload_0
   7:   getfield        #15; //Field myString:Ljava/lang/String;
   10:  astore_1
   11:  aload_1
   12:  ldc     #30; //String X
   14:  invokevirtual   #36; //Method java/lang/String.endsWith:
(Ljava/lang/String;)Z
   17:  ifeq    33
   20:  ldc     #38; //String local1
   22:  astore_2
   23:  getstatic       #44; //Field java/lang/System.out:Ljava/io/PrintStream;
   26:  aload_2
   27:  invokevirtual   #50; //Method java/io/PrintStream.println:
(Ljava/lang/String;)V
   30:  goto    65
   33:  aload_1
   34:  ldc     #52; //String Y
   36:  invokevirtual   #36; //Method java/lang/String.endsWith:
(Ljava/lang/String;)Z
   39:  ifeq    55
   42:  ldc     #54; //String local2
   44:  astore_2
   45:  getstatic       #44; //Field java/lang/System.out:Ljava/io/PrintStream;
   48:  aload_2
   49:  invokevirtual   #50; //Method java/io/PrintStream.println:
(Ljava/lang/String;)V
   52:  goto    65
   55:  ldc     #56; //String local3
   57:  astore_2
   58:  getstatic       #44; //Field java/lang/System.out:Ljava/io/PrintStream;
   61:  aload_2
   62:  invokevirtual   #50; //Method java/io/PrintStream.println:
(Ljava/lang/String;)V
   65:  return

  LineNumberTable: 
   line 7: 6
   line 8: 11
   line 9: 20
   line 10: 23
   line 11: 33
   line 12: 42
   line 13: 45
   line 15: 55
   line 16: 58
   line 18: 65
  LocalVariableTable: 
   Start  Length  Slot  Name   Signature
   6      60      0    this       LFoo;
   11      55      1    myLocal       Ljava/lang/String;
   45      12      2    local2       Ljava/lang/String;
   23      43      2    local1       Ljava/lang/String;

We see that the two occurences of the "local1" variable erroneously have been 
combined into one entry, starting at byte 23 and ending at byte 66. This is 
obviously wrong, since "local1" has no value in the "local2" block. Secondly, 
the "local2" variable end is wrongly offset by one instruction offset.</description>
      <comments>
		<comment id="1" date="2005-06-21 10:24:43 EDT" author="Per S Hustad">I started looking into this in conjunction with 
https://bugs.eclipse.org/bugs/show_bug.cgi?id=100195.
The reason why the weaver combines distinct local variables with the same name 
into one table entry is probably due to a wrong "equal" method implementation 
in the org.aspectj.weaver.bcel.LocalVariableTag class. It only considers the 
variable name and slot nuumber when comparing.

The reason for the wrong offset is probably that 
org.aspectj.apache.bcel.generic.LocalVariableGen.getLocalVariable() increases 
the length by one instruction, and this is not compansated for by the weaver 
when writing back the woven classfiles.</comment>
		<comment id="2" date="2005-08-26 11:29:34 EDT" author="Adrian Colyer">shame not to take advantage of all the good detective work done by Per Hustad,
so marking for investigation in M4</comment>
		<comment id="3" date="2005-09-27 17:09:44 EDT" author="Adrian Colyer">This was indeed a comination of two problems. Firstly the the comparison on LocalVariableTags was 
insufficient as you suggested. I've changed the implementation to record not just name and slot but 
also the start position. Whilst two distinct local variables can have the same name and occupy the same 
slot, they cannot also have the same start position! 

Secondly, BCEL had an off-by-one error in the LocalVariableGen.getLocalVariable routine. The spec says 
that the range of the variable is from start-pos to start-pos + length INCLUSIVE, but BCEL was giving a 
length that included the first byte of the following instruction after the range. This is now fixed.

Note that I discovered on investigating this that the JDT compiler and javac disagree on where local2 
etc. go out of scope. javac says that local2 goes out of scope at the end of the invokevirtual instruction, 
whereas the JDT says it is the end of the goto instruction. I don't think this will make any practical 
difference to debuggers - the important thing is that we now have a valid length that ends on an 
instruction boundary.

Fix commited in tree, will be available in first published dev build with date &gt;= 28th Sept. 2005</comment>
		<comment id="4" date="2005-09-28 02:05:14 EDT" author="Adrian Colyer">I'm reopening this. On thinking about the "off-by-one" situation some more, I think it was me who was 
off-by-one, and the orignal BCEL routine was correct. I'm going to think some more on this before fully 
closing.</comment>
		<comment id="5" date="2005-09-28 16:11:26 EDT" author="Adrian Colyer">Problem resolution log.... for those who may one day have to look into a related
issue.

Here's the result of compiling this with aspectj now.

private void foo();
  org.aspectj.weaver.MethodDeclarationLineNumber: length = 0x8
   00 00 00 0F 00 00 01 0C 
  Code:
   Stack=2, Locals=3, Args_size=1
   0: invokestatic #65; //Method Test.aspectOf:()LTest;
   3: invokevirtual #68; //Method Test.ajc$before$Test$1$f0485e90:()V
   6: aload_0
   7: getfield #15; //Field myString:Ljava/lang/String;
   10: astore_1
   11: aload_1
   12: ldc #30; //String X
   14: invokevirtual #36; //Method java/lang/String.endsWith:(Ljava/lang/String;)Z
   17: ifeq 33
   20: ldc #38; //String local1
   22: astore_2
   23: getstatic #44; //Field java/lang/System.out:Ljava/io/PrintStream;
   26: aload_2
   27: invokevirtual #50; //Method java/io/PrintStream.println:(Ljava/lang/String;)V
   30: goto 65
   33: aload_1
   34: ldc #52; //String Y
   36: invokevirtual #36; //Method java/lang/String.endsWith:(Ljava/lang/String;)Z
   39: ifeq 55
   42: ldc #54; //String local2
   44: astore_2
   45: getstatic #44; //Field java/lang/System.out:Ljava/io/PrintStream;
   48: aload_2
   49: invokevirtual #50; //Method java/io/PrintStream.println:(Ljava/lang/String;)V
   52: goto 65
   55: ldc #56; //String local3
   57: astore_2
   58: getstatic #44; //Field java/lang/System.out:Ljava/io/PrintStream;
   61: aload_2
   62: invokevirtual #50; //Method java/io/PrintStream.println:(Ljava/lang/String;)V
   65: return

  LocalVariableTable: 
   Start  Length  Slot  Name   Signature
   6      60      0    this       LFoo;
   11      55      1    myLocal       Ljava/lang/String;
   23      11      2    local1       Ljava/lang/String;
   45      12      2    local2       Ljava/lang/String;
   58      8      2    local1       Ljava/lang/String;

So variable "this" starts at index 6, for 60 bytes - which is up to and
including the end of the return statement. CORRECT.

Variable "mylocal" starts at index 11, for 55 bytes - which is up to and
including the end of the return statement. CORRECT.

Variable "local1" (#1) starts at index 23, for 11 bytes - which is up to and
including the end of the aload_1 statement. 

Variable "local2" starts at index 45, for 12 bytes - which is up to and
including the end of the ldc statement. 

Variable "local1" (#2) starts at index 58, for 8 bytes - which is up to and
including the end of the return statement. (LEGITIMATE, but different to javac)

===================

If I compile the "same" program with javac (hand-written equivalent), I get:

private void foo();
  Code:
   Stack=2, Locals=3, Args_size=1
   0: invokestatic #7; //Method Test.aspectOf:()LTest;
   3: invokevirtual #8; //Method Test.before:()V
   6: aload_0
   7: getfield #3; //Field myString:Ljava/lang/String;
   10: astore_1
   11: aload_1
   12: ldc #9; //String X
   14: invokevirtual #10; //Method java/lang/String.endsWith:(Ljava/lang/String;)Z
   17: ifeq 33
   20: ldc #11; //String local1
   22: astore_2
   23: getstatic #12; //Field java/lang/System.out:Ljava/io/PrintStream;
   26: aload_2
   27: invokevirtual #13; //Method java/io/PrintStream.println:(Ljava/lang/String;)V
   30: goto 65
   33: aload_1
   34: ldc #14; //String Y
   36: invokevirtual #10; //Method java/lang/String.endsWith:(Ljava/lang/String;)Z
   39: ifeq 55
   42: ldc #15; //String local2
   44: astore_2
   45: getstatic #12; //Field java/lang/System.out:Ljava/io/PrintStream;
   48: aload_2
   49: invokevirtual #13; //Method java/io/PrintStream.println:(Ljava/lang/String;)V
   52: goto 65
   55: ldc #16; //String local3
   57: astore_2
   58: getstatic #12; //Field java/lang/System.out:Ljava/io/PrintStream;
   61: aload_2
   62: invokevirtual #13; //Method java/io/PrintStream.println:(Ljava/lang/String;)V
   65: return

  LocalVariableTable: 
   Start  Length  Slot  Name   Signature
   23      7      2    local1       Ljava/lang/String;
   45      7      2    local2       Ljava/lang/String;
   58      7      2    local1       Ljava/lang/String;
   0      66      0    this       LFoo;
   11      55      1    myLocal       Ljava/lang/String;

So variable "this" starts at index 6, for 60 bytes - which is up to and
including the end of the return statement. 

Variable "mylocal" starts at index 11, for 55 bytes - which is up to and
including the end of the return statement.

Variable "local1" (#1) starts at index 23, for 7 bytes - which is up to and
including the end of the invokevirtual statement.

Variable "local2" starts at index 45, for 7 bytes - which is up to and including
the end of the invokevirtual statement.

Variable "local1" (#2) starts at index 58, for 7 bytes - which is up to and
including the end of the invokevirtual statement.

====================

If I compile the original again using -XnoWeave, I get:

private void foo();
  org.aspectj.weaver.MethodDeclarationLineNumber: length = 0x8
   00 00 00 0F 00 00 01 0C 
  Code:
   Stack=2, Locals=3, Args_size=1
   0: aload_0
   1: getfield #15; //Field myString:Ljava/lang/String;
   4: astore_1
   5: aload_1
   6: ldc #30; //String X
   8: invokevirtual #36; //Method java/lang/String.endsWith:(Ljava/lang/String;)Z
   11: ifeq 27
   14: ldc #38; //String local1
   16: astore_2
   17: getstatic #44; //Field java/lang/System.out:Ljava/io/PrintStream;
   20: aload_2
   21: invokevirtual #50; //Method java/io/PrintStream.println:(Ljava/lang/String;)V
   24: goto 59
   27: aload_1
   28: ldc #52; //String Y
   30: invokevirtual #36; //Method java/lang/String.endsWith:(Ljava/lang/String;)Z
   33: ifeq 49
   36: ldc #54; //String local2
   38: astore_2
   39: getstatic #44; //Field java/lang/System.out:Ljava/io/PrintStream;
   42: aload_2
   43: invokevirtual #50; //Method java/io/PrintStream.println:(Ljava/lang/String;)V
   46: goto 59
   49: ldc #56; //String local3
   51: astore_2
   52: getstatic #44; //Field java/lang/System.out:Ljava/io/PrintStream;
   55: aload_2
   56: invokevirtual #50; //Method java/io/PrintStream.println:(Ljava/lang/String;)V
   59: return

  LocalVariableTable: 
   Start  Length  Slot  Name   Signature
   0      60      0    this       LFoo;
   5      55      1    myLocal       Ljava/lang/String;
   17      10      2    local1       Ljava/lang/String;
   39      10      2    local2       Ljava/lang/String;
   52      7      2    local1       Ljava/lang/String;

So variable "this" starts at index 0, for 60 bytes - which is up to and
including the end of the return statement. 

Variable "mylocal" starts at index 5, for 55 bytes - which is up to and
including the end of the return statement.

Variable "local1" (#1) starts at index 17, for 10 bytes - which is up to and
including the end of the goto statement.

Variable "local2" starts at index 39, for 10 bytes - which is up to and
including the end of the goto statement.

Variable "local1" (#2) starts at index 52, for 7 bytes - which is up to and
including the end of the invokevirtual statement.

============================

So.... compared to javac, the jdt compiler includes the goto statement as part
of the scope of the local variable. From the spec, both behaviours could be
considered correct, so I don't think this is anything to worry about.

BUT... when the weaver reads in the class file generated by the jdt compiler,
and then writes it out again, the end point of the local variable scope has been
incorrectly moved on by one instruction.

When unpacking locals for foo() as it comes into the weaver we find:
"this" has start instruction aload_0 (index 0), end instruction return(index 59)
"mylocal" has start instruction aload_1 (index 5), end instruction return(index 59)
"local1" has start instruction getstatic (index 17), end instruction a_load1
(index 27)
"local2" has start instruction getstatic (index 39), end instruction ldc (index 49)
"local1" has start instruction getstatic (index 52), end instruction return
(index 59)

So the information we're getting from Bcel is wrong right up front...

Aha... now we're getting close : here's the relevant snipped from MethodGen:

     for(int k=0; k &lt; lv.length; k++) {
       LocalVariable     l     = lv[k];
       InstructionHandle start = il.findHandle(l.getStartPC());
       InstructionHandle end   = il.findHandle(l.getStartPC() + l.getLength());

notice it's making the same mistake that I was making ... start + length gives
the starting index of the first instruction AFTER the range of the local
variable. The "findHandle" routine can't cope with an index that does not point
to the start of an instruction though.

Finally, with Bcel fixed we get:

private void foo();
  org.aspectj.weaver.MethodDeclarationLineNumber: length = 0x8
   00 00 00 0F 00 00 01 0C 
  Code:
   Stack=2, Locals=3, Args_size=1
   0: invokestatic #65; //Method Test.aspectOf:()LTest;
   3: invokevirtual #68; //Method Test.ajc$before$Test$1$f0485e90:()V
   6: aload_0
   7: getfield #15; //Field myString:Ljava/lang/String;
   10: astore_1
   11: aload_1
   12: ldc #30; //String X
   14: invokevirtual #36; //Method java/lang/String.endsWith:(Ljava/lang/String;)Z
   17: ifeq 33
   20: ldc #38; //String local1
   22: astore_2
   23: getstatic #44; //Field java/lang/System.out:Ljava/io/PrintStream;
   26: aload_2
   27: invokevirtual #50; //Method java/io/PrintStream.println:(Ljava/lang/String;)V
   30: goto 65
   33: aload_1
   34: ldc #52; //String Y
   36: invokevirtual #36; //Method java/lang/String.endsWith:(Ljava/lang/String;)Z
   39: ifeq 55
   42: ldc #54; //String local2
   44: astore_2
   45: getstatic #44; //Field java/lang/System.out:Ljava/io/PrintStream;
   48: aload_2
   49: invokevirtual #50; //Method java/io/PrintStream.println:(Ljava/lang/String;)V
   52: goto 65
   55: ldc #56; //String local3
   57: astore_2
   58: getstatic #44; //Field java/lang/System.out:Ljava/io/PrintStream;
   61: aload_2
   62: invokevirtual #50; //Method java/io/PrintStream.println:(Ljava/lang/String;)V
   65: return

  LocalVariableTable: 
   Start  Length  Slot  Name   Signature
   6      60      0    this       LFoo;
   11      55      1    myLocal       Ljava/lang/String;
   23      10      2    local1       Ljava/lang/String;
   45      10      2    local2       Ljava/lang/String;
   58      7      2    local1       Ljava/lang/String;

So variable "this" starts at index 6, for 60 bytes - which is up to and
including the end of the return statement. 

Variable "mylocal" starts at index 11, for 55 bytes - which is up to and
including the end of the return statement.

Variable "local1" (#1) starts at index 23, for 10 bytes - which is up to and
including the end of the goto statement.

Variable "local2" starts at index 45, for 10 bytes - which is up to and
including the end of the goto statement.

Variable "local1" (#2) starts at index 58, for 7 bytes - which is up to and
including the end of the invokevirtual statement.

Hurrah!</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="85a4b0afb2c4b69cb467484d9ed18b21e414a868" author="acolyer" date="2005-09-29 05:10:19"/>
          <file name="bcel-builder/src/org/aspectj/apache/bcel/generic/MethodGen.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="108118" opendate="2005-8-26 10:37:00" fixdate="2005-9-29 11:43:00">
    <buginformation>
      <summary>Complete implementation of @SuppressAjWarnings</summary>
      <description>ensure that @SuppressAJWarnings are indeed suppressed during pointcut
operations. This requires wrapping major pointcut operations with calls to Lint
from the associated advice.</description>
      <comments>
		<comment id="1" date="2005-08-26 10:37:59 EDT" author="Adrian Colyer">for M4</comment>
		<comment id="2" date="2005-09-27 05:56:21 EDT" author="Adrian Colyer">raising to P2</comment>
		<comment id="3" date="2005-09-29 11:43:11 EDT" author="Adrian Colyer">Calls now wrapped appropriately in BcelAdvice (Advice supertype has no knowledge
of the annotations, this could be refactored better if we had multiple
implementations of Advice, but since we don't it's plenty good enough for the
time being).</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="81a07900d1e2c4db563d5b4a833b404ac51ee5bd" author="acolyer" date="2005-09-30 12:42:52"/>
          <file name="tests/src/org/aspectj/systemtest/ajc150/SuppressedWarnings.java">
              <method name="testSuppressionWithCflow_pr93345" returnType="void" parameters=""/>
          </file>
          <file name="weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/bcel/Utility.java">
              <method name="getSuppressedWarnings" returnType="List" parameters="AnnotationX[] Lint"/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="100195" opendate="2005-6-15 10:40:00" fixdate="2005-10-05 05:39:12">
    <buginformation>
      <summary>Missing LocalVariableTable debug info for around advice</summary>
      <description>AspectJ version: 1.2.1  (also observed in aspectj-DEVELOPMENT)
java version "1.4.2_07"

When debugging java code woven with an "around" advice with proceed, it looks 
like the LocalVariableTable information gets lost during the weaving. Example 
code:

// Foo.java
public class Foo {
    private String myString = "A String";
    public static void main(String[] args) {
        new Foo().foo();
    }
    private void foo() {
      String myLocal = myString;
      System.out.println(myLocal);   // breakpoint here
    }
}
// Test.aj
aspect Test {
  void around() : ( execution(* Foo.foo(..) ) ) {
      System.out.println("before");
      proceed();
      System.out.println("after");
  }
}

We compiled with ajc 1.2.1:
  ajc -g -preserveAllLocals -sourceroots .

When running Foo in the Eclipse 3.1.0 debugger and setting a breakpoint at
the "System.out.println(myLocal);" line, the debugger "Variables" window is
empty. Also, disassembling with javap shows that the LocalVariableTable is
empty in the generated foo_aroundBody0 method :

&gt; javap -c -l -s -private Foo

 private static final void foo_aroundBody0(Foo);
  Signature: (LFoo;)V
  Code:
   0:   aload_0
   1:   getfield        #15; //Field myString:Ljava/lang/String;
   4:   astore_1
   5:   aload_1
   6:   ldc     #30; //String X
   8:   invokevirtual   #36; //Method java/lang/String.endsWith:
(Ljava/lang/String;)Z
   11:  ifeq    27
   14:  ldc     #38; //String local1
   16:  astore_3
   17:  getstatic       #44; //Field java/lang/System.out:Ljava/io/PrintStream;
   20:  aload_3
   21:  invokevirtual   #50; //Method java/io/PrintStream.println:
(Ljava/lang/String;)V
   24:  goto    37
   27:  ldc     #52; //String local2
   29:  astore_3
   30:  getstatic       #44; //Field java/lang/System.out:Ljava/io/PrintStream;
   33:  aload_3
   34:  invokevirtual   #50; //Method java/io/PrintStream.println:
(Ljava/lang/String;)V
   37:  return

  LineNumberTable: 
   line 7: 0
   line 8: 5
   line 9: 14
   line 10: 17
   line 12: 27
   line 13: 30
   line 15: 37</description>
      <comments>
		<comment id="1" date="2005-06-15 10:55:08 EDT" author="Per S Hustad">I have started looking into this. Obviously, the 
org.aspectj.weaver.bcel.ShadowRange does not copy the LocalVariableTags, see 
the comment
// XXX destroying local variable info
Copying the old instruction handle to the new instruction handle actually 
generates a LocalVariableTable for the woven class, but there is another 
problem:
  When the woven code contains branches, the LazyMethodGen.packBody() method 
seem to generate wrong start_pc and length indexes. I'll look further into this </comment>
		<comment id="2" date="2005-09-24 07:37:03 EDT" author="Adrian Colyer">Adding M4 target milestone as per discussion in Oslo...</comment>
		<comment id="3" date="2005-09-29 07:22:11 EDT" author="Adrian Colyer">After a few investigations, it turns out that it is safe to retarget local
variable tags when extracting a whole block (method execution, cons execution
etc..), but not when weaving around advice at the statement level inside a block
(eg. get/set/call). I've updated ShadowRange to reflect this. If the new logic
fails, the symptom you well see is a VerifyError with "invalid local variable
index: &lt;some number&gt;".

When I compile:

class Foo {
 
    static int x;
 
    private String myString = "A String";
 
    public static void main(String[] args) {
        new Foo().foo();
        AroundCasting.main(new String[0]);
    }
 
    public void foo() {
      String myLocal = myString;
      x = 5;
      System.out.println(myLocal);   // breakpoint here
      bar(x);
    }
    
    public void bar(int y) {}
}
// Test.aj
aspect Test {
  void around() : ( execution(* Foo.foo(..) ) ) {
   int y = 4;
      System.out.println("before");
      proceed();
      System.out.println("after");
  }
}

I now get the output:

private static final void foo_aroundBody0(Foo);
  Code:
   Stack=2, Locals=2, Args_size=1
   0: aload_0
   1: getfield #17; //Field myString:Ljava/lang/String;
   4: astore_1
   5: iconst_5
   6: putstatic #38; //Field x:I
   9: getstatic #44; //Field java/lang/System.out:Ljava/io/PrintStream;
   12: aload_1
   13: invokevirtual #50; //Method java/io/PrintStream.println:(Ljava/lang/String;)V
   16: aload_0
   17: getstatic #38; //Field x:I
   20: invokevirtual #54; //Method bar:(I)V
   23: return
  LocalVariableTable: 
   Start  Length  Slot  Name   Signature
   0      24      0    this       LFoo;
   5      19      1    myLocal       Ljava/lang/String;
  LineNumberTable: 
   line 22: 0
   line 23: 5
   line 24: 9
   line 25: 16
   line 26: 23

(note the correctly preserved locals and line numbers).

I'm committing this change, but want to wait and see this do the right thing in
the AJDT debugger before closing out the bug.</comment>
		<comment id="4" date="2005-10-05 05:39:12 EDT" author="Adrian Colyer">Required one final change in the weaver to cope with our remapping of locals to
wide slots. Finally you can debug inlined around advice methods and see all
locals in the debugger (see screenshot in the attachment).

Fix will be available in next published AspectJ build, and incorporated into
AJDT next Monday.</comment>
		<comment id="5" date="2005-10-05 05:40:05 EDT" author="Adrian Colyer">Created attachment 27852 [details]
screenshot of debugging inlined around advice w. local vars</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="d6256b8c3c944d8fa2feb6d837900144db6521ac" author="acolyer" date="2005-09-29 08:30:49"/>
          <file name="tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java">
              <method name="testArrayCloneCallJoinPoints" returnType="void" parameters=""/>
          </file>
          <file name="weaver/src/org/aspectj/weaver/bcel/ShadowRange.java">
              <method name="extractInstructionsInto" returnType="void" parameters="LazyMethodGen IntMap boolean"/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="112243" opendate="2005-10-11 14:27:00" fixdate="2005-10-13 12:18:00">
    <buginformation>
      <summary>Compiler Core Dump with Apparent Fix</summary>
      <description>I am seeing this exception when using ajc to do binary weaving:

     [iajc] Exception thrown from AspectJ 1.5.0M4

     [iajc] This might be logged as a bug already -- find current bugs at
     [iajc]   http://bugs.eclipse.org/bugs/buglist.cgi?product=AspectJ&amp;component
=Compiler

     [iajc] Bugs for exceptions thrown have titles File:line from the top stack,

     [iajc] e.g., "SomeFile.java:243"

     [iajc] If you don't find the exception below in a bug, please add a new bug

     [iajc] at http://bugs.eclipse.org/bugs/enter_bug.cgi?product=AspectJ
     [iajc] To make the bug a priority, please include a test program
     [iajc] that can reproduce this exception.
     [iajc] org.aspectj.weaver.MissingResolvedTypeWithKnownSignature

     [iajc] when batch building with classpath: ...
     [iajc] org.aspectj.weaver.MissingResolvedTypeWithKnownSignature
     [iajc] java.lang.ClassCastException: org.aspectj.weaver.MissingResolvedTypeWithKnownSignature
     [iajc]     at org.aspectj.weaver.bcel.BcelWorld.addSourceObjectType(BcelWorld.java:277)
     [iajc]     at org.aspectj.weaver.bcel.BcelWeaver.addClassFile(BcelWeaver.java:373)
     [iajc]     at org.aspectj.weaver.bcel.BcelWeaver.addJarFile(BcelWeaver.java:306)
     [iajc]     at org.aspectj.ajdt.internal.core.builder.AjBuildManager.initBcelWorld(AjBuildManager.java:598)
     [iajc]     at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:204)
     [iajc]     at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:151)
     [iajc]     at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:112)
     [iajc]     at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:60)
     [iajc]     at org.aspectj.tools.ajc.Main.run(Main.java:326)
     [iajc]     at org.aspectj.tools.ajc.Main.runMain(Main.java:240)
     [iajc]     at org.aspectj.tools.ajc.Main.main(Main.java:83)


     [iajc] 1 fail|abort

I see this also in HEAD and used the debugger to determine it is trying to 
resolve the type that it's trying to load!

I am able to get it to finish the weave with no errors by changing BcelWorld as 
follows:

	public BcelObjectType addSourceObjectType(JavaClass jc) {
		BcelObjectType ret = null;
		String signature = UnresolvedType.forName(jc.getClassName
()).getSignature();
		ReferenceType nameTypeX = null;
		Object lookup = typeMap.get(signature);
		if (lookup instanceof ReferenceType) {
			nameTypeX = (ReferenceType)lookup;
		}

Instead of just casting. Then the result is null and it falls through to the 
usual lookup unresolved type logic. Is this fix correct?

I suspect it would take a few hours to narrow down a test case for this one.</description>
      <comments>
		<comment id="1" date="2005-10-12 03:36:50 EDT" author="Andrew Clement">Bug 84572 is the same problem.  And as I mentioned in that bug, I would rather
see what has accidentally made it into the type map.  Ron - as you are working
on it, can you change your logic a little to print out what *was* in the type
map which is preventing the cast from working?  Something like:

public BcelObjectType addSourceObjectType(JavaClass jc) {
  BcelObjectType ret = null;
  String signature = UnresolvedType.forName(jc.getClassName()).getSignature();
  ReferenceType nameTypeX = null;
  Object lookup = typeMap.get(signature);
  if (lookup instanceof ReferenceType) {
     nameTypeX = (ReferenceType)lookup;
  } else {
    System.err.println("Signature: "+signature);
    System.err.println("lookup: "+lookup+" "+lookup.getClass());
  }

and let me know what it says?  I can then hopefully determine if just 'ignoring'
the entry in the map is safe.</comment>
		<comment id="2" date="2005-10-12 07:34:45 EDT" author="Ron Bodkin">adding
} else if (lookup != null){
 System.err.println("DEBUG typeref: Signature: " + signature);
 System.err.println("lookup: " + lookup + " " + lookup.getClass());

produces

DEBUG typeref: Signature: Lcom/sample/service/ejb/BungeApplicationServiceBean;
lookup: com.sample.service.ejb.BungeApplicationServiceBean class 
org.aspectj.weaver.MissingResolvedTypeWithKnownSignature

Up the stack trace I can see that this is the very type being loaded from the 
inpath. I think it's because there's a reference to it in an entry in the 
aspectpath.</comment>
		<comment id="3" date="2005-10-12 07:58:38 EDT" author="Andrew Clement">thanks for doing that so quickly Ron - I'll mull it over on my lunchtime run :)</comment>
		<comment id="4" date="2005-10-12 10:29:43 EDT" author="Andrew Clement">Ron,

Can you try applying this patch to World.java (not BcelWorld):

========================== snip below here =======================
Index: World.java
===================================================================
RCS file:
/home/technology/org.aspectj/modules/weaver/src/org/aspectj/weaver/World.java,v
retrieving revision 1.58
diff -u -r1.58 World.java
--- World.java 11 Oct 2005 08:25:09 -0000 1.58
+++ World.java 12 Oct 2005 14:17:23 -0000
@@ -684,6 +684,11 @@
      System.err.println("Not putting a bounded reference type into the typemap:
key="+key+" type="+type);
     return type;
    }
+   if (type instanceof MissingResolvedTypeWithKnownSignature) {
+    if (debug) 
+     System.err.println("Not putting a missing type into the typemap:
key="+key+" type="+type);
+    return type;
+   }
       
    if (isExpendable(type))  {
     return (ResolvedType) expendableMap.put(key,type);
========================== snip above here =======================

I'm not surprised to see the problematic entry being the
MissingResolvedTypeWithKnownSignature.  And of course this fails because it is a
subtype of ResolvedType and not a subtype of ReferenceType.

I'd rather keep that entry out of the type map in the first place ... I think. 
Can you try it?</comment>
		<comment id="5" date="2005-10-13 06:01:17 EDT" author="Ron Bodkin">That fixes it too, and more elegantly ;-) If I enable the print-lines I see 
this:

Not putting a missing type into the typemap: 
key=Lcom/sample/service/ejb/BungeApplicationServiceBean; 
type=com.sample.service.ejb.BungeApplicationServiceBean
Not putting a missing type into the typemap: 
key=Lcom/sample/service/ejb/BungeApplicationServiceBean; 
type=com.sample.service.ejb.BungeApplicationServiceBean

So that solves the problem for me. Thanks.</comment>
		<comment id="6" date="2005-10-13 06:04:22 EDT" author="Andrew Clement">thanks for testing it Ron - i'll put in a variant of my fix and your fix - as if
it ever happens again I'd like to know what was accidentally in the type map. 
Working on it right now...</comment>
		<comment id="7" date="2005-10-13 06:44:17 EDT" author="Andrew Clement">fix committed - waiting on build.</comment>
		<comment id="8" date="2005-10-13 12:18:34 EDT" author="Andrew Clement">fix available.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="04e8dca2fc16f5f834e124b7abea5847d90c3366" author="aclement" date="2005-10-13 07:44:13"/>
          <file name="weaver/src/org/aspectj/weaver/World.java">
              <method name="put" returnType="ResolvedType" parameters="String ResolvedType"/>
          </file>
          <file name="weaver/src/org/aspectj/weaver/bcel/BcelWorld.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="107299" opendate="2005-8-18 1:41:00" fixdate="2005-10-28 9:21:00">
    <buginformation>
      <summary>#NAME?</summary>
      <description>ajc doesn't recognize Windows absolute file paths that don't start with a drive 
letter, e.g., run:
ajc -inpath \test.jar
[error] build config error: bad inpath component: \test.jar

but

ajc -inpath c:\test.jar
works

ajc -aspectpath \test.jar Test.aj

[error] build config error: bad aspectpath: \test.jar

ajc -aspectpath c:\test.jar Test.aj
(works)</description>
      <comments>
		<comment id="1" date="2005-10-14 23:37:17 EDT" author="Wes Isberg">Close as fixed?

Interesting that no one has ever reported this!

Java thinks new File("\home").isAbsolute() is false.  So
ConfigParser.makeFile(..) was prepending directory to the "relative" path.  To
handle absolute paths that look relative (!isAbsolute()),  I changed
ConfigParser(1.8).makeFile(..)  to take paths as absolute (and skip the prefix
dir) if isAbsolute() is false but the path starts with File.separator and the
file exists (without the startsWith test, .lst-file-relative entries would pick
up existing ${user.dir}-local resources of the same name).  Tested locally, but
no portable test possible.</comment>
		<comment id="2" date="2005-10-15 02:51:21 EDT" author="Ron Bodkin">Sounds great. I think Java's technically right that \foo isn't an absolute path 
since it is relative to the current drive in use (c:\foo vs d:\foo). But the 
fix sounds good. I will test when I next build/download...</comment>
		<comment id="3" date="2005-10-28 09:21:40 EDT" author="Adrian Colyer">moving to fixed, please reopen if not working as expected.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="332a5df39711d17d13ef2c87fdaba023d4869538" author="wisberg" date="2005-10-15 12:20:41"/>
          <file name="util/src/org/aspectj/util/ConfigParser.java">
              <method name="makeFile" returnType="File" parameters="File String"/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="113510" opendate="2005-10-24 5:36:00" fixdate="2005-11-2 5:36:00">
    <buginformation>
      <summary>readAspect</summary>
      <description>clearly define what the goal for readAspect is
old byte per byte reading cause NPE in some test case
current impl is hashcode for aspect name + classloader - ie unstable across
startups.</description>
      <comments>
		<comment id="1" date="2005-10-28 07:22:39 EDT" author="Adrian Colyer">for resolution by rc1...</comment>
		<comment id="2" date="2005-10-31 04:40:57 EST" author="Matthew Webster">This mechanism was added to support byte-code caching in a PoC OSGi 
environment. Actual aspect byte-code was use to determine when an aspect 
implementation had changed as well as the set of aspects affecting a 
particular class loader. However this approach is not sufficient to determine 
all the situations when a byte-code cache should be invalidated so I will 
change the implemtation to one that uses a sorted list of aspect names.</comment>
		<comment id="3" date="2005-11-01 12:33:20 EST" author="Matthew Webster">Created attachment 29081 [details]
Fix

Remove "readAspect()" method and use names instead. Have tested against my PoC
that needs it.</comment>
		<comment id="4" date="2005-11-02 05:36:01 EST" author="Andrew Clement">patch integrated, thanks Matthew.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="62d16d52c25f7b5ff389ee2de603bbb3dc186c8e" author="aclement" date="2005-11-02 07:36:05"/>
          <file name="loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java">
              <method name="registerAspects" returnType="void" parameters="BcelWeaver ClassLoader List"/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="103741" opendate="2005-7-13 19:19:00" fixdate="2005-11-4 4:05:00">
    <buginformation>
      <summary>Problem turning off Java 5 Support with @annotation pointcut (TypeX.java:821)</summary>
      <description>I had a project that I was compiling using Java 5 source support. I turned off 
java 5 support but accidentally left in an @annotation pointcut in it. When 
recompiling, I get an error dialog BCException thrown: Bad type signature: 
&lt;missing&gt;

When I restart I get this in my error log, and if I compile the same message.

java.lang.ClassCastException: org.eclipse.core.internal.resources.Project
at org.eclipse.ajdt.core.javaelements.AJCompilationUnit.&lt;init&gt;(AJCompilationUnit.java:118)
at org.eclipse.ajdt.core.AspectJCore.create(AspectJCore.java:137)
at org.eclipse.ajdt.core.AspectJCore.create(AspectJCore.java:38)
at org.eclipse.ajdt.core.model.AJProjectModel$Persistence.loadJavaElements(AJProjectModel.java:633)
at org.eclipse.ajdt.core.model.AJProjectModel$Persistence.loadModel(AJProjectModel.java:568)
at org.eclipse.ajdt.core.model.AJProjectModel.loadModel(AJProjectModel.java:136)
at org.eclipse.ajdt.core.model.AJModel.getModelForProject(AJModel.java:83)
at org.eclipse.ajdt.core.model.AJModel.isAdvised(AJModel.java:126)
at org.eclipse.ajdt.internal.buildconfig.ImageDecorator.decorateImage(ImageDecorator.java:207)
at org.eclipse.ui.internal.decorators.FullDecoratorDefinition.decorateImage(FullDecoratorDefinition.java:111)
at org.eclipse.ui.internal.decorators.FullImageDecoratorRunnable.run(FullImageDecoratorRunnable.java:28)
at org.eclipse.core.internal.runtime.InternalPlatform.run(InternalPlatform.java:1044)
at org.eclipse.core.runtime.Platform.run(Platform.java:783)
at org.eclipse.ui.internal.decorators.DecoratorManager.safeDecorateImage(DecoratorManager.java:395)
at org.eclipse.ui.internal.decorators.DecoratorManager.decorateImage(DecoratorManager.java:360)
at org.eclipse.jface.viewers.DecoratingLabelProvider.getImage(DecoratingLabelProvider.java:84)
at org.eclipse.jface.viewers.DecoratingLabelProvider.updateLabel(DecoratingLabelProvider.java:212)
at org.eclipse.jface.viewers.StructuredViewer.buildLabel(StructuredViewer.java:1855)
at org.eclipse.jface.viewers.TreeViewer.doUpdateItem(TreeViewer.java:228)
at org.eclipse.jface.viewers.AbstractTreeViewer$UpdateItemSafeRunnable.run(AbstractTreeViewer.java:85)
at org.eclipse.core.internal.runtime.InternalPlatform.run(InternalPlatform.java:1044)
at org.eclipse.core.runtime.Platform.run(Platform.java:783)
at org.eclipse.ui.internal.JFaceUtil$1.run(JFaceUtil.java:44)
at org.eclipse.jface.util.SafeRunnable.run(SafeRunnable.java:148)
at org.eclipse.jface.viewers.AbstractTreeViewer.doUpdateItem(AbstractTreeViewer.java:621)
at org.eclipse.jface.viewers.StructuredViewer$UpdateItemSafeRunnable.run(StructuredViewer.java:434)
at org.eclipse.core.internal.runtime.InternalPlatform.run(InternalPlatform.java:1044)
at org.eclipse.core.runtime.Platform.run(Platform.java:783)
at org.eclipse.ui.internal.JFaceUtil$1.run(JFaceUtil.java:44)
at org.eclipse.jface.util.SafeRunnable.run(SafeRunnable.java:148)</description>
      <comments>
		<comment id="1" date="2005-07-13 19:25:09 EDT" author="Ron Bodkin">Created attachment 24709 [details]
zipped up project in this bad state

The full zip is too big. I had to remove spring-1.2.1.jar from the lib folder
to make it small enough to upload...

In fact, even after removing any Java 5 code the project is STILL in a bad
state.</comment>
		<comment id="2" date="2005-07-13 19:26:41 EDT" author="Ron Bodkin">Even removing &amp; re-adding the AspectJ nature doesn't fix this bug for me!</comment>
		<comment id="3" date="2005-07-13 19:54:22 EDT" author="Ron Bodkin">I found this stack trace in the .log file under .metadata, giving some data on 
the Bad type popup...

!ENTRY org.eclipse.ajdt.ui 4 0 2005-07-13 15:30:12.445
!MESSAGE BCException thrown: Bad type signature: &lt;missing&gt;
!STACK 0
org.aspectj.weaver.BCException: Bad type signature: &lt;missing&gt;
 at org.aspectj.weaver.TypeX.signatureToName(TypeX.java:821)
 at org.aspectj.weaver.TypeX.getName(TypeX.java:329)
 at org.aspectj.weaver.bcel.BcelWorld.resolveObjectType(BcelWorld.java:221)
 at org.aspectj.weaver.World.resolveObjectType(World.java:160)
 at org.aspectj.weaver.World.resolve(World.java:132)
 at org.aspectj.weaver.patterns.ExactAnnotationTypePattern.resolveBindings(ExactAnnotationTypePattern.java:148)
 at org.aspectj.weaver.patterns.AnnotationPointcut.resolveBindings(AnnotationPointcut.java:162)
 at org.aspectj.weaver.patterns.NotPointcut.resolveBindings(NotPointcut.java:106)
 at org.aspectj.weaver.patterns.AndPointcut.resolveBindings(AndPointcut.java:112)
 at org.aspectj.weaver.patterns.Pointcut.resolve(Pointcut.java:231)
 at org.aspectj.ajdt.internal.compiler.ast.PointcutDesignator.finishResolveTypes(PointcutDesignator.java:82)
 at org.aspectj.ajdt.internal.compiler.ast.PointcutDeclaration.resolveStatements(PointcutDeclaration.java:164)
 at org.aspectj.org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:397)
 at org.aspectj.ajdt.internal.compiler.ast.PointcutDeclaration.resolvePointcut(PointcutDeclaration.java:145)
 at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.resolvePointcutDeclarations(AjLookupEnvironment.java:283)
 at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.completeTypeBindings(AjLookupEnvironment.java:179)
 at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.beginToCompile(Compiler.java:302)
 at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:316)
 at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:727)
 at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:206)
 at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:166)
 at org.aspectj.ajdt.internal.core.builder.AjBuildManager.incrementalBuild(AjBuildManager.java:147)
 at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:116)
 at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)</comment>
		<comment id="4" date="2005-07-14 08:50:37 EDT" author="Matt Chapman">I'm passing over to AspectJ because the main problem here is the BCException
from the compiler (which I can reproduce with the attached project). The
ClassCastException from AJDT (which I couldn't reproduce) may or may not be
related, but it shouldn't stop anything working, so I suggest we revisit that
after the compiler bug is fixed. There are a few AJ bugs already with similiar
"Bad type signature" errors, but I couldn't find any exactly the same as this one.</comment>
		<comment id="5" date="2005-07-18 08:31:48 EDT" author="Matt Chapman">*** Bug 104207 has been marked as a duplicate of this bug. ***</comment>
		<comment id="6" date="2005-07-18 21:59:56 EDT" author="Dean Wampler">I'm seeing the same error with code where I've removed the annotation implementations, commented out 
all use of annotations in source code, but left PCDs with annotation "matchers".</comment>
		<comment id="7" date="2005-07-18 23:43:47 EDT" author="Dean Wampler">Could this have something to do with adding constructors to aspects? I only started seeing this problem 
when I added a few constructors to some existing aspects, to initialize some newly-added properties with 
default values. (Those weren't the only changes, however.)</comment>
		<comment id="8" date="2005-08-26 11:37:01 EDT" author="Adrian Colyer">for investigation in M4</comment>
		<comment id="9" date="2005-10-05 03:32:54 EDT" author="Andrew Clement">Is it possible to ask you recreate this with a recent AJDT?  We have changed the
handling of 'missing' *and* we have changed the reporting of errors to give us
more context about what AJ was doing at the time things went wrong.  I've tried
to create this failure from the command line and couldnt (used -emacssym too).

I was also wondering if this only happens on an incremental compile and that
when you do a full compile it 'goes away' ?</comment>
		<comment id="10" date="2005-10-28 06:48:50 EDT" author="Adrian Colyer">We should check for use of Java 5 only features (such as the @xxx pcd family) and make sure that a 
friendly error message is issued in a project that is compiled without -1.5.</comment>
		<comment id="11" date="2005-11-04 04:05:23 EST" author="Adrian Colyer">Compiler now prevents use of any of the @xxx pcd family, annotations patterns in signature and type 
patterns, and the declare @xxx series if compliance level is not Java 5 or greater (planning for the 
future ;)).</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="c4ce2448ee0ad553d6768a22e82bba7f437a93fa" author="acolyer" date="2005-11-04 06:04:58"/>
          <file name="tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java">
              <method name="testITDCWithNoExplicitConsCall" returnType="void" parameters=""/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="95529" opendate="2005-5-17 5:53:00" fixdate="2005-11-12 13:53:00">
    <buginformation>
      <summary>concrete-aspect</summary>
      <description>for M4

note: need to think some if we want to jit the concrete aspect, or if its not
that needed ie that the shadow munger API allow us to do what we need (perhaps
not easy to deal with perClause and uniqueness enforcement of concrete-aspect
name, but perhaps a burden as well to deal with jit since then no bytecode can
be grabbed from file system ie may confuse the bcel repository and resolvedTypeX
and alike)

Ideas Andy ? I am more in favor of bytecode gen the concrete aspect there.
(that further means the underlying infra needs to support define class callbacks
like "acceptClass" thing used for ajc$Closure and alike when running LTW. I am
ok with that)</description>
      <comments>
		<comment id="1" date="2005-08-26 10:32:05 EDT" author="Adrian Colyer">marking as "enhancement" to make it easier to distinguish between new function
to be implemented in M4 and bugs to be fixed.</comment>
		<comment id="2" date="2005-09-27 05:49:16 EDT" author="Adrian Colyer">Raising to P2 to ensure we resolve this in the run-up to AJ5 RC1</comment>
		<comment id="3" date="2005-10-24 08:47:19 EDT" author="Alexandre Vasseur">Some notes:

@Aspect
abstract class MyA {
  @Before("pc()")
  .... {..}

  @Pointcut  // see here, nothing defined ie default "" in annotation
  abstract void pc(); // must be abstract for @Pointcut() to be allowed
}

// note: If AJC + run: as we have an abstract aspect, the before advice is not
// applied

Scenario A
----------

aop.xml contains:
&lt;aspect name="MyA"/&gt; // ie refers an abstract aspect
--&gt; what should happen?
I think it is an error, and we report it as such

Scenario B
----------
aop.xml contains:
&lt;aspect name="MyA_Real" extends="MyA"&gt;
  &lt;pointcut name="pc" expression="..."/&gt;
&lt;/aspect&gt;
--&gt; checks as follow:
- MyA is abstract
- Every abstract poincut from MyA is defined in XML &lt;pointcut elements
- Only void and (noargs) method are allowed
(ie not: &lt;pointcut name="pc(a)" expression="... &amp;&amp; target(a)" /&gt;
 with lookup of binding for void pc(SomeType x) etc)
[that means only simple pointcut can be xml-defined] 


comments?</comment>
		<comment id="4" date="2005-10-25 05:29:51 EDT" author="Alexandre Vasseur">impl done

some notes:
concrete aspect is JIT generated, using @AspectJ style
@Aspect // ie per from super
public class My extends Asbtract {
   @Pointcut(.... the expr from xml)
   mods.. void pc() {} 
   //mods must obey OO rules here
}

this ones is then passed thru the munger for aspectof method to be added
(this does NOT follow the regular process - which assumes as configured weaver,
as we are precisely doing the config at that stage).

doc updated with sample</comment>
		<comment id="5" date="2005-10-25 05:31:11 EDT" author="Alexandre Vasseur">spotted that decl precedence cannot be late defined.
added some xml for that (that again is turned to an @AJ annotation)

&lt;concrete-aspect.... precedence="..."&gt;
...</comment>
		<comment id="6" date="2005-10-25 06:01:09 EDT" author="Alexandre Vasseur">impl commited
work pending on ajdt core to not complain on asbtract @Pointcut and do some
checks (abstract ()V method only)</comment>
		<comment id="7" date="2005-10-25 09:11:16 EDT" author="Alexandre Vasseur">all done
TODO = test on error reporting</comment>
		<comment id="8" date="2005-10-26 14:14:29 EDT" author="Matthew Webster">This looks great however:
-  Declaring an abstract aspect is quite valid because it may have an 
effect even if not made concrete e.g. ITDs (see 
http://dev.eclipse.org/mhonarc/lists/aspectj-users/msg04545.html). I am 
working on a testcase.
- The support for precedence has not been fully specified. The user 
should be able to define it without having to extend an existing aspect as can 
be done with the AspectJ syntax. There is an enhancement request for this: 
https://bugs.eclipse.org/bugs/show_bug.cgi?id=106504
- Testing error messages will be much easier using the new LTW support 
in the harness. I have started the work and will post a patch when I have one. 
We can reuse all the expected message handling that exists for the âcompileâ 
task.</comment>
		<comment id="9" date="2005-10-28 08:30:15 EDT" author="Matthew Webster">Created attachment 28914 [details]
Testcase for abstract LTW aspect and harness improvements

This started as a simple LTW ITD testcase but needed several small changes to
the harness and weaving adaptor to get consistent message handling. It also
contains a test for empty aop.xml files.</comment>
		<comment id="10" date="2005-11-02 12:40:06 EST" author="Matthew Webster">Created attachment 29186 [details]
Patch for loadtime, weaver, ...

1. Improved test for empty aop.xml
2. Avoid creating duplicate world/weaver in WeavingAdaptor.init()</comment>
		<comment id="11" date="2005-11-08 09:06:15 EST" author="Andrew Clement">Do we need to integrate Matthews patches here?</comment>
		<comment id="12" date="2005-11-08 12:12:39 EST" author="Matthew Webster">Now that bug 95516 is complete we need to remove the warning about abstract 
aspects being declared in aop.xml.</comment>
		<comment id="13" date="2005-11-11 07:50:29 EST" author="Matthew Webster">Created attachment 29771 [details]
Updated patch

1. Test weaving adaptor disabled and message issued when no aop.xml found
2. Test declaration and side effect of an abstract aspect</comment>
		<comment id="14" date="2005-11-11 08:51:42 EST" author="Andrew Clement">as per discussion on call yesterday, new patch integrated. will close when build
available.</comment>
		<comment id="15" date="2005-11-12 13:53:18 EST" author="Andrew Clement">code available in latest dev build.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="76ebbc76add2abd815b3a8b5ea0beb11c94c8c49" author="avasseur" date="2005-10-25 07:00:58"/>
          <file name="aspectj5rt/java5-src/org/aspectj/lang/annotation/Pointcut.java">
          </file>
          <file name="loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java">
              <method name="initialize" returnType="void" parameters="ClassLoader IWeavingContext"/>
              <method name="acceptClass" returnType="void" parameters="String byte[]"/>
          </file>
          <file name="loadtime/src/org/aspectj/weaver/loadtime/ConcreteAspectCodeGen.java">
          </file>
          <file name="loadtime/src/org/aspectj/weaver/loadtime/WeavingURLClassLoader.java">
          </file>
          <file name="loadtime/src/org/aspectj/weaver/loadtime/definition/Definition.java">
          </file>
          <file name="loadtime/src/org/aspectj/weaver/loadtime/definition/DocumentParser.java">
          </file>
          <file name="tests/java5/ataspectj/ataspectj/ConcreteAtAspectTest.java">
          </file>
          <file name="tests/src/org/aspectj/systemtest/ajc150/ataspectj/AtAjLTWTests.java">
              <method name="testCompileTimeAspectsDeclaredToLTWWeaver" returnType="void" parameters=""/>
          </file>
          <file name="weaver/src/org/aspectj/weaver/bcel/AtAjAttributes.java">
              <method name="handlePointcutAnnotation" returnType="void" parameters="RuntimeAnnotations AjAttributeMethodStruct"/>
          </file>
          <file name="weaver/src/org/aspectj/weaver/bcel/BcelPerClauseAspectAdder.java">
              <method name="munge" returnType="boolean" parameters="BcelClassWeaver"/>
          </file>
          <file name="weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java">
              <method name="addLibraryAspect" returnType="ResolvedType" parameters="String"/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="115275" opendate="2005-11-7 4:14:00" fixdate="2005-11-16 3:17:00">
    <buginformation>
      <summary>aop.xml aspect include</summary>
      <description>I have a question about load-time weaving in AspectJ.  According to the
AspectJ 5 Development Kit Developer's Notebook,  the &lt;aspects&gt; element
can have an &lt;include within="[pattern]"&gt; child element
(http://eclipse.org/aspectj/doc/next/adk15notebook/ltw-configuration.html).

However, when I include that element as a child to the &lt;aspects&gt; element
in my aop.xml file, I get a SAX exception:

org.xml.sax.SAXException: Unknown element while parsing &lt;aspectj&gt;
element: include


Is the &lt;include&gt; element currently supported within the &lt;aspects&gt;
element?  Or do I have to explicitly list every aspect I want woven at
load time using an &lt;aspect name="..."&gt; for each aspect?  Basically I do
not wish to explicitly ennumerate every aspect in the aop.xml file for
the load-time weaver.  Rather, I want to use a wildcard pattern to
capture them all.</description>
      <comments>
		<comment id="1" date="2005-11-07 04:42:42 EST" author="Alexandre Vasseur">note: aspects/include and aspects/exclude only affect the set of aspects
declared in this aop.xml file

discussion needed to allow further side effect (usefull to debug but quite
dangerous as could lead to unknow deactivation of aspects configured by someone
else).

doc updated accordingly</comment>
		<comment id="2" date="2005-11-07 06:30:36 EST" author="Matthew Webster">This implementation is pointless. The user can easily determine which aspects 
declared or defined locally are _actually_ used by commenting out or deleting 
the relevant entries. It is also contrary to the intent of the agreed 
specification. In a large system it may be necessary to quickly and easily 
disable one or more aspects globally. This change makes that impossible.

Certainly in a classloader hierarchy the careless use of an include/exclude 
aspects sub-element can cause LTW to be disabled at a lower level. However the 
same applies to include/exclude for weaver sub-elements. With this 
implementation the user _cannot_ prevent a concrete aspect somewhere in the 
system effecting their application without tracking it down and removing its 
declaration/definition or changing its implementation. Removing the 
declaration/definition may have an undesirable effect on other applications 
and changing the implementation may be difficult or impossible especially if 
it is 3rd party code.

We need to discuss this further before simply changing the specification.</comment>
		<comment id="3" date="2005-11-07 07:28:05 EST" author="Alexandre Vasseur">Don't forget that weaver/include and weaver/exclude are weaver wide and can thus
be used for "prevent a concrete aspect somewhere in the system effecting their
application".

The tradeoff here is:
- if using weaver/exclude, the user CAN prevent some concrete aspect somewhere,
but also prevent all other aspects to apply to its application - and in that
case this fact is well know. This is implemented.
- if using (not implemented weaver wide) aspect/exclude the user can also
prevent that but also MAY trigger side effects on other parts of the system -
and in that case this fact cannot be well know unless the user has complete
knowledge on which aspects applied to where - which is not the intented approach
of a classloader tied load time weaver.

Note I am not changing the ""spec"". Obviously I had some issues regarding this
since I had a bunch of TODO/FIXME/TBD left around that in the DTD and in the
code and some emails/communication has probably beeing lost in the whole set of
things discussed/implemented/prioritized - and I certainly agree the non weaver
wide implementation is just useless.

For this feature to happen

- there is a need of a JVM wide flag to allow such behavior 
(-D...allowAspectIncludeExclude), else it is an easy way to simply kick out
AspectJ aspects which certainly won't help much in troubleshooting (use
showWeaveInfo, or -verbose &amp; co will help much more ie if one suspects an aspect
to be guilty, -verbose etc will help spot it and weaver/exclude will help
isolate the user application from it)
Even with this option I don't feel comfortable. I can't see any real scenario
that cannot be addressed by weaver/include/exclude instead.

- there is a need to change the impl quite heavily as it requires aop.xml'
aspect to be actually registered only when ALL aop.xml's of the current
classloader visibility level have been parsed.</comment>
		<comment id="4" date="2005-11-10 05:59:49 EST" author="Alexandre Vasseur">Matthew made me realized that I was wrong. Sorry for the confusion
We do allow an aspects'include/exclude to affect the list of aspects declared to
be used in sub-deployment ie a parent deployed unit can possibly take full
control and dissallow all aspects in the system/ear/war/ etc
(put aop.xml &lt;aspects&gt;&lt;exclude within="*..*"/&gt;&lt;/aspects&gt;)

What was missing was some bits of the implementation.

The thing is that given a classloader C we build an adaptor WA. WA is build by
aggregation of all visible aop.xml files higher up in the hierarchy. Then we
build the weaver and its world.
Hence at the end of the parsing we indeed have all the include/exclude elements
to accept aspects. 

Next we need to decide if we want to issue a message or something that would
help understand why the thing you deploy is not weaved - f.e. if someone higher
up is using a "&lt;aspects&gt;&lt;include&gt;" that does not match our aspect bundled in the
deployed unit.
Ideally some verbose mode that reports 'type X not exposed to the weaver due to
....path..to..aop.xml   [include|exclude] ....pattern....'
and 'aspect A not registered due to ....path..to..aop.xml  [include|exclude]
....pattern....'</comment>
		<comment id="5" date="2005-11-10 06:28:12 EST" author="Matthew Webster">Created attachment 29688 [details]
Use case for &lt;aspects&gt;&lt;include&gt;

An application may inherit one or more concrete aspects from the platform on
which it runs e.g. Tomcat. These may relate to problem diagnosis, profiling or
some other platform feature. The application author/deployer needs to be able
to select which aspects are actually used without having to modify the aspect
the source code to which they may not have access.</comment>
		<comment id="6" date="2005-11-15 08:50:06 EST" author="Matthew Webster">Created attachment 29958 [details]
Testcases and fix

1. Lint warning issued when aspect not included for weaving
2. Testcase for warning</comment>
		<comment id="7" date="2005-11-15 09:34:20 EST" author="Andrew Clement">patch integrated.</comment>
		<comment id="8" date="2005-11-16 03:17:43 EST" author="Andrew Clement">matthews fix now available.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="e2db71535154c6564fb30bebf2f51fc321a94f7c" author="avasseur" date="2005-11-07 07:04:00"/>
          <file name="loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java">
          </file>
          <file name="loadtime/src/org/aspectj/weaver/loadtime/definition/Definition.java">
          </file>
          <file name="loadtime/src/org/aspectj/weaver/loadtime/definition/DocumentParser.java">
              <method name="startElement" returnType="void" parameters="String String String Attributes"/>
          </file>
          <file name="loadtime/testsrc/org/aspectj/weaver/loadtime/test/DocumentParserTest.java">
              <method name="testSimpleWithDtd" returnType="void" parameters=""/>
          </file>
          <file name="tests/java5/ataspectj/ataspectj/ConcreteAtAspectTest.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="95517" opendate="2005-5-17 5:19:00" fixdate="2005-11-16 5:39:00">
    <buginformation>
      <summary>ajc pseudo LTW not consistent with LTW</summary>
      <description>docs says ajc provides LTW things, but that one does not at all go thru aop.xml
lookups and so on

Needs to be removed or made consistent in some way</description>
      <comments>
		<comment id="1" date="2005-09-27 05:47:36 EDT" author="Adrian Colyer">moved to P2.
Alex and Matthew, please can you work together to decide what we should do with
"aj" in the new world. Just rebasing it on the new LTW agents so that it obeys
the aop.xml etc. seems the simplest and best thing here?</comment>
		<comment id="2" date="2005-09-28 04:10:57 EDT" author="Alexandre Vasseur">this won't solve the issue for java 1.3/1.4 since we decided to not have the AW
LTW in there but as an extension (see my blog).

I suggest to keep aj as it is (no aop.xml, based on aspect path etc)and possibly
have an aj5 script for use with java5 -javaagent and aop.xml

Matthew?</comment>
		<comment id="3" date="2005-10-13 10:07:57 EDT" author="Matthew Webster">We could have 2 scripts: the existing "aj" and "aj5". They are both installed 
regardless of which JDK you specify during install. We will rely on any error 
messages from the JDK if someone uses the wrong one although 1.3 will fail 
silently.

- "aj" will use both aspectpath and aop.xml since my changes in 107741. We 
need to update the documentation and examples
- "aj5" will be a simple wrapper for "java -javaagent:aspectjweaver.jar ..." 
using aop.xml. We also need a implementation for bug 95516.</comment>
		<comment id="4" date="2005-10-28 05:31:13 EDT" author="Adrian Colyer">Matthew, could you close this one out for RC1 pls? </comment>
		<comment id="5" date="2005-11-08 12:04:08 EST" author="Matthew Webster">Created attachment 29547 [details]
Patch

build: Modified installer to update aj.bat and add aj5.bat
docs:  New README and simple HelloWorld/Tracing example to illustrate aop.xml
support and new âoutxml option
lib:   build/build.jar must be update. Build as follows:
- Run â..\lib\ant\bin\ant buildâ from âfrom build moduleâ
- Copy âaj-build\jars\build.jarâ to âlib\buildâ
- Commit lib module

Can someone please test aj and aj5 on Linux/Mac</comment>
		<comment id="6" date="2005-11-15 09:55:42 EST" author="Matthew Webster">Created attachment 29960 [details]
Patch

Now tested successfully on Mac after changing onUnix test to be true for Mac.</comment>
		<comment id="7" date="2005-11-15 11:59:03 EST" author="Andrew Clement">patch integrated - waiting on build.</comment>
		<comment id="8" date="2005-11-16 05:39:59 EST" author="Andrew Clement">fix available.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="4ea00513761eeb32b3403caa1a3ba39f9218a839" author="aclement" date="2005-11-16 01:55:56"/>
          <file name="build/src/$installer$/org/aspectj/Main.java">
          </file>
          <file name="docs/dist/doc/examples/ltw/HelloWorld.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="115252" opendate="2005-11-6 22:10:00" fixdate="2005-11-19 4:53:00">
    <buginformation>
      <summary>want xlint message for improper annotation type</summary>
      <description>When an annotation can only target one kind of thing (e.g., a type) but is used
to modify something else in a pointcut (e.g., a method), it would be nice if the
compiler emitted an error, since the two situations can be confusingly similar:

   call(@Nice * *(..))      // method
   call((@Nice *) *(..))    // return type


---------------------------------------------
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

public class AnnotationTypePatternMistakes {
	@Retention(RetentionPolicy.RUNTIME)
	@Target({ElementType.TYPE}) 
	@interface I{}
	@I()
	class C{}
	static aspect A {
		// would like a CE here - I only on types
		pointcut pc() : execution(@I * *(..));
		declare error : pc() : "hi";
	}
}</description>
      <comments>
		<comment id="1" date="2005-11-08 03:47:48 EST" author="Andrew Clement">take a look... start at WildTypePattern.resolveBindings() which converts all
patterns to concrete ExactTypePatterns in situations like this..</comment>
		<comment id="2" date="2005-11-17 08:34:32 EST" author="Helen Beeken">The fix has to go in to SignaturePattern.resolveBindings(..) rather than lower
down because in the case of the annotation pattern being non-null i.e you have a
pointcut of the form

@MyAnnotation * *(..) 

then you need to know the fact that you're interested in methods when you check
whether @MyAnnotation has an @Target annotation which is ElementType.METHOD (if
no @Target is specified then the default is that it applies to everything). 

There is then the cases for incorrect annotation types in the other positions
within the signature pattern, for example

* (@MyAnnotation *).*(..)           - declaring type
* *(@MyAnnotation *)                - parameter type
(@MyAnnotation *) *(..)             - return type
* *.*(..) throws (@MyAnnotation *)  - throws pattern (required)
* *.*(..) throws !(@MyAnnotation *) - throws pattern (disallowed)

In these cases, all that needs to be checked is whether the patternNode has a
@Target annotation on it which is either not the default or not ElementType.TYPE
(as these are the only ones allowed). Again, I believe that the logic should be
contained in the SignaturePattern class rather than lower down because the
different implementations of resolveBindings(..) can be called from various
places and placing a check on the targetKind might result in an xlint warning
being recorded when it shouldn't. Unfortuntately, I can't think of a testcase
for this :-(

The overall fix is to mirror the implementation of working out whether runtime
retention is there by adding a method "String getTargetType()" to the
ReferenceTypeDelegate interface and the corresponding implementations in the
four classes which implement this (excluding the AbstractReferenceTypeDelegate
class). Then, in SignaturePattern.resolveBindings(..) after each PatternNode has
been resolved, check whether it has the correct target kind.

The drawback of putting the fix in SignaturePattern is that not all pointcuts
are resolved via this route, for example 

handler(@TypeAnnotation *)

however, I'm leaving the implementation for these scenarios until someone raises
it as a bug since the proposed fix covers the scenario under which this bug was
raised. I believe though, a similar implementation to the one proposed here
would need to be applied in this case.</comment>
		<comment id="3" date="2005-11-17 08:53:40 EST" author="Helen Beeken">Created attachment 30135 [details]
testcase patch

Apply this patch to the tests project.

Note that this fix means that with testAtField_WrongTargetSource() we now get
two xlint messages which has meant that updates have had to be made to the
corresponding place in ajc150.xml.</comment>
		<comment id="4" date="2005-11-17 08:57:33 EST" author="Helen Beeken">Created attachment 30136 [details]
zip containing fix 

This zip contains two patches which make up the proposed fix for this bug:

* pr115252-org-aspectj-ajdt-core-patch.txt - apply to the org.aspectj.ajdt.core
project
* pr115252-weaver-patch.txt - apply to the weaver project</comment>
		<comment id="5" date="2005-11-18 09:24:16 EST" author="Helen Beeken">The previously attached patches need to be ammended for a couple of reasons.
Firstly, the scenario when an annotation has more than one @Target annotations
isn't covered (which requires updates to both the tests and proposed fixes).
Secondly, it is nicer to deal with AnnotationTargetKind's (which is a newly
created TypeSafeEnum which lives better in its own class rather than as an inner
class) rather than Strings.</comment>
		<comment id="6" date="2005-11-18 09:26:34 EST" author="Helen Beeken">Created attachment 30220 [details]
updated testcase patch

Updated testcase patch including one extra test which has annotations that have
more than one @Target annotation.

Apply patch to the tests project.</comment>
		<comment id="7" date="2005-11-18 09:31:05 EST" author="Helen Beeken">Created attachment 30222 [details]
zip containing updated proposed fix

Zip containing updated proposed fix as discussed in comment #5.

This zip contains two patches which make up the proposed fix for this bug:

* pr115252-org-aspectj-ajdt-core-patch2.txt - apply to the
org.aspectj.ajdt.core
project
* pr115252-weaver-patch2.txt - apply to the weaver project</comment>
		<comment id="8" date="2005-11-18 10:05:33 EST" author="Andrew Clement">patches integrated - thanks Helen.  Waiting on build.</comment>
		<comment id="9" date="2005-11-19 04:53:22 EST" author="Andrew Clement">fix available.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="b1a8c138a6af2d94747a66a03dc9249d9c5554ce" author="aclement" date="2005-11-18 11:47:31"/>
          <file name="tests/bugs150/pr115252/AndTypePattern.java">
          </file>
          <file name="tests/bugs150/pr115252/AnnotationDeclaringType.java">
          </file>
          <file name="tests/bugs150/pr115252/AnnotationParameterType.java">
          </file>
          <file name="tests/bugs150/pr115252/AnnotationReturnType.java">
          </file>
          <file name="tests/bugs150/pr115252/AnnotationThrowsPattern.java">
          </file>
          <file name="tests/bugs150/pr115252/ExactAnnotationTypePattern.java">
          </file>
          <file name="tests/bugs150/pr115252/MoreThanOneTargetAnnotation.java">
          </file>
          <file name="tests/bugs150/pr115252/OrTypePattern.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="114875" opendate="2005-11-3 0:25:00" fixdate="2005-11-21 6:29:00">
    <buginformation>
      <summary>@Pointcut - throws java.lang.NullPointerException</summary>
      <description>Eclipse 3.1
AJDT 1.3.0.20051102174241

package com.aspectj.test;

import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.aspectj.lang.annotation.Pointcut;

@Aspect
public abstract class Base {

    @Pointcut                                     --&gt;Seems to be the problem
    abstract void method();
	

    public static void main(String args[]){
    }
}

package com.aspectj.test;

import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.aspectj.lang.annotation.Pointcut;

@Aspect
public class Sub extends Base{

    @Pointcut( "execution(* com.aspectj.test.Base.main(..))" )
    void method(){};

    @Before("method()")
    public void test(){
		
    }
}


The code above shows

java.lang.NullPointerException
	at org.aspectj.weaver.patterns.BasicTokenSource.makeTokenSource(BasicTokenSource.java:84)
	at org.aspectj.weaver.patterns.PatternParser.&lt;init&gt;(PatternParser.java:1373)
	at org.aspectj.ajdt.internal.compiler.ast.ValidateAtAspectJAnnotationsVisitor.convertToPointcutDeclaration(ValidateAtAspectJAnnotationsVisitor.java:493)
	at org.aspectj.ajdt.internal.compiler.ast.ValidateAtAspectJAnnotationsVisitor.visit(ValidateAtAspectJAnnotationsVisitor.java:188)
	at org.aspectj.org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.traverse(MethodDeclaration.java:185)
	at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.traverse(TypeDeclaration.java:1183)
	at org.aspectj.org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.traverse(CompilationUnitDeclaration.java:339)
	at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.beforeAnalysing(AjCompilerAdapter.java:154)
	at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$before$org_aspectj_ajdt_internal_compiler_CompilerAdapter$7$db78446d(CompilerAdapter.aj:101)
	at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:517)
	at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:329)
	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:759)
	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:225)
	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:180)
	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.incrementalBuild(AjBuildManager.java:158)
	at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:117)
	at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)


The syntax @Pointcut("") is shown as error too. If this is not a bug then a 
proper message instead of an exception is helpful.</description>
      <comments>
		<comment id="1" date="2005-11-03 03:24:03 EST" author="Andrew Clement">*** Bug 114876 has been marked as a duplicate of this bug. ***</comment>
		<comment id="2" date="2005-11-03 03:24:25 EST" author="Andrew Clement">needs fixing for RC1</comment>
		<comment id="3" date="2005-11-03 04:10:37 EST" author="Alexandre Vasseur">odd
the line ValidateAtAspectJAnnotationsVisitor.java:493 is meaningless
this is also covered by the suite (ConcreteAtAspect.java)

I suspect that ajdt.core is not properly mirroring what is in the source.
Andy, you can probably understand what 's going on there - unless the answer is
simply that AJ in AJDT is older than AJ last good known snapshot.

Mohan you can try using a recent AJ build and ajc (outside of AJDT)</comment>
		<comment id="4" date="2005-11-03 04:19:47 EST" author="Andrew Clement">AJDT definetly has an older AJ in it (from a week or so ago).  I've tried this
program with the latest AJ and it doesn't fail for me.

Line 493 said this:

Pointcut pc = new PatternParser(pointcutExpression,context).parsePointcut();

in version 1.12 of the Validateblahblahblah class. and given that alex's checkin
comment is 'ajdtcore for abstract @Pointcut' for 1.13 then I'm assuming the fix
went into 1.13 and hasn't surfaced in an AJDT yet.</comment>
		<comment id="5" date="2005-11-03 07:51:18 EST" author="Mohan Radhakrishnan">I tried the latest aj dev. build.

Now my code is

import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.aspectj.lang.annotation.Pointcut;

@Aspect
public abstract class Base {

 @Pointcut
    abstract void method();
 

 public static void main(String args[]){
 }
}

import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.aspectj.lang.annotation.Pointcut;

@Aspect
public class Sub extends Base{

 @Pointcut( "execution(* com.aspectj.test.Base.main(..))" )
    void method(){};

 @Before("method()")
    public void test(){
  //System.out.println("Advised by "+this);

 }
}

When I compile Base.java it works. When I compile Sub.java I see this 
exception.

java.lang.NullPointerException
        at org.aspectj.ajdt.internal.compiler.ast.ValidateAtAspectJAnnotationsVisitor.validateAspectDeclaration(ValidateAtAspectJAnnotationsVisitor.java:243)
        at org.aspectj.ajdt.internal.compiler.ast.ValidateAtAspectJAnnotationsVisitor.checkTypeDeclaration(ValidateAtAspectJAnnotationsVisitor.java:119)
        at org.aspectj.ajdt.internal.compiler.ast.ValidateAtAspectJAnnotationsVisitor.visit(ValidateAtAspectJAnnotationsVisitor.java:107)
        at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.traverse(TypeDeclaration.java:1145)
        at org.aspectj.org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.traverse(CompilationUnitDeclaration.java:339)
        at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.beforeAnalysing(AjCompilerAdapter.java:154)
        at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$before$org_aspectj_ajdt_internal_compiler_CompilerAdapter$7$db78446d(CompilerAdapter.aj:101)
        at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:517)
        at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:329)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:759)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:225)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:151)
        at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:112)
        at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:60)
        at org.aspectj.tools.ajc.Main.run(Main.java:326)
        at org.aspectj.tools.ajc.Main.runMain(Main.java:240)
        at org.aspectj.tools.ajc.Main.main(Main.java:83)</comment>
		<comment id="6" date="2005-11-03 10:17:21 EST" author="Alexandre Vasseur">fails when looking for parent type?

   if (parentBinding instanceof SourceTypeBinding) {
    SourceTypeBinding parentSTB = (SourceTypeBinding) parentBinding;
    TypeDeclaration parentDecl = parentSTB.scope.referenceContext; //!!!!!!!!
NPE here
    if (isAspect(parentDecl) &amp;&amp; !Modifier.isAbstract(parentDecl.modifiers)) {
    
typeDecl.scope.problemReporter().signalError(typeDecl.sourceStart,typeDecl.sourceEnd,"cannot
extend a concrete aspect");
    }   
   }</comment>
		<comment id="7" date="2005-11-07 05:50:19 EST" author="Alexandre Vasseur">cannot reproduce in AJC from CVS head
see test - in tests/java5/ataspectj.../bugs/AbstractAspectNPE[Child|Parent].java

Mohan, please advise</comment>
		<comment id="8" date="2005-11-08 05:24:37 EST" author="Mohan Radhakrishnan">I am using the Last Known Good developer build.</comment>
		<comment id="9" date="2005-11-21 03:50:20 EST" author="Andrew Clement">I've recreated this. fixing it now.</comment>
		<comment id="10" date="2005-11-21 04:23:57 EST" author="Andrew Clement">this happens during incremental compilation.  We attempt to look at the scope of an object we believe is a SourceTypeBinding.  In the AJ world a BinaryTypeBinding is a subtype of SourceTypeBinding (for our 'binary source' support) - and if we don't allow for this case we end up working with a null scope.

fix checked in, waiting on build</comment>
		<comment id="11" date="2005-11-21 06:29:34 EST" author="Andrew Clement">fix available in latest AJ dev build.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="e9e0a7be5be07919d74f7da12fa59232a8b81a1e" author="avasseur" date="2005-11-07 07:50:55"/>
          <file name="tests/java5/ataspectj/ataspectj/bugs/AbstractAspectNPEChild.java">
          </file>
          <file name="tests/java5/ataspectj/ataspectj/bugs/AbstractAspectNPEParent.java">
          </file>
          <file name="tests/src/org/aspectj/systemtest/ajc150/ataspectj/AtAjSyntaxTests.java">
              <method name="testDeclareParentsImplements" returnType="void" parameters=""/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="116626" opendate="2005-11-16 3:54:00" fixdate="2005-11-22 0:24:00">
    <buginformation>
      <summary>Load-time weaving - exception from the weaver</summary>
      <description>Hi again :-)

I'm trying to use loadtime weaving and getting an exception. Please look at the 
testcase:

Java code:
==========
public class Test&lt;T&gt; {

	Set&lt;T&gt; intsSet;

	public Test() {
		this.intsSet = new HashSet&lt;T&gt;();
	}

	public &lt;T&gt; T[] getObjs(T[] a) {
		return intsSet.toArray(a);
	}

	public static void main(String[] args) {
		System.out.println("AAA :-)");
		new TTT().foo();
	}
}

class TTT {
	public void foo() {
		Test&lt;Object&gt; mt = new Test&lt;Object&gt;();
		Object[] arr = mt.getObjs(new Object[]{});
	}
}

Aspect:
=======
public privileged aspect TestAspect {

      pointcut TestToArray(Test mt) :
                target(mt) &amp;&amp;
                !within(TestAspect);


    Object[] around(Test mt, Object[] objs) :
            TestToArray(mt) &amp;&amp;
            args(objs) &amp;&amp;
            execution(Object[] com.mprv.secsph.Test.getObjs(Object[])) {

        objs = proceed(mt, objs);
        System.out.println("GO Aspects!");
        return objs;
    }
}

aop.xml
=======
&lt;aspectj&gt;
	&lt;aspects&gt;
		&lt;aspect name="com.mprv.secsph.TestAspect"/&gt;
	&lt;/aspects&gt;

	&lt;weaver options="-verbose -XlazyTjp -showWeaveInfo"&gt;
		&lt;include within="com.mprv.*"/&gt;
	&lt;/weaver&gt;
&lt;/aspectj&gt;

Program output:
==============
AAA :-)
info weaving 'com/mprv/secsph/TestAspect'
java.lang.NullPointerException
	at org.aspectj.weaver.tools.WeavingAdaptor$WeavingClassFileProvider.getBytes(WeavingAdaptor.java:390)
	at org.aspectj.weaver.tools.WeavingAdaptor.getAtAspectJAspectBytes(WeavingAdaptor.java:259)
	at org.aspectj.weaver.tools.WeavingAdaptor.weaveClass(WeavingAdaptor.java:181)
	at org.aspectj.weaver.loadtime.Aj.preProcess(Aj.java:66)
	at org.aspectj.weaver.loadtime.ClassPreProcessorAgentAdapter.transform(ClassPreProcessorAgentAdapter.java:52)
	at sun.instrument.TransformerManager.transform(TransformerManager.java:122)
	at sun.instrument.InstrumentationImpl.transform(InstrumentationImpl.java:155)
	at java.lang.ClassLoader.defineClass1(Native Method)
	at java.lang.ClassLoader.defineClass(ClassLoader.java:620)
	at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:124)
	at java.net.URLClassLoader.defineClass(URLClassLoader.java:260)
	at java.net.URLClassLoader.access$100(URLClassLoader.java:56)
	at java.net.URLClassLoader$1.run(URLClassLoader.java:195)
	at java.security.AccessController.doPrivileged(Native Method)
	at java.net.URLClassLoader.findClass(URLClassLoader.java:188)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:306)
	at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:268)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:251)
	at java.lang.ClassLoader.loadClassInternal(ClassLoader.java:319)
	at com.mprv.secsph.Test.getObjs(Test.java:1)
	at com.mprv.secsph.TTT.foo(Test.java:34)
	at com.mprv.secsph.Test.main(Test.java:27)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:585)
	at com.intellij.rt.execution.application.AppMain.main(AppMain.java:86)
GO Aspects!

====

This exception doesn't happen all the time ... but if you will try a few times, 
you will probably get it. May you can understand what is the problem event 
without running the test case. 

Anyway, I took a look at your code, and have a guess (but it's only the guess) -
My aspect is in the application classpath. Actually it's in the same package, 
so may be you are trying to weave the aspect with itself somehow ...

Thanks!
Misha.</description>
      <comments>
		<comment id="1" date="2005-11-16 03:56:10 EST" author="Andrew Clement">Matthew, can you take a look at recreating this?</comment>
		<comment id="2" date="2005-11-16 11:16:55 EST" author="Matthew Webster">This bug is a result of the âfixâ to bug 113587. When an aspect is not 
included in the weave it now gets a second chance if it is an @AspectJ aspect 
(see WeavingAdaptor.weaveClass()). However the test in 
BcelWorld.isAnnotationStyleAspect() called from 
shouldWeaveAnnotationStyleAspect() is unreliable because it only looks for the 
org/aspectj/lang/annotation/Aspect annotation which for Java 5 is also added 
to code-style aspects. The trouble happens later in BcelWeaver.weaver() where 
we use the right test so the aspect is not âmungedâ. This means no new bytes 
are generated and WeavingClassFileProvider.getBytes() throws an NPE. The 
solution is to return the unwoven bytes if there are no woven bytes.

Here are some things I spotted:
1. The aop.xml is wrong and the TestAspect is no included. It should be 
&lt;include within="com.mprv..*"/&gt; (two dots).
2. The aspect is loaded and weaving is attempted despite its exclusion.
3. The application and aspect run correctly.

What is missing from the testcase is how it was built. It has already been 
woven. If it had not been of the aspect had been included correctly the bug 
would not have occurred.</comment>
		<comment id="3" date="2005-11-16 11:37:21 EST" author="Matthew Webster">Created attachment 30073 [details]
Testcase

Failing user testcase integrated into harness.</comment>
		<comment id="4" date="2005-11-16 12:03:40 EST" author="Matthew Webster">Created attachment 30080 [details]
Fix

WeavingClassFileProvider.getBytes() returns original unwoven bytes if no
weaving takes place.</comment>
		<comment id="5" date="2005-11-16 12:48:00 EST" author="Matthew Webster">While this change solves the user's problem I am not happy with the fix. In 
fact I don't think any changes should have been made for bug 113587 in the 
first place. When using annotation-style aspects the Aspects.aspectOf() 
interface should be used not try to fix it up in the run-time.

I have a couple issues with the current implementation:
1. The BcelWorld.isAnnotationStyleAspect() seems to be bogus on Java 5.
2. More seriously the else clause in WeavingAdaptor.weaveClass() ignores 
the "enabled" flag used in shouldWeave() thereby partially invalidating the 
performance improvement in Bug 113511: we create and parse a BCEL JavaClass 
for _every_ excluded class.

I will raise a separate bug to deal with this.</comment>
		<comment id="6" date="2005-11-18 04:07:05 EST" author="Andrew Clement">fix integrated, waiting on build.  thanks Matthew.  Oh, and to the original
raiser: you dont need to specify XlazyTjp - its the default now.</comment>
		<comment id="7" date="2005-11-18 07:10:47 EST" author="Andrew Clement">Fix available for the NPE.</comment>
		<comment id="8" date="2005-11-22 00:24:12 EST" author="Ron Bodkin">*** Bug 117160 has been marked as a duplicate of this bug. ***</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="c7608950f0deb6f9951435f58209ad60aaf28e06" author="aclement" date="2005-11-18 06:01:17"/>
          <file name="tests/bugs150/pr116626/com/foo/bar/Test.java">
          </file>
          <file name="tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java">
              <method name="testNoStackOverflowWithCircularPCDInGenericAspect2" returnType="void" parameters=""/>
          </file>
          <file name="weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="115607" opendate="2005-11-9 4:35:00" fixdate="2005-11-22 3:24:00">
    <buginformation>
      <summary>Incorrect structure model for simple declare @type program?</summary>
      <description>This program:
---8&lt;-----
@interface I {}

class Simple {}

public aspect C {
  declare @type: Simple : @I;
}
---8&lt;-----
(all in a file called C.java, open with the AJ editor) when built shows
incorrect gutter markers, it shows a double headed arrow on Simple implying that
it annotates itself - rather than something outgoing from the declare statement
and something incoming on the Simple type.</description>
      <comments>
		<comment id="1" date="2005-11-21 10:24:14 EST" author="Helen Beeken">Converting the given program to an AJ testcase and printing out the structure model gives:


=== MODEL STATUS REPORT ========= After a batch build
&lt;root&gt;  [java source file] 
  pr115607.java  [java source file] C:\temp\ajcSandbox\ajcTest20582.tmp\pr115607.java:1::0
    import declarations  [import reference] 
    I  [annotation] C:\temp\ajcSandbox\ajcTest20582.tmp\pr115607.java:1::11
    Simple  [class] C:\temp\ajcSandbox\ajcTest20582.tmp\pr115607.java:3::25
    pr115607  [aspect] C:\temp\ajcSandbox\ajcTest20582.tmp\pr115607.java:5::52
      declare @type: Simple : @I  [declare @type] C:\temp\ajcSandbox\ajcTest20582.tmp\pr115607.java:6::66
=== END OF MODEL REPORT =========
=== RELATIONSHIPS REPORT ========= After a batch build
Hid:1:(targets=1) C:\temp\ajcSandbox\ajcTest20582.tmp\pr115607.java|3|0|25 (annotated by) C:\temp\ajcSandbox\ajcTest20582.tmp\pr115607.java|6|-1|66
Hid:2:(targets=1) C:\temp\ajcSandbox\ajcTest20582.tmp\pr115607.java|6|-1|66 (annotates) C:\temp\ajcSandbox\ajcTest20582.tmp\pr115607.java|3|0|25
=== END OF RELATIONSHIPS REPORT ==
=== Properties of the model and relationships map =====
annotation=1
FileMapSize=1
aspect=1
RelationshipMapSize=2
java source file=2
declare @type=1
import reference=1
class=1


The problem is coming from the -1 in the column i.e.

C:\temp\ajcSandbox\ajcTest20582.tmp\pr115607.java|6|-1|66

In this case the actual IProgramElement corresponding to the 'declare @type: Simple : @I' doesn't have any relationships (since it's ISourceLocation is C:\temp\ajcSandbox\ajcTest20582.tmp\pr115607.java|6|0|66)

If the test program is changed to:

---8&lt;-----
@interface I {}

class Simple {}

public aspect C {
  declare @type: Simple : @I;
                              &lt;------- Add an extra empty line here
}
---8&lt;-----

Then the entry in the relationship map becomes 

C:\temp\ajcSandbox\ajcTest20582.tmp\pr115607.java|6|0|66

which is the IProgramElement for 'declare @type: Simple : @I'.  </comment>
		<comment id="2" date="2005-11-21 10:34:00 EST" author="Helen Beeken">Following on from comment #1....

The reason adding another line to the test program works is due to the logic in EclipseSourceLocation.getColumn(). When we enter the method, if the column is currently -1 (which is it because that's the value it's created with), we get the line number, which in the above example is 6. We then check whether this value is greater than zero and less than the number of line separator positions in the file. In the reported testcase this is also 6 so we return with the column still being set to -1. In the case when we add an extra line the number of line separator positions becomes 8 so we pass through this check and set the column to be 0.

The fix is to add another check, namely if the line number is equal to the number of line separator positions then we set the column to be zero.</comment>
		<comment id="3" date="2005-11-21 10:46:59 EST" author="Helen Beeken">Created attachment 30312 [details]
testcase

Apply this patch to the tests project.

This patch contains the given testcase converted to a test for the AJ test harness.</comment>
		<comment id="4" date="2005-11-21 10:58:10 EST" author="Helen Beeken">Created attachment 30314 [details]
patch containing proposed fix

Patch containing fixed proposed in comment #2.

Apply patch to org.aspectj.ajdt.core project.</comment>
		<comment id="5" date="2005-11-21 11:33:31 EST" author="Andrew Clement">patch checked in (thanks Helen).</comment>
		<comment id="6" date="2005-11-22 03:24:18 EST" author="Andrew Clement">fix available.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="9ed75a10abaca8a6c8569ead1b74eaaadc980b07" author="aclement" date="2005-11-22 01:33:56"/>
          <file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseSourceLocation.java">
              <method name="getColumn" returnType="int" parameters=""/>
          </file>
          <file name="tests/bugs150/pr115607.java">
          </file>
          <file name="tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="113511" opendate="2005-10-24 5:39:00" fixdate="2005-11-22 03:27:29">
    <buginformation>
      <summary>LTW enhancements</summary>
      <description>Alex, here is the basic patch that is working well before you leave for the
weekend ;-) I'll let Matthew post it officially to bugzilla since it was his
idea. The earlier return from !enabled is a small addition I made that seems
to help further. It would be great to have this in HEAD so I can report
performance numbers based on it in part 2 of my article on developerworks
;-)

Hope you are enjoying your new addition!

Thanks!

Index: ClassLoaderWeavingAdaptor.java
===================================================================
RCS file:
/home/technology/org.aspectj/modules/loadtime/src/org/aspectj/weaver/loadtim
e/ClassLoaderWeavingAdaptor.java,v
retrieving revision 1.18
diff -u -r1.18 ClassLoaderWeavingAdaptor.java
--- ClassLoaderWeavingAdaptor.java      19 Oct 2005 13:11:36 -0000      1.18
+++ ClassLoaderWeavingAdaptor.java      21 Oct 2005 16:04:41 -0000
@@ -107,8 +107,13 @@

        // register the definitions
        registerDefinitions(weaver, loader);
+        if (!enabled) {
+               return;
+        }
        messageHandler = bcelWorld.getMessageHandler();

+
bcelWorld.setResolutionLoader((ClassLoader)null);//loader.getParent());
+
        // after adding aspects
        weaver.prepareForWeave();
    }
@@ -148,7 +153,11 @@
                           definitions.add(DocumentParser.parse(xml));
                       }
               }
-
+               if (definitions.isEmpty()) {
+                       enabled = false;
+                       return;
+               }
+
            // still go thru if definitions is empty since we will
configure
            // the default message handler in there
            registerOptions(weaver, loader, definitions);</description>
      <comments>
		<comment id="1" date="2005-10-24 05:48:56 EDT" author="Alexandre Vasseur">commited this one (TomcatGlassBox startup 28s -&gt; 21s)

please attach next for World sharing on java.* things</comment>
		<comment id="2" date="2005-10-24 06:31:30 EDT" author="Alexandre Vasseur">RC1</comment>
		<comment id="3" date="2005-10-25 11:47:43 EDT" author="Alexandre Vasseur">*** Bug 112817 has been marked as a duplicate of this bug. ***</comment>
		<comment id="4" date="2005-10-28 07:24:00 EDT" author="Adrian Colyer">using P2 to track things for RC1 (P3 or below will not make the cut...)</comment>
		<comment id="5" date="2005-11-14 11:47:55 EST" author="Ron Bodkin">The reflection delegates code is now requiring a special type of world, a 
ReflectionWorld, which causes my previously working optimization that used 
reflection delegates when loading bootstrap classes to fail. This will also 
cause problems with any attempt to use reflection-based proxies to optimize 
instead of using BCEL proxies...

In ReflectionBasedReferenceTypeDelegate this method fails now:
 protected ReflectionWorld getReflectionWorld() {
  return (ReflectionWorld) this.world;
 }

My changed code that supported this is in BcelWorld. I think Matthew's right 
that it is going to be better to replace BCEL delegates with reflection-based 
proxies by weaving into classloaders. However, either way, I think it's going 
to be important to support reflection-based proxies for load-time weaving.

 protected ReferenceTypeDelegate resolveDelegate(ReferenceType ty) {
        String name = ty.getName();
        JavaClass jc = null;
        if (hasResolutionLoader) {
   try {
     String asRes = name.replace
('.', '/').concat(".class");
     // will I resolve this by delegating to 
my parent?
     java.net.URL parentURL = 
parent.getResource(asRes);
     if (parentURL != null &amp;&amp; 
parentURL.equals(resolutionLoader.getResource(asRes))) {
      Class resultBoot = Class.forName
(name, false, parent);
      if (resultBoot != null) {
             return new 
ReflectionBasedReferenceTypeDelegate(resultBoot, this, ty);   
  
      }
     }
     
     Class resultBoot = Class.forName(name, 
false, null);
     if (resultBoot != null) {
            return new 
ReflectionBasedReferenceTypeDelegate(resultBoot, this, ty);   
  
     }
    
   } catch (Throwable e) {
    // proceed with normal
   }
        }</comment>
		<comment id="6" date="2005-11-21 11:01:25 EST" author="Matthew Webster">Notes from a conversation with Adrian 10/11/05

We need to reduce startup time and latent foot print. There are 3 things we can do:
1. Only weave when we need to. We have already identified the âenbledâ flag as a way to avoid using a weaver when no aop.xml is present. This could be extended to include situations where no aspects are actually declared or defined.
2. Use reflection instead of byte-code when it is safe to do so. We can introduce a new LTW World &amp; Weaver which is constructed with a class loader and uses both BCEL/byte-code as well as reflection to resolve types.
3. Replace byte-code when we are certain that a class has been successfully defined. Woven byte-code must be retained in memory because it is difficult and expensive to recreate. However once a class has been defined the byte-code can be replaced by the Class object. There are 3 levels of optimization possible:
a. Intercept successful calls to defineClass(), either though custom class loaders or weaving, and call back into the weaver.
b. Cascade define events from parent loaders for types used in resolution but not defined locally
c. Use weak references to allow the ResolvedMembers associated with a delegate to be dropped and further reduce latent footprint.

Certain environments make these optimizations difficult. It is not possible to share resources reliably between weaver worlds because the relationship between the class loaders with which they are associated cannot always be determined e.g. OSGi. Using reflection may only be safe when using the boot loader due to non-delegating web application class loaders. Byte-code must continue to be used for aspects as their meta-data is not available through reflection pre-Java 5. However they will represent a small proportion of types in the system and a hybrid delegate could be introduced used where reflection is used for Java meta-data and byte-code for AspectJ meta-data.

Many of these enhancements will be targeted post 1.5.0 therefore I suggest closing this bug as resolved because it addresses the simple enhancement to use the enabled flag. We should raise a separate enhancement for each possible optimization (I have already opened bug 114083 to cover an LTWWorld) to help stage their introduction and wider testing. Using this bug as a long running âbucketâ will just be confusing.</comment>
		<comment id="7" date="2005-11-22 03:27:29 EST" author="Adrian Colyer">Closing as per matthew's last comment. Ron :- note that the reflection world issue has been fixed under a separate bug report and your optimization should hopefully be working again now.</comment>
		<comment id="8" date="2005-11-22 04:33:46 EST" author="Ron Bodkin">I updated bug #114083 with an improved optimization. Unfortunately, it isn't so simple to integrate even just the bootstrap loader performance improvement because it results in ClassCastExceptions from code like this:

 public static ResolvedMember createResolvedMethod(Method aMethod, World inWorld) {
  ReflectionBasedResolvedMemberImpl ret = new ReflectionBasedResolvedMemberImpl(org.aspectj.weaver.Member.METHOD,
    toResolvedType(aMethod.getDeclaringClass(),(ReflectionWorld)inWorld),
    aMethod.getModifiers(),
    toResolvedType(aMethod.getReturnType(),(ReflectionWorld)inWorld),

Sample stack trace (from the debugger the method being resolved is public native int java.lang.Object.hashCode()):

java.lang.ClassCastException: org.aspectj.weaver.ltw.LTWWorld
 at org.aspectj.weaver.reflect.ReflectionBasedReferenceTypeDelegateFactory.createResolvedMethod(ReflectionBasedReferenceTypeDelegateFactory.java:83)
 at org.aspectj.weaver.reflect.ReflectionBasedReferenceTypeDelegateFactory.createResolvedMember(ReflectionBasedReferenceTypeDelegateFactory.java:73)
 at org.aspectj.weaver.reflect.ReflectionBasedReferenceTypeDelegate.getDeclaredMethods(ReflectionBasedReferenceTypeDelegate.java:232)
 at org.aspectj.weaver.ReferenceType.getDeclaredMethods(ReferenceType.java:412)
 at org.aspectj.weaver.ResolvedType.getDeclaredAdvice(ResolvedType.java:682)
 at org.aspectj.weaver.ResolvedType.getDeclaredShadowMungers(ResolvedType.java:719)
 at org.aspectj.weaver.ResolvedType.collectShadowMungers(ResolvedType.java:559)
 at org.aspectj.weaver.ResolvedType.collectCrosscuttingMembers(ResolvedType.java:488)
 at org.aspectj.weaver.CrosscuttingMembersSet.addOrReplaceAspect(CrosscuttingMembersSet.java:58)
 at org.aspectj.weaver.bcel.BcelWeaver.addLibraryAspect(BcelWeaver.java:172)
 at org.aspectj.weaver.loadtime.ClassLoaderWeavingAdaptor.registerAspects(ClassLoaderWeavingAdaptor.java:330)
 at org.aspectj.weaver.loadtime.ClassLoaderWeavingAdaptor.registerDefinitions(ClassLoaderWeavingAdaptor.java:188)
 at org.aspectj.weaver.loadtime.ClassLoaderWeavingAdaptor.initialize(ClassLoaderWeavingAdaptor.java:125)
 at org.aspectj.weaver.loadtime.Aj$ExplicitlyInitializedClassLoaderWeavingAdaptor.initialize(Aj.java:130)
 at org.aspectj.weaver.loadtime.Aj$ExplicitlyInitializedClassLoaderWeavingAdaptor.getWeavingAdaptor(Aj.java:135)
 at org.aspectj.weaver.loadtime.Aj$WeaverContainer.getWeaver(Aj.java:101)
 at org.aspectj.weaver.loadtime.Aj.preProcess(Aj.java:65)</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="70888ddc862b717646b236db2767e11a586b6157" author="avasseur" date="2005-10-24 06:48:39"/>
          <file name="loadtime/src/org/aspectj/weaver/loadtime/Aj.java">
          </file>
          <file name="loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java">
              <method name="initialize" returnType="void" parameters="ClassLoader IWeavingContext"/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="117296" opendate="2005-11-21 6:11:00" fixdate="2005-11-23 3:45:00">
    <buginformation>
      <summary>Stack overflow when using self-bounded generics</summary>
      <description>Hi,

This code is a form of "Curiously Recurring Template Pattern"

public class PropertySupport&lt;T extends PropertySupport&lt;T&gt;&gt; {

}
My AJDT project does not accept this though my JDK 5.0 ECLIPSE project does.

java.lang.StackOverflowError
at org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.fromBinding(EclipseFactory.java:197)
at org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.fromBinding(EclipseFactory.java:281)
at org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.fromBinding(EclipseFactory.java:281)

Thanks,
Mohan</description>
      <comments>
		<comment id="1" date="2005-11-21 06:12:57 EST" author="Matt Chapman">Passing over to AspectJ</comment>
		<comment id="2" date="2005-11-21 06:14:36 EST" author="Matt Chapman">*** Bug 117297 has been marked as a duplicate of this bug. ***</comment>
		<comment id="3" date="2005-11-21 06:55:53 EST" author="Andrew Clement">must fix.</comment>
		<comment id="4" date="2005-11-21 11:34:06 EST" author="Andrew Clement">taking a look right now...</comment>
		<comment id="5" date="2005-11-22 11:42:30 EST" author="Andrew Clement">fix checked in for this. waiting on build.</comment>
		<comment id="6" date="2005-11-23 03:45:41 EST" author="Andrew Clement">fix available in latest dev build of AJ.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="fa0d385efb794ade2bfd31c2f1e40f1f15927f76" author="aclement" date="2005-11-22 01:34:32"/>
          <file name="tests/bugs150/pr117296/PropertySupport.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="117189" opendate="2005-11-19 13:05:00" fixdate="2005-11-23 6:15:00">
    <buginformation>
      <summary>Contribution: reduce overhead when no aspects define</summary>
      <description>This patch to the ClassLoaderWeavingAdaptor adds two optimizations when enabled 
is false for the adaptor: it immediately returns false for accept and it also 
avoids the overhead of constructing a weaver or world.

It also contains commented out code that was letting me improve performance by 
loading reflective proxies instead of creating BCEL objects for a resolution 
loader (which is currently broken since reflective proxies now require a 
ReflectionWorld...)</description>
      <comments>
		<comment id="1" date="2005-11-19 13:06:25 EST" author="Ron Bodkin">Created attachment 30279 [details]
patch as described</comment>
		<comment id="2" date="2005-11-22 04:45:49 EST" author="Matthew Webster">Created attachment 30364 [details]
Fixed patch

Nice fix. Unfortunately it crashed and burned in the harness because the test on the "enabled" flag needs to be made in WeavingAdaptor.weaveClass(). I have made the necessary changes and all the tests now pass.</comment>
		<comment id="3" date="2005-11-23 04:02:29 EST" author="Andrew Clement">patch checked in. waiting on build.</comment>
		<comment id="4" date="2005-11-23 06:15:35 EST" author="Andrew Clement">available in latest dev build.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="a5ac5af396426f2049abe52036748bd344a7d1fe" author="aclement" date="2005-11-23 06:01:53"/>
          <file name="loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java">
              <method name="weaveClass" returnType="byte[]" parameters="String byte[]"/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="114343" opendate="2005-10-31 7:22:00" fixdate="2005-11-24 3:31:00">
    <buginformation>
      <summary>[generics] field-get problems when generic field is used.</summary>
      <description>Hi guys!

I've downloaded DEVELOPMENT-20051029200407.

There is some issue that I think is still open.
Take a look at the example:

Java Code:
----------

public class Test1 {

	Set&lt;Integer&gt; intsSet;

	public Set&lt;Integer&gt; foo() {
		return intsSet;
	}
}

public class Test2 {

	Set&lt;Double&gt; dSet;

	public Set&lt;Double&gt; foo() {
		return dSet;
	}
}

Aspect:
-------

public privileged aspect TestAspect {

    pointcut gettingMemberCollection(Test t) :
                target(t) &amp;&amp;
                get(!public Set&lt;Number+&gt; com.*.*) &amp;&amp;
                !within(TestAspect);

    Set around(Test t) : gettingMemberCollection(t)  {
        Set s =  proceed(t);
        return s;
    }
}

As you can see, I would like to replace access to member Set of something which 
derives from Number. But the problem is that around advice is stricted to 
return exact type of the member, and I'm getting the same error as earlier.

incompatible return type applying to field-get(java.util.Set 
com.mprv.secsph.Test.intsSet)

incompatible return type applying to field-get(java.util.Set 
com.mprv.secsph.Test.dSet)

In the M2 I just declared the advice this way and it worked fine.

May be now, you should allow to declare the advice this way:

    Set&lt;? extends Number&gt; around(Test t) : gettingMemberCollection(t) {
        Set s = proceed(t);
        return s;
    }

Thanks!
Misha.</description>
      <comments>
		<comment id="1" date="2005-10-31 07:38:27 EST" author="Andrew Clement">interesting.  it is a slight variation from the previous problem posted. marking
RC1.</comment>
		<comment id="2" date="2005-11-01 06:23:01 EST" author="Andrew Clement">Fix checked in.  We will allow the case where you use 'Set' as the around()
advice return value but you will get an unchecked conversion warning, if you
want to hide the conversion warning, use -Xlint to suppress it or this
annotation on the advice

@org.aspectj.lang.annotation.SuppressAjWarnings("uncheckedAdviceConversion")

Waiting on build before closing.</comment>
		<comment id="3" date="2005-11-01 06:38:00 EST" author="Misha Kantarovich">Thanks A LOT!

I'll get the build as soon as it's ready.</comment>
		<comment id="4" date="2005-11-01 08:17:48 EST" author="Andrew Clement">fix available from download page.  thanks for the clear bug report and test case.</comment>
		<comment id="5" date="2005-11-02 14:13:20 EST" author="Misha Kantarovich">Hi!

Another issue ... :)

Here is the example:

Java Code:
----------

public class Test&lt;T&gt; {

 Set&lt;T&gt; set;

 public &lt;T&gt; T[] toArray(T[] a) {
  return set.toArray(a);
 }
}

public class TTT {
 public void foo() {
  Test&lt;Integer&gt; mt = new Test&lt;Integer&gt;();
  Integer[] arr = mt.toArray(new Integer[]{});
 }
}

Aspect:
-------

public privileged aspect TestAspect {

      pointcut TestToArray(Test mt) :
                target(mt) &amp;&amp;
                !within(TestAspect);


    Object[] around(Test mt, Object[] objs) :
            TestToArray(mt) &amp;&amp;
            args(objs) &amp;&amp;
            execution(Object[] com.Test.toArray(Object[])) {

        objs = proceed(mt, objs);
        return objs;
    }
}

Errors:
-------
TestAspect.aj:19::381 incompatible return type applying to method-execution
(java.lang.Object[] com.mprv.secsph.Test.toArray(java.lang.Object[]))

Test.java:19:0::0 incompatible return type applying to method-execution
(java.lang.Object[] com.mprv.secsph.Test.toArray(java.lang.Object[]))


As you see, I'm trying to apply around advice to generic version of "toArray" 
method. I think it's impossible for now to do so ...

P.S. THANKS A LOT for your fast responses and almost immediate bug fixes!!!</comment>
		<comment id="6" date="2005-11-02 14:32:51 EST" author="Andrew Clement">sigh...</comment>
		<comment id="7" date="2005-11-02 15:35:03 EST" author="Andrew Clement">eventually we'll get to a point where you try something and it works :)  I'll
look at this bug tomorrow morning.</comment>
		<comment id="8" date="2005-11-03 03:19:45 EST" author="Misha Kantarovich">Don't misunderstand me, I've tried a lot of things in AspectJ that already 
work :) - we have developed for a 6 months with M2 version and it was great. 

Just a new generics stuff is still causing problems, but this is what 
Milestones are made for :)

I think you are doing a great job!

Thanks!</comment>
		<comment id="9" date="2005-11-03 05:31:16 EST" author="Andrew Clement">Fix for latest case committed.  I'm going to experiment a little bit with it
though - I suspect if the bounds of the type variable aren't Object then we'll
blow up...</comment>
		<comment id="10" date="2005-11-03 06:05:56 EST" author="Andrew Clement">Ok, tried my case and *it worked* (shock horror).  So i'll close this bug again
when the build comes through :)  thanks for the simple testcase each time.</comment>
		<comment id="11" date="2005-11-03 08:16:44 EST" author="Andrew Clement">*boing* it bounces closed again - build is available with latest fix in.</comment>
		<comment id="12" date="2005-11-17 03:15:10 EST" author="Misha Kantarovich">Hi,

It seems that those "field-get problems" were not fixed in aspectjweaver.jar.

When I compile my code I only get warnings for "unchecked conversion" (like 
expected). But when I've tried to enable load time weaving, I've got the same 
errors like in my first post here.

Thanks!</comment>
		<comment id="13" date="2005-11-17 03:30:16 EST" author="Andrew Clement">As it fails LTW, it probably fails binary weaving - I'll try it out.</comment>
		<comment id="14" date="2005-11-17 08:01:24 EST" author="Andrew Clement">seems to work for me either binary weaving or LTW - so I need more information,
I must be doing something different to you.  I'm using the program almost as
described in the original post on this bug report - except my Test1 and Test2
are subclasses of a simple Test type (required by the pointcut definition...)

Or are you referring to the program in comment #5?

And when you say 'enabled load time weaving' - how are you doing that? command
line? in AJDT?

I'm confused because exactly the same logic is used to weave in either case - so
I can't currently see how it can work in one case and not another, hmmm.</comment>
		<comment id="15" date="2005-11-17 08:20:17 EST" author="Misha Kantarovich">Hi,

I'm referring to the FIRST post - not comment #5.
I'm enabling LTW by passing: 
-javaagent:/my_path/aspectjweaver.jar 
to JVM.

I have the development build from November 3. When I look at the content of the 
aspectjweaver.jar I can see that most of the classes are created at Nov 3, but 
some of them are from Oct 17. May be aspectjweaver.jar is not up-to-date?

Thanks!</comment>
		<comment id="16" date="2005-11-17 08:31:34 EST" author="Misha Kantarovich">October 10, not 17</comment>
		<comment id="17" date="2005-11-17 09:11:00 EST" author="Andrew Clement">Some of the jar contents come from other jars - if those weren't rebuilt then
they'll still have the old dates in aspectjweaver.jar (e.g.
org/aspectj/apache/bcel/*).  I don't think thats a problem here as the fix was
in org/aspectj/weaver/Advice which doesn't come from a jar.

two things:

1. Can you try on a more up to date dev build?  3rd Nov is a bit old... 
although I don't know that this will help considering the fix was committed on
the 1st Nov.

2. Can I ask how you are building the parts of the application prior to load
time weaving?</comment>
		<comment id="18" date="2005-11-17 09:57:12 EST" author="Misha Kantarovich">Created attachment 30140 [details]
Test case</comment>
		<comment id="19" date="2005-11-17 10:00:07 EST" author="Misha Kantarovich">Hi Andy,

I've attached the IntelliJ Idea's project. Unfortunately bugzilla didn't allow
me to attach more than 10MB, so you will have to put aspectj libs in the
project's lib directory.

Run it. You will receive the errors. 
For build information, you can look at the build.xml

If you have questions, I'm here :)</comment>
		<comment id="20" date="2005-11-22 05:21:39 EST" author="Misha Kantarovich">Guys? What about this bug? </comment>
		<comment id="21" date="2005-11-22 05:44:25 EST" author="Andrew Clement">You havent been forgotten - I've just a mountain of bugs to get through and they are all serious.  Did you try a more recent dev build, per my comment #17.  If you could unpick your build.xml to explain how the parts of the application build prior to load time weaving, that will help me too.  I don't use intellij so haven't looked at the appended tar.gz yet.</comment>
		<comment id="22" date="2005-11-23 09:31:40 EST" author="Andrew Clement">I'm trying to recreate this problem.

I've installed an up to date AspectJ in c:\aspectj1.5.0-dev

Then I type 'ant build' then 'ant build-aspects' (the latter of which gives me warnings I can ignore about advice not matching)

I then try and run it from the resultant classes folder:

java -javaagent:c:\aspectj1.5.0-dev\lib\aspectjweaver.jar com.mprv.secsph.Test

and it just blows up with a BCException.

what am i doing wrong such that I don't see the failure you see?

this is what I get:

warning Register definition failed -- (BCException) malformed org.aspectj.weaver.PointcutDeclaration attribute java.io.EOFExceptio
n

malformed org.aspectj.weaver.PointcutDeclaration attribute java.io.EOFException

org.aspectj.weaver.BCException: malformed org.aspectj.weaver.PointcutDeclaration attribute java.io.EOFException

        at org.aspectj.weaver.AjAttribute.read(AjAttribute.java:123)
        at org.aspectj.weaver.bcel.BcelAttributes.readAjAttributes(BcelAttributes.java:59)
        at org.aspectj.weaver.bcel.BcelObjectType.unpackAspectAttributes(BcelObjectType.java:270)
        at org.aspectj.weaver.bcel.BcelObjectType.&lt;init&gt;(BcelObjectType.java:131)
        at org.aspectj.weaver.bcel.BcelWorld.makeBcelObjectType(BcelWorld.java:255)
        at org.aspectj.weaver.bcel.BcelWorld.resolveDelegate(BcelWorld.java:250)
        at org.aspectj.weaver.World.resolveToReferenceType(World.java:296)</comment>
		<comment id="23" date="2005-11-23 12:00:02 EST" author="Misha Kantarovich">Hi,

Sorry for the late response. Tonns of work ... :)
Are you still getting this exception?

I'm going to try the latest build now with this testcase.</comment>
		<comment id="24" date="2005-11-23 12:16:52 EST" author="Misha Kantarovich">Hi,

I've runned the testcase with the latest (today's Nov 23 build) build and it worked!

I've rechecked it with Nov 3 build, and it didn't work!

Did you do something? :-)

Anyway, thanks a lot!</comment>
		<comment id="25" date="2005-11-23 12:26:30 EST" author="Andrew Clement">Thanks for trying it out.  I haven't knowingly done anything to affect this test but we have fixed quite a few bugs in the last few days all over the place.  

So shall I close it again for now? :)  Feel free to reopen if you encounter this problem again.</comment>
		<comment id="26" date="2005-11-23 13:48:17 EST" author="Misha Kantarovich">Hi Andy,

Thanks for the help!

I think now this bug can be closed :-)

But there is another issue. Take a look at this post (and topic) - you will know what I'm talking about. 

http://dev.eclipse.org/mhonarc/lists/aspectj-dev/msg01869.html

My problem is that I'm working with Hibernate (3.0.5, cglib 2.1) and LTW seems to cause exceptions in generated code.

Is this issue will be solved in 1.5, or should I leave LTW for a while?

Thanks!
Misha.</comment>
		<comment id="27" date="2005-11-24 03:31:47 EST" author="Andrew Clement">Closing as fixed.

On the other comments... I remember that long debate about attributes and annotations.  We have no plans to move to annotations for everything during 1.5.0 - we're going to look at it again for 1.5.1.  Out of interest, how does it manifest as failing for you?  

The problem we were getting at in the annotation/attribute discussion was that ASM discards attributes it doesn't understand - so it discards the attributes AspectJ adds that tells the weaver what to do.  We are thinking about what the right solution is  .... maybe a plugin for ASM that would allow us to define whats allowed through ... maybe we move to annotations, but that isn't a small piece of work we can fit into 1.5.0 now.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="2483e609ca9c0d9f5c43b60c0f32d7b9cdf51adc" author="aclement" date="2005-11-01 08:22:49"/>
          <file name="tests/bugs150/pr114343/Test.java">
          </file>
          <file name="tests/bugs150/pr114343/Test1.java">
          </file>
          <file name="tests/bugs150/pr114343/Test2.java">
          </file>
          <file name="tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/Advice.java">
              <method name="match" returnType="boolean" parameters="Shadow World"/>
          </file>
          <file name="weaver/src/org/aspectj/weaver/Lint.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="117681" opendate="2005-11-23 4:27:00" fixdate="2005-11-24 4:03:00">
    <buginformation>
      <summary>VerifyError when using annotations to define inter-type annotation</summary>
      <description>Using Sun JDK1.5.0_04

Audit.java
public interface Audit {
   public String getLastUpdatedBy();
   public void   setLastUpdatedBy(String un);
}

AuditImpl.java
public class AuditImpl implements Audit {
   private String lastUpdatedBy;
   public String getLastUpdatedBy() {
       return lastUpdatedBy;
   }
   public void setLastUpdatedBy(String un) {
       lastUpdatedBy = un;
   }
}

TestAspect.java
import org.aspectj.lang.annotation.*;

Test.java
@Aspect
public class TestAspect {
      @DeclareParents("Test")
      public static Audit introduced = new AuditImpl();
}
public class Test {
    public static void main(String[] args) {
        Test t = new Test();
        Audit a = (Audit)t;
	    a.setLastUpdatedBy("username");
		System.out.println("Username ="+a.getLastUpdatedBy());
    }
}

files.lst
Audit.java
AuditImpl.java
TestAspect.java
Test.java

Compiled using the following command
d:\aspectj1.5\bin\ajc -classpath "d:\aspectj1.5\lib\aspectjrt.jar" -argfi
le files.lst -1.5

d:\aspectj1.5\bin\aj5 Test
Exception in thread "main" java.lang.VerifyError: (class: Test, method: setLastUpdatedBy signature: (Ljava/lang/String;)V) Incompatible argument to function

d:\aspectj1.5\bin\aj5 -noverify Test
Username=</description>
      <comments>
		<comment id="1" date="2005-11-23 06:36:56 EST" author="Andrew Clement">just my findings: this works fine if you use code style.

Any reason why you use 'aj5' to run the program, rather than just 'java Test' - since there is no LTW??</comment>
		<comment id="2" date="2005-11-23 09:35:18 EST" author="Andrew Clement">The code style version is 

public aspect TestAspect {
  declare parents: Test extends AuditImpl;
}

After compilation, Test looks like this:

public class Test extends AuditImpl{
    public Test();
    public static void main(java.lang.String[]);
}

If I compile the annotation style, then Test looks like this:

public class Test extends java.lang.Object implements Audit{
    public Test();
    public static void main(java.lang.String[]);
    public java.lang.String getLastUpdatedBy();
    public void setLastUpdatedBy(java.lang.String);
}

Looking in 'setLastUpdatedBy' we can see:

public void setLastUpdatedBy(java.lang.String);
  Code:
   Stack=2, Locals=2, Args_size=2
   0:   getstatic       #64; //Field TestAspect.introduced:LAudit;
   3:   aload_0
   4:   invokeinterface #25,  2; //InterfaceMethod Audit.setLastUpdatedBy:
                                   (Ljava/lang/String;)V
   9:   return

This is not a static method so aload_0 gets 'this' and attempts to pass it as a String parameter to setLastUpdatedBy().  BANG.

The solution is to know whether you are dealing with static methods - and skip 'this' if necessary.  Fix checked in, waiting on build.</comment>
		<comment id="3" date="2005-11-23 09:51:17 EST" author="Andrew Clement">fix available in AspectJ dev build.</comment>
		<comment id="4" date="2005-11-24 04:03:22 EST" author="Ramana Gundapuneni">As 'Java -noverify Test' is resulting in jvm crash, I tried with 'aj5'.

(In reply to comment #1)
&gt; just my findings: this works fine if you use code style.
&gt; Any reason why you use 'aj5' to run the program, rather than just 'java Test' -
&gt; since there is no LTW??</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="11ab99f1c46007b084873d1050da2f9e78e43c82" author="aclement" date="2005-11-23 09:54:02"/>
          <file name="tests/bugs150/pr117681/Audit.java">
          </file>
          <file name="tests/bugs150/pr117681/AuditImpl.java">
          </file>
          <file name="tests/bugs150/pr117681/MoodIndicator.java">
          </file>
          <file name="tests/bugs150/pr117681/Test.java">
          </file>
          <file name="tests/bugs150/pr117681/TestAspect.java">
          </file>
          <file name="tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java">
              <method name="mungeMethodDelegate" returnType="boolean" parameters="BcelClassWeaver MethodDelegateTypeMunger"/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="115251" opendate="2005-11-6 21:36:00" fixdate="2005-11-25 14:19:00">
    <buginformation>
      <summary>BCException when compiling incrementally on constructor-call shadow</summary>
      <description>I get the same BCException when I build incrementally but not after cleaning the
project.  The code is correct (I think) and runs fine after clean-and-build.

AJDT Build id: 20051104134042
AspectJ version: 1.5.0.200510241400

(Sorry if this is another manifestation of a different bug or an AJDT bug.)

---------------------------------------------------------------
----------------- Singleton.java
package com.isberg.articles.aop7.patterns;

/**
 * CODE article singleton variant without eager/lazy
 */
public abstract aspect Singleton&lt;Target&gt; pertypewithin(Target) {
	private final Object lock = new Object();
	private Target singleton;

	/**
	 * Subaspects define this.  All join points must return type Target.
	 */
	abstract protected pointcut creation();

	pointcut creating() : cflow(within(Singleton+) &amp;&amp; adviceexecution());
	
    Target around() : creation() &amp;&amp; !creating(){
    	synchronized(lock) {
            if (singleton == null) {
                singleton = proceed();
            }
            return singleton;
    	}
    }
}

----------------- SingletonTest.java
package com.isberg.articles.aop7.patterns;

import junit.framework.TestCase;

public class SingletonTest extends TestCase {
	public void testSingleton() throws Exception {
		C[] cs = {C.create(), new C(), C.create()};
		for (int i = 1; i &lt; cs.length; i++) {
			assertEquals(cs[0], cs[i]);
		}
	}
	static class C {
		static C create() {return new C();}
		C() {}		
	}
	static aspect A extends Singleton&lt;C&gt; {
		protected pointcut creation() : execution(static C C.create())
			|| call(C.new());
	}
}
---------------------------------------------------------------

trouble in:public class com.isberg.articles.aop7.patterns.SingletonTest extends
junit.framework.TestCase:
public void &lt;init&gt;():
ALOAD_0     // com.isberg.articles.aop7.patterns.SingletonTest this   (line 5)
INVOKESPECIAL junit.framework.TestCase.&lt;init&gt; ()V
constructor-execution(void com.isberg.articles.aop7.patterns.SingletonTest.&lt;init&gt;())
|               RETURN
constructor-execution(void com.isberg.articles.aop7.patterns.SingletonTest.&lt;init&gt;())
end public void &lt;init&gt;()
public void testSingleton() throws java.lang.Exception   
org.aspectj.weaver.MethodDeclarationLineNumber: 6:142
:
method-execution(void
com.isberg.articles.aop7.patterns.SingletonTest.testSingleton())
|               ICONST_3   (line 7)
|               ANEWARRAY com.isberg.articles.aop7.patterns.SingletonTest$C
|               DUP
|               ICONST_0
| method-call(com.isberg.articles.aop7.patterns.SingletonTest$C
com.isberg.articles.aop7.patterns.SingletonTest$C.create())
| |             INVOKESTATIC
com.isberg.articles.aop7.patterns.SingletonTest$C.create
()Lcom/isberg/articles/aop7/patterns/SingletonTest$C;
| method-call(com.isberg.articles.aop7.patterns.SingletonTest$C
com.isberg.articles.aop7.patterns.SingletonTest$C.create())
|               AASTORE
|               DUP
|               ICONST_1
| constructor-call(void com.isberg.articles.aop7.patterns.SingletonTest$C.&lt;init&gt;())
| |             NEW com.isberg.articles.aop7.patterns.SingletonTest$C
| |             DUP
| |             INVOKESPECIAL
com.isberg.articles.aop7.patterns.SingletonTest$C.&lt;init&gt; ()V
| constructor-call(void com.isberg.articles.aop7.patterns.SingletonTest$C.&lt;init&gt;())
|               AASTORE
|               DUP
|               ICONST_2
| method-call(com.isberg.articles.aop7.patterns.SingletonTest$C
com.isberg.articles.aop7.patterns.SingletonTest$C.create())
| |             INVOKESTATIC
com.isberg.articles.aop7.patterns.SingletonTest$C.create
()Lcom/isberg/articles/aop7/patterns/SingletonTest$C;
| method-call(com.isberg.articles.aop7.patterns.SingletonTest$C
com.isberg.articles.aop7.patterns.SingletonTest$C.create())
|               AASTORE
|               ASTORE_1
|               ICONST_1   (line 8)
|               ISTORE_2
|               GOTO L1
|           L0: ALOAD_1     //
com.isberg.articles.aop7.patterns.SingletonTest$C[] cs   (line 9)
|               ICONST_0
|               AALOAD
|               ALOAD_1     //
com.isberg.articles.aop7.patterns.SingletonTest$C[] cs
|               ILOAD_2     // int i
|               AALOAD
| method-call(void junit.framework.Assert.assertEquals(java.lang.Object,
java.lang.Object))
| |             INVOKESTATIC
com.isberg.articles.aop7.patterns.SingletonTest.assertEquals
(Ljava/lang/Object;Ljava/lang/Object;)V
| method-call(void junit.framework.Assert.assertEquals(java.lang.Object,
java.lang.Object))
|               IINC 2 1     // int i   (line 8)
|           L1: ILOAD_2     // int i
|               ALOAD_1     //
com.isberg.articles.aop7.patterns.SingletonTest$C[] cs
|               ARRAYLENGTH
|               IF_ICMPLT L0
|               RETURN   (line 11)
method-execution(void
com.isberg.articles.aop7.patterns.SingletonTest.testSingleton())
end public void testSingleton() throws java.lang.Exception
end public class com.isberg.articles.aop7.patterns.SingletonTest
when implementing on shadow constructor-call(void
com.isberg.articles.aop7.patterns.SingletonTest$C.&lt;init&gt;())
when weaving type com.isberg.articles.aop7.patterns.SingletonTest
when weaving classes
when weaving
when incrementally building
BuildConfig[c:\home\ws\main-31\.metadata\.plugins\org.eclipse.ajdt.core\devworks-fall.generated.lst]
#Files=90


org.aspectj.weaver.BCException: Class
com.isberg.articles.aop7.patterns.Singleton does not have a method
ajc$around$com_isberg_articles_aop7_patterns_Singleton$1$51e13820 with signature
(Lorg/aspectj/runtime/internal/AroundClosure;)Ljava/lang/Object;
when implementing on shadow constructor-call(void
com.isberg.articles.aop7.patterns.SingletonTest$C.&lt;init&gt;())
when weaving type com.isberg.articles.aop7.patterns.SingletonTest
when weaving classes
when weaving
when incrementally building
BuildConfig[c:\home\ws\main-31\.metadata\.plugins\org.eclipse.ajdt.core\devworks-fall.generated.lst]
#Files=90
at org.aspectj.weaver.bcel.LazyClassGen.getLazyMethodGen(LazyClassGen.java:1161)
at org.aspectj.weaver.bcel.LazyClassGen.getLazyMethodGen(LazyClassGen.java:1146)
at org.aspectj.weaver.bcel.BcelShadow.weaveAroundInline(BcelShadow.java:1973)
at org.aspectj.weaver.bcel.BcelAdvice.implementOn(BcelAdvice.java:211)
at org.aspectj.weaver.Shadow.implementMungers(Shadow.java:514)
at org.aspectj.weaver.Shadow.implement(Shadow.java:391)
at org.aspectj.weaver.bcel.BcelClassWeaver.implement(BcelClassWeaver.java:1782)
at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:394)
at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:98)
at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1478)
at org.aspectj.weaver.bcel.BcelWeaver.weaveWithoutDump(BcelWeaver.java:1443)
at org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify(BcelWeaver.java:1217)
at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1039)
at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave(AjCompilerAdapter.java:300)
at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling(AjCompilerAdapter.java:178)
at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$afterReturning$org_aspectj_ajdt_internal_compiler_CompilerAdapter$2$f9cc9ca0(CompilerAdapter.aj:70)
at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:367)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:759)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:249)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.incrementalBuild(AjBuildManager.java:158)
at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:117)
at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)</description>
      <comments>
		<comment id="1" date="2005-11-07 03:05:27 EST" author="Andrew Clement">I better take a look.</comment>
		<comment id="2" date="2005-11-22 08:21:13 EST" author="Helen Beeken">Created attachment 30372 [details]
testcase patch

Patch containing failing testcase - apply to the tests project.

The testcase contains the line:

 AjdeInteractionTestbed.VERBOSE=true;

to be used for debugging, but should probably be removed when integrated.

The key things to recreating this bug seemed to be the around advice returning a 'Target' which is the same as used within the aspect declaration.</comment>
		<comment id="3" date="2005-11-22 08:23:51 EST" author="Helen Beeken">Created attachment 30373 [details]
NPE fix patch

Apply to the org.aspectj.ajdt.core project.

When you run the test program attached above an NPE occurs before the reported BCException (this has been introduced since the bug was raised since I've run the test program within a workspace containing an old version of aspectj and no NPE was seen). This patch contains a fix for that NPE. With this fix, the previously attached testcase produces the reported BCException.</comment>
		<comment id="4" date="2005-11-25 04:55:56 EST" author="Adrian Colyer">This bug is proving to be really hard to track down - here's what I've learnt so far:

"The case of the zombie shadow munger"
==========================

We start off with a full build, and aspect A1 has around advice in it. This cause an around advice shadow munger to be created in the crosscutting member set. 

We change A1 (to delete the around advice) and do an incremental build. This causes us to source compile only A1.java, but to weave everything. The first bug lurking here is that A1 is an abstract aspect extended by A. When we addOrReplaceAspect in the CrosscuttingMembersSet, if the aspect is abstract we also need to refresh the crosscutting members of any subaspects of it we have defined - because crosscutting members are aggregated in concrete subaspects from abstract super aspects. This part of the fix is in and working. When we do this, the around advice shadow munger is no longer present (correct).

We come back to the incremental compilation loop, and the references tell us that we need to recompile C1.java too (because in that file is a subtype of A1 that we just rebuilt). So we do an incremental compile of C1.java, which triggers a full weave again (C1.java contains the definition of concrete aspect A). But this time, when we get all of the shadow mungers for the crosscutting members set, the around advice shadow munger has come back from the dead! In particular, when we ask the reference type for A1 for it shadowMungers, it returns the around advice munger.

Well, it's all downhill from here. We do matching, see that the around advice munger matches, and try to inline a call to the advice method that the munger specifies - but that method doesn't exist anymore, and bang!. 

So the question is.... why does the around shadowMunger come back from the dead, having correctly disappeared in the first incremental compilation round? ??</comment>
		<comment id="5" date="2005-11-25 06:46:58 EST" author="Adrian Colyer">"The case of the zombie shadow munger, part 2"

OK, there were two more layered problems here. Firstly, generic reference types need to remember all of their derivative types, so that if the delegate of the generic type is updated, the delegates of the derivative (raw and parameterized) types get updated too. This is mostly an issue during incremental compilation when delegates get updated after an increment.

Second issue was that EclipseFactory was sometimes creating new Reference types for generic types when the world already had one. This leads to multiple versions kicking around and trouble later on.

Both of these are now fixed, and this test case passes, but several other tests in the suite are broken so we're not out of the woods yet...</comment>
		<comment id="6" date="2005-11-25 11:20:24 EST" author="Adrian Colyer">The final hurdle.

It turns out that cflow is a bit of a mess. The change to add-or-replace sub-aspects when adding-or-replacing an abstract super aspect breaks an assumption in CflowPointcut.concretize1 that adds special shadow and type mungers to the crosscutting member set of a concrete aspect. If you ask for the crosscutting member set more than once, you don't get the members second time round. After several more hours looking at the options, I backed out this part of the change. It should probably be re-enabled post 1.5.0 when we can reconsider the cflow design at our leisure. Breaking backwards compatibility with 1.2.1 is one of the issues I ran into. The part of the change that is backed out is actually not necessary to make this case pass :- the order of adding aspects to the member set seems to nearly always work out so that my safeguard was just that. I'd just like to be 100% certain about it rather than saying "it seems to (nearly?) always work out". ...!</comment>
		<comment id="7" date="2005-11-25 12:40:42 EST" author="Adrian Colyer">fixes checked into cvs - first green bar in a long time it feels like! waiting on build.....</comment>
		<comment id="8" date="2005-11-25 14:19:53 EST" author="Adrian Colyer">fix available</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="e05df7e5ac7fb91031d8f98d4b93e361918e4b56" author="aclement" date="2005-11-23 09:34:51"/>
          <file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectDeclaration.java">
              <method name="lookupPerClauseKind" returnType="PerClause.Kind" parameters="ReferenceBinding"/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="116949" opendate="2005-11-17 17:09:00" fixdate="2005-11-25 18:49:00">
    <buginformation>
      <summary>[waitingOnAJDTdrop]Exception thrown from AspectJ compiler</summary>
      <description>java.lang.ClassCastException
at org.aspectj.weaver.bcel.BcelClassWeaver.checkForOverride(BcelClassWeaver.java:607)
at org.aspectj.weaver.bcel.BcelClassWeaver.calculateAnyRequiredBridgeMethods(BcelClassWeaver.java:676)
at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1537)
at org.aspectj.weaver.bcel.BcelWeaver.weaveWithoutDump(BcelWeaver.java:1485)
at org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify(BcelWeaver.java:1266)
at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1088)
at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave(AjCompilerAdapter.java:300)
at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling(AjCompilerAdapter.java:178)
at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$afterReturning$org_aspectj_ajdt_internal_compiler_CompilerAdapter$2$f9cc9ca0(CompilerAdapter.aj:70)
at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:367)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:809)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:254)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.incrementalBuild(AjBuildManager.java:163)
at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:117)
at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)

trouble in: 
public class ts.simul.client.AbstractClient$OptionSetter extends 
ts.util.CmdLineProgram$OptionSetterBase:
  final ts.simul.client.AbstractClient this$0
  private static final org.aspectj.lang.JoinPoint$StaticPart ajc$tjp_0
  public void &lt;init&gt;(ts.simul.client.AbstractClient)    
org.aspectj.weaver.MethodDeclarationLineNumber: 59:1411
:
                    ALOAD_0     // ts.simul.client.AbstractClient$OptionSetter this   (line 60)
                    ALOAD_1
                    PUTFIELD ts.simul.client.AbstractClient$OptionSetter.this$0 Lts/simul/client/AbstractClient;
                    ALOAD_0     // ts.simul.client.AbstractClient$OptionSetter this   (line 59)
                    ALOAD_1
                    INVOKESPECIAL 
ts.util.CmdLineProgram$OptionSetterBase.&lt;init&gt; (Lts/util/CmdLineProgram;)V
    constructor-execution(void 
ts.simul.client.AbstractClient$OptionSetter.&lt;init&gt;
(ts.simul.client.AbstractClient))
    |               RETURN
    constructor-execution(void 
ts.simul.client.AbstractClient$OptionSetter.&lt;init&gt;
(ts.simul.client.AbstractClient))
  end public void &lt;init&gt;(ts.simul.client.AbstractClient)

  public boolean setOption_file(String) throws 
ts.util.IllegalProgramArgumentException    
org.aspectj.weaver.MethodDeclarationLineNumber: 62:1469
:
    method-execution(boolean 
ts.simul.client.AbstractClient$OptionSetter.setOption_file(java.lang.String))
    |               ALOAD_1     // java.lang.String optParam   (line 65)
    | method-call(int java.lang.String.length())
    | |             INVOKEVIRTUAL java.lang.String.length ()I
    | method-call(int java.lang.String.length())
    |               IFLE L1
    |               ALOAD_0     // ts.simul.client.AbstractClient$OptionSetter 
this   (line 66)
    |               GETFIELD ts.simul.client.AbstractClient$OptionSetter.this$0 
Lts/simul/client/AbstractClient;
    |               ALOAD_1     // java.lang.String optParam
    |               PUTFIELD ts.simul.client.AbstractClient.fileName 
Ljava/lang/String;
    |               NEW java.io.File   (line 67)
    |               DUP
    |               ALOAD_0     // ts.simul.client.AbstractClient$OptionSetter 
this
    |               GETFIELD ts.simul.client.AbstractClient$OptionSetter.this$0 
Lts/simul/client/AbstractClient;
    |               GETFIELD ts.simul.client.AbstractClient.fileName 
Ljava/lang/String;
    | constructor-call(void java.io.File.&lt;init&gt;(java.lang.String))
    | |             INVOKESPECIAL java.io.File.&lt;init&gt; (Ljava/lang/String;)V
    | constructor-call(void java.io.File.&lt;init&gt;(java.lang.String))
    |               ASTORE_2
    |               ALOAD_2     // java.io.File file   (line 68)
    | method-call(boolean java.io.File.exists())
    | |             INVOKEVIRTUAL java.io.File.exists ()Z
    | method-call(boolean java.io.File.exists())
    |               IFNE L0
    |               NEW ts.util.IllegalProgramArgumentException   (line 69)
    |               DUP
    |               NEW java.lang.StringBuilder
    |               DUP
    |               LDC "Cannot find file: ["
    | constructor-call(void java.lang.StringBuilder.&lt;init&gt;(java.lang.String))
    | |             INVOKESPECIAL java.lang.StringBuilder.&lt;init&gt; 
(Ljava/lang/String;)V
    | constructor-call(void java.lang.StringBuilder.&lt;init&gt;(java.lang.String))
    |               ALOAD_0     // ts.simul.client.AbstractClient$OptionSetter 
this
    |               GETFIELD ts.simul.client.AbstractClient$OptionSetter.this$0 
Lts/simul/client/AbstractClient;
    |               GETFIELD ts.simul.client.AbstractClient.fileName 
Ljava/lang/String;
    | method-call(java.lang.StringBuilder java.lang.StringBuilder.append
(java.lang.String))
    | |             INVOKEVIRTUAL java.lang.StringBuilder.append 
(Ljava/lang/String;)Ljava/lang/StringBuilder;
    | method-call(java.lang.StringBuilder java.lang.StringBuilder.append
(java.lang.String))
    |               LDC "]"
    | method-call(java.lang.StringBuilder java.lang.StringBuilder.append
(java.lang.String))
    | |             INVOKEVIRTUAL java.lang.StringBuilder.append 
(Ljava/lang/String;)Ljava/lang/StringBuilder;
    | method-call(java.lang.StringBuilder java.lang.StringBuilder.append
(java.lang.String))
    | method-call(java.lang.String java.lang.StringBuilder.toString())
    | |             INVOKEVIRTUAL java.lang.StringBuilder.toString ()
Ljava/lang/String;
    | method-call(java.lang.String java.lang.StringBuilder.toString())
    | constructor-call(void ts.util.IllegalProgramArgumentException.&lt;init&gt;
(java.lang.String))
    | |             INVOKESPECIAL 
ts.util.IllegalProgramArgumentException.&lt;init&gt; (Ljava/lang/String;)V
    | constructor-call(void ts.util.IllegalProgramArgumentException.&lt;init&gt;
(java.lang.String))
    |               ATHROW
    |           L0: ICONST_1   (line 70)
    |               IRETURN
    |           L1: ICONST_0   (line 73)
    |               IRETURN
    method-execution(boolean 
ts.simul.client.AbstractClient$OptionSetter.setOption_file(java.lang.String))
  end public boolean setOption_file(String) throws 
ts.util.IllegalProgramArgumentException

  public boolean setOption_class(String) throws 
ts.util.IllegalProgramArgumentException    
org.aspectj.weaver.MethodDeclarationLineNumber: 76:1971
:
    method-execution(boolean 
ts.simul.client.AbstractClient$OptionSetter.setOption_class(java.lang.String))
    |               ALOAD_1     // java.lang.String optParam   (line 79)
    | method-call(int java.lang.String.length())
    | |             INVOKEVIRTUAL java.lang.String.length ()I
    | method-call(int java.lang.String.length())
    |               IFLE L1
    |               ALOAD_0     // ts.simul.client.AbstractClient$OptionSetter 
this   (line 80)
    |               GETFIELD ts.simul.client.AbstractClient$OptionSetter.this$0 
Lts/simul/client/AbstractClient;
    |               ALOAD_1     // java.lang.String optParam
    |               PUTFIELD ts.simul.client.AbstractClient.className 
Ljava/lang/String;
    | catch ts.simul.SimulationException -&gt; E0
    | |             ALOAD_0     // ts.simul.client.AbstractClient$OptionSetter 
this   (line 82)
    | |             GETFIELD ts.simul.client.AbstractClient$OptionSetter.this$0 
Lts/simul/client/AbstractClient;
    | |             ALOAD_0     // ts.simul.client.AbstractClient$OptionSetter 
this
    | |             GETFIELD ts.simul.client.AbstractClient$OptionSetter.this$0 
Lts/simul/client/AbstractClient;
    | |             GETFIELD ts.simul.client.AbstractClient.className 
Ljava/lang/String;
    | | method-call(java.lang.Class ts.simul.SceneFactory.getSceneClass
(java.lang.String))
    | | |           INVOKESTATIC ts.simul.SceneFactory.getSceneClass 
(Ljava/lang/String;)Ljava/lang/Class;
    | | method-call(java.lang.Class ts.simul.SceneFactory.getSceneClass
(java.lang.String))
    | |             PUTFIELD ts.simul.client.AbstractClient.sceneClass 
Ljava/lang/Class;
    | |             ALOAD_0     // ts.simul.client.AbstractClient$OptionSetter 
this   (line 83)
    | |             GETFIELD ts.simul.client.AbstractClient$OptionSetter.this$0 
Lts/simul/client/AbstractClient;
    | | method-call(void ts.simul.client.AbstractClient.setBeanInfoSearchPath())
    | | |           INVOKESTATIC ts.simul.Architecture.aspectOf ()
Lts/simul/Architecture;
    | | |           GETSTATIC 
ts.simul.client.AbstractClient$OptionSetter.ajc$tjp_0 
Lorg/aspectj/lang/JoinPoint$StaticPart;
    | | |           INVOKEVIRTUAL 
ts.simul.Architecture.ajc$before$ts_simul_Architecture$1$ae285a4d 
(Lorg/aspectj/lang/JoinPoint$StaticPart;)V
    | | |           INVOKEVIRTUAL 
ts.simul.client.AbstractClient.setBeanInfoSearchPath ()V
    | | method-call(void ts.simul.client.AbstractClient.setBeanInfoSearchPath())
    | |             GOTO L0
    | catch ts.simul.SimulationException -&gt; E0
    |           E0: ASTORE_2   (line 85)
    |               NEW ts.util.IllegalProgramArgumentException   (line 86)
    |               DUP
    |               ALOAD_2     // ts.simul.SimulationException e
    | method-call(java.lang.String ts.simul.SimulationException.getMessage())
    | |             INVOKEVIRTUAL ts.simul.SimulationException.getMessage ()
Ljava/lang/String;
    | method-call(java.lang.String ts.simul.SimulationException.getMessage())
    | constructor-call(void ts.util.IllegalProgramArgumentException.&lt;init&gt;
(java.lang.String))
    | |             INVOKESPECIAL 
ts.util.IllegalProgramArgumentException.&lt;init&gt; (Ljava/lang/String;)V
    | constructor-call(void ts.util.IllegalProgramArgumentException.&lt;init&gt;
(java.lang.String))
    |               ATHROW
    |           L0: ICONST_1   (line 88)
    |               IRETURN
    |           L1: ICONST_0   (line 91)
    |               IRETURN
    method-execution(boolean 
ts.simul.client.AbstractClient$OptionSetter.setOption_class(java.lang.String))
  end public boolean setOption_class(String) throws 
ts.util.IllegalProgramArgumentException

  public boolean setOption_name(String)    
org.aspectj.weaver.MethodDeclarationLineNumber: 94:2593
:
    method-execution(boolean 
ts.simul.client.AbstractClient$OptionSetter.setOption_name(java.lang.String))
    |               ALOAD_0     // ts.simul.client.AbstractClient$OptionSetter 
this   (line 96)
    |               GETFIELD ts.simul.client.AbstractClient$OptionSetter.this$0 
Lts/simul/client/AbstractClient;
    |               ALOAD_1     // java.lang.String optParam
    |               PUTFIELD ts.simul.client.AbstractClient.sceneName 
Ljava/lang/String;
    |               ICONST_1   (line 97)
    |               IRETURN
    method-execution(boolean 
ts.simul.client.AbstractClient$OptionSetter.setOption_name(java.lang.String))
  end public boolean setOption_name(String)

  public boolean setOption_actors(String)    
org.aspectj.weaver.MethodDeclarationLineNumber: 100:2739
:
    method-execution(boolean 
ts.simul.client.AbstractClient$OptionSetter.setOption_actors(java.lang.String))
    | catch java.lang.NumberFormatException -&gt; E0
    | |             ALOAD_1     // java.lang.String optParam   (line 103)
    | | method-call(int java.lang.Integer.parseInt(java.lang.String))
    | | |           INVOKESTATIC java.lang.Integer.parseInt (Ljava/lang/String;)
I
    | | method-call(int java.lang.Integer.parseInt(java.lang.String))
    | |             ISTORE_2
    | |             GOTO L0
    | catch java.lang.NumberFormatException -&gt; E0
    |           E0: ASTORE_2     // int n   (line 105)
    |               ICONST_0   (line 106)
    |               IRETURN
    |           L0: ICONST_1   (line 108)
    |               IRETURN
    method-execution(boolean 
ts.simul.client.AbstractClient$OptionSetter.setOption_actors(java.lang.String))
  end public boolean setOption_actors(String)

end public class ts.simul.client.AbstractClient$OptionSetter

when weaving type ts.simul.client.AbstractClient$OptionSetter
when weaving classes 
when weaving 
when incrementally building BuildConfig
[c:\Projects\eclipse\.metadata\.plugins\org.eclipse.ajdt.core\TS.generated.lst] 
#Files=79</description>
      <comments>
		<comment id="1" date="2005-11-18 04:17:26 EST" author="Andrew Clement">Seems the code is expecting a BcelTypeMunger but is encountering an
EclipseTypeMunger.  I've put in a guard - this will fix the ClassCastException.
 Fix checked in - waiting on build.</comment>
		<comment id="2" date="2005-11-18 07:10:24 EST" author="Andrew Clement">fix available in latest AspectJ dev build - it will be in AJDT early next week.</comment>
		<comment id="3" date="2005-11-22 18:46:42 EST" author="Tadeusz Skrzyszowski">It seems that the new version dated 20051122132809 didn't fix the problem. After having installed the new version (and after having restarted Eclipse) I got exactly the same behavior (exception). 
Or was the fix not yet included in this AJDT build ?

I tried to reproduce the problem on a simple example, but with no effect. The original code where the problem was observed is a part of a relatively large system, so I did not send it. I'm going to continue trying to find a simplified example. </comment>
		<comment id="4" date="2005-11-22 18:59:39 EST" author="Tadeusz Skrzyszowski">Important observation: it happens only when incremental compilation is turned on. </comment>
		<comment id="5" date="2005-11-23 03:34:56 EST" author="Andrew Clement">The fix is not in AJDT yet.</comment>
		<comment id="6" date="2005-11-24 05:35:34 EST" author="Andrew Clement">Fix is in the latest 1.3 version of AJDT.</comment>
		<comment id="7" date="2005-11-25 18:49:43 EST" author="Tadeusz Skrzyszowski">Great, with this version (1.3.0.20051125115230) it is fixed !</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="dd9a9b284ab44b14ea3735d2663e85afb861220b" author="aclement" date="2005-11-18 06:17:56"/>
          <file name="weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java">
              <method name="checkForOverride" returnType="ResolvedMember" parameters="ResolvedType String String String int String UnresolvedType[]"/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="112736" opendate="2005-10-15 14:15:00" fixdate="2005-11-29 5:18:00">
    <buginformation>
      <summary>Bogus Compiler Warnings when Converting file extensions</summary>
      <description>If you convert file extensions between .aj and .java, the compiler doesn't 
properly clear its symbol table, generating bogus warnings about conflicting 
inter-type declarations. It should avoid this. Work around: full rebuild.

See screenshot for an example. After recompiling the "errors" go away...</description>
      <comments>
		<comment id="1" date="2005-10-15 14:16:52 EDT" author="Ron Bodkin">Created attachment 28317 [details]
example</comment>
		<comment id="2" date="2005-11-07 09:40:24 EST" author="Andrew Clement">Not sure what you renamed here Ron - was it the aspect containing the ITD that
appears in the error message or some other aspect? (tracing?)

Changes to aspects should cause a full build - I'm confused as to why renaming a
file isn't causing this to happen.  It is possible we don't do a full build on
adding a new aspect (just a full weave - I cant remember) - so maybe we aren't
noticing the delete that proceeds the adding...</comment>
		<comment id="3" date="2005-11-22 11:40:01 EST" author="Helen Beeken">Created attachment 30390 [details]
testcase patch

Patch containing failing testcase.

Apply to the tests project.</comment>
		<comment id="4" date="2005-11-25 09:55:59 EST" author="Andrew Clement">testcase checked in (commented out).  </comment>
		<comment id="5" date="2005-11-28 07:59:20 EST" author="Andrew Clement">fix checked in.  Basically does better analysis of changes between compiles: 
you change an aspect == you get a full build

the compiler is not aware that a 'rename' has occurred, it sees a file deletion and a file addition.  We detect a file has been deleted, check it - discover it contained an aspect previously and then full build.</comment>
		<comment id="6" date="2005-11-29 05:18:57 EST" author="Andrew Clement">fix available.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="361757b0fcfc845efaa75ed062e9a6178d050764" author="aclement" date="2005-11-25 11:56:21"/>
          <file name="tests/multiIncremental/PR112736/base/src/pack/A.java">
          </file>
          <file name="tests/multiIncremental/PR112736/base/src/pack/C.java">
          </file>
          <file name="tests/multiIncremental/PR93310_1/base/src/pack/C1.java">
          </file>
          <file name="tests/multiIncremental/PR93310_1/base/src/pack/C2.java">
          </file>
          <file name="tests/multiIncremental/PR93310_2/base/src/pack/C1.java">
          </file>
          <file name="tests/multiIncremental/PR93310_2/base/src/pack/C2.java">
          </file>
          <file name="tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="118192" opendate="2005-11-28 2:07:00" fixdate="2005-11-29 5:18:00">
    <buginformation>
      <summary>Missing superclass for java.io.Serializable in reflection 1.5 delegate impl</summary>
      <description>See attached patch for a failing junit test case.</description>
      <comments>
		<comment id="1" date="2005-11-28 02:10:43 EST" author="Ron Bodkin">Created attachment 30689 [details]
adds a failing test case to TestJava5ReflectionBasedReferenceTypeDelegate</comment>
		<comment id="2" date="2005-11-28 02:16:14 EST" author="Ron Bodkin">This test fails on the Java 1.5 reflection delegate impl, since it returns a missing type (which is clearly wrong). 

If you move this test to the Java reflection delegate impl, it throws an NPE, since that implementation has the superclass of java.io.Serializable as null. The javadoc comment in ResolvedType.getSuperclass doesn't specify what the superclass of a top-level interface should be. 

If null is the right superclass here, then the test should just assertNull :-)</comment>
		<comment id="3" date="2005-11-28 02:33:55 EST" author="Ron Bodkin">Created attachment 30691 [details]
Put tests for null superclass into base reflection delegate test not just the 1.5 tests

Adds more tests and moves tests to base test case. Supersedes previous test case.</comment>
		<comment id="4" date="2005-11-28 02:35:46 EST" author="Ron Bodkin">Created attachment 30692 [details]
fixes the problem: checks for any class with a null superclass, even an interface</comment>
		<comment id="5" date="2005-11-28 02:45:21 EST" author="Ron Bodkin">It looks like the superclass behavior is inconsistent between Java's notion of the superclass and BCEL's. This test fails:

 public void testGenericInterfaceSuperclass() {
  BcelWorld world = new BcelWorld();
  world.setBehaveInJava5Way(true);
  UnresolvedType javaUtilMap = UnresolvedType.forName("java.util.Map");
  ResolvedType rtx = world.resolve(javaUtilMap);
  assertNull(rtx.getSuperclass());  
 }

The rtx.getSuperclass() result is Object...

I discovered this because my patch caused an NPE in ReferenceType.getSuperclass() ...</comment>
		<comment id="6" date="2005-11-28 10:55:26 EST" author="Andrew Clement">The reflection based stuff is intended to be a drop in replacement for the bcel stuff.  Therefore we need the reflection stuff to return the same as bcel.  So, I've modified the reflection code to return a superclass of Object rather than NULL - except for primitive types where it is null (bcel returns null in these cases too).  I modified Rons supplied test programs to verify consistency across the bcel world and reflection world.

fixes checked in.</comment>
		<comment id="7" date="2005-11-28 12:12:21 EST" author="Ron Bodkin">Created attachment 30714 [details]
Fixes pre-1.5 reflection delegate to be consistent by returning Object as the superclass of an interface.

This works for the 1.5 implementation but the pre-1.5 code was still breaking. This updated patch fixes the pre-1.5 implementation</comment>
		<comment id="8" date="2005-11-28 12:14:23 EST" author="Ron Bodkin">Created attachment 30715 [details]
Patch to remove the 1.5-specific test from the weaver project

This test relies on Java 5 and was breaking on the earlier Java versions.</comment>
		<comment id="9" date="2005-11-28 12:16:40 EST" author="Ron Bodkin">Created attachment 30716 [details]
Patch to add the 1.5-specific test to the weaver5 project test case instead

These 3 patches fix the pre-1.5 reflection implementation and move tests around to work properly for both pre-1.5 and 1.5.</comment>
		<comment id="10" date="2005-11-28 12:43:54 EST" author="Andrew Clement">oops, silly me - hurrying and I've made mistakes.  I've applied those changes.  Can you possibly create patches at the module level rather than the file level Ron?  They are much easier for me to work with.</comment>
		<comment id="11" date="2005-11-29 05:18:30 EST" author="Andrew Clement">fix available.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="97b5f52b520f534ac712d1ce3cff7b6ed5cca14f" author="aclement" date="2005-11-29 12:52:50"/>
          <file name="weaver/src/org/aspectj/weaver/UnresolvedType.java">
          </file>
          <file name="weaver/testsrc/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateTest.java">
          </file>
          <file name="weaver5/java5-src/org/aspectj/weaver/reflect/Java15ReflectionBasedReferenceTypeDelegate.java">
              <method name="getDeclaredInterfaces" returnType="ResolvedType[]" parameters=""/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="118599" opendate="2005-11-30 3:55:00" fixdate="2005-12-1 10:15:00">
    <buginformation>
      <summary>Ambiguous method error when weaving in binary aspects</summary>
      <description>Configuration:
  - Eclipse 3.1.1
  - AJDT 1.3.0.20051129155513


Problem Description:

Project A defines an interface with static aspect to provide a default implementation:


public interface Attributable {

  void setAttribute(String name, Object attribute);
  Object getAttribute(String name);

  static aspect DefImpl {

    private Map&lt;String,Object&gt; Attributable.attributes =
      new HashMap&lt;String,Object&gt;();

    public void Attributable.setAttribute(String name, Object attribute) {
      this.attributes.put(name, attribute);
    }

    public Object Attributable.getAttribute(String name) {
      return this.attributes.get(name);
    }
  }
}


Project A generates a JAR that gets used in Project B on both the Java Build Path and the AspectJ Aspect Path. Project B contains the following implementing class:


public class AnAttributedClass implements Attributable {

  public void doSomething() {
    this.setAttribute("foo", "bar");
  }
}


This results in the compile error "The method setAttribute(String,Object) is ambiguous for the type AnAttributedClass".

Please note that using the aspected interface within Project A when implementing classes does not cause said compiler error.

With best regards,
Christoph Cenowa</description>
      <comments>
		<comment id="1" date="2005-11-30 09:08:27 EST" author="Matt Chapman">Passing over to the compiler</comment>
		<comment id="2" date="2005-11-30 09:26:16 EST" author="Andrew Clement">Recreated on the command line:

C:\aspectj1.5.0-dev\pr118599&gt;ajc -1.5 -d output Attributable.java

C:\aspectj1.5.0-dev\pr118599&gt;ajc -1.5 -aspectpath output AnAttributedClass.java
C:\aspectj1.5.0-dev\pr118599\AnAttributedClass.java:4 [error] The method setAttribute(String, Object) is ambiguous for the type AnAttributedClass
this.setAttribute("foo", "bar");
     ^^^^^^^

1 error</comment>
		<comment id="3" date="2005-12-01 05:53:39 EST" author="Andrew Clement">Some progress.  The difference when binary weaving is that we find two method bindings for setAttributes() on the Attributable class.  We find the one declared in the interface directly and another is returned from the inter type member finder.</comment>
		<comment id="4" date="2005-12-01 05:59:47 EST" author="Andrew Clement">In the 'working' case when everything is compiled together, we go into the 'getMethods()' for the intertypememberfinder attached to the binarytypebinding for the Attributable interface - this asks the sourcetypebinding for 'getMethodsBase("setAttribute")' and gets back null (the methods aren't resolved yet...).  (in the failing case there is a method returned).  The finder then discovers the ITD and returns it - so only one 'answer' and therefore not reported as ambiguous.</comment>
		<comment id="5" date="2005-12-01 07:06:36 EST" author="Andrew Clement">I've just committed a fix for this - the problem was comparing an unresolved method binding with a resolved method binding and discovering that 'Unresolved type String' didnt match 'String'.  If the matching fails in the inter type member finder then we don't sort out duplicates correctly in the member finder and so you can end up with two entries for the same method.

Fix will be in next AspectJ build and AJDT in a few days.</comment>
		<comment id="6" date="2005-12-01 10:15:08 EST" author="Andrew Clement">fix available now in AspectJ.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="4da88a25f937a55568a0436a0354950343c3b84f" author="aclement" date="2005-12-01 09:01:32"/>
          <file name="tests/bugs150/pr118599/AnAttributedClass.java">
          </file>
          <file name="tests/bugs150/pr118599/Attributable.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="117882" opendate="2005-11-24 6:05:00" fixdate="2005-12-5 3:12:00">
    <buginformation>
      <summary>[waiting-on-build] NullPointerException with declare annotations and incremental compilation</summary>
      <description>Test program included and stack trace shown below:

java.lang.NullPointerException
at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.doDeclareAnnotations(AjLookupEnvironment.java:742)
at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.weaveInterTypeDeclarations(AjLookupEnvironment.java:556)
at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.weaveInterTypeDeclarations(AjLookupEnvironment.java:483)
at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.doPendingWeaves(AjLookupEnvironment.java:350)
at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.completeTypeBindings(AjLookupEnvironment.java:177)
at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.beginToCompile(Compiler.java:301)
at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:315)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:809)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:254)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.incrementalBuild(AjBuildManager.java:163)
at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:117)
at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)

NullPointerException thrown: null</description>
      <comments>
		<comment id="1" date="2005-11-24 06:08:05 EST" author="Sian January">Created attachment 30532 [details]
Test project</comment>
		<comment id="2" date="2005-11-24 06:33:47 EST" author="Andrew Clement">Helen, can you integrate this project into our incremental compilation area?

This is similar to other bugs Helen and I have looked at recently.  It is related to accessing state for a SourceTypeBinding when in fact what you are dealing with is a BinaryTypeBinding.  Although a quick hack here would seem to also work - I'm worried about the implications as the code following where the NPE occurs seems to really need to know what was on the typebinding - we need to see if we can access the annotations through the binary type binding in some way.</comment>
		<comment id="3" date="2005-11-25 03:58:20 EST" author="Helen Beeken">I've managed to easily reproduce this with a minimal test project in AJDT containing:

- Class C.java with no contents
- Annotation Annotation.java with no contents
- Aspect A.aj with the following declare statement: 
          declare @type : C : @Annotation;

To consistently recreate the problem, you need to do a full build on the project, then make a change to the aspect A (for example, add a comment), save the aspect and the NPE occurs every time on the incremental build.

The NPE only happens with declare @type, with all the others (@field, @method and @constructor) you just see the markers disappear in AJDT until you do a full build.

I'm currently trying to integrate the above scenario into the MultiProjectIncrementalTests, however, with declare @type I'm getting an ArrayIndexOutOfBoundsException because the annotations are not being added when run within the testsuite.</comment>
		<comment id="4" date="2005-11-25 05:35:13 EST" author="Helen Beeken">Created attachment 30601 [details]
first pass at testcase

Apply this patch to the tests project.

This patch contains the start of the testcase to reproduce the NPE. However, as mentioned in the previous comment I haven't reached that far yet and am still stuck on the ArrayIndexOutofBoundsException. The testcase supplied reproduces this (note that this patch contains sysout's and Task Tags, however, I'm attaching it in it's current state so the AIOBException can be seen) 

The reason for the ArrayIndexOutOfBoundsException is that in DeclareAnnotation.ensureAnnotationDiscovered(..) we get the declare @type ResolvedMember ajc$declare_at_type_1(), ask for it's annotations and get back an empty array. Consequently member.getAnnotations()[0] causes the exception. The problem is that in the case of running this test within the Aspectj testsuite, when we come to parse A.class in ClassParser.parse(..) and read the number of methods in readMethods(), we get back that there are 6 methods, one of which is the ajc$declare_at_type_1() as expected. However, when we step through this we find that in the FieldOrMethod constructor the call 

attributes_count = file.readUnsignedShort(); 

returns 3 (these are Unknown, Unknown and Code) and the ajc$declare_at_type_1() method consequently has these three attributes attached to it. 

In the case when this is run in AJDT, the call 

attributes_count = file.readUnsignedShort(); 

returns 5. The two extra ones are RuntimeInvisibleAnnotations and RuntimeVisibleAnnotations. It is the lack of these which cause the ArrayIndexOutOfBoundsException.

The same behaviour happens with the other declare statements (@method, @field and @constructor), however, in these cases it makes no difference because noone asks).</comment>
		<comment id="5" date="2005-11-25 07:02:15 EST" author="Helen Beeken">Looking into this further, the reason the RuntimeAnnotations aren't there is the check at line 3289 in org.aspectj.org.eclipse.jdt.internal.compiler.ClassFile: 

this.targetJDK &gt;= ClassFileConstants.JDK1_5 &amp;&amp; !this.creatingProblemType &amp;&amp; !createProblemMethod

This is never true in the case when this is run within the aspectj test harness and consequently the RuntimeAnnotations aren't generated. The problem is that

this.targetJDK &gt;= ClassFileConstants.JDK1_5 

returns false so it seems like there's something else which needs to be done to get the test to realise it's running in Java5 mode.</comment>
		<comment id="6" date="2005-11-25 08:04:53 EST" author="Helen Beeken">Fixing the BuildOptionsAdapter in AjdeInteractionTestbed to also have the targetPlatform = 1.5 in its javaOptionsMap fixes the problem with getting the test to realise its running in 1.5 mode.

I'm now able to recreate the NPE originally reported in this bug.</comment>
		<comment id="7" date="2005-11-25 09:20:55 EST" author="Helen Beeken">Created attachment 30611 [details]
testcase patch

Apply this patch to the tests project.

This patch contains a failing testcase which shows the reported NPE.</comment>
		<comment id="8" date="2005-11-29 09:07:26 EST" author="Helen Beeken">When we enter AjLookupEnvironment.doDeclareAnnotations(..) during a full build we have a SourceTypeBinding.  This has a scope (ClassScope) which we can then query for it's TypeDeclaration and consequently the annotations. Within this method, we find out if there are any new annotations to add and update the list of annotations to be this new set. 

In an incremental build we have a BinaryTypeBinding which has null scope which leads to the NPE when we query for the annotations. There are two options, either to do a null check the first time and return false if it's null, or stick null checks around these calls and return true. The problem is that in both these cases, we don't update the list of annotations to be the new set. Consequently, there are situations where we don't know that there are annotations and we report compiler errors instead. The workaround would be to do a full build.</comment>
		<comment id="9" date="2005-11-29 09:11:39 EST" author="Helen Beeken">Created attachment 30766 [details]
augmented testcase patch

Apply this patch to the tests project.

This is a testcase patch which includes the previously attached testcase, but also a testcase which shows the failure described in the previous comment. When MultiProjectIncrementalTests.testPr117882_2() is run (if there are null checks put in to fix MultiProjectIncrementalTests.testPr117882()), then this will fail with the error:

Build errors:
error at new C().method();
        ^^^
C:\temp\ajcSandbox\ajcTest35899.tmp\PR117882_2\src\pack\A.aj:13:0::0 The method method() is undefined for the type C
---------

If the four lines in this test:

build("PR117882_2");
checkWasntFullBuild();
//fullBuild("PR117882_2");
//checkWasFullBuild();

are changed to:

//build("PR117882_2");
//checkWasntFullBuild();
fullBuild("PR117882_2");
checkWasFullBuild();

then this test passes because a full build has been done and the annotations have been recorded.</comment>
		<comment id="10" date="2005-12-01 10:50:18 EST" author="Helen Beeken">I believe the reason that the errror message "....undefined for the type...." is coming out when running MultiProjectIncrementalTests.testPr117882_2() rather than it blowing up with an NPE is that at this point we're in CompilationUnitDeclaration.resolve(..) which calls resolve on AspectDeclaration, which in turn calls resolve on AjMethodDeclaration (the method we're resolving within A.aj is 

  public static void main(String []argv) {
     new C().method();
  }

). AjMethodDeclaration has a non-null MethodScope which means that we're not NPE'ing.</comment>
		<comment id="11" date="2005-12-04 08:41:16 EST" author="Andrew Clement">fixes checked in - waiting on build</comment>
		<comment id="12" date="2005-12-05 03:12:30 EST" author="Andrew Clement">fix available.

basically we can't 'attach' annotations to a binarytypebinding and thats the type that we are processing on the incremental build.  The other features that require the annotations to be there (declare parents/annotation) check the weaver type for the annotations - so the solution is that we map from the binarytypebinding to the weaver type and put the annotations on *it*.  What we stick on the weaver type is a 'fakeannotation' - which is created from an eclipse annotation and only knows its annotation type name (that's all the other decps/decas will need).  This works fine - the FakeAnnotation never makes it to disk, the weaver adds the real annotation when it correctly processes the declare @type later on.

(that makes sense to me...at least) :)</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="1b111328220bc522194ecc7361f282d169d781f3" author="aclement" date="2005-12-03 12:30:37"/>
          <file name="bcel-builder/src/org/aspectj/apache/bcel/classfile/annotation/Annotation.java">
              <method name="getTypeIndex" returnType="int" parameters=""/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="117209" opendate="2005-11-20 1:07:00" fixdate="2005-12-7 5:24:00">
    <buginformation>
      <summary>"Runtime error - Stack size too large, Bug#69706 related."</summary>
      <description>AspectJ compiler version: 1.5M5
AJDT plugin version: 1.3.0

This is the same error as reported by Bug#69706, even the bug is resolved I'm 
still experiencing problem by using the classes attached at the bottom.

// RUNTIME ERROR MESSAGE
========================
Exception in thread "main" java.lang.VerifyError: (class: 
DefaultInterfaceImplementationRecipe, method: &lt;clinit&gt; signature: ()V) Stack 
size too large
	at MyClass_ch16.main(MyClass_ch16.java:15)


// MyClass_ch16.java
====================
public class MyClass_ch16
{
        public void foo(int number, String name)
	{
		System.out.println("Inside foo (int, String) with args: " + 
number + ":" + name);
	}

	public static void main(String[] args)
	{
		// Create an instance of MyClass
		MyInterface_ch16 myObject = (MyInterface_ch16)new MyClass_ch16
();
		
		// Make the call to foo
		myObject.bar("Russ");
	}
}

//MyInterface_ch16.java
=======================
public interface MyInterface_ch16
{
	public void bar(String name);
}

// DefaultInterfaceImplementationRecipe.aj
==========================================
public aspect DefaultInterfaceImplementationRecipe
{
	declare parents : MyClass_ch16 implements MyInterface_ch16;
	
	// Declare the default implementation of the bar method
	public void MyInterface_ch16.bar(String name)
	{
		System.out.println("bar(String) called on " + this);
	}
}</description>
      <comments>
		<comment id="1" date="2005-11-21 06:06:30 EST" author="Matt Chapman">*** Bug 117210 has been marked as a duplicate of this bug. ***</comment>
		<comment id="2" date="2005-11-21 06:11:16 EST" author="Matt Chapman">Passing over to AspectJ</comment>
		<comment id="3" date="2005-11-21 06:20:02 EST" author="Andrew Clement">Bug 69706 was related to using -XnoWeave.  I assume you aren't using -XnoWeave here?

I tried M5 and the latest dev build on the command line - compiled those 3 files and they run OK, producing:

C:\pr117209&gt;java MyClass_ch16
bar(String) called on MyClass_ch16@111a3ac

I've tried with -emacssym on too - I'll now try again in AJDT to see if that makes a difference.</comment>
		<comment id="4" date="2005-11-21 12:33:11 EST" author="David">I use AJDT with the default setting - without checking any checkbox option in the Preferences/AspectJ/Compiler/Advanced tab, and check all checkbox options in the Other tab.
I've tried with the latest M5 (1.3.0.20051121083802) and found the problem still exist.

Thanks
David

(In reply to comment #3)
&gt; Bug 69706 was related to using -XnoWeave.  I assume you aren't using -XnoWeave
&gt; here?
&gt; 
&gt; I tried M5 and the latest dev build on the command line - compiled those 3
&gt; files and they run OK, producing:
&gt; 
&gt; C:\pr117209&gt;java MyClass_ch16
&gt; bar(String) called on MyClass_ch16@111a3ac
&gt; 
&gt; I've tried with -emacssym on too - I'll now try again in AJDT to see if that
&gt; makes a difference.
&gt; </comment>
		<comment id="5" date="2005-11-21 13:22:43 EST" author="Andrew Clement">Can I ask what JVM you are running your eclipse on? Sun/IBM/JRockit 1.3/1.4/1.5?

I tried it in AJDT myself and those 3 files just compiled fine :(

Can you possibly attach the .class files that are broken after the compilation has occurred? And I'll take a look straightaway.

thanks.</comment>
		<comment id="6" date="2005-11-22 23:50:20 EST" author="David">Created attachment 30450 [details]
MyClass_ch16.class</comment>
		<comment id="7" date="2005-11-22 23:51:18 EST" author="David">Created attachment 30451 [details]
MyInterface-ch16.class</comment>
		<comment id="8" date="2005-11-22 23:52:03 EST" author="David">Created attachment 30452 [details]
DefaultInterfaceImplementationRecipe.class</comment>
		<comment id="9" date="2005-11-22 23:52:44 EST" author="David">I use Sun JDk 1.5.0_05 and I've attached 3 classes files for your reference.
But by looking at the class files decompiled by JODE, there is a missing method in MyInterface_ch16 and error in DefaultInterfaceImplementationReceipe.
It's weird since in Eclipse there is no error message indicated any compilation error after I clicked on the Build AspectJ Project button.

// decompiled DefaultInterfaceImplementationRecipe
===================================================
Exception while decompiling:java.lang.ArrayIndexOutOfBoundsException: 0
 at jode.jvm.CodeVerifier.doVerify(CodeVerifier.java:1068)
 at jode.jvm.CodeVerifier.verify(CodeVerifier.java:1102)
 at jode.decompiler.MethodAnalyzer.analyze(MethodAnalyzer.java:610)
 at jode.decompiler.ClassAnalyzer.analyze(ClassAnalyzer.java:325)
 at jode.decompiler.ClassAnalyzer.dumpJavaFile(ClassAnalyzer.java:624)
 at jode.decompiler.Decompiler.decompile(Decompiler.java:192)
 at jode.swingui.Main.run(Main.java:204)
 at java.lang.Thread.run(Unknown Source)

// decompiled MyClass_ch16
==========================
/* MyClass_ch16 - Decompiled by JODE
 * Visit http://jode.sourceforge.net/
 */

public class MyClass_ch16
{
    public void foo(int number, String name) {
 System.out.println(new StringBuilder
          ("Inside foo (int, String) with args: ").append
          (number).append
          (":").append
          (name).toString());
    }
    
    public static void main(String[] args) {
 MyClass_ch16 myclass_ch16 = new MyClass_ch16();
 DefaultInterfaceImplementationRecipe
     .ajc$interMethodDispatch1$DefaultInterfaceImplementationRecipe$MyInterface_ch16$bar
     (/*TYPE_ERROR*/ myclass_ch16, "Russ");
    }
}

// decompiled MyInterface_ch16
==============================
/* MyInterface_ch16 - Decompiled by JODE
 * Visit http://jode.sourceforge.net/
 */

public interface MyInterface_ch16
{
}


Thnaks
David</comment>
		<comment id="10" date="2005-11-24 06:11:00 EST" author="Andrew Clement">Findings for pr117209...

When it works, the 3 classes look like this:

public class MyClass_ch16 extends java.lang.Object implements MyInterface_ch16{
    public MyClass_ch16();
    public void foo(int, java.lang.String);
    public static void main(java.lang.String[]);
    public void bar(java.lang.String);
}

public interface MyInterface_ch16{
    public abstract void bar(java.lang.String);
}

public class DefaultInterfaceImplementationRecipe extends java.lang.Object{
    private static java.lang.Throwable ajc$initFailureCause;
    public static final DefaultInterfaceImplementationRecipe ajc$perSingletonInstance;
    static {};
    public DefaultInterfaceImplementationRecipe();
    void ajc$declare_parents_1();
    public static void ajc$interMethod$DefaultInterfaceImplementationRecipe$MyInterface_ch16$bar(MyInterface_ch16, java.lang.String);
    public static void ajc$interMethodDispatch1$DefaultInterfaceImplementationRecipe$MyInterface_ch16$bar(MyInterface_ch16, java.lang.String);
    public static DefaultInterfaceImplementationRecipe aspectOf();
    public static boolean hasAspect();
    private static void ajc$postClinit();
}

In the failing code I've been sent:

public class MyClass_ch16 extends java.lang.Object{
    public MyClass_ch16();
    public void foo(int, java.lang.String);
    public static void main(java.lang.String[]);
}

public interface MyInterface_ch16{
}

public class DefaultInterfaceImplementationRecipe extends java.lang.Object{
    private static java.lang.Throwable ajc$initFailureCause;
    public static final DefaultInterfaceImplementationRecipe ajc$perSingletonInstance;
    static {};
    public DefaultInterfaceImplementationRecipe();
    void ajc$declare_parents_1();
    public static void ajc$interMethod$DefaultInterfaceImplementationRecipe$MyInterface_ch16$bar(MyInterface_ch16, java.lang.String);
    public static void ajc$interMethodDispatch1$DefaultInterfaceImplementationRecipe$MyInterface_ch16$bar(MyInterface_ch16, java.lang.String);
    public static DefaultInterfaceImplementationRecipe aspectOf();
    public static boolean hasAspect();
    private static void ajc$postClinit();
}

Differences:

MyClass_ch16 is missing the method
    public void bar(java.lang.String);

MyInterface_ch16 is missing the method 
    public abstract void bar(java.lang.String);


In the failing case, the clinit for DefaultInterfaceImplementationRecipe is:

static {};
  Code:
   Stack=0, Locals=1, Args_size=0
   0:   invokestatic    #14; //Method ajc$postClinit:()V
   3:   goto    11
   6:   astore_0
   7:   aload_0
   8:   putstatic       #16; //Field ajc$initFailureCause:Ljava/lang/Throwable;
   11:  return
  Exception table:
   from   to  target type
     0     3     6   Class java/lang/Throwable

In the working case, the clinit for DefaultInterfaceImplementationRecipe is:

static {};
  Code:
   Stack=1, Locals=1, Args_size=0
   0:   invokestatic    #14; //Method ajc$postClinit:()V
   3:   goto    11
   6:   astore_0
   7:   aload_0
   8:   putstatic       #16; //Field ajc$initFailureCause:Ljava/lang/Throwable;
   11:  return
  Exception table:
   from   to  target type
     0     3     6   Class java/lang/Throwable

Notice the 'stack is 0 in the failing case and 1 in the working case'.

The missing meethods and incorrect stack are exactly what I saw for 69706 (see comment 4 in that bug).

You mentioned that you turn on all the options in the 'Others' page for compiler options.  Do you see weaving messages in the problems view for the declare parents and ITD actually occurring then?

Can you check that the project properties aren't overriding the workbench preferences.

Can you try turning *on* 'no weave', doing a build, then turning it off again and rebuilding - just in case its a problem in how options are persisted?</comment>
		<comment id="11" date="2005-11-25 23:53:51 EST" author="David">My project properties do override the workbench preferences. But doesn't matter how I change the properties, for instance uncheck "Enable project specific settings" or uncheck all opetions under Other tab, the result is still the same.

Below are messages shown on the "AJDT Event Trace" view (not sure if this is the one you mentioned as problem view)

## Build ourput while "no weave" is turned on
22:41:16  Build kind = FULLBUILD
22:41:16  build: No structure model to be built for project: AspectJ cookbook
22:41:16  Project=AspectJ cookbook         kind of build requested =Full AspectJ compilation
22:41:17  Builder: Tidied output folder, deleted 267 .class files from C:\codes\aspectjcookbook_examples\bin
22:41:19  Timer event: 1963ms: Time to first compiled message
22:41:22  Timer event: 5838ms: Total time spent in AJDE
22:41:23  Timer event: 70ms: Create element map (338 rels in project: AspectJ cookbook)
22:41:23  Types affected during build = 380
22:41:23  Timer event: 10ms: Add markers (83 markers)
22:41:23  Timer event: 6740ms: Total time spent in AJBuilder.build()

## Build ourput while "no weave" is turned off
22:41:52  Build kind = FULLBUILD
22:41:52  build: No structure model to be built for project: AspectJ cookbook
22:41:52  Project=AspectJ cookbook         kind of build requested =Full AspectJ compilation
22:41:52  Builder: Tidied output folder, deleted 267 .class files from C:\codes\aspectjcookbook_examples\bin
22:41:53  Timer event: 1442ms: Time to first compiled message
22:41:57  Timer event: 5368ms: Total time spent in AJDE
22:41:58  Timer event: 60ms: Create element map (338 rels in project: AspectJ cookbook)
22:41:58  Types affected during build = 380
22:41:58  Timer event: 10ms: Add markers (83 markers)
22:41:58  Timer event: 6280ms: Total time spent in AJBuilder.build()
22:42:10  AJDTContentProvider.selectionChanged(): Marking visualiser content as out of date
22:44:19  AJDTContentProvider.selectionChanged(): Marking visualiser content as out of date</comment>
		<comment id="12" date="2005-11-26 11:54:11 EST" author="Andrew Clement">By problems view I actually meant the standard Eclipse problems view - if you have the option 'Output weaving messages to problems view' then you should get entries in the problems view indicating that weaving is occurring - that would tell me whether weaving was occurring properly.  

this entry in the event trace when no weave is turned 'off' worries me:

22:41:52         build: No structure model to be built for project: AspectJ cookbook

After the build has finished, do you normally see gutter markers etc in the editor and cross references view suggesting that weaving has occurred as you expect?</comment>
		<comment id="13" date="2005-11-26 18:18:41 EST" author="David">My answer inline

(In reply to comment #12)
&gt; By problems view I actually meant the standard Eclipse problems view - if you
&gt; have the option 'Output weaving messages to problems view' then you should get
&gt; entries in the problems view indicating that weaving is occurring - that would
&gt; tell me whether weaving was occurring properly.  

Just checked "Output weaving info message to problems view" and rebuilt the project, but found no any error/warning message in the problem view.

&gt; 
&gt; this entry in the event trace when no weave is turned 'off' worries me:
&gt; 
&gt; 22:41:52         build: No structure model to be built for project: AspectJ
&gt; cookbook
&gt; 

When I checked "Create a structure model during compilation", the message you mentioned above disappeared. Below is the output message with "Create a structure model during compilation" checked.
But if it's unchecked the message you mentioned will always show up.

17:11:37  Build kind = INCREMENTALBUILD
17:11:37  Project=AspectJ cookbook         kind of build requested =Full AspectJ compilation
17:11:37  build: Examined delta - no source file changes for project AspectJ cookbook
17:11:37  Timer event: 10ms: Add markers (83 markers)
17:11:37  Timer event: 20ms: Total time spent in AJBuilder.build()


&gt; After the build has finished, do you normally see gutter markers etc in the
&gt; editor and cross references view suggesting that weaving has occurred as you
&gt; expect?
&gt; 

Yes, and when I right-clicked it, a popup menu will show either "Declared on" (on DefaultInterfaceImplementationRecipe.aj) or  "Aspect Declarations" (on MyClass_ch16.java)to bring me to the right source code.</comment>
		<comment id="14" date="2005-11-26 18:22:29 EST" author="David">// Not sure if my Ecllipse configuration detail help to identify the problem but here you go ...

*** Date: Sat Nov 26 17:21:42 CST 2005
*** Platform Details:
*** System properties:
awt.toolkit=sun.awt.windows.WToolkit
eclipse.application=org.eclipse.ui.ide.workbench
eclipse.buildId=M20050929-0840
eclipse.commands=-os
win32
-ws
win32
-arch
x86
-launcher
C:\Eclipse\3.11\eclipse\eclipse.exe
-name
Eclipse
-showsplash
600
-exitdata
440_68
-vm
C:\j2sdk1.4.2_09\jre\bin\javaw.exe
eclipse.product=org.eclipse.sdk.ide
eclipse.startTime=1133046132325
eclipse.vm=C:\j2sdk1.4.2_09\jre\bin\javaw.exe
eclipse.vmargs=-Xmx256M
-jar
C:\Eclipse\3.11\eclipse\startup.jar
eof=eof
file.encoding=GBK
file.encoding.pkg=sun.io
file.separator=\
java.awt.graphicsenv=sun.awt.Win32GraphicsEnvironment
java.awt.printerjob=sun.awt.windows.WPrinterJob
java.class.path=C:\Eclipse\3.11\eclipse\startup.jar
java.class.version=48.0
java.endorsed.dirs=C:\j2sdk1.4.2_09\jre\lib\endorsed
java.ext.dirs=C:\j2sdk1.4.2_09\jre\lib\ext
java.home=C:\j2sdk1.4.2_09\jre
java.io.tmpdir=C:\DOCUME~1\changd\LOCALS~1\Temp\
java.library.path=C:\j2sdk1.4.2_09\jre\bin;.;C:\WINDOWS\system32;C:\WINDOWS;C:\PROGRAM FILES\THINKPAD\UTILITIES;C:\WINDOWS\system32;C:\WINDOWS;C:\WINDOWS\System32\Wbem;C:\Program Files\Support Tools\;C:\Program Files\ATI Technologies\ATI Control Panel;C:\Program Files\Rational\ClearCase\bin;C:\Program Files\Rational\common;T:\perl\current\bin;T:\cctools\current\bin;C:\Program Files\ssh communications security\ssh Secure Shell;C:\tools\MultiDesk\shortcuts;C:\tools\groovy-1.0-jsr-04\bin
java.runtime.name=Java(TM) 2 Runtime Environment, Standard Edition
java.runtime.version=1.4.2_09-b05
java.specification.name=Java Platform API Specification
java.specification.vendor=Sun Microsystems Inc.
java.specification.version=1.4
java.util.prefs.PreferencesFactory=java.util.prefs.WindowsPreferencesFactory
java.vendor=Sun Microsystems Inc.
java.vendor.url=http://java.sun.com/
java.vendor.url.bug=http://java.sun.com/cgi-bin/bugreport.cgi
java.version=1.4.2_09
java.vm.info=mixed mode
java.vm.name=Java HotSpot(TM) Client VM
java.vm.specification.name=Java Virtual Machine Specification
java.vm.specification.vendor=Sun Microsystems Inc.
java.vm.specification.version=1.0
java.vm.vendor=Sun Microsystems Inc.
java.vm.version=1.4.2_09-b05
line.separator=

org.eclipse.jdt.debug.ui.scrapbookActive=false
org.osgi.framework.bootdelegation=*
org.osgi.framework.executionenvironment=J2SE-1.4
org.osgi.framework.language=zh
org.osgi.framework.os.name=WindowsXP
org.osgi.framework.os.version=5.1
org.osgi.framework.processor=x86
org.osgi.framework.system.packages=javax.accessibility,javax.crypto,javax.crypto.interfaces,javax.crypto.spec,javax.imageio,javax.imageio.event,javax.imageio.metadata,javax.imageio.plugins.jpeg,javax.imageio.spi,javax.imageio.stream,javax.naming,javax.naming.directory,javax.naming.event,javax.naming.ldap,javax.naming.spi,javax.net,javax.net.ssl,javax.print,javax.print.attribute,javax.print.attribute.standard,javax.print.event,javax.rmi,javax.rmi.CORBA,javax.security.auth,javax.security.auth.callback,javax.security.auth.kerberos,javax.security.auth.login,javax.security.auth.spi,javax.security.auth.x500,javax.security.cert,javax.sound.midi,javax.sound.midi.spi,javax.sound.sampled,javax.sound.sampled.spi,javax.sql,javax.swing,javax.swing.border,javax.swing.colorchooser,javax.swing.event,javax.swing.filechooser,javax.swing.plaf,javax.swing.plaf.basic,javax.swing.plaf.metal,javax.swing.plaf.multi,javax.swing.table,javax.swing.text,javax.swing.text.html,javax.swing.text.html.parser,javax.swing.text.rtf,javax.swing.tree,javax.swing.undo,javax.transaction,javax.transaction.xa,javax.xml.parsers,javax.xml.transform,javax.xml.transform.dom,javax.xml.transform.sax,javax.xml.transform.stream,org.ietf.jgss,org.omg.CORBA,org.omg.CORBA_2_3,org.omg.CORBA_2_3.portable,org.omg.CORBA.DynAnyPackage,org.omg.CORBA.ORBPackage,org.omg.CORBA.portable,org.omg.CORBA.TypeCodePackage,org.omg.CosNaming,org.omg.CosNaming.NamingContextExtPackage,org.omg.CosNaming.NamingContextPackage,org.omg.Dynamic,org.omg.DynamicAny,org.omg.DynamicAny.DynAnyFactoryPackage,org.omg.DynamicAny.DynAnyPackage,org.omg.IOP,org.omg.IOP.CodecFactoryPackage,org.omg.IOP.CodecPackage,org.omg.Messaging,org.omg.PortableInterceptor,org.omg.PortableInterceptor.ORBInitInfoPackage,org.omg.PortableServer,org.omg.PortableServer.CurrentPackage,org.omg.PortableServer.POAManagerPackage,org.omg.PortableServer.POAPackage,org.omg.PortableServer.portable,org.omg.PortableServer.ServantLocatorPackage,org.omg.SendingContext,org.omg.stub.java.rmi,org.w3c.dom,org.xml.sax,org.xml.sax.ext,org.xml.sax.helpers
org.osgi.framework.vendor=Eclipse
org.osgi.framework.version=1.3.0
org.osgi.supports.framework.extension=true
org.xml.sax.driver=org.apache.crimson.parser.XMLReaderImpl
os.arch=x86
os.name=Windows XP
os.version=5.1
osgi.arch=x86
osgi.bundles=org.eclipse.core.runtime@2:start, org.eclipse.update.configurator@3:start
osgi.bundlestore=c:\Eclipse\3.11\eclipse\configuration\org.eclipse.osgi\bundles
osgi.configuration.area=file:/c:/Eclipse/3.11/eclipse/configuration/
osgi.framework=file:/c:/Eclipse/3.11/eclipse/plugins/org.eclipse.osgi_3.1.1.jar
osgi.framework.beginningstartlevel=1
osgi.framework.shape=jar
osgi.framework.version=3.1.1
osgi.install.area=file:/c:/Eclipse/3.11/eclipse/
osgi.instance.area=file:/C:/workspace/
osgi.instance.area.default=file:/C:/Documents and Settings/changd/workspace/
osgi.logfile=C:\workspace\.metadata\.log
osgi.manifest.cache=c:\Eclipse\3.11\eclipse\configuration\org.eclipse.osgi\manifests
osgi.nl=zh_CN
osgi.os=win32
osgi.splashLocation=c:\Eclipse\3.11\eclipse\plugins\org.eclipse.platform_3.1.1\splash.bmp
osgi.splashPath=platform:/base/plugins/org.eclipse.platform
osgi.syspath=c:\Eclipse\3.11\eclipse\plugins
osgi.ws=win32
path.separator=;
sun.arch.data.model=32
sun.boot.class.path=C:\j2sdk1.4.2_09\jre\lib\rt.jar;C:\j2sdk1.4.2_09\jre\lib\i18n.jar;C:\j2sdk1.4.2_09\jre\lib\sunrsasign.jar;C:\j2sdk1.4.2_09\jre\lib\jsse.jar;C:\j2sdk1.4.2_09\jre\lib\jce.jar;C:\j2sdk1.4.2_09\jre\lib\charsets.jar;C:\j2sdk1.4.2_09\jre\classes
sun.boot.library.path=C:\j2sdk1.4.2_09\jre\bin
sun.cpu.endian=little
sun.cpu.isalist=pentium i486 i386
sun.io.unicode.encoding=UnicodeLittle
sun.java2d.fontpath=
sun.os.patch.level=Service Pack 2
user.country=CN
user.dir=C:\Eclipse\3.11\eclipse
user.home=C:\Documents and Settings\changd
user.language=zh
user.name=changd
user.timezone=America/Chicago
user.variant=
vendor=Apache Software Foundation
vendor-url=http://xml.apache.org/xalan-j
version=2.4.1

*** Features:
net.sourceforge.eclipseccase (1.0.3) "Eclipse ClearCase Integration Core"
org.eclipse.aspectj (1.3.0.20051125115230) "AspectJ Development Tools"
org.eclipse.jdt (3.1.1) "Eclipse Java Development Tools"
org.eclipse.jdt.source (3.1.1) "Eclipse Java Development Tools SDK"
org.eclipse.pde (3.1.1) "Eclipse Plug-in Development Environment"
org.eclipse.pde.source (3.1.1) "Eclipse Plug-in Development Environment Developer Resources"
org.eclipse.platform (3.1.1) "Eclipse Platform"
org.eclipse.platform.source (3.1.1) "Eclipse Platform Plug-in Developer Resources"
org.eclipse.rcp (3.1.1) "Eclipse RCP"
org.eclipse.rcp.source (3.1.1) "Eclipse RCP Plug-in Developer Resources"
org.eclipse.sdk (3.1.1) "Eclipse Project SDK"
org.rubypeople.rdt (0.6.0) "Ruby Development Tools"
org.rubypeople.rdt.source (0.6.0) "pluginName"
org.testng.eclipse (4.2.0.0) "TestNG Eclipse Support"

*** Plug-in Registry:
com.cisco.ong.ctc.wizards.project (0.3.1) "CTC Project Wizard Plug-in" [Resolved]
de.loskutov.BytecodeOutline (2.0.2) "Bytecode Outline Plug-in" [Resolved]
net.sourceforge.clearcase (1.0.3) "ClearCase Java API" [Resolved]
net.sourceforge.eclipseccase (1.0.3) "Eclipse ClearCase Integration Core" [Active]
net.sourceforge.eclipseccase.ui (1.0.3) "Eclipse ClearCase Integration UI" [Active]
org.apache.ant (1.6.5) "Apache Ant" [Resolved]
org.apache.lucene (1.4.3) "Apache Lucene" [Resolved]
org.aspectj.ajde (1.5.0.20051125115230) "AspectJ" [Active]
org.aspectj.runtime (1.5.0.20051125115230) "AspectJ Runtime" [Resolved]
org.aspectj.weaver (1.5.0.20051125115230) "AspectJ Weaver" [Resolved]
org.eclipse.ajdt.core (1.3.0.20051125115230) "AspectJ Development Tools Core" [Active]
org.eclipse.ajdt.examples (1.3.0.20051125115230) "AspectJ Examples" [Resolved]
org.eclipse.ajdt.source (1.3.0.20051125115230) "AspectJ Development Tools SDK" [Resolved]
org.eclipse.ajdt.ui (1.3.0.20051125115230) "AspectJ Development Tools UI" [Active]
org.eclipse.ant.core (3.1.1) "Ant Build Tool Core" [Resolved]
org.eclipse.ant.ui (3.1.1) "Ant UI" [Resolved]
org.eclipse.aspectj (1.3.0.20051125115230) "AspectJ Development Tools" [Resolved]
org.eclipse.compare (3.1.1) "Compare Support" [Active]
org.eclipse.contribution.visualiser (2.2.0.20051125115230) "Visualiser Plug-in" [Active]
org.eclipse.contribution.xref.core (1.3.0.20051125115230) "Cross Reference Core Plugin" [Active]
org.eclipse.contribution.xref.ui (1.3.0.20051125115230) "Cross Reference UI Plugin" [Active]
org.eclipse.core.boot (3.1.0) "Core Boot" [Resolved]
org.eclipse.core.commands (3.1.0) "Commands" [Active]
org.eclipse.core.expressions (3.1.0) "Expression Language" [Active]
org.eclipse.core.filebuffers (3.1.0) "File Buffers" [Active]
org.eclipse.core.resources (3.1.0) "Core Resource Management" [Active]
org.eclipse.core.resources.compatibility (3.1.0) "Core Resource Management Compatibility Fragment" [Resolved]
org.eclipse.core.resources.win32 (3.1.0) "Core Resource Management Win32 Fragment" [Resolved]
org.eclipse.core.runtime (3.1.1) "Core Runtime" [Active]
org.eclipse.core.runtime.compatibility (3.1.0) "Core Runtime Plug-in Compatibility" [Active]
org.eclipse.core.variables (3.1.0) "Core Variables" [Active]
org.eclipse.debug.core (3.1.0) "Debug Core" [Active]
org.eclipse.debug.ui (3.1.1) "Debug UI" [Active]
org.eclipse.help (3.1.0) "Help System Core" [Active]
org.eclipse.help.appserver (3.1.0) "Help Application Server" [Resolved]
org.eclipse.help.base (3.1.0) "Help System Base" [Resolved]
org.eclipse.help.ui (3.1.1) "Help System UI" [Resolved]
org.eclipse.help.webapp (3.1.0) "Help System Webapp" [Resolved]
org.eclipse.jdt (3.1.0) "Eclipse Java Development Tools" [Resolved]
org.eclipse.jdt.core (3.1.1) "Java Development Tools Core" [Active]
org.eclipse.jdt.debug (3.1.1) "JDI Debug Model" [Active]
org.eclipse.jdt.debug.ui (3.1.1) "JDI Debug UI" [Active]
org.eclipse.jdt.doc.isv (3.1.1) "Eclipse JDT Plug-in Developer Guide" [Resolved]
org.eclipse.jdt.doc.user (3.1.1) "Eclipse Java Development User Guide" [Resolved]
org.eclipse.jdt.junit (3.1.1) "Java Development Tools JUnit support" [Active]
org.eclipse.jdt.junit.runtime (3.1.0) "Java Development Tools JUnit runtime support" [Resolved]
org.eclipse.jdt.launching (3.1.0) "Java Development Tools Launching Support" [Active]
org.eclipse.jdt.source (3.1.1) "Eclipse Java Development Tools SDK" [Resolved]
org.eclipse.jdt.ui (3.1.1) "Java Development Tools UI" [Active]
org.eclipse.jface (3.1.1) "JFace" [Active]
org.eclipse.jface.text (3.1.1) "JFace Text" [Active]
org.eclipse.ltk.core.refactoring (3.1.0) "Refactoring Core" [Active]
org.eclipse.ltk.ui.refactoring (3.1.1) "Refactoring UI" [Active]
org.eclipse.osgi.services (3.1.1) "OSGi Release 3 Services" [Resolved]
org.eclipse.osgi.util (3.1.1) "OSGi R3 Utility Classes" [Resolved]
org.eclipse.pde (3.1.0) "Eclipse Plug-in Development Environment" [Resolved]
org.eclipse.pde.build (3.1.0) "Plug-in Development Environment Build Support" [Resolved]
org.eclipse.pde.core (3.1.1) "Plug-in Development Core" [Active]
org.eclipse.pde.doc.user (3.1.1) "Eclipse Plug-in Development User Guide" [Resolved]
org.eclipse.pde.junit.runtime (3.1.0) "PDE JUnit Plug-in Test" [Resolved]
org.eclipse.pde.runtime (3.1.1) "Plug-in Development Environment Runtime" [Resolved]
org.eclipse.pde.source (3.1.1) "Eclipse Plug-in Development Environment Developer Resources" [Resolved]
org.eclipse.pde.ui (3.1.1) "Plug-in Development UI" [Active]
org.eclipse.platform (3.1.1) "Eclipse Platform" [Resolved]
org.eclipse.platform.doc.isv (3.1.1) "Eclipse Platform Plug-in Developer Guide" [Resolved]
org.eclipse.platform.doc.user (3.1.1) "Eclipse Workbench User Guide" [Resolved]
org.eclipse.platform.source (3.1.1) "Eclipse Platform Plug-in Developer Resources" [Resolved]
org.eclipse.platform.source.win32.win32.x86 (3.1.1) "Eclipse Platform Plug-in Developer Resources" [Resolved]
org.eclipse.rcp (3.1.0) "Eclipse RCP" [Resolved]
org.eclipse.rcp.source (3.1.1) "Eclipse RCP Plug-in Developer Resources" [Resolved]
org.eclipse.rcp.source.win32.win32.x86 (3.1.1) "Eclipse RCP Plug-in Developer Resources" [Resolved]
org.eclipse.sdk (3.1.1) "Eclipse Project SDK" [Resolved]
org.eclipse.search (3.1.1) "Search Support" [Active]
org.eclipse.swt (3.1.0) "Standard Widget Toolkit" [Resolved]
org.eclipse.swt.win32.win32.x86 (3.1.1) "Standard Widget Toolkit for Windows" [Resolved]
org.eclipse.team.core (3.1.1) "Team Support Core" [Active]
org.eclipse.team.cvs.core (3.1.1) "CVS Team Provider Core" [Active]
org.eclipse.team.cvs.ssh (3.1.0) "CVS SSH Core" [Resolved]
org.eclipse.team.cvs.ssh2 (3.1.0) "CVS SSH2" [Resolved]
org.eclipse.team.cvs.ui (3.1.1) "CVS Team Provider UI" [Active]
org.eclipse.team.ui (3.1.1) "Team Support UI" [Active]
org.eclipse.text (3.1.1) "Text" [Active]
org.eclipse.tomcat (4.1.30.1) "Tomcat Wrapper" [Resolved]
org.eclipse.ui (3.1.1) "Eclipse UI" [Active]
org.eclipse.ui.browser (3.1.1) "Browser Support" [Resolved]
org.eclipse.ui.cheatsheets (3.1.1) "Cheat Sheets" [Resolved]
org.eclipse.ui.console (3.1.0) "Console" [Active]
org.eclipse.ui.editors (3.1.1) "Default Text Editor" [Active]
org.eclipse.ui.externaltools (3.1.1) "External Tools" [Active]
org.eclipse.ui.forms (3.1.0) "Eclipse Forms" [Active]
org.eclipse.ui.ide (3.1.1) "Eclipse IDE UI" [Active]
org.eclipse.ui.intro (3.1.1) "Welcome Framework" [Resolved]
org.eclipse.ui.presentations.r21 (3.1.0) "R21 Presentation Plug-in" [Resolved]
org.eclipse.ui.views (3.1.1) "Views" [Active]
org.eclipse.ui.win32 (3.1.0) "Eclipse UI Win32 Enhancements" [Resolved]
org.eclipse.ui.workbench (3.1.1) "Workbench" [Active]
org.eclipse.ui.workbench.compatibility (3.1.0) "Workbench Compatibility" [Resolved]
org.eclipse.ui.workbench.texteditor (3.1.1) "Text Editor Framework" [Active]
org.eclipse.update.configurator (3.1.0) "Install/Update Configurator" [Active]
org.eclipse.update.core (3.1.1) "Install/Update Core" [Resolved]
org.eclipse.update.core.win32 (3.1.0) "Install/Update Core for Windows" [Resolved]
org.eclipse.update.scheduler (3.1.0) "Automatic Updates Scheduler" [Active]
org.eclipse.update.ui (3.1.1) "Install/Update UI" [Resolved]
org.epic.regexp (0.1.4) "Regexp Plug-in" [Resolved]
org.junit (3.8.1) "JUnit Testing Framework" [Resolved]
org.kxml2 (2.1.4) "Kxml2" [Resolved]
org.objectweb.asm (2.1.0) "ASM Framework" [Resolved]
org.rubypeople.rdt (0.6.0) "Ruby Development Tools" [Resolved]
org.rubypeople.rdt.core (0.6.0) "Ruby Development Tools Core" [Resolved]
org.rubypeople.rdt.debug.core (0.6.0) "Ruby Development Debug Core" [Resolved]
org.rubypeople.rdt.debug.ui (0.6.0) "Ruby Development Tools Debug UI" [Resolved]
org.rubypeople.rdt.doc.user (0.6.0) "Ruby Development Documentation" [Resolved]
org.rubypeople.rdt.launching (0.6.0) "Ruby Development Tools Launching Support" [Resolved]
org.rubypeople.rdt.source (0.6.0) "pluginName" [Resolved]
org.rubypeople.rdt.testunit (0.6.0) "Ruby Development Tools Test::Unit support" [Resolved]
org.rubypeople.rdt.ui (0.6.0) "Ruby Development Tools UI" [Resolved]
org.testng.eclipse (4.2.0.0) "TestNG Eclipse Support" [Resolved]
system.bundle (3.1.1) "OSGi System Bundle" [Active]

*** User Preferences:
#Sat Nov 26 17:21:44 CST 2005
/instance/net.sourceforge.phpeclipse/fontPropagated=true
/instance/org.eclipse.jdt.core/org.eclipse.jdt.core.builder.resourceCopyExclusionFilter=*.launch
/instance/org.eclipse.jdt.ui/org.eclipse.jdt.internal.ui.PackageExplorer.EmptyPackageFilter=true
/project/AspectJ\ cookbook/org.eclipse.ajdt.core/org.aspectj.ajdt.core.compiler.lint.invalidTargetForAnnotation=warning
/instance/org.eclipse.jdt.ui/org.eclipse.jdt.ui.PackageExplorer.ImportDeclarationFilter=true
/project/AspectJ\ cookbook/org.eclipse.ajdt.core/org.aspectj.ajdt.core.compiler.weaver.XSerializableAspects=false
/instance/org.eclipse.jdt.core/org.eclipse.jdt.core.compiler.problem.unusedDeclaredThrownException=ignore
/project/Java\ Instrument/org.eclipse.jdt.ui/internal.default.compliance=default
/instance/org.eclipse.team.cvs.ui/pref_text_ksubst=-kk
/instance/org.eclipse.jdt.ui/content_assist_guess_method_arguments=true
/instance/org.eclipse.ajdt.ui//doneAutoOpenXRefViewC\:/workspace=true
/project/AspectJ\ -\ HelloWorld/org.eclipse.jdt.core/org.eclipse.jdt.core.compiler.problem.enumIdentifier=warning
/project/AspectJ\ cookbook/org.eclipse.ajdt.core/org.aspectj.ajdt.core.compiler.weaver.XNoInline=false
/instance/org.eclipse.jdt.core/org.eclipse.jdt.core.codeComplete.discouragedReferenceCheck=disabled
/instance/org.rubypeople.rdt.ui/useAnnotationsPrefPage=true
/instance/org.eclipse.jdt.ui/org.eclipse.jdt.ui.text.custom_code_templates=&lt;?xml version\="1.0" encoding\="UTF-8"?&gt;\r\n&lt;templates/&gt;
/project/AspectJ\ -\ HelloWorld/org.eclipse.jdt.core/org.eclipse.jdt.core.compiler.source=1.3
/instance/org.eclipse.ui.ide/platformState=547
@org.eclipse.ui.ide=3.1.1
@org.eclipse.jdt.core=3.1.1
/instance/org.eclipse.jdt.core/org.eclipse.jdt.core.classpathVariable.ECLIPSE_HOME=c\:/Eclipse/3.11/eclipse
/instance/org.eclipse.jdt.core/org.eclipse.jdt.core.compiler.problem.unusedImport=warning
@org.eclipse.team.core=3.1.1
/project/AspectJ\ cookbook/org.eclipse.ajdt.core/org.aspectj.ajdt.core.compiler.lint.annotationAsTargetForDecpIgnored=warning
/instance/org.eclipse.jdt.core/org.eclipse.jdt.core.compiler.taskPriorities=NORMAL,HIGH,NORMAL
/instance/org.eclipse.jdt.ui/org.eclipse.jdt.ui.PackageExplorer_patternFilterId_.*=true
/instance/org.eclipse.jdt.ui/org.eclipse.jdt.ui.javadoclocations.migrated=true
/project/Java\ Instrument/org.eclipse.jdt.core/org.eclipse.jdt.core.compiler.problem.assertIdentifier=error
/project/db4o\ 5.0\ examples/org.eclipse.jdt.ui/internal.default.compliance=default
/configuration/org.eclipse.ui.ide/SHOW_WORKSPACE_SELECTION_DIALOG=false
/project/Java\ 1.5\ Tiger\ aspects/org.eclipse.ajdt.ui/org.eclipse.ajdt.ui.inPath1=/Java 1.5 Tiger
/project/db4o\ 5.0\ examples/org.eclipse.jdt.core/org.eclipse.jdt.core.compiler.debug.sourceFile=generate
/project/AspectJ\ -\ HelloWorld/org.eclipse.jdt.core/org.eclipse.jdt.core.compiler.debug.lineNumber=generate
@org.eclipse.update.ui=3.1.1
/project/AspectJ\ cookbook/org.eclipse.ajdt.core/org.aspectj.ajdt.core.compiler.list.UnmatchedSuperTypeInCall=warning
/instance/org.eclipse.jdt.core/org.eclipse.jdt.core.codeComplete.visibilityCheck=enabled
/instance/org.eclipse.jdt.ui/hoverModifierMasks=org.eclipse.jdt.ui.BestMatchHover;0;zorg.eclipse.ajdt.ui.PointcutSourceHover;0;org.eclipse.jdt.internal.debug.ui.JavaDebugHover;0;org.eclipse.jdt.ui.ProblemHover;0;org.eclipse.jdt.ui.NLStringHover;0;org.eclipse.jdt.ui.JavadocHover;0;org.eclipse.jdt.ui.JavaSourceHover;262144;org.eclipse.jdt.ui.AnnotationHover;0;
/instance/org.eclipse.ant.ui/useQuickDiffPrefPage=true
/instance/org.eclipse.jdt.core/org.eclipse.jdt.core.compiler.problem.missingDeprecatedAnnotation=ignore
/project/Java\ 1.5\ Tiger\ aspects/org.eclipse.jdt.core/org.eclipse.jdt.core.compiler.problem.assertIdentifier=error
/project/Java\ Instrument/org.eclipse.jdt.core/org.eclipse.jdt.core.compiler.codegen.targetPlatform=1.5
/instance/org.eclipse.debug.core/prefWatchExpressions=&lt;?xml version\="1.0" encoding\="UTF-8"?&gt;\r\n&lt;watchExpressions&gt;\r\n&lt;expression text\="alpha" enabled\="true"/&gt;\r\n&lt;expression text\="beta" enabled\="true"/&gt;\r\n&lt;expression text\="compatible" enabled\="true"/&gt;\r\n&lt;expression text\="instance" enabled\="true"/&gt;\r\n&lt;/watchExpressions&gt;\r\n
@org.eclipse.team.ui=3.1.1
/instance/org.eclipse.jdt.launching/org.eclipse.jdt.launching.PREF_VM_XML=&lt;?xml version\="1.0" encoding\="UTF-8"?&gt;\r\n&lt;vmSettings defaultVM\="57,org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType13,1128059437582" defaultVMConnector\=""&gt;\r\n&lt;vmType id\="org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType"&gt;\r\n&lt;vm id\="0" name\="jre1.5.0_05" path\="C\:\\Java\\jre1.5.0_05" javadocURL\="http\://java.sun.com/j2se/1.5.0/docs/api/"/&gt;\r\n&lt;vm id\="1128059437582" name\="Jdk 1.5.0_05" path\="C\:\\Java\\jdk1.5.0_05" javadocURL\="http\://java.sun.com/j2se/1.5.0/docs/api/"/&gt;\r\n&lt;vm id\="1128226873366" name\="jre 1.4.2_09" path\="C\:\\j2sdk1.4.2_09" javadocURL\="http\://java.sun.com/j2se/1.4.2/docs/api/"/&gt;\r\n&lt;vm id\="1132238290960" name\="jdk1.3.1_15" path\="C\:\\jdk1.3.1_15" javadocURL\="http\://java.sun.com/j2se/1.3/docs/api/"/&gt;\r\n&lt;/vmType&gt;\r\n&lt;/vmSettings&gt;\r\n
/instance/org.eclipse.jdt.core/org.eclipse.jdt.core.compiler.problem.noEffectAssignment=warning
/instance/org.eclipse.team.cvs.ui/pref_first_startup=false
/instance/net.sourceforge.phpeclipse.webbrowser/browsers=&lt;?xml version\="1.0" encoding\="UTF-8"?&gt;\r\n&lt;web-browsers current\="0"&gt;\r\n&lt;internal new_page\="false" clear_history\="false"/&gt;\r\n&lt;external name\="Internet Explorer" location\="C\:\\Program Files\\Internet Explorer\\IEXPLORE.EXE" parameters\=""/&gt;\r\n&lt;/web-browsers&gt;
/instance/org.eclipse.jdt.ui/content_assist_insert_completion=true
/instance/org.eclipse.jdt.core/org.eclipse.jdt.core.codeComplete.forbiddenReferenceCheck=enabled
/instance/org.eclipse.jdt.core/org.eclipse.jdt.core.compiler.problem.hiddenCatchBlock=warning
/instance/org.eclipse.ui.ide/quickStart=true
/instance/org.eclipse.ajdt.ui/DontInformUserAboutFileFilter=true
/instance/org.eclipse.jdt.ui/content_assist_order_proposals=false
/project/AspectJ\ cookbook/org.eclipse.ajdt.core/org.aspectj.ajdt.core.compiler.lint.CannotImplementLazyTJP=ignore
\!/=
/project/AspectJ\ -\ HelloWorld/org.eclipse.jdt.core/org.eclipse.jdt.core.compiler.debug.localVariable=generate
/instance/org.eclipse.jdt.core/org.eclipse.jdt.core.compiler.problem.autoboxing=ignore
@org.eclipse.search=3.1.1
/instance/org.eclipse.jdt.core/org.eclipse.jdt.core.compiler.source=1.5
@org.eclipse.contribution.visualiser=2.2.0.20051125115230
/instance/org.eclipse.jdt.core/org.eclipse.jdt.core.compiler.taskCaseSensitive=enabled
@org.rubypeople.rdt.core=0.6.0
/instance/org.eclipse.ui.ide/tipsAndTricks=true
/instance/org.rubypeople.rdt.core/org.rubypeople.rdt.core.compiler.taskPriorities=NORMAL,HIGH,NORMAL
/instance/org.eclipse.jdt.ui/tabWidthPropagated=true
/project/AspectJ\ cookbook/org.eclipse.ajdt.core/org.aspectj.ajdt.core.compiler.lint.NeedSerialVersionUIDField=ignore
/instance/org.rubypeople.rdt.ui/org.rubypeople.rdt.ui.customtemplates=&lt;?xml version\="1.0" encoding\="UTF-8"?&gt;\r\n&lt;templates/&gt;
/project/AspectJ\ -\ HelloWorld/org.eclipse.jdt.core/org.eclipse.jdt.core.compiler.codegen.unusedLocal=preserve
/project/Java\ 1.5\ Tiger/org.eclipse.jdt.core/org.eclipse.jdt.core.compiler.codegen.inlineJsrBytecode=enabled
/instance/org.eclipse.ui.editors/overviewRuler_migration=migrated_3.1
/project/AspectJ\ -\ HelloWorld/org.eclipse.jdt.core/org.eclipse.jdt.core.compiler.compliance=1.4
/instance/org.eclipse.team.core/file_types=cvsignore\n1\nproduct\n1\ntif\n2\naj\n1\ntiff\n2\nmxsd\n1\nhtml\n1\ngif\n2\nprefs\n1\nxml\n1\nico\n2\nproperties\n1\nexsd\n1\nMF\n1\nppt\n2\njpage\n1\nbmp\n2\nso\n2\npdf\n2\nxsl\n1\nini\n1\nzip\n2\njardesc\n1\nhtm\n1\nexe\n2\ndll\n2\njar\n2\nclass\n2\noptions\n1\nclasspath\n1\ntxt\n1\ndoc\n2\njava\n1\njpeg\n2\nproject\n1\npng\n2\nxls\n2\njpg\n2\najmap\n2\nlaunch\n1\n
/instance/org.eclipse.jdt.ui/org.eclipse.jdt.ui.PackageExplorer.LibraryFilter=true
/project/Java\ 1.5\ Tiger/org.eclipse.jdt.core/org.eclipse.jdt.core.compiler.problem.enumIdentifier=error
@org.eclipse.ui.workbench=3.1.1
/instance/org.eclipse.jdt.ui/org.eclipse.jdt.ui.text.code_templates_migrated=true
/instance/org.eclipse.jdt.core/org.eclipse.jdt.core.compiler.problem.unusedPrivateMember=warning
/project/Java\ 1.5\ Tiger\ aspects/org.eclipse.ajdt.ui/org.eclipse.ajdt.ui.inPath.contentKind1=BINARY
/instance/org.eclipse.jdt.core/org.eclipse.jdt.core.compiler.problem.unusedParameterWhenOverridingConcrete=disabled
/project/AspectJ\ cookbook/org.eclipse.ajdt.core/org.aspectj.ajdt.core.compiler.lint.NoInterfaceCtorJoinpoint=warning
/instance/org.eclipse.jdt.core/org.eclipse.jdt.core.classpathVariable.JRE_LIB=C\:/Java/jdk1.5.0_05/jre/lib/rt.jar
/instance/org.eclipse.jdt.core/org.eclipse.jdt.core.compiler.problem.unusedLocal=warning
/project/AspectJ\ cookbook/org.eclipse.ajdt.core/org.aspectj.ajdt.core.compiler.lint.elementAlreadyAnnotated=warning
/project/AspectJ\ cookbook/org.eclipse.ajdt.core/org.aspectj.ajdt.core.compiler.lint.InvalidAbsoluteTypeName=warning
/instance/org.eclipse.jdt.ui/content_assist_prefix_completion=false
/instance/org.eclipse.jdt.ui/content_assist_show_visible_proposals=true
/project/AspectJ\ cookbook/org.eclipse.jdt.ui/internal.default.compliance=default
/project/Java\ 1.5\ Tiger\ aspects/org.eclipse.jdt.core/org.eclipse.jdt.core.compiler.problem.enumIdentifier=error
/project/AspectJ\ cookbook/org.eclipse.ajdt.core/org.aspectj.ajdt.core.compiler.lint.enumAsTargetForDecpIgnored=warning
/project/AspectJ\ cookbook/org.eclipse.ajdt.core/org.aspectj.ajdt.core.compiler.lint.WildcardTypeName=ignore
/instance/org.eclipse.ajdt.ui/org.aspectj.ajdt.core.compiler.BuildOptions.showweavemessages=true
/instance/org.eclipse.jdt.core/org.eclipse.jdt.core.compiler.problem.syntheticAccessEmulation=ignore
@org.eclipse.ant.ui=3.1.1
/instance/org.eclipse.jdt.core/org.eclipse.jdt.core.compiler.problem.noImplicitStringConversion=warning
/project/db4o\ 5.0\ examples/org.eclipse.jdt.core/org.eclipse.jdt.core.compiler.debug.lineNumber=generate
/instance/org.eclipse.ui/showIntro=false
/instance/org.eclipse.update.ui/ConfigurationView.showUnconf=true
/project/db4o\ 5.0\ examples/org.eclipse.jdt.core/org.eclipse.jdt.core.compiler.problem.enumIdentifier=error
/instance/org.eclipse.ui.editors/quickdiff.quickDiff=false
/instance/org.rubypeople.rdt.ui/rdocDirectoryPath=C\:\\tools\\ruby\\bin\\rdoc.bat
/instance/org.eclipse.jdt.core/org.eclipse.jdt.core.compiler.problem.overridingPackageDefaultMethod=warning
@org.rubypeople.rdt.debug.ui=0.6.0
/instance/org.eclipse.team.ui/org.eclipse.team.ui.first_time=false
/project/AspectJ\ cookbook/org.eclipse.ajdt.core/org.aspectj.ajdt.core.compiler.lint.ShadowNotInStructure=ignore
/instance/org.eclipse.jdt.ui/org.eclipse.ajdt.javamodel.FileFilter=true
/instance/org.rubypeople.rdt.ui/useQuickDiffPrefPage=true
/instance/org.eclipse.jdt.ui/org.eclipse.jdt.ui.gettersetter.use.is=true
@org.eclipse.ui.browser=3.1.1
/project/Java\ Instrument/org.eclipse.jdt.core/org.eclipse.jdt.core.compiler.compliance=1.5
/instance/org.eclipse.jdt.core/org.eclipse.jdt.core.compiler.problem.annotationSuperInterface=warning
/instance/org.eclipse.jdt.ui/content_assist_autoinsert=true
/instance/org.eclipse.help.ui/browser.maximized=false
/instance/org.eclipse.pde.core/platform_path=c\:\\Eclipse\\3.11\\eclipse
/configuration/org.eclipse.ui.ide/RECENT_WORKSPACES_PROTOCOL=2
/instance/org.eclipse.jdt.core/org.eclipse.jdt.core.compiler.problem.finallyBlockNotCompletingNormally=warning
/instance/org.eclipse.jdt.core/org.eclipse.jdt.core.compiler.problem.discouragedReference=warning
/instance/org.eclipse.jdt.core/org.eclipse.jdt.core.compiler.problem.typeParameterHiding=warning
/project/AspectJ\ -\ HelloWorld/org.eclipse.jdt.core/org.eclipse.jdt.core.compiler.codegen.targetPlatform=1.2
/instance/org.eclipse.ajdt.ui/ajde.version.at.previous.startup=@AJDEVERSION@
/instance/org.eclipse.jdt.ui/matchingBracketsColor=128,128,64
/instance/org.eclipse.jdt.ui/useQuickDiffPrefPage=true
/instance/org.eclipse.jdt.core/org.eclipse.jdt.core.codeComplete.localPrefixes=
/project/AspectJ\ -\ HelloWorld/org.eclipse.jdt.core/org.eclipse.jdt.core.compiler.codegen.inlineJsrBytecode=enabled
/instance/org.eclipse.jdt.core/org.eclipse.jdt.core.compiler.problem.methodWithConstructorName=warning
/instance/org.eclipse.contribution.visualiser/org.eclipse.contribution.visualiser.preferences.renderer=Default
/project/Java\ Instrument/org.eclipse.jdt.core/org.eclipse.jdt.core.compiler.debug.localVariable=generate
/instance/org.eclipse.core.resources/description.autobuilding=false
/instance/org.eclipse.jdt.core/org.eclipse.jdt.core.compiler.problem.unqualifiedFieldAccess=ignore
/instance/org.eclipse.jdt.ui/org.eclipse.jdt.internal.ui.PackageExplorer.EmptyInnerPackageFilter=true
/project/AspectJ\ cookbook/org.eclipse.ajdt.core/org.aspectj.ajdt.core.compiler.lint.runtimeExceptionNotSoftened=warning
/instance/org.eclipse.jdt.core/org.eclipse.jdt.core.compiler.problem.assertIdentifier=error
/project/Java\ 1.5\ Tiger/org.eclipse.jdt.core/org.eclipse.jdt.core.compiler.debug.sourceFile=generate
/instance/org.eclipse.team.ui/org.eclipse.team.ui.syncview_default_perspective=org.eclipse.jdt.ui.JavaPerspective
@org.eclipse.jdt.ui=3.1.1
/instance/org.eclipse.jdt.core/org.eclipse.jdt.core.classpathVariable.ASPECTJRT_LIB=c\:/Eclipse/3.11/eclipse/plugins/org.aspectj.runtime_1.5.0.20051125115230/aspectjrt.jar
/instance/org.eclipse.jdt.core/org.eclipse.jdt.core.compiler.problem.fieldHiding=ignore
/project/Java\ Instrument/org.eclipse.jdt.core/org.eclipse.jdt.core.compiler.codegen.unusedLocal=preserve
/instance/org.eclipse.jdt.core/org.eclipse.jdt.core.codeComplete.localSuffixes=
/instance/org.eclipse.jdt.ui/spelling_locale=en_US
@org.eclipse.jdt.debug.ui=3.1.1
/instance/org.eclipse.jdt.ui/useAnnotationsPrefPage=true
/instance/org.eclipse.jdt.ui/content_assist_fill_method_arguments=true
/instance/org.eclipse.jdt.core/org.eclipse.jdt.core.codeComplete.argumentPrefixes=
/configuration/org.eclipse.ui.ide/RECENT_WORKSPACES=C\:\\workspace
/instance/org.eclipse.jdt.core/org.eclipse.jdt.core.compiler.problem.specialParameterHidingField=disabled
/project/Java\ 1.5\ Tiger\ aspects/org.eclipse.jdt.core/org.eclipse.jdt.core.compiler.compliance=1.5
/instance/org.eclipse.jdt.core/org.eclipse.jdt.core.compiler.problem.unnecessaryElse=ignore
/instance/org.eclipse.jdt.ui/org.eclipse.jdt.ui.formatterprofiles.version=8
/instance/org.eclipse.jdt.ui/MemberFilterActionGroup.HierarchyMethodView.4=true
/instance/org.eclipse.jdt.ui/MemberFilterActionGroup.HierarchyMethodView.2=true
/instance/org.eclipse.jdt.ui/internal.default.compliance=default
/project/db4o\ 5.0\ examples/org.eclipse.jdt.core/org.eclipse.jdt.core.compiler.compliance=1.5
@org.eclipse.help.base=3.1.0
/project/Java\ Instrument/org.eclipse.jdt.core/org.eclipse.jdt.core.compiler.debug.sourceFile=generate
/instance/org.eclipse.jdt.debug.ui/org.eclipse.debug.ui.ExpressionView.org.eclipse.jdt.debug.ui.show_null_entries=true
/instance/org.eclipse.jdt.core/org.eclipse.jdt.core.compiler.problem.incompleteEnumSwitch=ignore
/instance/org.eclipse.jdt.core/org.eclipse.jdt.core.compiler.problem.undocumentedEmptyBlock=ignore
/instance/org.eclipse.jdt.ui/org.eclipse.jdt.ui.wizards.srcBinFoldersInNewProjects=true
file_export_version=3.0
/instance/org.eclipse.jdt.core/org.eclipse.jdt.core.codeComplete.argumentSuffixes=
/project/Java\ 1.5\ Tiger\ aspects/org.eclipse.ajdt.ui/org.eclipse.ajdt.ui.inPath.entryKind1=LIBRARY
/instance/org.eclipse.jdt.core/org.eclipse.jdt.core.classpathVariable.JUNIT_HOME=c\:/Eclipse/3.11/eclipse/plugins/org.junit_3.8.1
/project/AspectJ\ cookbook/org.eclipse.ajdt.core/org.eclipse.ajdt.core.compiler.useProjectSettings=true
/project/Java\ 1.5\ Tiger/org.eclipse.jdt.core/org.eclipse.jdt.core.compiler.problem.assertIdentifier=error
/instance/org.eclipse.jdt.core/org.eclipse.jdt.core.codeComplete.staticFieldPrefixes=
/project/Java\ 1.5\ Tiger/org.eclipse.jdt.core/org.eclipse.jdt.core.compiler.debug.lineNumber=generate
@org.eclipse.ajdt.ui=1.3.0.20051125115230
@org.rubypeople.rdt.ui=0.6.0
/configuration/org.eclipse.ui.ide/MAX_RECENT_WORKSPACES=5
/project/AspectJ\ cookbook/org.eclipse.ajdt.core/org.aspectj.ajdt.core.compiler.lint.adviceDidNotMatch=warning
/instance/org.eclipse.ui.browser/browsers=&lt;?xml version\="1.0" encoding\="UTF-8"?&gt;\r\n&lt;web-browsers current\="0"&gt;\r\n&lt;system/&gt;\r\n&lt;external name\="Firefox" location\="C\:\\Program Files\\Mozilla Firefox\\firefox.exe"/&gt;\r\n&lt;external name\="Internet Explorer" location\="C\:\\Program Files\\Internet Explorer\\iexplore.exe"/&gt;\r\n&lt;/web-browsers&gt;
/project/AspectJ\ cookbook/org.eclipse.ajdt.core/org.aspectj.ajdt.core.compiler.BuildOptions.incrementalMode=false
/instance/net.sourceforge.phpeclipse/org.eclipse.jface.textfont=1|Courier New|10|0|WINDOWS|1|0|0|0|0|0|0|0|0|1|0|0|0|0|Courier New;
/instance/org.eclipse.ant.ui/useAnnotationsPrefPage=true
/project/db4o\ 5.0\ examples/org.eclipse.jdt.core/org.eclipse.jdt.core.compiler.source=1.5
/instance/org.eclipse.jdt.ui/content_assist_case_sensitivity=false
/project/Java\ 1.5\ Tiger/org.eclipse.jdt.core/org.eclipse.jdt.core.compiler.codegen.targetPlatform=1.5
/instance/org.eclipse.jdt.core/org.eclipse.jdt.core.compiler.problem.enumIdentifier=error
/instance/org.eclipse.jdt.core/org.eclipse.jdt.core.codeComplete.staticFieldSuffixes=
/project/AspectJ\ -\ HelloWorld/org.eclipse.jdt.core/org.eclipse.jdt.core.compiler.problem.assertIdentifier=warning
/instance/org.eclipse.jdt.ui/org.eclipse.jdt.ui.editor.tab.width=
/project/Java\ 1.5\ Tiger\ aspects/org.eclipse.jdt.core/org.eclipse.jdt.core.compiler.codegen.targetPlatform=1.5
/project/Java\ 1.5\ Tiger/org.eclipse.jdt.core/org.eclipse.jdt.core.compiler.source=1.5
/project/Java\ 1.5\ Tiger/org.eclipse.jdt.core/org.eclipse.jdt.core.compiler.compliance=1.5
/project/AspectJ\ cookbook/org.eclipse.ajdt.core/org.aspectj.ajdt.core.compiler.BuildOptions.showweavemessages=true
/instance/org.eclipse.jdt.core/org.eclipse.jdt.core.compiler.problem.unhandledWarningToken=warning
/instance/org.eclipse.jdt.ui/content_assist_autoactivation_triggers_javadoc=@\#
/instance/org.eclipse.jdt.core/org.eclipse.jdt.core.compiler.compliance=1.5
/instance/net.sourceforge.phpeclipse.webbrowser/internalWebBrowserOldFavorites=PHPEclipse|*|http\://www.phpeclipse.de|*|Plog4U.org|*|http\://www.plog4u.org|*|Plog4U.de|*|http\://www.plog4u.de|*|Eclipse|*|http\://www.eclipse.org|*|EclipseProject.de|*|http\://www.eclipseproject.de|*|JSurfer.org|*|http\://www.jsurfer.org|*|
/instance/org.eclipse.jdt.core/org.eclipse.jdt.core.compiler.problem.missingOverrideAnnotation=ignore
/project/db4o\ 5.0\ examples/org.eclipse.jdt.core/org.eclipse.jdt.core.compiler.codegen.targetPlatform=1.5
/instance/org.rubypeople.rdt.debug.ui/org.rubypeople.rdt.debug.ui.evaluationExpressions=&lt;?xml version\="1.0" encoding\="UTF-8"?&gt;\r\n&lt;expressions&gt;&lt;expression name\="global variable names" description\="Show global variable names"&gt;global_variables  &lt;/expression&gt;&lt;expression name\="global variables" description\="Global variables"&gt;h\={}; global_variables.each { |v| h[v] \= eval(v) }; h  &lt;/expression&gt;&lt;expression name\="instance methods incl. inherited" description\="instance methods, including methods from superclasses"&gt;%s.class.instance_methods(true).sort  &lt;/expression&gt;&lt;expression name\="instance methods excl. inherited" description\="instance methods of the methods from superclasses"&gt;%s.class.instance_methods(false).sort  &lt;/expression&gt;&lt;expression name\="All constants" description\="Show all constants"&gt;Module.constants.sort  &lt;/expression&gt;&lt;expression name\="Ancestors" description\="Shows all ancestors of a module"&gt;(%s.respond_to? \:ancestors) ? %s.ancestors \: %s.class.ancestors  &lt;/expression&gt;&lt;/expressions&gt;
/instance/org.eclipse.jdt.core/org.eclipse.jdt.core.compiler.problem.indirectStaticAccess=ignore
/project/AspectJ\ cookbook/org.eclipse.ajdt.core/org.aspectj.ajdt.core.compiler.weaver.XHasMember=false
/instance/org.rubypeople.rdt.core/org.rubypeople.rdt.core.compiler.taskCaseSensitive=enabled
/instance/org.eclipse.contribution.visualiser/org.eclipse.contribution.visualiser.preferences.provider=AspectJ Provider
/instance/org.eclipse.help.ui/browser.y=103
/instance/org.eclipse.jdt.core/org.eclipse.jdt.core.compiler.problem.possibleAccidentalBooleanAssignment=ignore
/instance/org.eclipse.help.ui/browser.x=101
/instance/org.eclipse.jdt.ui/org.eclipse.jdt.ui.PackageExplorer.NonJavaElementFilter=true
/instance/org.eclipse.help.ui/browser.w=1024
/project/AspectJ\ cookbook/org.eclipse.ajdt.core/org.aspectj.ajdt.core.compiler.weaver.XNotReweavable=false
/project/Java\ Instrument/org.eclipse.jdt.core/org.eclipse.jdt.core.compiler.debug.lineNumber=generate
@org.eclipse.ui.editors=3.1.1
/project/Java\ 1.5\ Tiger/org.eclipse.jdt.ui/internal.default.compliance=default
/instance/org.eclipse.search/org.eclipse.search.defaultPerspective=org.eclipse.search.defaultPerspective.none
/instance/org.eclipse.core.resources/version=1
/instance/org.eclipse.jdt.ui/LexicalSortingAction.isChecked=true
/instance/org.eclipse.jdt.core/org.eclipse.jdt.core.compiler.problem.unnecessaryTypeCheck=ignore
/project/AspectJ\ cookbook/org.eclipse.ajdt.core/org.aspectj.ajdt.core.compiler.lint.cantMatchArrayTypeOnVarargs=ignore
/instance/org.eclipse.help.ui/browser.h=740
/project/AspectJ\ cookbook/org.eclipse.ajdt.core/org.aspectj.ajdt.core.compiler.lint.UnresolvableMember=warning
@org.eclipse.debug.core=3.1.0
@org.eclipse.core.resources=3.1.0
/instance/net.sourceforge.phpeclipse.webbrowser/internalWebBrowserFavorites=PHPEclipse|*|http\://www.phpeclipse.de|*|Plog4U.org|*|http\://www.plog4u.org|*|Plog4U.de|*|http\://www.plog4u.de|*|Eclipse|*|http\://www.eclipse.org|*|EclipseProject.de|*|http\://www.eclipseproject.de|*|JSurfer.org|*|http\://www.jsurfer.org|*|
/instance/org.eclipse.jdt.ui/org.eclipse.jdt.ui.PackageExplorer.PackageDeclarationFilter=true
/instance/org.eclipse.jdt.ui/org.eclipse.jface.textfont=1|Courier New|10|0|WINDOWS|1|0|0|0|0|0|0|0|0|1|0|0|0|0|Courier New;
@org.eclipse.jdt.launching=3.1.0
@org.eclipse.team.cvs.ui=3.1.1
/instance/org.eclipse.jdt.debug.ui/org.eclipse.debug.ui.VariableView.org.eclipse.jdt.debug.ui.show_null_entries=true
/instance/org.eclipse.jdt.core/org.eclipse.jdt.core.classpathVariable.JRE_SRCROOT=
/instance/org.rubypeople.rdt.core/org.rubypeople.rdt.core.compiler.taskTags=TODO,FIXME,XXX
/instance/org.eclipse.jdt.ui/fontPropagated=true
/project/Java\ Instrument/org.eclipse.jdt.core/org.eclipse.jdt.core.compiler.problem.enumIdentifier=error
/instance/org.eclipse.jdt.ui/command=C\:\\Java\\jdk1.5.0_05\\bin\\javadoc.exe
/project/Java\ Instrument/org.eclipse.jdt.core/org.eclipse.jdt.core.compiler.codegen.inlineJsrBytecode=enabled
/project/db4o\ 5.0\ examples/org.eclipse.jdt.core/org.eclipse.jdt.core.compiler.debug.localVariable=generate
/instance/org.eclipse.jdt.ui/lastRecentlyUsedFilters=org.eclipse.ajdt.javamodel.FileFilter,org.eclipse.jdt.ui.PackageExplorer.NonJavaElementFilter,
/instance/org.eclipse.jdt.core/org.eclipse.jdt.core.compiler.problem.suppressWarnings=enabled
/project/Java\ 1.5\ Tiger/org.eclipse.jdt.core/org.eclipse.jdt.core.compiler.debug.localVariable=generate
/instance/org.eclipse.jdt.ui/org.eclipse.jdt.ui.PackageExplorer.SyntheticMembersFilter=true
/instance/org.eclipse.jdt.core/org.eclipse.jdt.core.compiler.problem.unusedParameterWhenImplementingAbstract=disabled
/instance/org.eclipse.jdt.ui/org.eclipse.jdt.ui.exception.name=e
/instance/org.eclipse.jdt.ui/content_assist_autoactivation_triggers_java=.
/instance/org.eclipse.jdt.core/org.eclipse.jdt.core.compiler.problem.uncheckedTypeOperation=warning
/project/db4o\ 5.0\ examples/org.eclipse.jdt.core/org.eclipse.jdt.core.compiler.codegen.unusedLocal=preserve
/instance/org.eclipse.jdt.ui/hoverModifiers=org.eclipse.jdt.ui.BestMatchHover;0;zorg.eclipse.ajdt.ui.PointcutSourceHover;\!0;org.eclipse.jdt.internal.debug.ui.JavaDebugHover;\!0;org.eclipse.jdt.ui.ProblemHover;\!0;org.eclipse.jdt.ui.NLStringHover;\!0;org.eclipse.jdt.ui.JavadocHover;\!0;org.eclipse.jdt.ui.JavaSourceHover;Ctrl;org.eclipse.jdt.ui.AnnotationHover;\!0;
/instance/org.eclipse.jdt.ui/org.eclipse.jdt.ui.packages.linktoeditor=true
/project/Java\ 1.5\ Tiger/org.eclipse.jdt.core/org.eclipse.jdt.core.compiler.codegen.unusedLocal=preserve
/instance/org.eclipse.jdt.core/org.eclipse.jdt.core.compiler.problem.deprecationWhenOverridingDeprecatedMethod=disabled
/project/AspectJ\ cookbook/org.eclipse.ajdt.core/org.aspectj.ajdt.core.compiler.BuildOptions.buildAsm=true
/project/Java\ 1.5\ Tiger\ aspects/org.eclipse.jdt.core/org.eclipse.jdt.core.compiler.source=1.5
/project/db4o\ 5.0\ examples/org.eclipse.jdt.core/org.eclipse.jdt.core.compiler.codegen.inlineJsrBytecode=enabled
/instance/org.eclipse.jdt.core/org.eclipse.jdt.core.compiler.problem.localVariableHiding=ignore
/instance/org.eclipse.jdt.core/org.eclipse.jdt.core.compiler.problem.unusedDeclaredThrownExceptionWhenOverriding=disabled
/instance/org.eclipse.jdt.core/org.eclipse.jdt.core.codeComplete.fieldPrefixes=
/instance/org.eclipse.jdt.ui/content_assist_add_import=true
/project/db4o\ 5.0\ examples/org.eclipse.jdt.core/org.eclipse.jdt.core.compiler.problem.assertIdentifier=error
/instance/org.eclipse.jdt.ui/org.eclipse.jdt.ui.text.templates_migrated=true
/instance/org.eclipse.jdt.core/org.eclipse.jdt.core.compiler.problem.deprecation=warning
/instance/org.eclipse.jdt.core/org.eclipse.jdt.core.compiler.problem.deprecationInDeprecatedCode=disabled
/instance/org.eclipse.jdt.ui/org.eclipse.jdt.ui.overrideannotation=true
/instance/org.eclipse.jdt.core/org.eclipse.jdt.core.compiler.problem.emptyStatement=ignore
/instance/org.eclipse.jdt.ui/content_assist_autoactivation=true
/instance/org.eclipse.ui.workbench/ENABLED_DECORATORS=com.rational.resourcemanagement.cmui.decorator\:true,org.eclipse.ajdt.buildconfig.decorator\:true,org.eclipse.jdt.ui.override.decorator\:true,org.eclipse.pde.ui.binaryProjectDecorator\:false,org.eclipse.team.cvs.ui.decorator\:true,org.eclipse.ui.LinkedResourceDecorator\:true,
/instance/org.eclipse.jdt.ui/_patternFilterId_*.ajsym=true
/project/Java\ Instrument/org.eclipse.jdt.core/org.eclipse.jdt.core.compiler.source=1.5
/instance/org.eclipse.jdt.core/org.eclipse.jdt.core.compiler.problem.incompatibleNonInheritedInterfaceMethod=warning
/instance/org.eclipse.jdt.core/org.eclipse.jdt.core.compiler.codegen.inlineJsrBytecode=enabled
/instance/org.eclipse.jdt.ui/CustomFiltersActionGroup.org.eclipse.jdt.ui.PackageExplorer.TAG_DUMMY_TO_TEST_EXISTENCE=storedViewPreferences
/instance/org.eclipse.jdt.core/org.eclipse.jdt.core.compiler.taskTags=TODO,FIXME,XXX
/instance/org.eclipse.jdt.core/org.eclipse.jdt.core.codeComplete.fieldSuffixes=
/project/AspectJ\ cookbook/org.eclipse.ajdt.core/org.aspectj.ajdt.core.compiler.lint.noJoinpointsForBridgeMethods=warning
/project/Tracing\ Example/org.eclipse.ajdt.ui/org.eclipse.ajdt.ui.activeBuildConfiguration=notrace.ajproperties
/project/AspectJ\ cookbook/org.eclipse.ajdt.core/org.aspectj.ajdt.core.compiler.lint.BrokeSerialVersionCompatibility=ignore
/instance/org.eclipse.jdt.core/org.eclipse.jdt.core.compiler.codegen.targetPlatform=1.5
/project/AspectJ\ cookbook/org.eclipse.ajdt.core/org.aspectj.ajdt.core.compiler.weaver.NoWeave=false
/instance/org.eclipse.jdt.ui/org.eclipse.jdt.ui.PackageExplorer_patternFilterId_*$*.class=true
/instance/org.eclipse.jdt.core/org.eclipse.jdt.core.compiler.problem.missingSerialVersion=warning
/instance/org.eclipse.jdt.core/org.eclipse.jdt.core.compiler.problem.varargsArgumentNeedCast=warning
/instance/org.eclipse.jdt.ui/MemberFilterActionGroup.org.eclipse.jdt.ui.JavaOutlinePage.2=true
/instance/org.eclipse.jdt.ui/MemberFilterActionGroup.org.eclipse.jdt.ui.JavaOutlinePage.1=true
/instance/org.eclipse.jdt.core/org.eclipse.jdt.core.compiler.problem.finalParameterBound=warning
/instance/org.eclipse.jdt.core/org.eclipse.jdt.core.compiler.problem.forbiddenReference=error
/instance/org.eclipse.help.base/showDisabledActivityTopics=on
/instance/org.eclipse.jdt.core/org.eclipse.jdt.core.compiler.problem.staticAccessReceiver=warning
/project/AspectJ\ cookbook/org.eclipse.ajdt.core/org.aspectj.ajdt.core.compiler.lint.TypeNotExposedToWeaver=warning
/instance/org.eclipse.jdt.core/org.eclipse.jdt.core.classpathVariable.JRE_SRC=C\:/Java/jdk1.5.0_05/src.zip
/instance/org.eclipse.jdt.core/org.eclipse.jdt.core.compiler.problem.nonExternalizedStringLiteral=ignore
/instance/org.eclipse.jdt.ui/content_assist_autoactivation_delay=200
@org.eclipse.help.ui=3.1.1
@org.eclipse.pde.core=3.1.1
/instance/org.eclipse.jdt.ui/org.eclipse.jdt.ui.text.custom_templates=&lt;?xml version\="1.0" encoding\="UTF-8"?&gt;\r\n&lt;templates&gt;&lt;template name\="adviceexecution" description\="adviceexecution pointcut (AspectJ)" context\="java" enabled\="true" deleted\="false" autoinsert\="true"&gt;adviceexecution()&lt;/template&gt;&lt;template name\="after_returning" description\="after returning advice (AspectJ)" context\="java" enabled\="true" deleted\="false" autoinsert\="true"&gt;after(${args}) returning() \: ${pointcut_expression} {}&lt;/template&gt;&lt;template name\="after_throwing" description\="after throwing advice (AspectJ)" context\="java" enabled\="true" deleted\="false" autoinsert\="true"&gt;after(${args}) throwing() \: ${pointcut_expression} {\r\n}&lt;/template&gt;&lt;template name\="around" description\="around advice (AspectJ)" context\="java" enabled\="true" deleted\="false" autoinsert\="true"&gt;around(${args}) \: ${pointcut_expression} {}&lt;/template&gt;&lt;template name\="before" description\="before advice (AspectJ)" context\="java" enabled\="true" deleted\="false" autoinsert\="true"&gt;before(${args}) \: ${pointcut_expression} {\r\n}&lt;/template&gt;&lt;template name\="call_cons" description\="call constructor pointcut (AspectJ)" context\="java" enabled\="true" deleted\="false" autoinsert\="true"&gt;call(${modifier_pattern} ${type_pattern}.new(..))&lt;/template&gt;&lt;template name\="call_method" description\="call method declaration (AspectJ)" context\="java" enabled\="true" deleted\="false" autoinsert\="true"&gt;call(${modifiers_pattern} ${ret_type_pattern} ${type_pattern}.${id_pattern}(..))&lt;/template&gt;&lt;template name\="cflow" description\="cflow pointcut (AspectJ)" context\="java" enabled\="true" deleted\="false" autoinsert\="true"&gt;cflow(${pointcut_expression})&lt;/template&gt;&lt;template name\="cflowbelow" description\="cflowbelow pointcut (AspectJ)" context\="java" enabled\="true" deleted\="false" autoinsert\="true"&gt;cflowbelow(${pointcut_expression})&lt;/template&gt;&lt;template name\="dece" description\="declare error (AspectJ)" context\="java" enabled\="true" deleted\="false" autoinsert\="true"&gt;declare error \: ${pointcut_expression} \r\n              \: "";&lt;/template&gt;&lt;template name\="decp_extends" description\="declare parents (AspectJ)" context\="java" enabled\="true" deleted\="false" autoinsert\="true"&gt;declare parents \: ${type_pattern} extends ${type};&lt;/template&gt;&lt;template name\="decp_implements" description\="declare parents (AspectJ)" context\="java" enabled\="true" deleted\="false" autoinsert\="true"&gt;declare parents \: ${type_pattern} implements ${type};&lt;/template&gt;&lt;template name\="decs" description\="declare soft (AspectJ)" context\="java" enabled\="true" deleted\="false" autoinsert\="true"&gt;declare soft \: ${exception_type} \: ${pointcut_expression};&lt;/template&gt;&lt;template name\="decw" description\="declare warning (AspectJ)" context\="java" enabled\="true" deleted\="false" autoinsert\="true"&gt;declare warning \: ${pointcut_expression} \: "";&lt;/template&gt;&lt;template name\="execution_cons" description\="execution of a constructor pointcut (AspectJ)" context\="java" enabled\="true" deleted\="false" autoinsert\="true"&gt;execution(${modifier_pattern} ${type_pattern}.new(..))&lt;/template&gt;&lt;template name\="execution_method" description\="execution of a method pointcut (AspectJ)" context\="java" enabled\="true" deleted\="false" autoinsert\="true"&gt;execution(${modifier_pattern} ${ret_type_pattern} ${type_pattern}.${id_pattern}(..))&lt;/template&gt;&lt;template name\="get" description\="get pointcut (AspectJ)" context\="java" enabled\="true" deleted\="false" autoinsert\="true"&gt;get(${modifier_pattern} ${ret_type_pattern} ${type_pattern}.${id_pattern})&lt;/template&gt;&lt;template name\="handler" description\="handler pointcut (AspectJ)" context\="java" enabled\="true" deleted\="false" autoinsert\="true"&gt;handler(${type_pattern})&lt;/template&gt;&lt;template name\="initialization" description\="initialization pointcut (AspectJ)" context\="java" enabled\="true" deleted\="false" autoinsert\="true"&gt;initialization(${modifier_pattern} ${type_pattern}.new(..))&lt;/template&gt;&lt;template name\="pc" description\="pointcut declaration (AspectJ)" context\="java" enabled\="true" deleted\="false" autoinsert\="true"&gt;pointcut ${name}() \: ${pointcut_expression};&lt;/template&gt;&lt;template name\="percflow" description\="percflow (AspectJ)" context\="java" enabled\="true" deleted\="false" autoinsert\="true"&gt;percflow(${pointcut_expression})&lt;/template&gt;&lt;template name\="percflowbelow" description\="percflowbelow (AspectJ)" context\="java" enabled\="true" deleted\="false" autoinsert\="true"&gt;percflowbelow(${pointcut_expression})&lt;/template&gt;&lt;template name\="pertarget" description\="pertarget (AspectJ)" context\="java" enabled\="true" deleted\="false" autoinsert\="true"&gt;pertarget(${pointcut_expression})&lt;/template&gt;&lt;template name\="perthis" description\="perthis (AspectJ)" context\="java" enabled\="true" deleted\="false" autoinsert\="true"&gt;perthis(${pointcut_expression})&lt;/template&gt;&lt;template name\="preinitialization" description\="preinitialization pointcut (AspectJ)" context\="java" enabled\="true" deleted\="false" autoinsert\="true"&gt;preinitialization(${modifier_pattern} ${type_pattern}.new(..))&lt;/template&gt;&lt;template name\="set" description\="set pointcut (AspectJ)" context\="java" enabled\="true" deleted\="false" autoinsert\="true"&gt;set(${modifier_pattern} ${ret_type_pattern} ${type_pattern}.${id_pattern})&lt;/template&gt;&lt;template name\="staticinitialization" description\="staticinitialization pointcut (AspectJ)" context\="java" enabled\="true" deleted\="false" autoinsert\="true"&gt;staticinitialization(${type_pattern})&lt;/template&gt;&lt;template name\="thisJoinPoint" description\="thisJoinPoint (AspectJ)" context\="java" enabled\="true" deleted\="false" autoinsert\="true"&gt;thisJoinPoint&lt;/template&gt;&lt;template name\="thisJoinPointStaticPart" description\="thisJoinPointStaticPart (AspectJ)" context\="java" enabled\="true" deleted\="false" autoinsert\="true"&gt;thisJoinPointStaticPart&lt;/template&gt;&lt;template name\="within" description\="within pointcut (AspectJ)" context\="java" enabled\="true" deleted\="false" autoinsert\="true"&gt;within(${type_pattern})&lt;/template&gt;&lt;template name\="withincode_cons" description\="withincode of a constructor pointcut (AspectJ)" context\="java" enabled\="true" deleted\="false" autoinsert\="true"&gt;withincode(${modifier_pattern} ${type_pattern}.new(..))&lt;/template&gt;&lt;template name\="withincode_method" description\="withincode of a method pointcut (AspectJ)" context\="java" enabled\="true" deleted\="false" autoinsert\="true"&gt;withincode(${modifier_pattern} ${ret_type_pattern} ${type_pattern}.${id_pattern}(..))&lt;/template&gt;&lt;template name\="sconst" description\="public static final String declaration" context\="java" enabled\="true" deleted\="false" autoinsert\="true"&gt;public static final String ${name} \= "${cursor}";&lt;/template&gt;&lt;template name\="iconst" description\="public static final int declaration" context\="java" enabled\="true" deleted\="false" autoinsert\="true"&gt;public static final int ${name} \= ${cursor};&lt;/template&gt;&lt;/templates&gt;
/instance/org.eclipse.jdt.core/org.eclipse.jdt.core.compiler.problem.unusedParameter=ignore
@org.eclipse.ui=3.1.1
/project/AspectJ\ -\ HelloWorld/org.eclipse.jdt.core/org.eclipse.jdt.core.compiler.debug.sourceFile=generate
/instance/org.rubypeople.rdt.ui/riDirectoryPath=C\:\\tools\\ruby\\bin\\ri.bat

*** Current Install Configuration:
Install configuration:
 Last changed on 2005-11-25
 Location: file:/c:/Eclipse/3.11/eclipse/configuration/org.eclipse.update/platform.xml

 Configured sites:
  file:/c:/tools/Plug-in/eclipse/
  platform:/base/

 Configured features:
  ID: de.loskutov.BytecodeOutline.feature, Version: 2.0.2
  ID: org.rubypeople.rdt, Version: 0.6.0
  ID: org.objectweb.asm.feature, Version: 2.1.0
  ID: org.testng.eclipse, Version: 4.2.0.0
  ID: org.rubypeople.rdt.source, Version: 0.6.0
  ID: org.eclipse.platform, Version: 3.1.1
  ID: org.eclipse.rcp, Version: 3.1.0
  ID: org.eclipse.platform.source, Version: 3.1.1
  ID: net.sourceforge.eclipseccase, Version: 1.0.3
  ID: org.eclipse.aspectj, Version: 1.3.0.20051125115230
  ID: org.eclipse.jdt, Version: 3.1.0
  ID: org.eclipse.jdt.source, Version: 3.1.1
  ID: org.eclipse.pde, Version: 3.1.0
  ID: CtcProjectWizardFeature, Version: 0.3.1
  ID: org.eclipse.sdk, Version: 3.1.1
  ID: org.eclipse.pde.source, Version: 3.1.1
  ID: org.eclipse.rcp.source, Version: 3.1.1

 Configured plug-ins:
  file:/c:/tools/Plug-in/eclipse/plugins/de.loskutov.BytecodeOutline_2.0.2/
  file:/c:/tools/Plug-in/eclipse/plugins/org.epic.regexp_0.1.4/
  file:/c:/tools/Plug-in/eclipse/plugins/org.kxml2_2.1.4/
  file:/c:/tools/Plug-in/eclipse/plugins/org.objectweb.asm_2.1.0/
  file:/c:/tools/Plug-in/eclipse/plugins/org.rubypeople.rdt.core_0.6.0/
  file:/c:/tools/Plug-in/eclipse/plugins/org.rubypeople.rdt.debug.core_0.6.0/
  file:/c:/tools/Plug-in/eclipse/plugins/org.rubypeople.rdt.debug.ui_0.6.0/
  file:/c:/tools/Plug-in/eclipse/plugins/org.rubypeople.rdt.doc.user_0.6.0/
  file:/c:/tools/Plug-in/eclipse/plugins/org.rubypeople.rdt.launching_0.6.0/
  file:/c:/tools/Plug-in/eclipse/plugins/org.rubypeople.rdt.source_0.6.0/
  file:/c:/tools/Plug-in/eclipse/plugins/org.rubypeople.rdt.testunit_0.6.0/
  file:/c:/tools/Plug-in/eclipse/plugins/org.rubypeople.rdt.ui_0.6.0/
  file:/c:/tools/Plug-in/eclipse/plugins/org.rubypeople.rdt_0.6.0/
  file:/c:/tools/Plug-in/eclipse/plugins/org.testng.eclipse_4.2.0.0/
  file:/c:/Eclipse/3.11/eclipse/plugins/com.cisco.ong.ctc.wizards.project_0.3.1/
  file:/c:/Eclipse/3.11/eclipse/plugins/net.sourceforge.clearcase_1.0.3/
  file:/c:/Eclipse/3.11/eclipse/plugins/net.sourceforge.eclipseccase.ui_1.0.3.jar
  file:/c:/Eclipse/3.11/eclipse/plugins/net.sourceforge.eclipseccase_1.0.3.jar
  file:/c:/Eclipse/3.11/eclipse/plugins/org.apache.ant_1.6.5/
  file:/c:/Eclipse/3.11/eclipse/plugins/org.apache.lucene_1.4.3/
  file:/c:/Eclipse/3.11/eclipse/plugins/org.aspectj.ajde_1.5.0.20051125115230/
  file:/c:/Eclipse/3.11/eclipse/plugins/org.aspectj.runtime_1.5.0.20051125115230/
  file:/c:/Eclipse/3.11/eclipse/plugins/org.aspectj.weaver_1.5.0.20051125115230/
  file:/c:/Eclipse/3.11/eclipse/plugins/org.eclipse.ajdt.core_1.3.0.20051125115230.jar
  file:/c:/Eclipse/3.11/eclipse/plugins/org.eclipse.ajdt.examples_1.3.0.20051125115230/
  file:/c:/Eclipse/3.11/eclipse/plugins/org.eclipse.ajdt.source_1.3.0.20051125115230/
  file:/c:/Eclipse/3.11/eclipse/plugins/org.eclipse.ajdt.ui_1.3.0.20051125115230.jar
  file:/c:/Eclipse/3.11/eclipse/plugins/org.eclipse.ant.core_3.1.1.jar
  file:/c:/Eclipse/3.11/eclipse/plugins/org.eclipse.ant.ui_3.1.1.jar
  file:/c:/Eclipse/3.11/eclipse/plugins/org.eclipse.aspectj_1.3.0.20051125115230/
  file:/c:/Eclipse/3.11/eclipse/plugins/org.eclipse.compare_3.1.1.jar
  file:/c:/Eclipse/3.11/eclipse/plugins/org.eclipse.contribution.visualiser_2.2.0.20051125115230.jar
  file:/c:/Eclipse/3.11/eclipse/plugins/org.eclipse.contribution.xref.core_1.3.0.20051125115230.jar
  file:/c:/Eclipse/3.11/eclipse/plugins/org.eclipse.contribution.xref.ui_1.3.0.20051125115230.jar
  file:/c:/Eclipse/3.11/eclipse/plugins/org.eclipse.core.boot_3.1.0.jar
  file:/c:/Eclipse/3.11/eclipse/plugins/org.eclipse.core.commands_3.1.0.jar
  file:/c:/Eclipse/3.11/eclipse/plugins/org.eclipse.core.expressions_3.1.0.jar
  file:/c:/Eclipse/3.11/eclipse/plugins/org.eclipse.core.filebuffers_3.1.0.jar
  file:/c:/Eclipse/3.11/eclipse/plugins/org.eclipse.core.resources.compatibility_3.1.0.jar
  file:/c:/Eclipse/3.11/eclipse/plugins/org.eclipse.core.resources.win32_3.1.0.jar
  file:/c:/Eclipse/3.11/eclipse/plugins/org.eclipse.core.resources_3.1.0.jar
  file:/c:/Eclipse/3.11/eclipse/plugins/org.eclipse.core.runtime.compatibility_3.1.0.jar
  file:/c:/Eclipse/3.11/eclipse/plugins/org.eclipse.core.runtime_3.1.1.jar
  file:/c:/Eclipse/3.11/eclipse/plugins/org.eclipse.core.variables_3.1.0.jar
  file:/c:/Eclipse/3.11/eclipse/plugins/org.eclipse.debug.core_3.1.0.jar
  file:/c:/Eclipse/3.11/eclipse/plugins/org.eclipse.debug.ui_3.1.1.jar
  file:/c:/Eclipse/3.11/eclipse/plugins/org.eclipse.help.appserver_3.1.0.jar
  file:/c:/Eclipse/3.11/eclipse/plugins/org.eclipse.help.base_3.1.0.jar
  file:/c:/Eclipse/3.11/eclipse/plugins/org.eclipse.help.ui_3.1.1.jar
  file:/c:/Eclipse/3.11/eclipse/plugins/org.eclipse.help.webapp_3.1.0/
  file:/c:/Eclipse/3.11/eclipse/plugins/org.eclipse.help_3.1.0.jar
  file:/c:/Eclipse/3.11/eclipse/plugins/org.eclipse.jdt.core_3.1.1.jar
  file:/c:/Eclipse/3.11/eclipse/plugins/org.eclipse.jdt.debug.ui_3.1.1.jar
  file:/c:/Eclipse/3.11/eclipse/plugins/org.eclipse.jdt.debug_3.1.1/
  file:/c:/Eclipse/3.11/eclipse/plugins/org.eclipse.jdt.doc.isv_3.1.1/
  file:/c:/Eclipse/3.11/eclipse/plugins/org.eclipse.jdt.doc.user_3.1.1/
  file:/c:/Eclipse/3.11/eclipse/plugins/org.eclipse.jdt.junit.runtime_3.1.0/
  file:/c:/Eclipse/3.11/eclipse/plugins/org.eclipse.jdt.junit_3.1.1/
  file:/c:/Eclipse/3.11/eclipse/plugins/org.eclipse.jdt.launching_3.1.0.jar
  file:/c:/Eclipse/3.11/eclipse/plugins/org.eclipse.jdt.source_3.1.1/
  file:/c:/Eclipse/3.11/eclipse/plugins/org.eclipse.jdt.ui_3.1.1.jar
  file:/c:/Eclipse/3.11/eclipse/plugins/org.eclipse.jdt_3.1.0.jar
  file:/c:/Eclipse/3.11/eclipse/plugins/org.eclipse.jface.text_3.1.1.jar
  file:/c:/Eclipse/3.11/eclipse/plugins/org.eclipse.jface_3.1.1.jar
  file:/c:/Eclipse/3.11/eclipse/plugins/org.eclipse.ltk.core.refactoring_3.1.0.jar
  file:/c:/Eclipse/3.11/eclipse/plugins/org.eclipse.ltk.ui.refactoring_3.1.1.jar
  file:/c:/Eclipse/3.11/eclipse/plugins/org.eclipse.osgi.services_3.1.1.jar
  file:/c:/Eclipse/3.11/eclipse/plugins/org.eclipse.osgi.util_3.1.1.jar
  file:/c:/Eclipse/3.11/eclipse/plugins/org.eclipse.osgi_3.1.1.jar
  file:/c:/Eclipse/3.11/eclipse/plugins/org.eclipse.pde.build_3.1.0/
  file:/c:/Eclipse/3.11/eclipse/plugins/org.eclipse.pde.core_3.1.1.jar
  file:/c:/Eclipse/3.11/eclipse/plugins/org.eclipse.pde.doc.user_3.1.1/
  file:/c:/Eclipse/3.11/eclipse/plugins/org.eclipse.pde.junit.runtime_3.1.0/
  file:/c:/Eclipse/3.11/eclipse/plugins/org.eclipse.pde.runtime_3.1.1.jar
  file:/c:/Eclipse/3.11/eclipse/plugins/org.eclipse.pde.source_3.1.1/
  file:/c:/Eclipse/3.11/eclipse/plugins/org.eclipse.pde.ui_3.1.1.jar
  file:/c:/Eclipse/3.11/eclipse/plugins/org.eclipse.pde_3.1.0.jar
  file:/c:/Eclipse/3.11/eclipse/plugins/org.eclipse.platform.doc.isv_3.1.1/
  file:/c:/Eclipse/3.11/eclipse/plugins/org.eclipse.platform.doc.user_3.1.1/
  file:/c:/Eclipse/3.11/eclipse/plugins/org.eclipse.platform.source.win32.win32.x86_3.1.1/
  file:/c:/Eclipse/3.11/eclipse/plugins/org.eclipse.platform.source_3.1.1/
  file:/c:/Eclipse/3.11/eclipse/plugins/org.eclipse.platform_3.1.1/
  file:/c:/Eclipse/3.11/eclipse/plugins/org.eclipse.rcp.source.win32.win32.x86_3.1.1/
  file:/c:/Eclipse/3.11/eclipse/plugins/org.eclipse.rcp.source_3.1.1/
  file:/c:/Eclipse/3.11/eclipse/plugins/org.eclipse.rcp_3.1.0.jar
  file:/c:/Eclipse/3.11/eclipse/plugins/org.eclipse.sdk_3.1.1/
  file:/c:/Eclipse/3.11/eclipse/plugins/org.eclipse.search_3.1.1.jar
  file:/c:/Eclipse/3.11/eclipse/plugins/org.eclipse.swt.win32.win32.x86_3.1.1.jar
  file:/c:/Eclipse/3.11/eclipse/plugins/org.eclipse.swt_3.1.0.jar
  file:/c:/Eclipse/3.11/eclipse/plugins/org.eclipse.team.core_3.1.1.jar
  file:/c:/Eclipse/3.11/eclipse/plugins/org.eclipse.team.cvs.core_3.1.1.jar
  file:/c:/Eclipse/3.11/eclipse/plugins/org.eclipse.team.cvs.ssh2_3.1.0/
  file:/c:/Eclipse/3.11/eclipse/plugins/org.eclipse.team.cvs.ssh_3.1.0.jar
  file:/c:/Eclipse/3.11/eclipse/plugins/org.eclipse.team.cvs.ui_3.1.1.jar
  file:/c:/Eclipse/3.11/eclipse/plugins/org.eclipse.team.ui_3.1.1.jar
  file:/c:/Eclipse/3.11/eclipse/plugins/org.eclipse.text_3.1.1.jar
  file:/c:/Eclipse/3.11/eclipse/plugins/org.eclipse.tomcat_4.1.30.1/
  file:/c:/Eclipse/3.11/eclipse/plugins/org.eclipse.ui.browser_3.1.1.jar
  file:/c:/Eclipse/3.11/eclipse/plugins/org.eclipse.ui.cheatsheets_3.1.1.jar
  file:/c:/Eclipse/3.11/eclipse/plugins/org.eclipse.ui.console_3.1.0.jar
  file:/c:/Eclipse/3.11/eclipse/plugins/org.eclipse.ui.editors_3.1.1.jar
  file:/c:/Eclipse/3.11/eclipse/plugins/org.eclipse.ui.externaltools_3.1.1.jar
  file:/c:/Eclipse/3.11/eclipse/plugins/org.eclipse.ui.forms_3.1.0.jar
  file:/c:/Eclipse/3.11/eclipse/plugins/org.eclipse.ui.ide_3.1.1.jar
  file:/c:/Eclipse/3.11/eclipse/plugins/org.eclipse.ui.intro_3.1.1.jar
  file:/c:/Eclipse/3.11/eclipse/plugins/org.eclipse.ui.presentations.r21_3.1.0.jar
  file:/c:/Eclipse/3.11/eclipse/plugins/org.eclipse.ui.views_3.1.1.jar
  file:/c:/Eclipse/3.11/eclipse/plugins/org.eclipse.ui.win32_3.1.0.jar
  file:/c:/Eclipse/3.11/eclipse/plugins/org.eclipse.ui.workbench.compatibility_3.1.0/
  file:/c:/Eclipse/3.11/eclipse/plugins/org.eclipse.ui.workbench.texteditor_3.1.1.jar
  file:/c:/Eclipse/3.11/eclipse/plugins/org.eclipse.ui.workbench_3.1.1.jar
  file:/c:/Eclipse/3.11/eclipse/plugins/org.eclipse.ui_3.1.1.jar
  file:/c:/Eclipse/3.11/eclipse/plugins/org.eclipse.update.configurator_3.1.0.jar
  file:/c:/Eclipse/3.11/eclipse/plugins/org.eclipse.update.core.win32_3.1.0.jar
  file:/c:/Eclipse/3.11/eclipse/plugins/org.eclipse.update.core_3.1.1.jar
  file:/c:/Eclipse/3.11/eclipse/plugins/org.eclipse.update.scheduler_3.1.0.jar
  file:/c:/Eclipse/3.11/eclipse/plugins/org.eclipse.update.ui_3.1.1.jar
  file:/c:/Eclipse/3.11/eclipse/plugins/org.junit_3.8.1/</comment>
		<comment id="15" date="2005-11-27 13:09:29 EST" author="Andrew Clement">This bug gets stranger and stranger...

&gt; Just checked "Output weaving info message to problems view" and rebuilt the
&gt; project, but found no any error/warning message in the problem view.

Weaving messages that come out will be info messages that go into that view - it's very strange that you get *none* and yet have gutter annotations for navigating the end result of the compilation, since the structure model gets built at exactly the same time as the info message comes out...hmmm.

&gt; When I checked "Create a structure model during compilation", the message 
&gt; you mentioned above disappeared. 

Ok, at least this is behaving itself, you should always have the option 'create a structure model' checked.

&gt; Yes, and when I right-clicked it, a popup menu will show either "Declared on"
&gt; (on DefaultInterfaceImplementationRecipe.aj) or  "Aspect Declarations" (on
&gt; MyClass_ch16.java)to bring me to the right source code.

I just (at the moment) dont understand how you can get this correct output and yet end up with broken stuff on the disk.  Maybe we need to wipe the project properties for this project in some way.  I don't suppose you can try it in a completely different eclipse workspace can you?

Can you check in the eclipse error log (its one of the views like the problem view that you can choose to show) - are there any errors in it that look like they might be related to this?

Have you left all the standard compiler options as default?  Since all the Java base options are inherited by the ajc compiler.

thanks.  sorry I don't seem to be able to solve this ...</comment>
		<comment id="16" date="2005-11-27 21:21:08 EST" author="David">It looks like if I create a new AspectJ project and copy those 3 files from the problematic project to this new project, then the problem is gone.
But the problematic project is created based on the examples downloaded from the book AspectJ cookbook. And what I did is to rename the 2 classes - MyClass.java and MyInterface.java in AspectJ cookbook "chapter_16/Provide a default implementation of an interface" to MyClass_ch16.java and MyInterface_ch16.java, the problem view/Error Lob view will show errors for other chapters due to the duplication of class name but there is no error warning for the chapter16.
Even I have the same setting between new created project (which works fine) and old problematic project, the latter one always spit out error as I mentioned before.
I am wondering if you can download the examples and rename class files in chapter16 and try for yourself ...

Thanks
David</comment>
		<comment id="17" date="2005-11-28 04:24:02 EST" author="Andrew Clement">Hi.  I've downloaded all the code for the book. How precisely do you create AspectJ projects for it?  I see the prefix for all the code is 'aspectjcookbook_examples/chapter_XX' - did you create one AspectJ project for all the code in 'aspectjcookbook_examples' or do you create one project per 'aspectjcookbook_examples/chaper_XX' - i.e. one per chapter?  I'm basically interested in exactly what files you have in the failing project, is it just the 3 or is it everything from the book?

cheers.</comment>
		<comment id="18" date="2005-11-29 23:52:39 EST" author="David">My answer inline

(In reply to comment #17)
&gt; Hi.  I've downloaded all the code for the book. How precisely do you create
&gt; AspectJ projects for it?  I see the prefix for all the code is
&gt; 'aspectjcookbook_examples/chapter_XX' - did you create one AspectJ project for
&gt; all the code in 'aspectjcookbook_examples' or do you create one project per
&gt; 'aspectjcookbook_examples/chaper_XX' - i.e. one per chapter?  I'm basically

I just created one project for all chapters, and appended "_ch16" to all java files for chapter 16, which means only chapter 16 will compile and all the other chapters will get errors such as duplicated class name ...

&gt; interested in exactly what files you have in the failing project, is it just
&gt; the 3 or is it everything from the book?
&gt; 
&gt; cheers.
&gt; 

The project has everything from the book (from chapter 2 to 22), but only chapter 16 compiles and run since I renamed them to the following names:

MyClass_ch16.java
MyInterface_ch16.java</comment>
		<comment id="19" date="2005-11-30 03:32:26 EST" author="Andrew Clement">Oh ......

If you have errors during compilation, we don't weave - we assume the result will be invalid if we tried ... that's why this is happening.

If you want to weave what might be broken code, you need to specify '-proceedOnError' - put it in the non-standard compiler options entry on the AspectJ preferences page for the project.  I believe there is a way to set it in the UI but I can't find it at the moment.</comment>
		<comment id="20" date="2005-11-30 12:19:53 EST" author="David">(In reply to comment #19)
&gt; Oh ......
&gt; If you have errors during compilation, we don't weave - we assume the result
&gt; will be invalid if we tried ... that's why this is happening.
&gt; If you want to weave what might be broken code, you need to specify
&gt; '-proceedOnError' - put it in the non-standard compiler options entry on the
&gt; AspectJ preferences page for the project.  I believe there is a way to set it
&gt; in the UI but I can't find it at the moment.

Looks like it's been fixed in Bug#74245 but unfortunately even with the flag "-proceedOnError" set on the "Non standard compiler options" I still get the same run-time error as shown below.

p.s. I'm using Eclipse Version: 3.1.1 Build id: M20050929-0840 and AJDT Version 1.3.0.20051130095036

***********************************************************
Exception in thread "main" java.lang.VerifyError: (class: DefaultInterfaceImplementationRecipe, method: &lt;clinit&gt; signature: ()V) Stack size too large
 at MyClass_ch16.main(MyClass_ch16.java:15)
***********************************************************</comment>
		<comment id="21" date="2005-11-30 12:44:16 EST" author="Andrew Clement">I'm just working on another options related bug where what is specified in the 'extra options' panel doesn't get through to the compiler.  I'm putting a similar fix in for this.  I suspect we have a lot of compiler tests that check -proceedOnError works but no AJDE based tests that verify the path from AJDT is working correctly.</comment>
		<comment id="22" date="2005-11-30 15:13:33 EST" author="Andrew Clement">fix checked in for ensuring '-proceedOnError' makes it across from AJDT to AJ.</comment>
		<comment id="23" date="2005-11-30 15:47:45 EST" author="David">Thanks Andy, I will give it a try whenever I get a new DEV build tomorrow.</comment>
		<comment id="24" date="2005-11-30 16:13:18 EST" author="Andrew Clement">it might take a day or so to appear in an AJDT build - i'll let you know through this bug report.</comment>
		<comment id="25" date="2005-12-01 23:39:36 EST" author="David">Looks like the AJDT Version 1.3.0.20051201090854 still generates the same error. 
I'll try another new build tomorrow to see if your fix is in.

Thanks</comment>
		<comment id="26" date="2005-12-02 04:31:20 EST" author="Andrew Clement">I marked the abstract such that I'll comment in here when an AJDT build includes the fix - given the current number of AJ bugs I'm working on, I suspect AJDT won't get refreshed until Monday.

I'll attach a patch you can apply yourself if you want to sort it out sooner.</comment>
		<comment id="27" date="2005-12-02 04:33:46 EST" author="Andrew Clement">Created attachment 31015 [details]
Patch to allow -proceedOnError to pass through

Apply as follows.  Put this patch.zip in the org.aspectj.ajde plugin directory (somewhere under eclipse/plugins).  Choose the ajde plugin dated correctly as you may have several installed and you want to patch the latest.

Then backup the ajde.jar file in that directory:

copy ajde.jar ajde.jar.backup

now apply the patch

jar -xvf patch.zip
jar -uvf ajde.jar org

now restart eclipse.</comment>
		<comment id="28" date="2005-12-03 00:47:11 EST" author="David">Hi Andy

Just did what you told me to do in the latest ajde directory (actually there is only one there since I uninstall all the old ajde plugins), below is the output of the jar command (sorry for the Chinese fonts, I set my locale to China) and I believe it successfully patch everything.
I double-checked the the Non Standard Compiler Options was set to -proceedOnError and then rebuilt everything but found the result was still the same. Are you able to run it with the patch by yourself ?

Thanks
David

C:\Eclipse\3.11\eclipse\plugins\org.aspectj.ajde_1.5.0.20051202173447&gt;jar -xvf p
atch.zip
&amp;#23637;&amp;#24320;:org/aspectj/ajdt/internal/core/builder/AjBuildConfig$1.class
&amp;#23637;&amp;#24320;:org/aspectj/ajdt/internal/core/builder/AjBuildConfig$BinarySourceFile.clas
s
&amp;#23637;&amp;#24320;:org/aspectj/ajdt/internal/core/builder/AjBuildConfig.class

C:\Eclipse\3.11\eclipse\plugins\org.aspectj.ajde_1.5.0.20051202173447&gt;jar -uvf a
jde.jar org
&amp;#22686;&amp;#21152;:org/(&amp;#35835;&amp;#20837;= 0) (&amp;#20889;&amp;#20986;= 0)(&amp;#23384;&amp;#20648;&amp;#20102; 0%)
&amp;#22686;&amp;#21152;:org/aspectj/(&amp;#35835;&amp;#20837;= 0) (&amp;#20889;&amp;#20986;= 0)(&amp;#23384;&amp;#20648;&amp;#20102; 0%)
&amp;#22686;&amp;#21152;:org/aspectj/ajdt/(&amp;#35835;&amp;#20837;= 0) (&amp;#20889;&amp;#20986;= 0)(&amp;#23384;&amp;#20648;&amp;#20102; 0%)
&amp;#22686;&amp;#21152;:org/aspectj/ajdt/internal/(&amp;#35835;&amp;#20837;= 0) (&amp;#20889;&amp;#20986;= 0)(&amp;#23384;&amp;#20648;&amp;#20102; 0%)
&amp;#22686;&amp;#21152;:org/aspectj/ajdt/internal/core/(&amp;#35835;&amp;#20837;= 0) (&amp;#20889;&amp;#20986;= 0)(&amp;#23384;&amp;#20648;&amp;#20102; 0%)
&amp;#22686;&amp;#21152;:org/aspectj/ajdt/internal/core/builder/(&amp;#35835;&amp;#20837;= 0) (&amp;#20889;&amp;#20986;= 0)(&amp;#23384;&amp;#20648;&amp;#20102; 0%)
&amp;#22686;&amp;#21152;:org/aspectj/ajdt/internal/core/builder/AjBuildConfig$1.class(&amp;#35835;&amp;#20837;= 847) (
&amp;#20889;&amp;#20986;= 461)(&amp;#21387;&amp;#32553;&amp;#20102; 45%)
&amp;#22686;&amp;#21152;:org/aspectj/ajdt/internal/core/builder/AjBuildConfig$BinarySourceFile.clas
s(&amp;#35835;&amp;#20837;= 976) (&amp;#20889;&amp;#20986;= 545)(&amp;#21387;&amp;#32553;&amp;#20102; 44%)
&amp;#22686;&amp;#21152;:org/aspectj/ajdt/internal/core/builder/AjBuildConfig.class(&amp;#35835;&amp;#20837;= 13079) (
&amp;#20889;&amp;#20986;= 4955)(&amp;#21387;&amp;#32553;&amp;#20102; 62%)

C:\Eclipse\3.11\eclipse\plugins\org.aspectj.ajde_1.5.0.20051202173447&gt;


==============================================================
= The decompiled MyInterface_ch16.class still looks like below:
==============================================================
// Decompiled by DJ v3.7.7.81 Copyright 2004 Atanas Neshkov  Date: 12/2/2005 11:33:45 PM
// Home Page : http://members.fortunecity.com/neshkov/dj.html  - Check often for new version!
// Decompiler options: packimports(3) 
// Source File Name:   MyInterface_ch16.java

public interface MyInterface_ch16
{
}</comment>
		<comment id="29" date="2005-12-06 01:14:43 EST" author="David">Hmmm... just found that the same error message (ava.lang.VerifyError) can be reproduced easilly by the following steps.

1. Create a new AspectJ project (says "AspectJ in Action")
2. Import Java/Aspect source from "AspectJ in Action\ch03\section3.3.1" (Ramniva Laddad's book) - the java/aspect codes will be imported to the default package.
2. Create a new class (says TestAccount.java) as below:

    public class TestAccount {
 public static void main(String[] args) {
  Account act = new SavingsAccount(567);
  act.credit(36.0f);
  System.out.println(act.getAvailableBalance());
 }
    }
3. Build and run the TestAccount - should be no problem till now.
4. Create a new package named "chapter3".
5. Move all java/aspect code to under the package "chapter3" by selecting all and then using Refactor-&gt;Move.
6. Sometime the aspect file (MinimumBalanceRuleAspect) will disappear, if this is the case for you then just re-import it from the same directory. And manually add the package name to it.
7. Try to rename the aspect file (MinimumBalanceRuleAspect) to .aj extension by using "AspectJ Tools-&gt;Convert File Extension to .aj".
8. Rebuild the project and then run it.
(*** Notice that the gutter markers are gone in the aspect file. And the java.lang.VerifyError will be shown ***)</comment>
		<comment id="30" date="2005-12-06 01:28:02 EST" author="David">Looks like the problem I mentioned above is caused by the aspect file not being moved to the package directory. There are 2 exactly the same aspect file in 2 different directories and the project seems somehow still make use of the old aspect file (which remain in the default package directory).
I have to manually remove the aspect file to make it run correctly. But this workaround doesn't apply to the bug that I opened(117209). I still have problem to run it with your patch :-(</comment>
		<comment id="31" date="2005-12-06 04:08:42 EST" author="Andrew Clement">There are known problems with eclipse refactorings (like move...) when working with aspects and .aj files.  So i'm not surprised that didn't behave as expected -  I think we typically say use the navigator view to move files around, rather than the eclipse options in the package explorer.

I've fully recreated your problem with my patch applied - I think the aspectjcookbook_examples project is just *too* broken with all those errors in it, so the weaver can't get on and do its job (so you get a verify error) - I believe -proceedOnError isn't helping because of how broken the project is.  What if you simply modify the set of source folders in the project (through project properties &gt; Java Build Path) to remove all the source folders apart from the one you are working on?  I removed all but the "chapter_16/Provide a default implementation" then it compiled (much faster than the broken variant of the project) and ran happily.</comment>
		<comment id="32" date="2005-12-06 10:36:44 EST" author="David">Thanks Andy for pointing out the existing issues with Eclipse. And I believe the workaround you proposed should work just fine.

Thanks again.</comment>
		<comment id="33" date="2005-12-07 05:24:59 EST" author="Andrew Clement">sorry it took so long to get to a solution that works for you! I should have thought of it earlier.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="551b9ca14c28b843c1dbbc14a48427bf4bb9f097" author="aclement" date="2005-12-01 04:51:24"/>
          <file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.java">
              <method name="installGlobals" returnType="void" parameters="AjBuildConfig"/>
          </file>
          <file name="tests/multiIncremental/pr117209/base/src/Aspect.java">
          </file>
          <file name="tests/multiIncremental/pr117209/base/src/Broken.java">
          </file>
          <file name="tests/multiIncremental/pr117209/base/src/DefaultInterfaceImplementationRecipe.java">
          </file>
          <file name="tests/multiIncremental/pr117209/base/src/MyClass_ch16.java">
          </file>
          <file name="tests/multiIncremental/pr117209/base/src/MyInterface_ch16.java">
          </file>
          <file name="tests/src/org/aspectj/systemtest/incremental/tools/AjdeInteractionTestbed.java">
              <method name="configureNewProjectDependency" returnType="void" parameters="String String"/>
          </file>
          <file name="tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java">
              <method name="testPr92837" returnType="void" parameters=""/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="118715" opendate="2005-11-30 16:53:00" fixdate="2005-12-7 6:39:00">
    <buginformation>
      <summary>Load Time Weaving wipes out Xlint files if no Xlint values</summary>
      <description>In ClassLoaderWeavingAdaptor if weaverOption.lint is null, then a loaded Xlint properties file gets overwritten by the default Xlint properties. See attached patch to fix this problem.</description>
      <comments>
		<comment id="1" date="2005-11-30 16:54:28 EST" author="Ron Bodkin">Created attachment 30903 [details]
Only parse default Xlint properties if an explicit Xlint properties file hasn't been loaded. Still allows Xlint options to override the values in a property file.</comment>
		<comment id="2" date="2005-12-01 12:26:00 EST" author="Matthew Webster">Created attachment 30959 [details]
New Xlint configuration for LTW

1. New xlint LTW tests
2. New &lt;run class="Test" xlintfile="mylint.properties"/&gt; attribute
3. New ordering for configuration

This patch includes the previous one.</comment>
		<comment id="3" date="2005-12-02 06:22:32 EST" author="Matthew Webster">Created attachment 31016 [details]
New Xlint configuration for LTW

1. Modified xlint file copy so that it's not renamed
2. Fixed small bug in WeavingAdaptor</comment>
		<comment id="4" date="2005-12-02 07:52:34 EST" author="Matthew Webster">Created attachment 31020 [details]
New Xlint configuration for LTW

2nd try</comment>
		<comment id="5" date="2005-12-06 04:09:36 EST" author="Matthew Webster">From email:

To test this, I need to copy a resource file (an Xlint.properties file) over to the sandbox directory to be accessible from the classloader at runtime. Is there any means already defined for copying resources over to the sandbox?
 
Ron</comment>
		<comment id="6" date="2005-12-06 04:11:31 EST" author="Matthew Webster">There is no mechanism for resource copying and there is no test (that I can find) for "-Xlintfile" in aop.xml. In fact there are no explicit Xlint LTW tests. I will add the necessary logic to the harness to copy an Xlint.properties file because I have already done it for aop.xml. However I don't think the current implementation is correct nor do I think your patch completely fixes it. I believe it should work like this:
1. Load XlintDefault.properties (otherwise all lint messages are WARNING)
2. Overlay LTW defaults i.e. ignore "adviceDidNotMatch" (see bug 117854)
3. Overlay user "-Xlintfile" (so they only have to specify the messages they want to tailor)
4. Override with user "-Xlint" option

Matthew


I agree: your proposed design sounds right: the userâs Xlintfile should be able to just partially override the defaults. And thanks for adding the logic to copy Xlint.properties files.

Ron</comment>
		<comment id="7" date="2005-12-06 08:02:13 EST" author="Andrew Clement">all checked in.</comment>
		<comment id="8" date="2005-12-07 06:39:46 EST" author="Andrew Clement">fixes available.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="1e1bbb3f2e7aab4757d715d76730cb68cceb3b87" author="aclement" date="2005-12-06 10:02:38"/>
          <file name="loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java">
          </file>
          <file name="testing/newsrc/org/aspectj/testing/OutputSpec.java">
              <method name="matchAgainst" returnType="void" parameters="String"/>
          </file>
          <file name="testing/newsrc/org/aspectj/testing/RunSpec.java">
          </file>
          <file name="testing/newsrc/org/aspectj/testing/XMLBasedAjcTestCase.java">
              <method name="getDigester" returnType="Digester" parameters=""/>
          </file>
          <file name="tests/src/org/aspectj/systemtest/ajc150/ltw/LTWTests.java">
              <method name="testAspectsIncludeWithLintWarning" returnType="void" parameters=""/>
          </file>
          <file name="weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java">
          </file>
          <file name="weaver5/java5-src/org/aspectj/weaver/reflect/Java15ReflectionBasedReferenceTypeDelegate.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="119543" opendate="2005-12-6 21:14:00" fixdate="2005-12-8 3:55:00">
    <buginformation>
      <summary>"[waiting-on-build] StringIndexOutOfBoundsException, perhaps due to nested aspects and targets"</summary>
      <description>Code and exception below.  

Same result for HEAD and AspectJ 1.5.0.20051206103951 via AJDT.

------------------------------- bugs/CachedToString.java

package bugs;

import java.lang.ref.SoftReference;

import junit.framework.TestCase;

public class CachedToString {

    /**
     * @param args
     */
    public static void main(String[] args) {
        new CacheGetterTest().testToString();
    }
    public static class CacheGetterTest extends TestCase {
        static boolean runAdvice;
        public void testToString() {
            RandomToString me = new RandomToString ();
            runAdvice = false;
            String one = me.toString();
            String two = me.toString();
            assertFalse(one.equals(two));
            runAdvice = true;
            one = me.toString();
            two = me.toString();
            assertTrue(one.equals(two));
        }
        static class RandomToString {
            static aspect CacheToString extends CachedItem&lt;String&gt; {
                public pointcut context() : if(runAdvice);
                public pointcut caching() :  
                    execution(String RandomToString.toString());
            }
            Random random = new Random(-1);
            public String toString() {
                return "" + random.nextFloat();
            }
        }
    }

    public abstract static aspect CachedItem&lt;Result&gt; pertarget(results()){
        SoftReference&lt;Result&gt; cache;

        boolean nullCache;

        // CODE writing pointcut trifecta separate context if extended and errors
        // getcode declaring-pointcuts-to-extend-with-caching START
        /**
         * Define join points to cache.
         * Must override, with staticly-determinable pointcuts 
         * that pick out join points that are permitted.
         */
        protected abstract pointcut caching();
            
        /** ok to use Result field-get or return value */
        private pointcut permitted() : get(Result *) || execution(Result *())
            || call(Result *()) || call(Result.new(..));

        /** Subaspects may add dynamic tests for the join points. */
        pointcut context() : !disabled();

        private pointcut disabled(); // fyi, undefined == none

        // getcode results START
        /** the pointcut composed from the user, as permitted, with context */
        pointcut results() : caching() &amp;&amp; permitted() &amp;&amp; context();
        // getcode results END

        Result around() :  results() {
            // ... }
            // getcode declaring-pointcuts-to-extend-with-caching END
            Result result;
            if (nullCache) {
                result = null;
            } else if ((null == cache) 
                    || (null == (result = cache.get()))){
                result = proceed();
                if (null == result) {
                    nullCache = true;
                } else {
                    cache = new SoftReference(result);
                }
            }
            return result;
        }

    }

}


------------------------------- exception
C:\home\ws\main-31\my-ajbugs\aspectj-src\bugs\CachedToString.java [error] Internal compiler error
java.lang.StringIndexOutOfBoundsException: String index out of range: -2
	at java.lang.String.substring(String.java:1768)
	at org.aspectj.weaver.TypeFactory.createTypeFromSignature(TypeFactory.java:86)
	at org.aspectj.weaver.UnresolvedType.forSignature(UnresolvedType.java:426)
	at org.aspectj.weaver.UnresolvedType.getOutermostType(UnresolvedType.java:601)
	at org.aspectj.weaver.ResolvedType.isVisible(ResolvedType.java:1259)
	at org.aspectj.weaver.ResolvedType.addPointcutsResolvingConflicts(ResolvedType.java:1743)
	at org.aspectj.weaver.ResolvedType.getExposedPointcuts(ResolvedType.java:1716)
	at org.aspectj.weaver.ResolvedType.getExposedPointcuts(ResolvedType.java:1710)
	at org.aspectj.ajdt.internal.compiler.lookup.EclipseSourceType.checkPointcutDeclarations(EclipseSourceType.java:293)
	at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.resolvePointcutDeclarations(AjLookupEnvironment.java:414)
	at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.resolvePointcutDeclarations(AjLookupEnvironment.java:419)
	at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.resolvePointcutDeclarations(AjLookupEnvironment.java:419)
	at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.resolvePointcutDeclarations(AjLookupEnvironment.java:419)
	at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.completeTypeBindings(AjLookupEnvironment.java:231)
	at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.beginToCompile(Compiler.java:301)
	at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:315)
	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:811)
	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:230)
	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:156)
	at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:112)
	at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:60)
	at org.aspectj.tools.ajc.Main.run(Main.java:326)
	at org.aspectj.tools.ajc.Main.runMain(Main.java:240)
	at org.aspectj.tools.ajc.Main.main(Main.java:83)

(no source information available)
ABORT
	
Exception thrown from AspectJ DEVELOPMENT

This might be logged as a bug already -- find current bugs at
  http://bugs.eclipse.org/bugs/buglist.cgi?product=AspectJ&amp;component=Compiler

Bugs for exceptions thrown have titles File:line from the top stack, 
e.g., "SomeFile.java:243"

If you don't find the exception below in a bug, please add a new bug
at http://bugs.eclipse.org/bugs/enter_bug.cgi?product=AspectJ
To make the bug a priority, please include a test program
that can reproduce this exception.
String index out of range: -2

when resolving pointcut declarations CachedToString
when completing type bindings 
when batch building with classpath: c:\home\apps\jdk15\jre\lib\ext\dnsns.jar;c:\home\apps\jdk15\jre\lib\ext\localedata.jar;c:\home\apps\jdk15\jre\lib\ext\sunjce_provider.jar;c:\home\apps\jdk15\jre\lib\ext\sunpkcs11.jar;C:\home\ws\main-31\lib\junit\junit.jar;C:\home\wes\dev\tools\aspectj-1.5\lib\aspectjrt.jar;
String index out of range: -2
java.lang.StringIndexOutOfBoundsException: String index out of range: -2
	at java.lang.String.substring(String.java:1768)
	at org.aspectj.weaver.TypeFactory.createTypeFromSignature(TypeFactory.java:86)
	at org.aspectj.weaver.UnresolvedType.forSignature(UnresolvedType.java:426)
	at org.aspectj.weaver.UnresolvedType.getOutermostType(UnresolvedType.java:601)
	at org.aspectj.weaver.ResolvedType.isVisible(ResolvedType.java:1259)
	at org.aspectj.weaver.ResolvedType.addPointcutsResolvingConflicts(ResolvedType.java:1743)
	at org.aspectj.weaver.ResolvedType.getExposedPointcuts(ResolvedType.java:1716)
	at org.aspectj.weaver.ResolvedType.getExposedPointcuts(ResolvedType.java:1710)
	at org.aspectj.ajdt.internal.compiler.lookup.EclipseSourceType.checkPointcutDeclarations(EclipseSourceType.java:293)
	at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.resolvePointcutDeclarations(AjLookupEnvironment.java:414)
	at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.resolvePointcutDeclarations(AjLookupEnvironment.java:419)
	at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.resolvePointcutDeclarations(AjLookupEnvironment.java:419)
	at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.resolvePointcutDeclarations(AjLookupEnvironment.java:419)
	at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.completeTypeBindings(AjLookupEnvironment.java:231)
	at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.beginToCompile(Compiler.java:301)
	at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:315)
	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:811)
	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:230)
	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:156)
	at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:112)
	at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:60)
	at org.aspectj.tools.ajc.Main.run(Main.java:326)
	at org.aspectj.tools.ajc.Main.runMain(Main.java:240)
	at org.aspectj.tools.ajc.Main.main(Main.java:83)


1 fail|abort, 1 error
Signal 127</description>
      <comments>
		<comment id="1" date="2005-12-07 05:53:35 EST" author="Helen Beeken">Created attachment 31284 [details]
testcase patch

Apply this patch to the tests project.

This patch contains a simplified testcase which recreates the problem. In order for the problem to manifest it needs:

1. An inner generic aspect which contains more than one pointcut and some advice which uses all the pointcuts
2. An inner aspect which extends the generic aspect</comment>
		<comment id="2" date="2005-12-07 08:22:29 EST" author="Helen Beeken">When there are two pointcuts UnresolvedType.getOuterMostType() is called on a ReferenceType with signature "LPR119543$A" and also with signature "PPR119543$A&lt;Ljava/lang/String;&gt;;". Since there is a "$", this method returns UnresolvedType.forSigntaure(sig.substring(0,sig.indexOf("$") + ";") which in the second case is UnresolvedType.forSignature("PPR119543"). Since "PPR119543" starts with a "P" this calls TypeFactory.createTypeFromSignature("PPR119543"). Inside this method since we start with a "P" we assume this is parameterized and consequently look for the positions of "&lt;" and "&gt;" which in this case don't exist. The call signature.substring(1,startOfParams) becomes "PPR119543".substring(1,-1) which blows up with the StringOutOfBoundsException. 

In the case where there is only one pointcut we never call UnresolvedType.getOuterMostType() on a ReferenceType with signature "PPR119543$A&lt;Ljava/lang/String;&gt;;". Instead, it's only called on a ReferenceType with signature "LPR119543$A". </comment>
		<comment id="3" date="2005-12-07 09:06:57 EST" author="Helen Beeken">In the case when there are two pointcuts, the method ResolvedType.addPointcutsResolvingConflicts(List acc,List added, boolean isOverriding) is called with the parameterrs:

acc = []
added = [pointcut PR119543$A&lt;java.lang.String&gt;.caching(), pointcut PR119543$A&lt;java.lang.String&gt;.permitted()]
isOverriding = true

This method iterates over the "added" list checking to see if there are any conflicts. At the end of every iteration it adds the pointcut to the acc list so it can calcualate possible conflicts with the other pointcuts it hasn't looked at yet. If there's only one pointcut then there clearly aren't any conflicts. If there are two pointcuts, then it just places the first one in the "acc" list since it hasn't discovered any conflicts yet. When it comes to look at the permitted() pointcut the caching() pointcut is in the acc list so it gets hold of this and starts comparing it for conflicts. The first check is whether they are the same. They're not so we continue. The second check is a call to 

isVisible(existing.getModifiers(), existing.getDeclaringType().resolve(getWorld()),this)

where existing.getDeclaringType().resolve(getWorld()) is the ResolvedType with signature "PPR119543$A&lt;Ljava/lang/String;&gt;;" and this is the ResolvedType also with signature "PPR119543$A&lt;Ljava/lang/String;&gt;;". It is the call getOutermostType() on these ResolvedType's which cause the StringOutOfBoundsException.</comment>
		<comment id="4" date="2005-12-07 09:59:49 EST" author="Helen Beeken">Created attachment 31298 [details]
improved testcase patch

Apply this patch to the tests project.

This testcase replaces the previously attached one as it checks for the advice not applied anywhere warning.</comment>
		<comment id="5" date="2005-12-07 10:01:27 EST" author="Helen Beeken">Created attachment 31299 [details]
patch containing fix

Apply to the weaver project.

The fix is to use the erasureSignature rather than the signature when getting the outermost type. The erasureSignature doesn't know about "P"'s and "&lt;"'s and works with the raw type.</comment>
		<comment id="6" date="2005-12-07 12:21:29 EST" author="Andrew Clement">fixes checked in.</comment>
		<comment id="7" date="2005-12-08 03:55:43 EST" author="Andrew Clement">fix available</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="a7bc19f804487d6160c5f29eec94e2442e38957e" author="aclement" date="2005-12-08 02:15:13"/>
          <file name="tests/bugs150/PR119543.java">
          </file>
          <file name="tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java">
              <method name="getSpecFile" returnType="File" parameters=""/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="109614" opendate="2005-9-15 9:57:00" fixdate="2005-12-8 10:17:00">
    <buginformation>
      <summary>[waiting-on-build] [iajc.task] java.lang.RuntimeException: Ranges must be updated with an enclosing instructionList</summary>
      <description>I am getting following error when compiling code using iajc ant task:


[iajc.task] trouble in:
[iajc.task] public class admin.modelbean.AdminUserMB extends web.FormSupport:
[iajc.task]   private static final org.apache.log4j.Logger log
....

(Ljava/lang/String;)Ljava/lang/StringBuffer;
[iajc.task]     | method-call(java.lang.StringBuffer
java.lang.StringBuffer.append(java.lang.String))
[iajc.task]     |               LDC_W "}"   (line 249)
[iajc.task]     | method-call(java.lang.StringBuffer
java.lang.StringBuffer.append(java.lang.String))
[iajc.task]     | |             INVOKEVIRTUAL java.lang.StringBuffer.append
(Ljava/lang/String;)Ljava/lang/StringBuffer;
[iajc.task]     | method-call(java.lang.StringBuffer
java.lang.StringBuffer.append(java.lang.String))
[iajc.task]     | method-call(java.lang.String java.lang.StringBuffer.toString())
[iajc.task]     | |             INVOKEVIRTUAL java.lang.StringBuffer.toString
()Ljava/lang/String;   (line 236)
[iajc.task]     | method-call(java.lang.String java.lang.StringBuffer.toString())
[iajc.task]     |               ARETURN
[iajc.task]     method-execution(java.lang.String
admin.modelbean.AdminUserMB.toString())
[iajc.task]   end public String toString()
[iajc.task] end public class admin.modelbean.AdminUserMB
[iajc.task] java.lang.RuntimeException: Ranges must be updated with an enclosinginstructionList
[iajc.task]     at org.aspectj.weaver.bcel.Range.updateTarget(Range.java:170)
[iajc.task]     at org.aspectj.weaver.bcel.BcelShadow.retargetFrom(BcelShadow.java:235)
[iajc.task]     at org.aspectj.weaver.bcel.BcelShadow.deleteNewAndDup(BcelShadow.java:212)
[iajc.task]     at org.aspectj.weaver.bcel.BcelShadow.prepareForMungers(BcelShadow.java:252)
[iajc.task]     at org.aspectj.weaver.Shadow.implement(Shadow.java:374)
[iajc.task]     at org.aspectj.weaver.bcel.BcelClassWeaver.implement(BcelClassWeaver.java:1754)
[iajc.task]     at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:393)
[iajc.task]     at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:96)
[iajc.task]     at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1372)
[iajc.task]     at org.aspectj.weaver.bcel.BcelWeaver.weaveWithoutDump(BcelWeaver.java:1337)
[iajc.task]     at org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify(BcelWeaver.java:1114)
[iajc.task]     at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1001)
[iajc.task]     at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave(AjCompilerAdapter.java:286)
[iajc.task]     at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling(AjCompilerAdapter.java:165)
[iajc.task]     at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$afterReturning$org_aspectj_ajdt_internal_compiler_CompilerAdapter$2$f9cc9ca0(CompilerAdapter.aj:70)
[iajc.task]     at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:367)
[iajc.task]     at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:728)
[iajc.task]     at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:206)
[iajc.task]     at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:140)
[iajc.task]     at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:112)
[iajc.task]     at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:60)
[iajc.task]     at org.aspectj.tools.ajc.Main.run(Main.java:324)
[iajc.task]     at org.aspectj.tools.ajc.Main.runMain(Main.java:238)
[iajc.task]     at org.aspectj.tools.ajc.Main.main(Main.java:82)
[iajc.task] ABORT
[iajc.task]
[iajc.task] Exception thrown from AspectJ 1.5.0_M3a

[iajc.task] This might be logged as a bug already -- find current bugs at
[iajc.task]  
http://bugs.eclipse.org/bugs/buglist.cgi?product=AspectJ&amp;component=Compiler

[iajc.task] Bugs for exceptions thrown have titles File:line from the top stack,
[iajc.task] e.g., "SomeFile.java:243"

[iajc.task] If you don't find the exception below in a bug, please add a new bug
[iajc.task] at http://bugs.eclipse.org/bugs/enter_bug.cgi?product=AspectJ
[iajc.task] To make the bug a priority, please include a test program
[iajc.task] that can reproduce this exception.
[iajc.task] Ranges must be updated with an enclosing instructionList
[iajc.task] Ranges must be updated with an enclosing instructionList
[iajc.task] java.lang.RuntimeException: Ranges must be updated with an enclosing instructionList
[iajc.task]     at org.aspectj.weaver.bcel.Range.updateTarget(Range.java:170)
[iajc.task]     at org.aspectj.weaver.bcel.BcelShadow.retargetFrom(BcelShadow.java:235)
[iajc.task]     at org.aspectj.weaver.bcel.BcelShadow.deleteNewAndDup(BcelShadow.java:212)
[iajc.task]     at org.aspectj.weaver.bcel.BcelShadow.prepareForMungers(BcelShadow.java:252)
[iajc.task]     at org.aspectj.weaver.Shadow.implement(Shadow.java:374)
[iajc.task]     at org.aspectj.weaver.bcel.BcelClassWeaver.implement(BcelClassWeaver.java:1754)
[iajc.task]     at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:393)
[iajc.task]     at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:96)
[iajc.task]     at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1372)
[iajc.task]     at org.aspectj.weaver.bcel.BcelWeaver.weaveWithoutDump(BcelWeaver.java:1337)
[iajc.task]     at org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify(BcelWeaver.java:1114)
[iajc.task]     at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1001)
[iajc.task]     at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave(AjCompilerAdapter.java:286)
[iajc.task]     at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling(AjCompilerAdapter.java:165)
[iajc.task]     at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$afterReturning$org_aspectj_ajdt_internal_compiler_CompilerAdapter$2$f9cc9ca0(CompilerAdapter.aj:70)
[iajc.task]     at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:367)
[iajc.task]     at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:728)
[iajc.task]     at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:206)
[iajc.task]     at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:140)
[iajc.task]     at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:112)
[iajc.task]     at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:60)
[iajc.task]     at org.aspectj.tools.ajc.Main.run(Main.java:324)
[iajc.task]     at org.aspectj.tools.ajc.Main.runMain(Main.java:238)
[iajc.task]     at org.aspectj.tools.ajc.Main.main(Main.java:82)


[iajc.task] 1 fail|abort

BUILD FAILED
/home/sbhatti/workspace/devint/build.xml:100: The following error occurred while
executing this line:
/home/sbhatti/workspace/devint/build.xml:164: The following error occurred while
executing this line:
/home/sbhatti/workspace/devint/modules/novo/build.xml:59: The following error
occurred while executing this line:
/opt/sbhatti/dev/current/novo/build.xml:326: failure[-1] running ajc</description>
      <comments>
		<comment id="1" date="2005-09-15 11:07:27 EDT" author="Matt Chapman">Passing over to AspectJ</comment>
		<comment id="2" date="2005-09-15 12:22:30 EDT" author="Andrew Clement">It is blowing up whilst processing the shadow for a constructor call - is there
anyway we can have the rest of the iajc output?  At the top of the input it
looks it was truncated so you just added the exception trace to the bug report -
but if you include the earlier stuff (where the "| method-call" stuff is), I may
be able to see what went wrong.  

Is it at all possible that you could attach the AdminUserMB class and the aspect
you used on it?</comment>
		<comment id="3" date="2005-09-15 13:30:48 EDT" author="shahzad bhatti">Created attachment 27178 [details]
Class that is failing to compile</comment>
		<comment id="4" date="2005-09-15 13:31:24 EDT" author="shahzad bhatti">Created attachment 27179 [details]
Aspect</comment>
		<comment id="5" date="2005-09-19 01:44:21 EDT" author="Wes Isberg">Looks like a compiler bug, not an ant task bug.  Let me know if I can help.</comment>
		<comment id="6" date="2005-09-30 08:46:44 EDT" author="Andrew Clement">We have recently added extra diagnostics to AspectJ that will give us more
context about a failure when the compiler goes bang.  Can you possibly download
the latest dev build and recreate this? Hopefully the exception produced will be
more informative.</comment>
		<comment id="7" date="2005-10-28 07:10:08 EDT" author="Adrian Colyer">moving to P2</comment>
		<comment id="8" date="2005-11-29 03:46:20 EST" author="Andrew Clement">I've been trying to recreate this.  I can use the aspect just about as is - but the AdminUserDB class just has too many dependencies.  I created a cut down version but can't get a failure.

Is it still failing for you?

Please can you try it with the most recent compiler version and include *all* the output here so I can see exactly which constructor-call shadow is causing the problem?  I really want to fix this for 1.5 - but if I can't recreate it, theres nothing I can do.

What would also be helpful is to try trimming down the code in the AdminUserDB class and see when the error suddenly disappears.

or if you could supply me all the dependencies for that class (the orbitz stuff) then I can try harder to recreate it here.</comment>
		<comment id="9" date="2005-12-07 12:26:17 EST" author="Andrew Clement">I've recreated this (woohoo) using the comment on bug 93489. I'll work on it tmrw.</comment>
		<comment id="10" date="2005-12-08 06:43:39 EST" author="Andrew Clement">Fix for this is checked in.</comment>
		<comment id="11" date="2005-12-08 10:17:40 EST" author="Andrew Clement">fix available.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="94159f9e80233497e02899c91a126ea5a3b605cc" author="aclement" date="2005-12-08 08:43:16"/>
          <file name="tests/bugs150/pr109614.java">
          </file>
          <file name="tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/bcel/BcelShadow.java">
              <method name="deleteNewAndDup" returnType="void" parameters=""/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="119210" opendate="2005-12-5 2:49:00" fixdate="2005-12-8 12:30:00">
    <buginformation>
      <summary>NullPointerException with around advice on field-set</summary>
      <description>I met NullPointerException when weaving. Doesn't Aj support this situations?

public class TestLib {

	  private static int myInt;
	  static {
		  myInt = 1;
	  }
	  public static void main(String[] args) {
		// TODO Auto-generated method stub
		System.out.println("myInt="+myInt);
	  }
}

public aspect ThreadAspectLib {
	pointcut setThreadLocalsField():set(private int TestLib.myInt);
	
	Integer around():setThreadLocalsField()
	{
		try{
			return new Integer(2);
		}
		catch(Exception e)
		{
			e.printStackTrace();
			return null;
		}
	}
}

---- AspectJ Properties ---
AspectJ Compiler DEVELOPMENT built on Tuesday Jun 14, 2005 at 15:41:05 GMT
---- Dump Properties ---
Dump file: ajcore.20051205.145247.250.txt
Dump reason: java.lang.NullPointerException
Dump on exception: true
Dump at exit condition: abort
---- Exception Information ---
java.lang.NullPointerException
	at org.aspectj.weaver.ResolvedTypeX$Primitive.isAssignableFrom(ResolvedTypeX.java:985)
	at org.aspectj.weaver.ResolvedTypeX.isAssignableFrom(ResolvedTypeX.java:96)
	at org.aspectj.weaver.Advice.match(Advice.java:143)
	at org.aspectj.weaver.bcel.BcelClassWeaver.match(BcelClassWeaver.java:1673)
	at org.aspectj.weaver.bcel.BcelClassWeaver.matchSetInstruction(BcelClassWeaver.java:1543)
	at org.aspectj.weaver.bcel.BcelClassWeaver.match(BcelClassWeaver.java(Compiled Code))
	at org.aspectj.weaver.bcel.BcelClassWeaver.match(BcelClassWeaver.java(Compiled Code))
	at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:377)
	at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:94)
	at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1362)
	at org.aspectj.weaver.bcel.BcelWeaver.weaveWithoutDump(BcelWeaver.java:1327)
	at org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify(BcelWeaver.java:1106)
	at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:993)
	at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave(AjCompilerAdapter.java:286)
	at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling(AjCompilerAdapter.java:165)
	at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$afterReturning$org_aspectj_ajdt_internal_compiler_CompilerAdapter$2$f9cc9ca0(CompilerAdapter.aj:70)
	at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:368)
	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:727)
	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:206)
	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:140)
	at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:112)
	at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:60)
	at org.aspectj.tools.ajc.Main.run(Main.java:318)
	at org.aspectj.tools.ajc.Main.runMain(Main.java:228)
	at org.aspectj.tools.ant.taskdefs.AjcTask.executeInSameVM(AjcTask.java:1194)
	at org.aspectj.tools.ant.taskdefs.AjcTask.execute(AjcTask.java:985)
	at org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:275)
	at org.apache.tools.ant.Task.perform(Task.java:364)
	at org.apache.tools.ant.Target.execute(Target.java:341)
	at org.apache.tools.ant.Target.performTasks(Target.java:369)
	at org.apache.tools.ant.Project.executeTarget(Project.java:1214)
	at org.apache.tools.ant.Project.executeTargets(Project.java:1062)
	at org.apache.tools.ant.Main.runBuild(Main.java:690)
	at org.apache.tools.ant.Main.startAnt(Main.java:200)
	at org.apache.tools.ant.launch.Launcher.run(Launcher.java:196)
	at org.apache.tools.ant.launch.Launcher.main(Launcher.java:55)
---- System Properties ---
java.assistive=ON
java.runtime.name=Java(TM) 2 Runtime Environment, Standard Edition
sun.boot.library.path=C:\Program Files\IBM\Java141\jre\bin
java.vm.version=1.4.1
java.vm.vendor=IBM Corporation
java.vendor.url=http://www.ibm.com/
path.separator=;
java.vm.name=Classic VM
file.encoding.pkg=sun.io</description>
      <comments>
		<comment id="1" date="2005-12-05 04:13:06 EST" author="Andrew Clement">You are running on quite an old version of AspectJ.  If you compile this program on a more recent build, you won't get an NPE.  However, I'm still investigating what does happen - thinking about what the right result is.  
Are you compiling with the -1.5 flag?  
Are you expecting autoboxing to allow transformation of int to Integer and vice versa?</comment>
		<comment id="2" date="2005-12-07 07:06:43 EST" author="Andrew Clement">through the magic of autoboxing, this probably ought to work ...</comment>
		<comment id="3" date="2005-12-08 10:41:46 EST" author="Andrew Clement">Hang on ... from the docs:

http://eclipse.org/aspectj/doc/released/progguide/semantics-joinPoints.html

Field set
    When a field is assigned to. Field set join points are considered to have one argument, the value the field is being set to. No value is returned from a field set join point, so its return type is considered to be void.

so the advice doesn't match, correctly, with the right message:

"incompatible return type applying to field-set(int TestLib.myInt)"


However, I checked the related case, where around advice using the boxed form of a primitive matches on a join point returning the unboxed form, and that blew up!

So, I've fixed this case and its reverse (the advice uses the unboxed form and join point returns the boxed form).

fix checked in.</comment>
		<comment id="4" date="2005-12-08 12:30:49 EST" author="Andrew Clement">fix available in aj - will be in AJDT in a few days.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="f5f36e2dd0f1318f44397f691c480967c57dbfb4" author="aclement" date="2005-12-09 12:32:36"/>
          <file name="tests/bugs150/pr119210/TestLib.java">
          </file>
          <file name="tests/bugs150/pr119210/TestLib2.java">
          </file>
          <file name="tests/bugs150/pr119210/ThreadAspectLib.java">
          </file>
          <file name="tests/bugs150/pr119210/ThreadAspectLib2.java">
          </file>
          <file name="tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java">
              <method name="getSpecFile" returnType="File" parameters=""/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="119353" opendate="2005-12-5 23:11:00" fixdate="2005-12-9 9:02:00">
    <buginformation>
      <summary>Inconsistent Implementations of ReferenceType.getDeclaredMethods()</summary>
      <description>I am running into a problem in load-time weaving when I use reflection delegates because the weaver is generating an incorrect bridge method when I perform an inter-type declaration on Struts.ActionServlet for the init method. On investigation, the BCEL world is recognizing this as an overriding method, because its version of getDeclaredMethods is returning the declared methods for all ancestor superclasses. However, the reflection world is returning only the declared methods for this one class. It therefore appears that the weaver expects getDeclaredMethods to return all of them (making the name quite misleading). I think previously the method was being implemented inconsistently between 1.5 reflection and &lt;1.5 reflection delegates. But it looks like it needs to be handled consistently to include all superclass methods.

However, I don't know what other places (e.g., the MAP) are really expecting getDeclaredMethods and its siblings to behave like Java reflection's versionÂ

I started work on adding a getAllDeclaredMethods method to ReferenceType and delegates, as an alternative to provide the weaver the ability to check method overriding as in this case, but it's a little bit involved and I wanted to flag the issue first.

Here's a test that fails and illustrates the issue:
Index: ReflectionBasedReferenceTypeDelegateTest.java
===================================================================
RCS file: /home/technology/org.aspectj/modules/weaver/testsrc/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateTest.java,v
retrieving revision 1.5
diff -u -r1.5 ReflectionBasedReferenceTypeDelegateTest.java
--- ReflectionBasedReferenceTypeDelegateTest.java	28 Nov 2005 17:44:40 -0000	1.5
+++ ReflectionBasedReferenceTypeDelegateTest.java	6 Dec 2005 04:11:41 -0000
@@ -238,6 +238,18 @@
         assertTrue("Superclass for Map generic type should be Object but was "+rt2,rt2.equals(UnresolvedType.OBJECT));         
     }
     
+    public void testCompareSubclassDelegates() {
+        world.setBehaveInJava5Way(true);
+        
+        BcelWorld bcelWorld = new BcelWorld();
+        bcelWorld.setBehaveInJava5Way(true);
+        UnresolvedType javaUtilHashMap = UnresolvedType.forName("java.util.HashMap");
+        ReferenceType rawType = (ReferenceType)bcelWorld.resolve(javaUtilHashMap );
+        
+        ReferenceType rawReflectType = (ReferenceType)world.resolve(javaUtilHashMap );
+        assertEquals(rawType.getDelegate().getDeclaredMethods().length, rawReflectType.getDelegate().getDeclaredMethods().length);
+    }
+    
 	// todo: array of int	
 
 	protected void setUp() throws Exception {


This results in:
junit.framework.AssertionFailedError: expected:&lt;41&gt; but was:&lt;29&gt;
	at junit.framework.Assert.fail(Assert.java:47)
	at junit.framework.Assert.failNotEquals(Assert.java:282)
	at junit.framework.Assert.assertEquals(Assert.java:64)
	at junit.framework.Assert.assertEquals(Assert.java:201)
	at junit.framework.Assert.assertEquals(Assert.java:207)
	at org.aspectj.weaver.reflect.ReflectionBasedReferenceTypeDelegateTest.testCompareSubclassDelegates(ReflectionBasedReferenceTypeDelegateTest.java:250)
	at java.lang.reflect.Method.invoke(Native Method)
	at junit.framework.TestCase.runTest(TestCase.java:154)
	at junit.framework.TestCase.runBare(TestCase.java:127)
	at junit.framework.TestResult$1.protect(TestResult.java:106)
	at junit.framework.TestResult.runProtected(TestResult.java:124)
	at junit.framework.TestResult.run(TestResult.java:109)
	at junit.framework.TestCase.run(TestCase.java:118)
	at junit.framework.TestSuite.runTest(TestSuite.java:208)
	at junit.framework.TestSuite.run(TestSuite.java:203)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:478)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:344)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196)</description>
      <comments>
		<comment id="1" date="2005-12-05 23:12:13 EST" author="Ron Bodkin">Two small clarifications: the incorrect bridge method results in a VerifyError. If I use only BCEL delegates then the system behaves properly.</comment>
		<comment id="2" date="2005-12-08 10:45:12 EST" author="Andrew Clement">I modified the test program to output what the differences are between the two sets.  Interesting results:

Couldn't find java.util.HashMap java.util.HashMap.init(int) in the bcel set
Couldn't find java.util.HashMap java.util.HashMap.init() in the bcel set
Couldn't find java.util.HashMap java.util.HashMap.init(java.util.Map) in the bcel set
Couldn't find java.util.HashMap java.util.HashMap.init(int, float) in the bcel set
Couldn't find void java.util.HashMap.&lt;init&gt;(int, float) in the reflection set
Couldn't find void java.util.HashMap.&lt;init&gt;(int) in the reflection set
Couldn't find void java.util.HashMap.&lt;init&gt;() in the reflection set
Couldn't find void java.util.HashMap.&lt;init&gt;(java.util.Map) in the reflection set
Couldn't find void java.util.HashMap.&lt;clinit&gt;() in the reflection set

I don't like the disagreement between the 'init' and '&lt;init&gt;' strings.  I suspect that is the root of this problem.  I'm not sure about the &lt;clinit&gt; - but at least we know that can't have an impact on bridge methods ;)

I'm not sure how this quite ties up with Rons description that getDeclaredMethods() is differing in each case as the initial fix here just seems to be transforming the reflection based entries for ctors to indicate &lt;init&gt;...</comment>
		<comment id="3" date="2005-12-08 10:53:18 EST" author="Andrew Clement">Created attachment 31379 [details]
Patch to the delegates (1.5 and &lt; 1.5)

Ron ... this zip contains two patches, one for the weaver project, one for weaver5 - can you try it out and see if it helps your situation with the rogue bridge method?  Basically I've made the reflection world return the same thing as the bcel world.  The test I modified still fails because of the &lt;clinit&gt; method but that shouldnt impact bridge method creation.</comment>
		<comment id="4" date="2005-12-08 10:57:49 EST" author="Andrew Clement">Hmmm .. I just re-read the original append by Ron.

In my case I wasn't getting 41 and 29, I was getting 41 and 40.

perhaps I'm not running it in quite the same way - i'll keep hacking away - but if you could try the patch it might help with the bridge problem.</comment>
		<comment id="5" date="2005-12-08 23:18:53 EST" author="Ron Bodkin">I will try the patches and report back...

On closer examination, the 29 vs 41 methods I was seeing was on a Java 1.3.1 VM but running in Eclipse where the Java 1.5 JRE was on the classpath and BCEL was using that to resolve types (!). When corrected to use a 1.3 JRE in Eclipse, I see 29 vs 30 methods on a Java 1.3 VM and I always saw 40 vs 41 on a Java 1.5 VM. Hopefully this test will show 29 vs 30 when run via ant (the docs on how to run ant tests for a module from the command line aren't working for me...)

Reflect:
put, clone, get, access$000, access$100, values, size, access$200, clear, remove, access$300, loadFactor, keySet, entrySet, isEmpty, containsValue, containsKey, rehash, putAll, writeObject, readObject, capacity, getHashIterator, access$308, access$110, init, init, init, init
BCEL:
&lt;init&gt;, &lt;init&gt;, &lt;init&gt;, &lt;init&gt;, size, isEmpty, containsValue, containsKey, get, rehash, put, remove, putAll, clear, clone, keySet, values, entrySet, getHashIterator, writeObject, readObject, capacity, loadFactor, access$000, access$100, access$200, access$308, access$110, access$300, &lt;clinit&gt;</comment>
		<comment id="6" date="2005-12-08 23:51:02 EST" author="Ron Bodkin">It looks like those patches fix the problem (although I had to patch the patches to use an IReflectionWorld interface that my LTWWorld implementation also implements :-)). I am not seeing the same error messages and things appear to be working properly on a quick run. Thanks!</comment>
		<comment id="7" date="2005-12-09 03:39:40 EST" author="Andrew Clement">fixes checked in - thanks for trying them out Ron. waiting on build.</comment>
		<comment id="8" date="2005-12-09 03:41:26 EST" author="Andrew Clement">oops - closed prematurely.  i'm really waiting on the build...</comment>
		<comment id="9" date="2005-12-09 09:02:37 EST" author="Andrew Clement">fix available.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="b52515fc2319ca34a045a0823ca0f5c8ffeaa2de" author="aclement" date="2005-12-09 05:40:12"/>
          <file name="weaver/src/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateFactory.java">
              <method name="createResolvedConstructor" returnType="ResolvedMember" parameters="Constructor World"/>
          </file>
          <file name="weaver/testsrc/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateTest.java">
          </file>
          <file name="weaver5/java5-src/org/aspectj/weaver/reflect/Java15ReflectionBasedReferenceTypeDelegate.java">
              <method name="createGenericConstructorMember" returnType="ResolvedMember" parameters="Constructor"/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="120351" opendate="2005-12-12 5:17:00" fixdate="2005-12-12 5:47:00">
    <buginformation>
      <summary>"cflowbelow issue when binding, in @AJ"</summary>
      <description>Sam wrote:

&gt; I'm trying something and it works from .aj but not from .java.  When
&gt; I try it with annotation based stuff I get a nasty exception:
&gt;
&gt;       [iajc] trouble in:
&gt;       [iajc] public class gsc.repository.IdentifierTest extends
&gt; junit.framework.TestCase:
&gt;       [iajc]   private static final org.aspectj.lang.JoinPoint
&gt; $StaticPart ajc$tjp_0
&gt;       [iajc]   public void &lt;init&gt;():
&gt;       [iajc]                     ALOAD_0
&gt;       [iajc]                     INVOKESPECIAL
&gt; junit.framework.TestCase.&lt;init&gt; ()V
&gt;       [iajc]     constructor-execution(void
&gt; gsc.repository.IdentifierTest.&lt;init&gt;())
&gt;       [iajc]     |               RETURN
&gt;       [iajc]     constructor-execution(void
&gt; gsc.repository.IdentifierTest.&lt;init&gt;())
&gt;       [iajc]   end public void &lt;init&gt;()
&gt;
&gt;       [iajc]   public void testIdentifierExactMatch() throws
&gt; java.security.NoSuchAlgorithmException, java.io.IOException:
&gt;       [iajc]     method-execution(void
&gt; gsc.repository.IdentifierTest.testIdentifierExactMatch())
&gt;       [iajc]     |               NEW java.io.File
&gt;       [iajc]     |               DUP
&gt;       [iajc]     |               LDC "test-repository/ant-test/jars/
&gt; ant-1.6.2.jar"
&gt;       [iajc]     |               INVOKESPECIAL java.io.File.&lt;init&gt;
&gt; (Ljava/lang/String;)V
&gt;       [iajc]     |               INVOKESTATIC
&gt; gsc.repository.Identifier.interrogate (Ljava/io/File;)Ljava/util/List;
&gt;       [iajc]     |               ASTORE_1
&gt;       [iajc]     |               ALOAD_1
&gt;       [iajc]     |               ICONST_0
&gt;       [iajc]     |               INVOKEINTERFACE java.util.List.get
&gt; (I)Ljava/lang/Object;
&gt;       [iajc]     |               CHECKCAST gsc.repository.ejb.Jar
&gt;       [iajc]     |               ASTORE_2
&gt;       [iajc]     |               ALOAD_2
&gt;       [iajc]     |               INVOKEVIRTUAL
&gt; gsc.repository.ejb.Jar.getVersion ()Ljava/lang/String;
&gt;       [iajc]     |               LDC "1.6.2"
&gt;       [iajc]     |               INVOKESTATIC
&gt; gsc.repository.IdentifierTest.assertEquals (Ljava/lang/String;Ljava/
&gt; lang/String;)V
&gt;       [iajc]     |               RETURN
&gt;       [iajc]     method-execution(void
&gt; gsc.repository.IdentifierTest.testIdentifierExactMatch())
&gt;       [iajc]   end public void testIdentifierExactMatch() throws
&gt; java.security.NoSuchAlgorithmException, java.io.IOException
&gt;
&gt;       [iajc]   public void testIdentifierExactSameClasses() throws
&gt; java.security.NoSuchAlgorithmException, java.io.IOException:
&gt;       [iajc]     method-execution(void
&gt; gsc.repository.IdentifierTest.testIdentifierExactSameClasses())
&gt;       [iajc]     |               NEW java.io.File
&gt;       [iajc]     |               DUP
&gt;       [iajc]     |               LDC "test-jars/ant-1.6.2-test.jar"
&gt;       [iajc]     |               INVOKESPECIAL java.io.File.&lt;init&gt;
&gt; (Ljava/lang/String;)V
&gt;       [iajc]     |               INVOKESTATIC
&gt; gsc.repository.Identifier.interrogate (Ljava/io/File;)Ljava/util/List;
&gt;       [iajc]     |               ASTORE_1
&gt;       [iajc]     |               ALOAD_1
&gt;       [iajc]     |               ICONST_0
&gt;       [iajc]     |               INVOKEINTERFACE java.util.List.get
&gt; (I)Ljava/lang/Object;
&gt;       [iajc]     |               CHECKCAST gsc.repository.ejb.Jar
&gt;       [iajc]     |               ASTORE_2
&gt;       [iajc]     |               ALOAD_2
&gt;       [iajc]     |               INVOKEVIRTUAL
&gt; gsc.repository.ejb.Jar.getVersion ()Ljava/lang/String;
&gt;       [iajc]     |               LDC "1.6.2"
&gt;       [iajc]     |               INVOKESTATIC
&gt; gsc.repository.IdentifierTest.assertEquals (Ljava/lang/String;Ljava/
&gt; lang/String;)V
&gt;       [iajc]     |               RETURN
&gt;       [iajc]     method-execution(void
&gt; gsc.repository.IdentifierTest.testIdentifierExactSameClasses())
&gt;       [iajc]   end public void testIdentifierExactSameClasses()
&gt; throws java.security.NoSuchAlgorithmException, java.io.IOException
&gt;
&gt;       [iajc]   public void testIdentifierMixedUp() throws
&gt; java.security.NoSuchAlgorithmException, java.io.IOException:
&gt;       [iajc]     method-execution(void
&gt; gsc.repository.IdentifierTest.testIdentifierMixedUp())
&gt;       [iajc]     |               NEW java.io.File
&gt;       [iajc]     |               DUP
&gt;       [iajc]     |               LDC "test-jars/groovy-1.0-beta-4-and-
&gt; commons-logging-1.0.2.jar"
&gt;       [iajc]     |               INVOKESPECIAL java.io.File.&lt;init&gt;
&gt; (Ljava/lang/String;)V
&gt;       [iajc]     |               INVOKESTATIC
&gt; gsc.repository.Identifier.interrogate (Ljava/io/File;)Ljava/util/List;
&gt;       [iajc]     |               ASTORE_1
&gt;       [iajc]     |               ALOAD_1
&gt;       [iajc]     |               INVOKEINTERFACE java.util.List.size ()I
&gt;       [iajc]     |               ICONST_2
&gt;       [iajc]     |               INVOKESTATIC
&gt; gsc.repository.IdentifierTest.assertEquals (II)V
&gt;       [iajc]     |               ICONST_2
&gt;       [iajc]     |               ISTORE_2
&gt;       [iajc]     |               ALOAD_1
&gt;       [iajc]     |               INVOKEINTERFACE
&gt; java.util.List.iterator ()Ljava/util/Iterator;
&gt;       [iajc]     |               ASTORE_3
&gt;       [iajc]     |           L0: ALOAD_3
&gt;       [iajc]     |               INVOKEINTERFACE
&gt; java.util.Iterator.hasNext ()Z
&gt;       [iajc]     |               IFEQ L3
&gt;       [iajc]     |               ALOAD_3
&gt;       [iajc]     |               INVOKEINTERFACE
&gt; java.util.Iterator.next ()Ljava/lang/Object;
&gt;       [iajc]     |               CHECKCAST gsc.repository.ejb.Jar
&gt;       [iajc]     |               ASTORE 4
&gt;       [iajc]     |               ALOAD 4
&gt;       [iajc]     |               INVOKEVIRTUAL
&gt; gsc.repository.ejb.Jar.getGroupid ()Ljava/lang/String;
&gt;       [iajc]     |               LDC "groovy"
&gt;       [iajc]     |               INVOKEVIRTUAL
&gt; java.lang.String.equals (Ljava/lang/Object;)Z
&gt;       [iajc]     |               IFEQ L1
&gt;       [iajc]     |               ALOAD 4
&gt;       [iajc]     |               INVOKEVIRTUAL
&gt; gsc.repository.ejb.Jar.getGroupid ()Ljava/lang/String;
&gt;       [iajc]     |               LDC "groovy"
&gt;       [iajc]     |               INVOKESTATIC
&gt; gsc.repository.IdentifierTest.assertEquals (Ljava/lang/String;Ljava/
&gt; lang/String;)V
&gt;       [iajc]     |               ALOAD 4
&gt;       [iajc]     |               INVOKEVIRTUAL
&gt; gsc.repository.ejb.Jar.getArtifactid ()Ljava/lang/String;
&gt;       [iajc]     |               LDC "groovy"
&gt;       [iajc]     |               INVOKESTATIC
&gt; gsc.repository.IdentifierTest.assertEquals (Ljava/lang/String;Ljava/
&gt; lang/String;)V
&gt;       [iajc]     |               ALOAD 4
&gt;       [iajc]     |               INVOKEVIRTUAL
&gt; gsc.repository.ejb.Jar.getVersion ()Ljava/lang/String;
&gt;       [iajc]     |               LDC "1.0-beta-4"
&gt;       [iajc]     |               INVOKESTATIC
&gt; gsc.repository.IdentifierTest.assertEquals (Ljava/lang/String;Ljava/
&gt; lang/String;)V
&gt;       [iajc]     |               IINC 2 -1
&gt;       [iajc]     |               GOTO L2
&gt;       [iajc]     |           L1: ALOAD 4
&gt;       [iajc]     |               INVOKEVIRTUAL
&gt; gsc.repository.ejb.Jar.getGroupid ()Ljava/lang/String;
&gt;       [iajc]     |               LDC "commons-logging"
&gt;       [iajc]     |               INVOKESTATIC
&gt; gsc.repository.IdentifierTest.assertEquals (Ljava/lang/String;Ljava/
&gt; lang/String;)V
&gt;       [iajc]     |               ALOAD 4
&gt;       [iajc]     |               INVOKEVIRTUAL
&gt; gsc.repository.ejb.Jar.getArtifactid ()Ljava/lang/String;
&gt;       [iajc]     |               LDC "commons-logging"
&gt;       [iajc]     |               INVOKESTATIC
&gt; gsc.repository.IdentifierTest.assertEquals (Ljava/lang/String;Ljava/
&gt; lang/String;)V
&gt;       [iajc]     |               ALOAD 4
&gt;       [iajc]     |               INVOKEVIRTUAL
&gt; gsc.repository.ejb.Jar.getVersion ()Ljava/lang/String;
&gt;       [iajc]     |               LDC "1.0.2"
&gt;       [iajc]     |               INVOKESTATIC
&gt; gsc.repository.IdentifierTest.assertEquals (Ljava/lang/String;Ljava/
&gt; lang/String;)V
&gt;       [iajc]     |               IINC 2 -1
&gt;       [iajc]     |           L2: GOTO L0
&gt;       [iajc]     |           L3: ILOAD_2
&gt;       [iajc]     |               ICONST_0
&gt;       [iajc]     |               INVOKESTATIC
&gt; gsc.repository.IdentifierTest.assertEquals (II)V
&gt;       [iajc]     |               RETURN
&gt;       [iajc]     method-execution(void
&gt; gsc.repository.IdentifierTest.testIdentifierMixedUp())
&gt;       [iajc]   end public void testIdentifierMixedUp() throws
&gt; java.security.NoSuchAlgorithmException, java.io.IOException
&gt;
&gt;       [iajc] end public class gsc.repository.IdentifierTest
&gt;
&gt;       [iajc]
&gt;       [iajc] Exception thrown from AspectJ 1.5.0M5
&gt;
&gt;       [iajc] This might be logged as a bug already -- find current
&gt; bugs at
&gt;       [iajc]   http://bugs.eclipse.org/bugs/buglist.cgi?
&gt; product=AspectJ&amp;component=Compiler
&gt;
&gt;       [iajc] Bugs for exceptions thrown have titles File:line from
&gt; the top stack,
&gt;       [iajc] e.g., "SomeFile.java:243"
&gt;
&gt;       [iajc] If you don't find the exception below in a bug, please
&gt; add a new bug
&gt;       [iajc] at http://bugs.eclipse.org/bugs/enter_bug.cgi?
&gt; product=AspectJ
&gt;       [iajc] To make the bug a priority, please include a test program
&gt;       [iajc] that can reproduce this exception.
&gt;       [iajc] Incorrectly attempting counter operation on stacked cflow
&gt;
&gt;       [iajc] when implementing on shadow method-execution(void
&gt; gsc.repository.IdentifierTest.testIdentifierExactMatch())
&gt;       [iajc] when weaving type gsc.repository.IdentifierTest
&gt;       [iajc] when weaving classes
&gt;       [iajc] when weaving
&gt;       [iajc] when batch building with classpath: /Users/sam/Library/
&gt; Java/Extensions/jsk-policy.jar:/System/Library/Java/Extensions/
&gt; CoreAudio.jar:/System/Library/Java/Extensions/dns_sd.jar:/System/
&gt; Library/Java/Extensions/j3daudio.jar:/System/Library/Java/Extensions/
&gt; j3dcore.jar:/System/Library/Java/Extensions/j3dutils.jar:/System/
&gt; Library/Java/Extensions/jai_codec.jar:/System/Library/Java/Extensions/
&gt; jai_core.jar:/System/Library/Java/Extensions/mlibwrapper_jai.jar:/
&gt; System/Library/Java/Extensions/MRJToolkit.jar:/System/Library/Java/
&gt; Extensions/QTJava.zip:/System/Library/Java/Extensions/QTJSupport.jar:/
&gt; System/Library/Java/Extensions/vecmath.jar:/System/Library/Frameworks/
&gt; JavaVM.framework/Versions/1.5.0/Home/lib/ext/apple_provider.jar:/
&gt; System/Library/Frameworks/JavaVM.framework/Versions/1.5.0/Home/lib/
&gt; ext/dnsns.jar:/System/Library/Frameworks/JavaVM.framework/Versions/
&gt; 1.5.0/Home/lib/ext/localedata.jar:/System/Library/Frameworks/
&gt; JavaVM.framework/Versions/1.5.0/Home/lib/ext/sunjce_provider.jar:/
&gt; Users/sam/gs/squire/jardb/.aspectj-lib/aspectjrt-1.5.0_M5.jar:/Users/
&gt; sam/gs/squire/jardb/.aspectj-lib/aspectjtools-1.5.0_M5.jar:/Users/sam/
&gt; gs/squire/jardb/target/classes:/Users/sam/gs/squire/jardb/target/test-
&gt; classes:/Users/sam/gs/squire/jardb/.lib/antlr-2.7.5.jar:/Users/sam/gs/
&gt; squire/jardb/.lib/asm-1.5.3.jar:/Users/sam/gs/squire/jardb/.lib/
&gt; cglib-2.1_2.jar:/Users/sam/gs/squire/jardb/.lib/commons-
&gt; collections-2.1.1.jar:/Users/sam/gs/squire/jardb/.lib/commons-
&gt; logging-1.0.4.jar:/Users/sam/gs/squire/jardb/.lib/dom4j-1.6.jar:/
&gt; Users/sam/gs/squire/jardb/.lib/ehcache-1.1.jar:/Users/sam/gs/squire/
&gt; jardb/.lib/ejb3-persistence-pr.jar:/Users/sam/gs/squire/jardb/.lib/
&gt; emma-2.0.latest.jar:/Users/sam/gs/squire/jardb/.lib/
&gt; emma_ant-2.0.latest.jar:/Users/sam/gs/squire/jardb/.lib/
&gt; hibernate-3.1alpha1.jar:/Users/sam/gs/squire/jardb/.lib/hibernate-
&gt; annotations-3.1beta3.jar:/Users/sam/gs/squire/jardb/.lib/hibernate-
&gt; entitymanager-3.1beta1.jar:/Users/sam/gs/squire/jardb/.lib/
&gt; jta-1.0.jar:/Users/sam/gs/squire/jardb/.lib/junit-3.8.1.jar:/Users/
&gt; sam/gs/squire/jardb/.lib/postgresql-7.4.1-jdbc3.jar:/Users/sam/gs/
&gt; squire/jardb/.lib/svn-javahl-1.2.0.jar:/Users/sam/gs/squire/jardb/lib/
&gt; testng-4.2-jdk15.jar:/Users/sam/gs/squire/jardb/target/aspects.jar:
&gt;       [iajc] Incorrectly attempting counter operation on stacked cflow
&gt;       [iajc] java.lang.RuntimeException: Incorrectly attempting
&gt; counter operation on stacked cflow
&gt;       [iajc]     at org.aspectj.weaver.bcel.BcelShadow.weaveCflowEntry(BcelShadow.java:1890)
&gt;       [iajc]     at org.aspectj.weaver.bcel.BcelAdvice.implementOn(BcelAdvice.java:231)
&gt;       [iajc]     at org.aspectj.weaver.Shadow.implementMungers(Shadow.java:514)
&gt;       [iajc]     at org.aspectj.weaver.Shadow.implement(Shadow.java:391)
&gt;       [iajc]     at org.aspectj.weaver.bcel.BcelClassWeaver.implement(BcelClassWeaver.java:2142)
&gt;       [iajc]     at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:467)
&gt;       [iajc]     at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:102)
&gt;       [iajc]     at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1534)
&gt;       [iajc]     at org.aspectj.weaver.bcel.BcelWeaver.weaveWithoutDump(BcelWeaver.java:1485)
&gt;       [iajc]     at org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify(BcelWeaver.java:1266)
&gt;       [iajc]     at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1088)
&gt;       [iajc]     at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave(AjCompilerAdapter.java:300)
&gt;       [iajc]     at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling(AjCompilerAdapter.java:178)
&gt;       [iajc]     at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$afterReturning$org_aspectj_ajdt_internal_compiler_CompilerAdapter$2$f9cc9ca0(CompilerAdapter.aj:70)
&gt;       [iajc]     at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:367)
&gt;       [iajc]     at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:809)
&gt;       [iajc]     at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:230)
&gt;       [iajc]     at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:156)
&gt;       [iajc]     at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:112)
&gt;       [iajc]     at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:60)
&gt;       [iajc]     at org.aspectj.tools.ajc.Main.run(Main.java:326)
&gt;       [iajc]     at org.aspectj.tools.ajc.Main.runMain(Main.java:240)
&gt;       [iajc]     at org.aspectj.tools.ant.taskdefs.AjcTask.executeInSameVM(AjcTask.java:1210)
&gt;       [iajc]     at org.aspectj.tools.ant.taskdefs.AjcTask.execute(AjcTask.java:1001)
&gt;       [iajc]     at org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:275)
&gt;       [iajc]     at org.apache.tools.ant.Task.perform(Task.java:364)
&gt;       [iajc]     at org.apache.tools.ant.taskdefs.Sequential.execute(Sequential.java:64)
&gt;       [iajc]     at org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:275)
&gt;       [iajc]     at org.apache.tools.ant.Task.perform(Task.java:364)
&gt;       [iajc]     at org.apache.tools.ant.taskdefs.MacroInstance.execute(MacroInstance.java:378)
&gt;       [iajc]     at org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:275)
&gt;       [iajc]     at org.apache.tools.ant.Task.perform(Task.java:364)
&gt;       [iajc]     at org.apache.tools.ant.Target.execute(Target.java:341)
&gt;       [iajc]     at org.apache.tools.ant.Target.performTasks(Target.java:369)
&gt;       [iajc]     at org.apache.tools.ant.Project.executeSortedTargets(Project.java:1216)
&gt;       [iajc]     at org.apache.tools.ant.Project.executeTarget(Project.java:1185)
&gt;       [iajc]     at org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:40)
&gt;       [iajc]     at org.apache.tools.ant.Project.executeTargets(Project.java:1068)
&gt;       [iajc]     at org.apache.tools.ant.Main.runBuild(Main.java:668)
&gt;       [iajc]     at org.apache.tools.ant.Main.startAnt(Main.java:187)
&gt;       [iajc]     at org.apache.tools.ant.launch.Launcher.run(Launcher.java:246)
&gt;       [iajc]     at org.apache.tools.ant.launch.Launcher.main(Launcher.java:67)
&gt;
&gt;
&gt; package gsc.aspects.testing;
&gt;
&gt; import junit.framework.*;
&gt; import java.io.*;
&gt; import java.util.*;
&gt;
&gt; import org.aspectj.lang.annotation.Pointcut;
&gt; import org.aspectj.lang.annotation.Before;
&gt; import org.aspectj.lang.annotation.Aspect;
&gt; import org.aspectj.lang.annotation.After;
&gt; import org.aspectj.lang.JoinPoint;
&gt;
&gt; @Aspect
&gt; public class TestMethodMapperAnnotations {
&gt;
&gt;      @Pointcut("this(testCase) &amp;&amp; this(TestCase) &amp;&amp; execution(void
&gt; test*())")
&gt;      public void inTestClass(TestCase testCase) {
&gt;      }
&gt;
&gt;      private Map&lt;String, Map&lt;String, Integer&gt;&gt; coverage;
&gt;
&gt;      @Before("cflowbelow(inTestClass(testCase)) &amp;&amp; execution(* *(..))")
&gt;      public void beforeMethodExecution(JoinPoint thisJoinPoint,
&gt; TestCase testCase) {
&gt;          String testname = testCase.getClass().getName();
&gt;          String methodSignature = thisJoinPoint.getStaticPart
&gt; ().getSignature().toString();
&gt;          Map&lt;String, Integer&gt; tests = coverage.get(methodSignature);
&gt;          if (tests == null) {
&gt;              tests = new HashMap&lt;String, Integer&gt;();
&gt;              coverage.put(methodSignature, tests);
&gt;          }
&gt;          Integer count = tests.get(testname);
&gt;          if (count == null) {
&gt;              count = 1;
&gt;          } else {
&gt;              count++;
&gt;          }
&gt;          tests.put(testname, count);
&gt;      }
&gt;
&gt;      @Before("inTestClass(testCase)")
&gt;      public void beforeExecutingTestMethod(TestCase testCase) {
&gt;          try {
&gt;              File file = new File("results.ser");
&gt;              if (file.exists()) {
&gt;                  ObjectInputStream ois = new ObjectInputStream(new
&gt; FileInputStream(file));
&gt;                  coverage = (Map&lt;String, Map&lt;String, Integer&gt;&gt;)
&gt; ois.readObject();
&gt;                  ois.close();
&gt;              } else {
&gt;                  coverage = new HashMap&lt;String, Map&lt;String, Integer&gt;&gt;();
&gt;              }
&gt;          } catch (Exception e) {
&gt;              e.printStackTrace();
&gt;          }
&gt;      }
&gt;
&gt;      @After("inTestClass(testCase)")
&gt;      public void afterExecutingTestMethod(TestCase testCase) {
&gt;          try {
&gt;              File file = new File("results.ser");
&gt;              ObjectOutputStream oos = new ObjectOutputStream(new
&gt; FileOutputStream(file));
&gt;              oos.writeObject(coverage);
&gt;              oos.close();
&gt;          } catch (Exception e) {
&gt;              e.printStackTrace();
&gt;          }
&gt;      }
&gt;
&gt; }
&gt;
&gt; vs.
&gt;
&gt; package gsc.aspects.testing;
&gt;
&gt; import junit.framework.*;
&gt; import java.io.*;
&gt; import java.util.*;
&gt;
&gt; public aspect TestMethodMapper {
&gt;
&gt;      pointcut inTestClass(TestCase testCase) : this(testCase) &amp;&amp; this
&gt; (TestCase) &amp;&amp; execution(void test*());
&gt;      private Map&lt;String, Map&lt;String, Integer&gt;&gt; coverage;
&gt;
&gt;      before(TestCase testCase) : cflowbelow(inTestClass(testCase)) &amp;&amp;
&gt; execution(* *(..)) {
&gt;         String testname = testCase.getClass().getName();
&gt;         String methodSignature = thisJoinPointStaticPart.getSignature
&gt; ().toString();
&gt;         Map&lt;String, Integer&gt; tests = coverage.get(methodSignature);
&gt;         if (tests == null) {
&gt;             tests = new HashMap&lt;String, Integer&gt;();
&gt;             coverage.put(methodSignature, tests);
&gt;         }
&gt;         Integer count = tests.get(testname);
&gt;         if (count == null) {
&gt;             count = 1;
&gt;         } else {
&gt;              count++;
&gt;         }
&gt;         tests.put(testname, count);
&gt;      }
&gt;
&gt;      before(TestCase testCase) : inTestClass(testCase) {
&gt;         try {
&gt;             File file = new File("results.ser");
&gt;             if (file.exists()) {
&gt;                 ObjectInputStream ois = new ObjectInputStream(new FileInputStream
&gt; (file));
&gt;                 coverage = (Map&lt;String, Map&lt;String, Integer&gt;&gt;) ois.readObject();
&gt;                 ois.close();
&gt;             } else {
&gt;                 coverage = new HashMap&lt;String, Map&lt;String, Integer&gt;&gt;();
&gt;             }
&gt;         } catch (Exception e) {
&gt;             e.printStackTrace();
&gt;         }
&gt;      }
&gt;
&gt;      after(TestCase testCase) : inTestClass(testCase) {
&gt;         try {
&gt;             File file = new File("results.ser");
&gt;             ObjectOutputStream oos = new ObjectOutputStream(new
&gt; FileOutputStream(file));
&gt;             oos.writeObject(coverage);
&gt;             oos.close();
&gt;         } catch (Exception e) {
&gt;             e.printStackTrace();
&gt;         }
&gt;      }
&gt;
&gt; }
&gt;
&gt;
&gt;</description>
      <comments>
		<comment id="1" date="2005-12-12 05:18:57 EST" author="Alexandre Vasseur">spotted issue in exposed stated
commiting fix

note: Sam, pointcut is not what you want in your sample:

        @Pointcut("this(testCase) &amp;&amp; this(TestCase) &amp;&amp; execution(void test*())")
                                          ^^^^^^^^^^^
// need FQN in @AJ, and actually don't need it since you use a binding with another this(testCase)

        public void inTestClass(TestCase testCase) {</comment>
		<comment id="2" date="2005-12-12 05:47:51 EST" author="Alexandre Vasseur">fix available</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="979124d0fe6ac23df1dd5ee41838056bbaed6789" author="avasseur" date="2005-12-12 07:48:46"/>
          <file name="tests/java5/ataspectj/ataspectj/bugs/CflowBelowStackTest.java">
          </file>
          <file name="tests/src/org/aspectj/systemtest/ajc150/ataspectj/AtAjLTWTests.java">
              <method name="testAppContainer" returnType="void" parameters=""/>
          </file>
          <file name="weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java">
              <method name="compareTo" returnType="int" parameters="Object"/>
          </file>
          <file name="weaver/src/org/aspectj/weaver/bcel/BcelShadow.java">
              <method name="weaveCflowEntry" returnType="void" parameters="BcelAdvice Member"/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="119451" opendate="2005-12-6 12:39:00" fixdate="2005-12-12 6:20:00">
    <buginformation>
      <summary>AJDoc produces incorrect warning for package accessed aspects</summary>
      <description>// Main.java
package bug;

public class Main {
}

aspect LogMain {
	
}

Generating ajdoc through Eclipse (AJDT 1.3.0.20051206092602, AspectJ 1.5.0.20051206103951) generate incorrect warning for the LogMain aspect:

&gt; Calling ajc...
&gt; Building signature files...
&gt; Calling javadoc...
Loading source file C:\work\aop\src\ajdocworkingdir\bug\Main.java...
Constructing Javadoc information...
C:\work\aop\src\ajdocworkingdir\bug\Main.java:11: class LogMain is public, should be declared in a file named LogMain.java
public class  LogMain {
       ^
Standard Doclet version 1.5.0_04
Building tree for all the packages and classes...
Generating c:\work\aop\src\workspace\AJDocPackageAspect\doc\bug/\LogMain.html...
Generating c:\work\aop\src\workspace\AJDocPackageAspect\doc\bug/\Main.html...
Generating c:\work\aop\src\workspace\AJDocPackageAspect\doc\bug/\package-frame.html...
Generating c:\work\aop\src\workspace\AJDocPackageAspect\doc\bug/\package-summary.html...
Generating c:\work\aop\src\workspace\AJDocPackageAspect\doc\bug/\package-tree.html...
Generating c:\work\aop\src\workspace\AJDocPackageAspect\doc\constant-values.html...
Building index for all the packages and classes...
Generating c:\work\aop\src\workspace\AJDocPackageAspect\doc\overview-tree.html...
Generating c:\work\aop\src\workspace\AJDocPackageAspect\doc\index-all.html...
Generating c:\work\aop\src\workspace\AJDocPackageAspect\doc\deprecated-list.html...
Building index for all classes...
Generating c:\work\aop\src\workspace\AJDocPackageAspect\doc\allclasses-frame.html...
Generating c:\work\aop\src\workspace\AJDocPackageAspect\doc\allclasses-noframe.html...
Generating c:\work\aop\src\workspace\AJDocPackageAspect\doc\index.html...
Generating c:\work\aop\src\workspace\AJDocPackageAspect\doc\help-doc.html...
Generating c:\work\aop\src\workspace\AJDocPackageAspect\doc\stylesheet.css...
1 warning
&gt; Decorating html files...
&gt; Decorating C:\work\aop\src\workspace\AJDocPackageAspect\doc\bug\Main.html...
&gt; Removing generated tags (this may take a while)...
&gt; Finished.</description>
      <comments>
		<comment id="1" date="2005-12-07 12:31:23 EST" author="Mik Kersten">The issue here might be that aspects are always considered public by the compiler and hence by the ASM.  I recall Adrian doing something to address that at some point back.  What does AJDT do to recognize package visibility of aspects?</comment>
		<comment id="2" date="2005-12-08 06:24:08 EST" author="Helen Beeken">As far as I'm aware AJDT doesn't do anything to recognise the package visibility of aspects - this is all handled by the compiler. All the error messages that come out when aspects aren't visible come from the compiler. Is this what you meant?</comment>
		<comment id="3" date="2005-12-08 10:14:05 EST" author="Helen Beeken">Just as a note...

&gt; The issue here might be that aspects are always considered public by the
&gt; compiler and hence by the ASM.  I recall Adrian doing something to address that
&gt; at some point back

I believe this was done as part of bug 82752.</comment>
		<comment id="4" date="2005-12-08 11:30:11 EST" author="Mik Kersten">This stuff is in AsmHierarchyBuilder, and as you point out Helen it's failing to pring the right source signature even though the accessibility on the node is correct.  So it looks like the following method:

 private String genSourceSignature(TypeDeclaration typeDeclaration) {
  StringBuffer output = new StringBuffer();
  typeDeclaration.printHeader(0, output);
  return output.toString();
 }

Should print modifiers explicitly, possibly more like this one:

private String genSourceSignature(ConstructorDeclaration constructorDeclaration) {
  StringBuffer output = new StringBuffer();
  ASTNode.printModifiers(constructorDeclaration.modifiers, output);

But ensuring to use Adrian's getDeclaredModifiers() fix:

        int typeModifiers = typeDeclaration.modifiers;
        if (typeDeclaration instanceof AspectDeclaration) {
         typeModifiers = ((AspectDeclaration)typeDeclaration).getDeclaredModifiers();
        }
 
Let me know how it goes.</comment>
		<comment id="5" date="2005-12-09 04:38:22 EST" author="Helen Beeken">Created attachment 31460 [details]
zip file of patches containing fix and tests

Thanks Mik that fixes the problem:-) 

What I've done is to keep the logic within genSourceSignature(TypeDeclaration typeDeclaration) as is and instead modified the printHeader(int,StringBuffer) method within AspectDeclaration to use the declaredModifiers field that Adrian introduced as part of the fix for bug 82752 rather than the modifiers field which has the "public" added to it. 

One consequence of the fix to remove "public" from the source signature is that in StubFileGenerator.genSourceSignature(IProgramElement) which translates "aspect" to "class", there was a check that fistly "aspect" was there and secondly it wasn't ".aspect". However this assumes that there is something before the "aspect" which is no longer certain. Therefore, I've added an extra check for "aspect" being the first word in the signature.

The attached zip file contains 3 patches:


- pr119451-ajde-patch.txt : apply to the ajde project. This contains an added assert in one of the tests to check that "public" isn't in the signature of an aspect not declared public

- pr119451-ajdoc-patch.txt : apply to the ajdoc project. This contains the change to StubFileGenerator mentioned above

- pr119451-org-aspectj-ajdt-core-patch.txt : apply to the org.aspect.ajdt.core project. This contains the change to AspectDeclaration also mentioned above.</comment>
		<comment id="6" date="2005-12-09 11:29:05 EST" author="Mik Kersten">Helen, shall I go ahead and apply these, or is someone doing that on your end?</comment>
		<comment id="7" date="2005-12-09 11:46:22 EST" author="Helen Beeken">Hi Mik, I think Andy has committed the patches :-)</comment>
		<comment id="8" date="2005-12-09 11:58:47 EST" author="Mik Kersten">Excellent.  Nice work helen :)

Ajdoc has some pretty horrible modularity and could use some serious refactoring, but without any major feature needs it's probably easiest to leave it as-is.</comment>
		<comment id="9" date="2005-12-12 06:14:41 EST" author="Andrew Clement">fix available.</comment>
		<comment id="10" date="2005-12-12 06:20:17 EST" author="Andrew Clement">oops, forgot to mark resolved!</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="5f8d2cdff480ac9d04cc73a4a69eb11563a0bb01" author="aclement" date="2005-12-09 07:32:57"/>
          <file name="ajde/testsrc/org/aspectj/ajde/AsmDeclarationsTest.java">
              <method name="testAspectAccessibility" returnType="void" parameters=""/>
          </file>
          <file name="ajdoc/src/org/aspectj/tools/ajdoc/StubFileGenerator.java">
              <method name="genSourceSignature" returnType="String" parameters="IProgramElement"/>
          </file>
          <file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectDeclaration.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="120543" opendate="2005-12-13 6:40:00" fixdate="2005-12-13 11:38:00">
    <buginformation>
      <summary>Issue version message during load-time weaving</summary>
      <description>It would be very useful to know exactly which version of the weaver is being used for LTW. An informational message could be issued when each WeavingAdaptor instance is created (it is possible to have multiple versions of AspectJ in a system). This message could be similar to the that issued by "ajc -version".</description>
      <comments>
		<comment id="1" date="2005-12-13 07:49:33 EST" author="Matthew Webster">Created attachment 31629 [details]
Modified testcase and implementation

1. Modified test XML to check for version message
2. Issue information message during WeavingAdaptor creation</comment>
		<comment id="2" date="2005-12-13 09:03:07 EST" author="Andrew Clement">fix checked in.</comment>
		<comment id="3" date="2005-12-13 11:38:49 EST" author="Andrew Clement">fix available.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="9d32b76c9b48e6a2593bff77dc120eb8c5f17cff" author="aclement" date="2005-12-13 11:03:53"/>
          <file name="weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="120474" opendate="2005-12-12 20:24:00" fixdate="2005-12-13 11:39:00">
    <buginformation>
      <summary>Don't dump stack trace when loading $Proxy classes</summary>
      <description>I am seeing a BCException that gets caught and prints a stack trace in Aj.preProcess when loading a class named "$Proxy4"

This occurs in UnresolvedType.nameToSignature because the string it receives from ResolvedType.getDeclaringType is "" (i.e., it strips off the leading $, treating the type as if it were a nested type of nothing).

I'm not sure of the best resolution, but maybe the loop in ResolvedType should just say while (lastDollar &gt; 0). This would handle the "leading $" case as an identifier rather than trying to look up the empty string. This might help with Hibernate's $$ types too...

Here is the stack when it happens:
UnresolvedType.nameToSignature(String) line: 774
UnresolvedType.forName(String) line: 309
ReferenceType(ResolvedType).getDeclaringType() line: 1255
WithinPointcut.isWithinType(ResolvedType) line: 50
WithinPointcut.fastMatch(FastMatchInfo) line: 67
AndPointcut.fastMatch(FastMatchInfo) line: 51
AndPointcut.fastMatch(FastMatchInfo) line: 51
AndPointcut.fastMatch(FastMatchInfo) line: 51
AndPointcut.fastMatch(FastMatchInfo) line: 51
AndPointcut.fastMatch(FastMatchInfo) line: 51
BcelWeaver.fastMatch(List, ResolvedType) line: 1635
BcelWeaver.weave(UnwovenClassFile, BcelObjectType, boolean) line: 1516
BcelWeaver.weaveWithoutDump(UnwovenClassFile, BcelObjectType) line: 1494
BcelWeaver.weaveAndNotify(UnwovenClassFile, BcelObjectType, IWeaveRequestor) line: 1275
BcelWeaver.weave(IClassFileProvider) line: 1097
ClassLoaderWeavingAdaptor(WeavingAdaptor).getWovenBytes(String, byte[]) line: 261
ClassLoaderWeavingAdaptor(WeavingAdaptor).weaveClass(String, byte[]) line: 194
Aj.preProcess(String, byte[], ClassLoader) line: 65</description>
      <comments>
		<comment id="1" date="2005-12-13 03:08:55 EST" author="Andrew Clement">I'm happy with the proposed fix if it gets through the test suite - i'm trying it now.</comment>
		<comment id="2" date="2005-12-13 04:20:23 EST" author="Matthew Webster">Ron,

It would be helpful if you stated what the _actual_ problem was, preferably in the summary, and attaching a simple testcase. I added a test to the harness (for bug 117854) that uses proxies which could be amended if we knew what you were doing when the failure occured. Dumping a stack trace is not the problem. In fact (ironically) if we didn't you would not have noticed the problem or been able to report it. If I was raising this bug the summary would be "BCException weaving Java proxy classes under LTW".</comment>
		<comment id="3" date="2005-12-13 10:35:04 EST" author="Ron Bodkin">I actually found out about the problem by seeing the BCException in the debugger and noticed that it caused weaving to abort. I can report it as a BCException if that's more helpful.</comment>
		<comment id="4" date="2005-12-13 11:39:47 EST" author="Andrew Clement">fix available.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="3339edbae5d6891cfbde6952329a4ff2808a7901" author="aclement" date="2005-12-13 05:24:13"/>
          <file name="tests/bugs150/pr120474/$Proxy4.java">
          </file>
          <file name="tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java">
              <method name="getSpecFile" returnType="File" parameters=""/>
          </file>
          <file name="weaver/src/org/aspectj/weaver/ResolvedType.java">
              <method name="getDeclaringType" returnType="ResolvedType" parameters=""/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="120363" opendate="2005-12-12 8:42:00" fixdate="2005-12-13 11:40:00">
    <buginformation>
      <summary>LTW weaver include and exclude does not behave correctly</summary>
      <description>According to the specification (http://www.eclipse.org/aspectj/doc/next/adk15notebook/ltw-configuration.html) "The set of types to be woven are those types matched by at least one weaver include element and not matched by any weaver exclude element." However if an includ elemement can be fast matched e.g. "com.foo..*" any exclude elements are ignored (see bug 117854). There is no explicit test in the harness for this feature.</description>
      <comments>
		<comment id="1" date="2005-12-12 10:19:07 EST" author="Matthew Webster">Created attachment 31562 [details]
Testcase and fix for uding include and exclude together

1. Modified dump before and after testcase to weave test but not accompanying "proxy" i.e. class with funny name
2. Fix to ClassLoaderWeavingAdaptor.accept() to only perform fast match for include if there are no exclude patterns.</comment>
		<comment id="2" date="2005-12-12 10:41:26 EST" author="Andrew Clement">patches checked in.</comment>
		<comment id="3" date="2005-12-13 11:40:08 EST" author="Andrew Clement">fix available.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="9edb4b6f9e8ca59b309ac382e6049321832d0700" author="aclement" date="2005-12-13 12:42:19"/>
          <file name="loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java">
              <method name="accept" returnType="boolean" parameters="String byte[]"/>
          </file>
          <file name="tests/java5/ataspectj/com/foo/bar/Test$$EnhancerByCGLIB$$12345.java">
          </file>
          <file name="tests/java5/ataspectj/com/foo/bar/Test.java">
          </file>
          <file name="tests/src/org/aspectj/systemtest/ajc150/ataspectj/AtAjLTWTests.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="120401" opendate="2005-12-12 12:11:00" fixdate="2005-12-14 4:20:00">
    <buginformation>
      <summary>add signature to UnresolvedType.parameterize(..) exception</summary>
      <description>I keep getting UnresolvedType UnsupportedOperationException unhelpful message "resolve this type first," so I'm adding the signature to the message (without permission, hence the bug as notice).

throw new UnsupportedOperationException("unable to parameterize unresolved type: " + signature);


-------------------------------
java.lang.UnsupportedOperationException
at org.aspectj.weaver.UnresolvedType.parameterize(UnresolvedType.java:218)
at org.aspectj.weaver.patterns.ExactTypePattern.parameterizeWith(ExactTypePattern.java:242)
at org.aspectj.weaver.patterns.TypePatternList.parameterizeWith(TypePatternList.java:195)
at org.aspectj.weaver.patterns.DeclareParents.parameterizeWith(DeclareParents.java:77)
at org.aspectj.weaver.ReferenceType.getDeclares(ReferenceType.java:484)
at org.aspectj.weaver.ResolvedType.collectDeclares(ResolvedType.java:523)
at org.aspectj.weaver.ResolvedType.collectCrosscuttingMembers(ResolvedType.java:488)
at org.aspectj.weaver.CrosscuttingMembersSet.addOrReplaceAspect(CrosscuttingMembersSet.java:60)
at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.addCrosscuttingStructures(AjLookupEnvironment.java:378)
at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.addCrosscuttingStructures(AjLookupEnvironment.java:388)
at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.collectAllITDsAndDeclares(AjLookupEnvironment.java:314)
at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.completeTypeBindings(AjLookupEnvironment.java:168)
at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.beginToCompile(Compiler.java:301)
at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:315)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:811)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:230)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:185)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.incrementalBuild(AjBuildManager.java:163)
at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:117)
at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)

UnsupportedOperationException thrown: resolve this type first</description>
      <comments>
		<comment id="1" date="2005-12-12 14:18:41 EST" author="Andrew Clement">so ....  are you able to recreate this with a nice signature coming out now Wes?  I guess it'll require you hacking your change into AJDT.  It just might be related to your other bug (119570) which was to do with processing types in the wrong order...</comment>
		<comment id="2" date="2005-12-14 04:20:25 EST" author="Andrew Clement">change is now available in the latest build.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="3ac46270398a3e9ddde620e03c9dc2123cbe78d0" author="wisberg" date="2005-12-13 02:13:35"/>
          <file name="weaver/src/org/aspectj/weaver/UnresolvedType.java">
              <method name="parameterize" returnType="UnresolvedType" parameters="Map"/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="113257" opendate="2005-10-20 13:00:00" fixdate="2005-12-14 04:19:27">
    <buginformation>
      <summary>Incremental Compilation Bug: parameter not bound with no parameter</summary>
      <description>I keep getting an incremental compilation error on this pointcut when I save 
other files (in AJDT):

    public pointcut scope() :
        within(DoMonitorErrors+) ||
        ((within(pkg1..*)|| within(pkg2..*) || within(pkg3..*)) &amp;&amp; 
        !within(pkg1.monitoring..*));

It is used as follows:
    after() throwing (Throwable t) : publicMethodExec() &amp;&amp; scope() &amp;&amp; 
adviceEnabled() {
...
        recordThrowable(t, thisJoinPointStaticPart, 
thisEnclosingJoinPointStaticPart);
    }

    before(Throwable t) : handler(*) &amp;&amp; args(t) &amp;&amp; scope() &amp;&amp; adviceEnabled() {
...
        recordThrowable(t, thisJoinPointStaticPart, 
thisEnclosingJoinPointStaticPart);
    }

The resulting incremental compilation produces an error which requires a full 
rebuild to clear:
	the parameter t is not bound in [all branches of] pointcut
	ErrorMonitor.aj	aspectjSupport/src/pkg1/monitoring	line 58</description>
      <comments>
		<comment id="1" date="2005-10-21 02:53:30 EDT" author="Andrew Clement">Hmmm ... i fixed a bug yesterday to do with messages like this "the parameter t
is not bound in [all branches of] pointcut" - however it wasn't an incremental
case that was causing it.</comment>
		<comment id="2" date="2005-11-11 07:15:02 EST" author="Andrew Clement">Sorry to do this to you Ron - is this easily recreatable on a recent AJDT -
firstly I'd like to see if the change I mentioned in the previous comment fixed
it, but I'd also like to see what you get if you put '-Xdev:Pinpoint' in the
'non-standard compiler options' setting in AJDT, that should put out some kind
of context about what is going on with the message.  Ideally I'd love to turn on
the pointcut rewriter for your environment and see what the rewriter is
producing but that isnt command line or ajdt configurable :(

I've tried taking your small snippets and making a program, but (sigh) it works
for me.  Or you could email me the project if it doesnt have too many
dependencies and you dont mind me seeing it?</comment>
		<comment id="3" date="2005-11-14 09:15:38 EST" author="Ron Bodkin">Because of bug 113368 (https://bugs.eclipse.org/bugs/show_bug.cgi?id=113368) - 
see the 2nd comment relating to incremental compilation I am getting NPE's on 
all incremental compiles on the project so I can't test easily. I tried 
commented out the line I suspected but there are other if pointcuts and at 
least one is (still?) causing the NPE...

So I guess 113368 is blocking this one...</comment>
		<comment id="4" date="2005-11-24 10:49:12 EST" author="Andrew Clement">Ron - with 113368 now resolved - can you try this one again?</comment>
		<comment id="5" date="2005-11-28 08:01:28 EST" author="Andrew Clement">*bump* any chance of reconfirming this failure Ron?</comment>
		<comment id="6" date="2005-11-28 13:40:06 EST" author="Ron Bodkin">I downloaded the latest AJDT build and it looks like this problem is solved. I'll reopen if I see it again...</comment>
		<comment id="7" date="2005-12-07 14:22:35 EST" author="Ron Bodkin">I just saw this bug again in AJDT 1.3.0.20051207063004 (the latest dev build) today. I was editing one aspect and the resulting incremental build choked when this aspect fired (the ITD DoMonitorErrors is affecting the other, incrementally compiled, aspect).</comment>
		<comment id="8" date="2005-12-12 06:02:27 EST" author="Helen Beeken">Hi Ron - I'm trying to reproduce the problem you're seeing and have so far been unsuccessful....would you be able to attach the ErrorMonitor aspect and the aspect you were editing when you last saw the problem? </comment>
		<comment id="9" date="2005-12-12 09:18:36 EST" author="Andrew Clement">In addition to Helens question, can I ask if you have multiple aspects in a hierarchy here Ron?  Where is adviceEnabled() defined? In a super abstract aspect?</comment>
		<comment id="10" date="2005-12-12 13:09:45 EST" author="Ron Bodkin">Yes there are multiple aspects. We have 

public aspect ErrorMonitor extends AbstractMonitorAspect {
...
    protected pointcut isAdviceEnabled() : if(ErrorMonitor.aspectOf().isAdviceEnabled()) ;  

}

And in 
public abstract aspect AbstractMonitorAspect {
...
 protected pointcut scope() : within(com.myco..*);

 protected pointcut adviceEnabled() : isAdviceEnabled() &amp;&amp; scope();

 protected abstract pointcut isAdviceEnabled();

 public boolean isAdviceEnabled() {
  return enabled;
 }

 public void setAdviceEnabled(boolean enabled) {
  this.enabled = enabled;
 }
}

If this lead doesn't help you find the bug, I will try to narrow it down to a small test case that is easy to share.</comment>
		<comment id="11" date="2005-12-13 09:58:07 EST" author="Helen Beeken">Ron - With the extra info you've provided, we've been able to recreate the problem you're seeing. All that's required is the following aspect:


package pkg1.monitoring;

public aspect ErrorMonitoring {
 
    pointcut adviceEnabled() : isAdviceEnabled() &amp;&amp; scope(); 
    pointcut isAdviceEnabled() : if(true);
 
    pointcut scope() : within(DoMonitorErrors+) || !within(pkg1.monitoring..*);

    before(Throwable t) : args(t) &amp;&amp; scope() &amp;&amp; adviceEnabled() {}
 
}

and an empty class "DoMonitorErrors.java". A scenario which causes the error is creating a new aspect.</comment>
		<comment id="12" date="2005-12-13 12:23:34 EST" author="Helen Beeken">Created attachment 31654 [details]
zip containing testcase and dev work

This zip file contains two patches:

* pr113257-tests-patch.txt: apply to the tests project - contains testcase which shows failure
* pr113257-weaver-patch.txt: apply to the weaver project - contains dev work done today on this bug.</comment>
		<comment id="13" date="2005-12-14 03:42:05 EST" author="Andrew Clement">Helen and I have spent a good deal of time hacking on this bug.  It is the pointcut rewriter.  During the first compile a big nasty pointcut is rewritten in DNF - then on the incremental compile we rewrite it again into DNF - this produces a broken result because the method pullUpDisjunctions doesnt cope with:

(A || B) &amp;&amp; (C || D)

and if its ignored then the result isn't DNF.  I had a quick look around for what that looks like when the ||s are moved up - but couldn't find much, so I dug out my boolean algebra knowledge ...

truth table for ABCD and the above expression:

ABCD    A|B  C|D  (A|B)&amp;(C|D)
0000     0    0        0
0001     0    1        0
0010     0    1        0
0011     0    1        0
0100     1    0        0
0101     1    1        1
0110     1    1        1
0111     1    1        1
1000     1    0        0
1001     1    1        1
1010     1    1        1
1011     1    1        1
1100     1    0        0
1101     1    1        1
1110     1    1        1
1111     1    1        1


So, all the 1's in the last column are:  
 (lower case = NOT, + = OR, letters adjacent to each other = AND)
   aBcD+aBCd+aBCD+AbcD+AbCd+AbCD+ABcD+ABCd+ABCD
and reducing that gives:

=&gt; aBcD+aBCd+aBCD+AbcD+AbCd+AbCD+ABcD+ABC
=&gt; aBcD+aBC+AbcD+AbCd+AbCD+ABcD+ABC
=&gt; aBcD+aBC+AbcD+AbC+ABcD+ABC
=&gt; aBcD+BC+AbcD+AbC+ABcD
=&gt; aBcD+BC+AcD+AbC
=&gt; aBcD+BC+AcD+AbC

or in english (?!?)

(Â¬A &amp;&amp; B &amp;&amp; Â¬C &amp;&amp; D) || (B &amp;&amp; C) || (A &amp;&amp; Â¬C &amp;&amp; D) || (A &amp;&amp; Â¬B &amp;&amp; C)

truth table for that beast:

ABCD  BC   aBcD    AcD    AbC (| of those)
0000   0     0      0      0      0
0001   0     0      0      0      0
0010   0     0      0      0      0
0011   0     0      0      0      0
0100   0     0      0      0      0
0101   0     1      0      0      1
0110   1     0      0      0      1
0111   1     0      0      0      1
1000   0     0      0      0      0
1001   0     0      1      0      1
1010   0     0      0      1      1
1011   0     0      0      1      1
1100   0     0      0      0      0
1101   0     0      1      0      1
1110   1     0      0      0      1
1111   1     0      0      0      1

which is the same answer.

So ... I implemented that.  However - DNFs aren't unique and constantly rewriting pcuts on every build is painful.  The above change to cope with (A||B)&amp;&amp;(C||D) introduces new NOTs into the pcut which the 'distributingNot' mechanism (part of becoming DNF) will attempt to move around on the next rewrite - when there is no need.  What is better is for us to recognize something is in DNF and don't mess with it.  So I implemented that too.  We still simplifyAnds and sortOrs - I didn't make that conditional on whether we are in DNF because some pcuts are in DNF but still need simplying or sorting.

phew - fix checked in.

Anyway, the fix is in - behaves for this problem and every other testcase in the suite.</comment>
		<comment id="14" date="2005-12-14 04:19:27 EST" author="Andrew Clement">fix available.</comment>
		<comment id="15" date="2005-12-14 06:37:30 EST" author="Andrew Clement">Hmmmmm .. trusty old spacewar didn't like my change - and then Mr Colyer pointed out an equivalent, much nicer rewrite:

(A || B) &amp;&amp; (C || D)

=&gt;

(A &amp;&amp; C) || (A &amp;&amp; D) || (B &amp;&amp; C) || (B &amp;&amp; D)

(DOH!)

which is also likely to give us more stable rewrites.  Spacewar even likes it :)
(Although I'm not sure why spacewar didn't like mine - must be an invalid assumption I'm making about something...)

i need a holiday</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="30718de26e1603f038027dfc4b1de4a42b61ec90" author="aclement" date="2005-12-14 05:10:31"/>
          <file name="tests/multiIncremental/PR113257/base/src/pkg1.monitoring/DoMonitorErrors.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="119749" opendate="2005-12-7 16:54:00" fixdate="2005-12-14 7:05:00">
    <buginformation>
      <summary>execution incorrectly matching based on overridden method throws clause</summary>
      <description>Per user email "after() throwing matching on interface" and the code below, the execution PCD is matching based on a throws clause declared in the overridden method of a supertype.  While this tracks the multiple-signature model for the execution join point, it's not correct to say that the method will throw the exceptions declared by the method it overrides, unless it explicitly declares them, so it seems like a bug.  (We should also document the difference between call and execution in this respect.)

In the code below, all warnings are matched by all method implementations because they implement MyInterface.

-------------------- bugs/InheritedThrows.java
package bugs;

public class InheritedThrows {

    static aspect A {
        declare warning : execution (* *.*(..) throws Ex1) : "one";
        declare warning : execution (* *.*(..) throws Ex2) : "two";
        declare warning : execution (* *.*(..) throws !(Ex1||Ex2)) : "neither";
        declare warning : execution (* *.*(..) throws Ex1, Ex2) : "both";
    }

    public static class Ex1 extends Exception {}

    public static class Ex2 extends Exception {}

    public interface MyInterface {
        public void m() throws Ex1, Ex2;
    }

    private static class NestedClass1 implements MyInterface {
        public void m() throws Ex1 {}
    }

    private static class NestedClass2 implements MyInterface {
        public void m() throws Ex2 {}
    }

    private static class NestedClassBoth implements MyInterface {
        public void m() throws Ex1, Ex2 {}
    }

    private static class NestedClassNeither implements MyInterface {
        public void m() {}
    }
}</description>
      <comments>
		<comment id="1" date="2005-12-08 12:20:12 EST" author="Wes Isberg">btw, discussion started in bug 119013.

To repeat, I believe the multiple-signatures rule is correct for overridden method-execution wrt declaring type, but not wrt declared exceptions.  But that also means you can't specify the overriding method-execution's of a method-execution specified using throws.  For call join points, it raises the question whether to match using the supertype throws clause when a subtype reference is used; the user might expect otherwise, but it's not correct.  (e.g., the enclosing method would not have catch or declare that it throws the checked exception)

----------------------------- pseudo-code for the call case...
  pointcut callex(): call(void Super.*(..) throws Exception);
  pointcut callnoex(): call(void Super.*(..));
  ...
  class Super {
     protected void m() throws Exception {}
  }
  class Sub extends Super {
     protected void m() {}
  }
  void someMethod() {
     Sub sub = new Sub();
     Super sup = sub;
     sub.m(); // callnoex, but not callex
     try {
       sup.m(); // callnoex and callex
     } catch (Exception e {}
  }
-----------------------------
(Even if the proposed semantics are adopted, this is likely to be treated as an implementation limitation in the near term.)</comment>
		<comment id="2" date="2005-12-12 09:40:10 EST" author="Andrew Clement">note - this is a change in behaviour since AspectJ1.2.1 (I've just tested it) - I suspect accidental.</comment>
		<comment id="3" date="2005-12-12 10:23:01 EST" author="Andrew Clement">There is a testcase for this behaviour in the suite already:

Line56 in SignaturePatternTestCase.testThrowsMatch().

The line was changed during the 1.5.0 timeframe, I believe to fit in with the changes to signature matching.  This change at SignaturePattern, line 383:

from

  if (!throwsPattern.matches(aMethod.getExceptions(), world)) 
    return FuzzyBoolean.MAYBE;

to
  if (!throwsPattern.matches(aMethod.getExceptions(), world)) 
    return FuzzyBoolean.NO;

enables the 1.2.1 behaviour for signature matching and the testcase I mentioned earlier needs changing to the form it had in 1.2.1.

Returning MAYBE means 'and take a look at signature above us' - returning NO says 'give up now'.

I need Adrian to comment on this.</comment>
		<comment id="4" date="2005-12-13 05:47:06 EST" author="Adrian Colyer">I've been thinking about this for the last hour or so. I believe there is a bug here, but it's not the one that is reported.

There are three parts of a signature that may legally vary up and down an inheritance hierarchy:
* the throws clause
* the return type
* the annotations

AspectJ 5 has a simple rule that a signature matching pcd (call, execution in this case) matches if the join point has a signature that is exactly matched by the signature pattern. This works consistently for throws, covariance, and annotations. By narrowing or widening the declaring type pattern, this allows a user to write a pointcut that matches any variation they care about. I'm very loathe to "special case" the throws pattern. If we did so, we'd continually have to explain the exception to the rule, and the somewhat counter-intuitive behaviour of expressions like:

execution(String MyInterface.getName() throws Exception)

which would no longer guarantee to match the execution of any implementation of the interface method. (I think you should be able to take the full signature as it is in the declaration, express that in a signature pattern, and have it match). 

In other words, Wes wrote "While this tracks the multiple-signature model for the
execution join point, it's not correct to say that the method will throw the
exceptions declared by the method it overrides, unless it explicitly declares
them, so it seems like a bug."  But matching like this does /not/ say that the method will throw the exceptions declared by the method it overrides - it says that the join point has a signature that matches. 

However....

AspectJ 5 also introduces a distinction between the signature*s* of a join point, and the subject of a join point. For execution, the subject being the method that actually gets to execute.  @annotation, and the returning(xxx) pattern in after returning. Using after throwing advice, the declared thrown exception type (if any) is also matching on the subject of the join point.

So 

after() throwing(Ex1 ex1) : execution(* *(..) throws Ex1) {
   ...
}

should *not* be showing as a match in the structure model (and should not be weaving NestedClassNeither.m for example) because the subject at the join point cannot throw the given checked exception.

In summary: if after throwing specifies a checked exception in the throwing clause, then this constrains join point matching to only those join points were the subject can throw the given checked exception.</comment>
		<comment id="5" date="2005-12-13 08:39:43 EST" author="Andrew Clement">I've implemented the fix for constraining matches if an exception is specified in the throwing() clause.  Here is a sample program that is effected:

public class InheritedThrows {

    static aspect A {
        after() throwing(Ex1 a): execution(* *.*(..) throws Ex1) {}
    }

    public static class Ex1 extends Exception {}

    public static class Ex2 extends Exception {}

    public interface MyInterface {
        public void m() throws Ex1, Ex2;
    }

    private static class NestedClass1 implements MyInterface {
        public void m() throws Ex1 {} // MATCHES HERE
    }

    private static class NestedClass2 implements MyInterface {
        public void m() throws Ex2 {}
    }

    private static class NestedClassBoth implements MyInterface {
        public void m() throws Ex1, Ex2 {}  // MATCHES HERE
    }

    private static class NestedClassNeither implements MyInterface {
        public void m() {}
    }
}

without the fix, the advice matches all four m() methods.  This only applies to checkedexceptions specified in the throwing() clause.</comment>
		<comment id="6" date="2005-12-13 15:25:34 EST" author="Wes Isberg">I think we're ok on declaring and return type, but not annotations or throws.

&gt; I think you should be able to take the full signature as
&gt; it is in the declaration, express that in a signature pattern, 
&gt; and have it match.

I respectfully disagree.  That's putting our implementation ahead of Java semantics. The multiple-signature implementation does the right thing wrt declaring type and perhaps return type, but not annotations or throws, which are not inherited even when the method is overridden.  The goal for our semantics is not consistency with our own constructs, but with the Java language as users use it. 

As you suggest, there are six relevant parts to the signature for the method-call and method-execution join points:
- name
- parameters
- declaring type
- return type
- throws
- annotation

Only the first two are part of the JLS-defined method signature, but all are subject to JLS rules wrt overriding, such that the first four can be said to be inherited when overriding.*

Strictly speaking, the declaring type of the supertype should not match a method declared in the subtype.  However, we made it do so because users expect this and it is useful.  They expect this because such methods override the supertype declarations, and are called instead of the supertype.  It is useful because it means you don't have to respecify the pointcut for each implementation.  In retrospect, it might have been better to require users to use + to include any subtypes.

For covariant return types returning a narrower type, the narrower type would not strictly-speaking be matched by the wider type (i.e., it would not match if subtype-narrow-returning method did not override the supertype-wider-returning method).  However, it seems harmless in practice since (like declaring type) this is always true.  And as with declaring type, it avoids requiring users to use + for subtypes, but that would do the same thing.

Method annotations are not inherited (class annotations can be). So the multiple-signature rule matches on the supertype annotation, but the subject method does not have that annotation.  I would think that if "execution(@Me *(..))" matches at a join point, then so would "@annotation(Me)"  But this is not true in the current implementation.

Similarly, throws clauses are not inherited.  I would expect that if "call(* *(..) throws Exception)" matches, then the join point must be in a code block that either catches or throws Exception, but that's not true (e.g., so there is no reason to soften the exception). I would also expect for "execution(void m() throws Exception)" that the subject method  would in fact declare that it throws the Exception.  Further, it seems weird that "execution(* *(..) throws Exception)" matches when the method is explicitly declared not to throw Exception.  I can't think off-hand how I would tell someone to work around this when their pointcut picks out a method-execution they don't want.

I don't mind saying that this is our implementation and we're going to stick with it.  (I personally wish we had instead required + for return and declaring type.)  But we're going to have to document its weirdness either way, because the "clean" rule about multiple signatures results in counter-intuitive matching, and may prevent users from being able to pick out certain join points.

wrt subject of after-returning, when the return type acts as part of the pointcut, it violates the central dogma (join points &lt;- pointcuts &lt;- advice), so I've never liked this.  I've suggested pointcuts "returns(TypePattern|TypeVariable)" and "throws(..)" by way of replacement, but the current form is so useful and well-understood... Anyway, that means I'm not fond of having more situations where after-returning binding makes a difference.

* wrt what users expect from Java ...
The JLS is I think careful not to say that the supertype declaration is "the" declaration or that the subtype declaration is the definition or implementation.  Per the JLS, the declared method is the subject, and the subject method overrides supertype methods with the same signature (the method signature is defined in the JLS 8.4.2 explicitly to not include throws clauses (and method annotations)).  It further constrains the exceptions that may be thrown and the result types that may be declared.  So our notion of "signature" as applied
to method-execution and method-call join points is clearly broader (and more restrictive) than what the JLS uses for methods, esp. wrt overriding.  It's in throws and annotations that our definition overreaches.

------------------------------------------------------ more experiments
package bugs;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

import org.aspectj.lang.JoinPoint;

public aspect OverriddenMethodDeclarations {
 // not inherited
 @Retention(RetentionPolicy.RUNTIME)
 @Target(ElementType.METHOD) 
 @interface Me{}
 
 static class C {
  @Me()
  void m() throws Exception {}
 }
 static class D extends C{
  void m() {}
 }
 static class E {
  D d(){return null;}
  C c(){return null;}
  static aspect A {
   declare warning: execution(C E.*()) : "C E.*()";
   declare warning: execution(D E.*()) : "D E.*()";
  }
 }
 public static void main(String[] args) {
  C c = new C();
  D d = new D();
  C cd = d;
  try {c.m();} catch (Exception e) {}
  try {cd.m();} catch (Exception e) {}
  d.m();
 }
 static aspect A {
  static void log(JoinPoint jp, Object o) {
   System.out.println("" + jp + ": " + o);
  }
  pointcut scope() : within(OverriddenMethodDeclarations);
  pointcut execMe() :execution(@Me void m()) &amp;&amp; scope();
  pointcut execEx() :execution(void m() throws Exception) &amp;&amp; scope();
  pointcut execAnyEx() :execution(* *(..) throws Exception) &amp;&amp; scope();
  pointcut callEx() :call(void m() throws Exception) &amp;&amp; scope();
  declare warning : execMe() : "aa @Me void m()";
  declare warning : execEx() : "aa void m() throws Exception";
  declare warning : execAnyEx() : "aa * *(..) throws Exception";
  declare warning : callEx() : "aa call void m() throws Exception";
  before(Me me) : @annotation(me) &amp;&amp; execMe() {
   log(thisJoinPoint, "execMe[" + me + "]");
  }
  before() : execEx() {
   log(thisJoinPoint, "execEx");
  }
 }
}</comment>
		<comment id="7" date="2005-12-13 15:56:35 EST" author="Adrian Colyer">doh. 

apologies to wes (thanks for coming back) and to andy (who implemented my proposal). one hour of thinking after 5 hours of jetlag clearly isn't enough.

If you look at my own documentation on this issue here: http://www.eclipse.org/aspectj/doc/next/adk15notebook/join-point-modifiers.html, I clearly state that throws, annotations, and visibility modifiers should be matched based on the subject. So I agree with my (non-jetlagged self) and disagree with my (jetlagged) self. 

did you tag that set of changes in any way andy??????

time to dig out the code again....</comment>
		<comment id="8" date="2005-12-13 17:19:28 EST" author="Adrian Colyer">fix in tree (as per AJDK notebook). See bugs150/pr119749.aj and the corresponding specification:

    &lt;ajc-test dir="bugs150" title="modifier overrides"&gt;
       &lt;compile files="pr119749.aj" options="-1.5"&gt;
         &lt;message kind="warning" line="26" text="C E.*()"/&gt;
         &lt;message kind="warning" line="25" text="D E.*()"/&gt;
         &lt;message kind="warning" line="17" text="aa @Me void m()"/&gt;
         &lt;message kind="warning" line="17" text="aa void m() throws Exception"/&gt;
         &lt;message kind="warning" line="17" text="aa * *(..) throws Exception"/&gt;
         &lt;message kind="warning" line="37" text="aa call void m() throws Exception"/&gt;
         &lt;message kind="warning" line="38" text="aa call void m() throws Exception"/&gt;
        &lt;/compile&gt;
        &lt;run class="pr119749"&gt;
            &lt;stdout&gt;
             &lt;line text="execution(void pr119749.C.m()): execMe[@pr119749$Me()]"/&gt;
             &lt;line text="execution(void pr119749.C.m()): execEx"/&gt;
            &lt;/stdout&gt;
        &lt;/run&gt;
    &lt;/ajc-test&gt;</comment>
		<comment id="9" date="2005-12-14 07:05:03 EST" author="Adrian Colyer">fix available</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="107bdfa4da65cd983fcdf92e9b6a15341940e304" author="aclement" date="2005-12-13 04:14:16"/>
          <file name="tests/bugs150/pr119749/InheritedThrows.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="120909" opendate="2005-12-14 11:58:00" fixdate="2005-12-19 2:09:00">
    <buginformation>
      <summary>Test failures using IBM Java 5</summary>
      <description>1. ReflectionBasedReferenceTypeDelegateTest.testCompareSubclassDelegates() 

junit.framework.AssertionFailedError: Errors:Couldn't find void java.util.HashMap.onEntry() in the bcel set 
Couldn't find void java.util.HashMap.onExit() in the bcel set 
Couldn't find void java.util.HashMap.transfer0(java.util.HashMap$Entry[]) in the bcel set 

????at junit.framework.Assert.fail(Assert.java:47) 
????at junit.framework.Assert.assertTrue(Assert.java:20) 
????at org.aspectj.weaver.reflect.ReflectionBasedReferenceTypeDelegateTest.testCompareSubclassDelegates(ReflectionBasedReferenceTypeDelegateTest.java:278) 
????at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 
????at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64) 
????at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 
????at java.lang.reflect.Method.invoke(Method.java:615) 
????at junit.framework.TestCase.runTest(TestCase.java:154) 
????at junit.framework.TestCase.runBare(TestCase.java:127) 
????at junit.framework.TestResult$1.protect(TestResult.java:106) 
????at junit.framework.TestResult.runProtected(TestResult.java:124) 
????at junit.framework.TestResult.run(TestResult.java:109) 
????at junit.framework.TestCase.run(TestCase.java:118) 
????at junit.framework.TestSuite.runTest(TestSuite.java:208) 
????at junit.framework.TestSuite.run(TestSuite.java:203) 
????at junit.framework.TestSuite.runTest(TestSuite.java:208) 
????at junit.framework.TestSuite.run(TestSuite.java:203) 
????at junit.framework.TestSuite.runTest(TestSuite.java:208) 
????at junit.framework.TestSuite.run(TestSuite.java:203) 
????at junit.framework.TestSuite.runTest(TestSuite.java:208) 
????at junit.framework.TestSuite.run(TestSuite.java:203) 
????at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:478) 
????at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:344) 
????at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196) 

This failure occures because when we compare BeclWorld with ReflectionWorld we are still picking up the default (Sun) version of HashMap in JRE15_LIB for BCEL. The solution is to create both worlds with the same class loader.

2. Ajc150Tests.testModifierOverrides() 

junit.framework.AssertionFailedError: Expecting output: 
execution(void pr119749.C.m()): execMe[@pr119749$Me()] 
execution(void pr119749.C.m()): execEx 
But found output: 
execution(void pr119749.C.m()): execMe[@pr119749.Me()] 
execution(void pr119749.C.m()): execEx 

First difference is on line 1 

????at junit.framework.Assert.fail(Assert.java:47) 
????at org.aspectj.testing.OutputSpec.matchAgainst(OutputSpec.java:58) 
????at org.aspectj.testing.RunSpec.execute(RunSpec.java:61) 
????at org.aspectj.testing.AjcTest.runTest(AjcTest.java:68) 
????at org.aspectj.testing.XMLBasedAjcTestCase.runTest(XMLBasedAjcTestCase.java:111) 
????at org.aspectj.systemtest.ajc150.Ajc150Tests.testModifierOverrides(Ajc150Tests.java:852) 
????at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 
????at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64) 
????at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 
????at java.lang.reflect.Method.invoke(Method.java:615) 
????at junit.framework.TestCase.runTest(TestCase.java:154) 
????at junit.framework.TestCase.runBare(TestCase.java:127) 
????at junit.framework.TestResult$1.protect(TestResult.java:106) 
????at junit.framework.TestResult.runProtected(TestResult.java:124) 
????at junit.framework.TestResult.run(TestResult.java:109) 
????at junit.framework.TestCase.run(TestCase.java:118) 
????at junit.framework.TestSuite.runTest(TestSuite.java:208) 
????at junit.framework.TestSuite.run(TestSuite.java:203) 
????at junit.framework.TestSuite.runTest(TestSuite.java:208) 
????at junit.framework.TestSuite.run(TestSuite.java:203) 
????at junit.extensions.TestDecorator.basicRun(TestDecorator.java:22) 
????at junit.extensions.TestSetup$1.protect(TestSetup.java:19) 
????at junit.framework.TestResult.runProtected(TestResult.java:124) 
????at junit.extensions.TestSetup.run(TestSetup.java:23) 
????at junit.framework.TestSuite.runTest(TestSuite.java:208) 
????at junit.framework.TestSuite.run(TestSuite.java:203) 
????at junit.framework.TestSuite.runTest(TestSuite.java:208) 
????at junit.framework.TestSuite.run(TestSuite.java:203) 
????at junit.framework.TestSuite.runTest(TestSuite.java:208) 
????at junit.framework.TestSuite.run(TestSuite.java:203) 
????at junit.framework.TestSuite.runTest(TestSuite.java:208) 
????at junit.framework.TestSuite.run(TestSuite.java:203) 
????at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:478) 
????at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:344) 
????at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196) 

This failure is due a difference between JDKs in the implementation of toString() for annotations.</description>
      <comments>
		<comment id="1" date="2005-12-14 12:20:23 EST" author="Matthew Webster">Created attachment 31760 [details]
Fixes to 2 harness tests</comment>
		<comment id="2" date="2005-12-15 06:38:36 EST" author="Matthew Webster">Created attachment 31804 [details]
Fixes to harness tests

Also remove public constructors that use Class.getClassLoader().</comment>
		<comment id="3" date="2005-12-19 02:09:10 EST" author="Adrian Colyer">fix now available</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="9abfc4044b23629af408459a3a5c638d7978e443" author="aclement" date="2005-12-16 12:57:36"/>
          <file name="loadtime/src/org/aspectj/weaver/loadtime/DefaultWeavingContext.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/reflect/ReflectionWorld.java">
          </file>
          <file name="weaver/testsrc/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateTest.java">
          </file>
          <file name="weaver/testsrc/org/aspectj/weaver/reflect/ReflectionWorldTest.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="119539" opendate="2005-12-6 20:52:00" fixdate="2005-12-13 11:40:32">
    <buginformation>
      <summary>generic pertypewithin advice fails to match though pointcut does</summary>
      <description>Get compiler xlint adviceDidNotMatch when using parameterized type to specify type pattern for pertypewithin clause.  Parameterized type works in pointcuts, and the pointcut matches staticly (with deow).  Same result for before or around advice.

Also, the permitted uses for the type parameter of a parameterized aspect in the adk15notebook section on point.

Resolutions could be:
- not a bug b/c the code below is wrong
- not permitted to use type parameter in pertypewithin; doc updated
- permitted, fixed
...

AspectJ version 1.5.0.20051206103951, via AJDT

----------------------------------------- sample
package bugs;

public class GenericPerTypeWithin {

    public static void main(String[] args) {
        new C(); // fyi, compiler does nothing absent this call?
    }
    public static abstract aspect Singleton&lt;Target&gt; pertypewithin(Target) {
        pointcut creation() : execution(Target+.new()) ;
        // adviceDoesNotMatch - same for before advice
        Target around() : creation() { return proceed(); }
        // picks out constructor-execution below
        declare warning : creation() : "Singleton.creation()";
    }
    static class C {
        C(){}
    }
    static aspect A extends Singleton&lt;C&gt; {}
}</description>
      <comments>
		<comment id="1" date="2005-12-07 12:26:47 EST" author="Andrew Clement">Bah!!!! I've fixed this - and my fix is great.  but it breaks an incremental compilation test ... the reason is that the incremental test aspect now matches where it didnt before (it used a generic pertypewithin).  It relates to bug 115251 which is where Adrian was investigating changes to abstract aspects during incremental compilation.  He put some stuff in, then commented it out - if I uncomment it then my pertypewithin fix works, but other tests fail ...</comment>
		<comment id="2" date="2005-12-09 01:07:55 EST" author="Adrian Colyer">here be dragons.... (and it's 1am, and I need to go to bed...). That abstract aspect fix I tried to put in and then backed out again really does need to happen to be solid in all cases. But as you discovered.... it has knock-on consequences that seemed unpleasant when I pulled on it (I was getting a 1.2.1 compatability test failure amongst other nasties). If you can find a clean way to include the absract aspect fix though, it's the right thing to do...</comment>
		<comment id="3" date="2005-12-12 07:09:24 EST" author="Andrew Clement">Right.  I have fixed this properly.  the abstract aspect fix is in.  the cflow optimizations are sorted (and more bullet proof than before) and pertypewithin(TypeVariable) works.

1. ReferenceType.getPerClause() needed to parameterize what it was returning when necessary.
2. EclipseSourceType.getPerClause() needed to return something intelligible when it could, rather than defaulting to PerSingleton(). It now looks on the aspect declaration and returns the right thing.
3. CrosscuttingMembersSet.addOrReplaceAspect().  I've uncommented Adrians stuff to  handle abstract aspects.  The problem is that addOrReplace.. was running twice - once during compile time, once during weave time.  The type mungers to add the cflow counters were put into the crosscutting set whilst resolving the pointcuts the first time through addOrReplace.  When the second addOrReplace occurs - the type mungers are deleted, and they never get readded because the fields are cached in the CflowPointcut logic (for reuse).  The fix is that if we are trashing the type mungers, we need to trash the CflowPointcut cache - causing things to be recreated correctly.
(Whether we need to call addOrReplaceAspect twice - compile time and weave time - i didnt investigate).
4. Finally, the logic in cflowpointcut for caching and reusing stacks/counters was a little shaky and I think could break if you used the same pointcut in two different aspects (because it maintained a cache of pointcut&gt;cflowfield).  Depending on the order in which ajc saw the aspects, the field might go into one aspect or the other - real problem for separate compilation.  The real fix is to include the aspect name in the key for the cache - so we only share stacks/counters if a cflow entry pointcut is reused within the same aspect. 

i will check this in shortly. should help with incremental bugs relating to abstract aspects!</comment>
		<comment id="4" date="2005-12-12 08:46:21 EST" author="Andrew Clement">fixes checked in.</comment>
		<comment id="5" date="2005-12-13 11:40:32 EST" author="Andrew Clement">fix available.</comment>
		<comment id="6" date="2006-01-04 16:36:48 EST" author="Wes Isberg">fyi, my original code for this bug (and some other code) now produces VerifyError when no-inline is on with the released AspectJ 5.  I'm still isolating test cases, but as a workaround users should use the compiler's default inline setting.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="cd49da26792c530d2a8c12028c7c1d7832ec6ad2" author="aclement" date="2005-12-08 02:17:13"/>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="124105" opendate="2006-1-17 7:41:00" fixdate="2006-1-17 11:53:00">
    <buginformation>
      <summary>-XhasMember doesn't appear to work well with types in packages</summary>
      <description>See Jeppe's post on the mailing list... will append more here soon.</description>
      <comments>
		<comment id="1" date="2006-01-17 08:44:12 EST" author="Andrew Clement">The problem here was that the type specified as a parameter in the hasmethod(new(OptionType)) signature was in a package and the new hasMethod typepattern support didn't resolve the signature to ensure OptionType became com.test.OptionType.  I added the missing resolve step and have integrated the testcode received from Jeppe into AJ so we can't regress.  waiting on build.</comment>
		<comment id="2" date="2006-01-17 11:53:23 EST" author="Andrew Clement">fix available in latest AspectJ - will be in AJDT in a few days.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="86797879e8c484fdeea87ea2e8304a3354af1e1e" author="aclement" date="2006-01-17 10:35:01"/>
          <file name="tests/bugs151/pr124105/com/test/IOption.java">
          </file>
          <file name="tests/bugs151/pr124105/com/test/IXOption.java">
          </file>
          <file name="tests/bugs151/pr124105/com/test/IYOption.java">
          </file>
          <file name="tests/bugs151/pr124105/com/test/IZOption.java">
          </file>
          <file name="tests/bugs151/pr124105/com/test/MyBrokenXOption.java">
          </file>
          <file name="tests/bugs151/pr124105/com/test/MyXOption.java">
          </file>
          <file name="tests/bugs151/pr124105/com/test/OptionType.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="123695" opendate="2006-1-12 19:59:00" fixdate="2006-1-17 11:53:00">
    <buginformation>
      <summary>Internal nullptr exception with complex declare annotation statement that affects injected methods</summary>
      <description>I have an aspect that declares an annotation on a method based on a complex condition :

declare @method : !@(Write || Read) public !static * (@MarkMyMethods *).*(..) : @Write;

Basically that means that every type that is annotated with @MarkMyMethods should have all of its public non static methods be annotated with either @Read or @Write. If neither of @Read nor @Write is present on such a method, @Write is added by default.

I have another aspect that makes every type annotated with @InjectName implement  the Named interface :

public Interface Named { public String getName(); }

public aspect NameAspect {
  declare parents: @InjectName * implements Named;
  
  private String Named.name;	
  public  String Named.getName() { return name; }
}

As soon as I annotate a class with both @MarkMyMethods and @InjectName, I get an internal null pointer exception at weave time.

However if I change the first aspect to say :

  declare @method : !@(Read) public !static * (@MarkMyMethods *).*(..) : @Write;
  or
  declare @method : !@(Write) public !static * (@MarkMyMethods *).*(..) : @Write;

instead of the !@(Read || Write) one, everything compiles fine.

Here is a link to a small application that exhibits the bug. :
  
http://www.cs.mcgill.ca/~jlegar/src_jslegare.zip

==========
Here is the error output :

java.lang.NullPointerException
at org.aspectj.weaver.patterns.WildAnnotationTypePattern.matches(WildAnnotationTypePattern.java:61)
at org.aspectj.weaver.patterns.NotAnnotationTypePattern.matches(NotAnnotationTypePattern.java:35)
at org.aspectj.weaver.patterns.SignaturePattern.matchesAnnotations(SignaturePattern.java:488)
at org.aspectj.weaver.patterns.SignaturePattern.matchesExactly(SignaturePattern.java:331)
at org.aspectj.weaver.patterns.SignaturePattern.matches(SignaturePattern.java:288)
at org.aspectj.weaver.patterns.DeclareAnnotation.matches(DeclareAnnotation.java:247)
at org.aspectj.weaver.bcel.BcelClassWeaver.weaveAtMethodOnITDSRepeatedly(BcelClassWeaver.java:995)
at org.aspectj.weaver.bcel.BcelClassWeaver.weaveDeclareAtMethodCtor(BcelClassWeaver.java:730)
at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:430)
at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:102)
at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1543)
at org.aspectj.weaver.bcel.BcelWeaver.weaveWithoutDump(BcelWeaver.java:1494)
at org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify(BcelWeaver.java:1275)
at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1078)
at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave(AjCompilerAdapter.java:300)
at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling(AjCompilerAdapter.java:178)
at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$afterReturning$org_aspectj_ajdt_internal_compiler_CompilerAdapter$2$f9cc9ca0(CompilerAdapter.aj:70)
at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:367)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:811)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:230)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:156)
at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:122)
at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)

trouble in: 
public class NameAspect extends java.lang.Object:
  TypeMungers: [(BcelTypeMunger ResolvedTypeMunger(Method, java.lang.String Named.getName())), (BcelTypeMunger ResolvedTypeMunger(Field, java.lang.String Named.name))]
     declares: [declare parents: @InjectName * extends (Named);]
  private static Throwable ajc$initFailureCause
  public static final NameAspect ajc$perSingletonInstance
  static void &lt;clinit&gt;():
    catch java.lang.Throwable -&gt; E0
    |               INVOKESTATIC NameAspect.ajc$postClinit ()V   (line 2)
    catch java.lang.Throwable -&gt; E0
                    GOTO L0
                E0: ASTORE_0
                    ALOAD_0
                    PUTSTATIC NameAspect.ajc$initFailureCause Ljava/lang/Throwable;
                L0: RETURN
  end static void &lt;clinit&gt;()

  public void &lt;init&gt;():
                    ALOAD_0     // NameAspect this   (line 2)
                    INVOKESPECIAL java.lang.Object.&lt;init&gt; ()V
                    RETURN
  end public void &lt;init&gt;()

  void ajc$declare_parents_1()    org.aspectj.weaver.MethodDeclarationLineNumber: 5:40
:
                    RETURN   (line 5)
  end void ajc$declare_parents_1()

  public static String ajc$interMethod$NameAspect$Named$getName(Named)    EffectiveSignatureAttribute(java.lang.String Named.getName(), method-execution)
:
                    ALOAD_0     // Named ajc$this_   (line 11)
                    INVOKESTATIC NameAspect.ajc$interFieldGetDispatch$NameAspect$Named$name (LNamed;)Ljava/lang/String;
                    ARETURN
  end public static String ajc$interMethod$NameAspect$Named$getName(Named)

  public static String ajc$interMethodDispatch1$NameAspect$Named$getName(Named)    EffectiveSignatureAttribute(java.lang.String Named.getName(), method-call)
:
                    ALOAD_0
                    INVOKEINTERFACE Named.getName ()Ljava/lang/String;
                    ARETURN
  end public static String ajc$interMethodDispatch1$NameAspect$Named$getName(Named)

  public static void ajc$interFieldInit$NameAspect$Named$name(Named)    org.aspectj.weaver.MethodDeclarationLineNumber: 12:279
:
                    RETURN   (line 12)
  end public static void ajc$interFieldInit$NameAspect$Named$name(Named)

  public static String ajc$interFieldGetDispatch$NameAspect$Named$name(Named)    EffectiveSignatureAttribute(java.lang.String Named.name, field-get)
:
                    ALOAD_0
                    INVOKEINTERFACE Named.ajc$interFieldGet$NameAspect$Named$name ()Ljava/lang/String;
                    ARETURN
  end public static String ajc$interFieldGetDispatch$NameAspect$Named$name(Named)

  public static void ajc$interFieldSetDispatch$NameAspect$Named$name(Named, String)    EffectiveSignatureAttribute(java.lang.String Named.name, field-set)
:
                    ALOAD_0
                    ALOAD_1
                    INVOKEINTERFACE Named.ajc$interFieldSet$NameAspect$Named$name (Ljava/lang/String;)V
                    RETURN
  end public static void ajc$interFieldSetDispatch$NameAspect$Named$name(Named, String)

  public void ajc$after$NameAspect$1$dd96786a(Named)    AdviceAttribute(after, (execution(Named+.new(..)) &amp;&amp; target(BindingTypePattern(Named, 0))), 0, 296)
:
                    GETSTATIC java.lang.System.out Ljava/io/PrintStream;   (line 15)
                    LDC "A new name was created"
                    INVOKEVIRTUAL java.io.PrintStream.println (Ljava/lang/String;)V
                    ALOAD_1     // Named newinstance   (line 16)
                    LDC "TikaTikaSlimShady"
                    INVOKESTATIC NameAspect.ajc$interFieldSetDispatch$NameAspect$Named$name (LNamed;Ljava/lang/String;)V
                    RETURN   (line 17)
  end public void ajc$after$NameAspect$1$dd96786a(Named)

  public static NameAspect aspectOf()    org.aspectj.weaver.AjAttribute$AjSynthetic@14d92f0
:
                    GETSTATIC NameAspect.ajc$perSingletonInstance LNameAspect;
                    IFNONNULL L0
                    NEW org.aspectj.lang.NoAspectBoundException
                    DUP
                    LDC "NameAspect"
                    GETSTATIC NameAspect.ajc$initFailureCause Ljava/lang/Throwable;
                    INVOKESPECIAL org.aspectj.lang.NoAspectBoundException.&lt;init&gt; (Ljava/lang/String;Ljava/lang/Throwable;)V
                    ATHROW
                L0: GETSTATIC NameAspect.ajc$perSingletonInstance LNameAspect;
                    ARETURN
  end public static NameAspect aspectOf()

  public static boolean hasAspect()    org.aspectj.weaver.AjAttribute$AjSynthetic@12e2f2e
:
                    GETSTATIC NameAspect.ajc$perSingletonInstance LNameAspect;
                    IFNULL L0
                    ICONST_1
                    IRETURN
                L0: ICONST_0
                    IRETURN
  end public static boolean hasAspect()

  private static void ajc$postClinit()    org.aspectj.weaver.AjAttribute$AjSynthetic@1f0523b
:
                    NEW NameAspect
                    DUP
                    INVOKESPECIAL NameAspect.&lt;init&gt; ()V
                    PUTSTATIC NameAspect.ajc$perSingletonInstance LNameAspect;
                    RETURN
  end private static void ajc$postClinit()
end public class NameAspect

when weaving type NameAspect
when weaving aspects 
when weaving 
when batch building BuildConfig[D:\workspace\.metadata\.plugins\org.eclipse.ajdt.core\AspectSandBox.generated.lst] #Files=8</description>
      <comments>
		<comment id="1" date="2006-01-12 20:03:59 EST" author="Jean-SÃ©bastien LÃ©garÃ©">Created attachment 32946 [details]
Contains 8 files (2 aspects, 4 annotations, 1 interface, 1 class) in one package (default package). Smallest application I could create that exhibits the bug. Everything is weaved on class Main. 

Same thing as the one cited in the bug's text (the URL).</comment>
		<comment id="2" date="2006-01-17 08:45:55 EST" author="Andrew Clement">I've just checked the fix for this into AspectJ.  The NPE can no longer occur *but* that doesn't mean your program works as I've not spent time digging into whether it behaves as expected - but removing the NPE at least gets it compiling.</comment>
		<comment id="3" date="2006-01-17 11:52:44 EST" author="Andrew Clement">fix for NPE is available in latest AspectJ dev build.  Will be in AJDT in a few days.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="8b6fbd3ae387e8746cd24184e747d3f8acef3dc2" author="aclement" date="2006-01-17 10:34:44"/>
          <file name="tests/bugs151/pr123695/InjectName.java">
          </file>
          <file name="tests/bugs151/pr123695/Main.java">
          </file>
          <file name="tests/bugs151/pr123695/MarkMyMethods.java">
          </file>
          <file name="tests/bugs151/pr123695/MarkMyMethodsAspect.java">
          </file>
          <file name="tests/bugs151/pr123695/NameAspect.java">
          </file>
          <file name="tests/bugs151/pr123695/Named.java">
          </file>
          <file name="tests/bugs151/pr123695/Read.java">
          </file>
          <file name="tests/bugs151/pr123695/Write.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="122728" opendate="2006-1-5 3:21:00" fixdate="2006-1-18 2:46:00">
    <buginformation>
      <summary>ajdoc crashes</summary>
      <description>When trying to run ajdoc on a moderate size code base (266 classes / interfaces / aspects), ajdoc crashes. Here's what happens:

D:\work\napa\jnapa\core&gt;ajdoc -source 1.5 -classpath D:\work\napa\jnapa\core\lib\aspectjrt.jar;D:\work\napa\jnapa\core\l
ib\dom4j-1.5.2.jar;D:\work\napa\jnapa\core\lib\groovy-all-1.0-jsr-03.jar -d D:\work\napa\jnapa\core\build\doc\internal -
author -package -argfile D:\work\napa\jnapa\core\jnapafilelist34352.lst
&gt; Calling ajc...
D:\work\napa\jnapa\commons\utils\src\fi\napa\util\aspects\CachingAspect.aj:72 [warning] advice defined in fi.napa.util.a
spects.CachingAspect has not been applied [Xlint:adviceDidNotMatch]


1 warning
&gt; Building signature files...
An internal error occured in ajdoc
Please copy the following text into an email message and send it,
along with any additional information you can add to:

       aspectj-dev@eclipse.org


java.lang.IndexOutOfBoundsException: Index: 3, Size: 3
java.lang.IndexOutOfBoundsException: Index: 3, Size: 3
        at java.util.ArrayList.RangeCheck(ArrayList.java:546)
        at java.util.ArrayList.get(ArrayList.java:321)
        at org.aspectj.tools.ajdoc.StubFileGenerator.processMembers(StubFileGenerator.java:124)
        at org.aspectj.tools.ajdoc.StubFileGenerator.processTypeDeclaration(StubFileGenerator.java:99)
        at org.aspectj.tools.ajdoc.StubFileGenerator.processMembers(StubFileGenerator.java:113)
        at org.aspectj.tools.ajdoc.StubFileGenerator.processTypeDeclaration(StubFileGenerator.java:99)
        at org.aspectj.tools.ajdoc.StubFileGenerator.processFile(StubFileGenerator.java:61)
        at org.aspectj.tools.ajdoc.StubFileGenerator.doFiles(StubFileGenerator.java:38)
        at org.aspectj.tools.ajdoc.Main.main(Main.java:157)

  The file jnapafilelist34352.lst contains only file entries w/ absolute paths, e.g. 
D:\work\napa\jnapa\core\src\fi\napa\core\tableprocessing\transfer\mapping\Transformation.java

I am using ajc and ajdoc 1.5.0 release version. I'll be happy to provide any other information that may help in solving this issue.

D:\work\napa\jnapa\core&gt;ajdoc -v
ajdoc version 1.5.0

D:\work\napa\jnapa\core&gt;ajc -v
AspectJ Compiler 1.5.0 built on Tuesday Dec 20, 2005 at 12:05:54 GMT</description>
      <comments>
		<comment id="1" date="2006-01-05 04:00:50 EST" author="Antti Karanta">I suppose this is the same bug, so I'll add this as a comment. I tried to run ajdoc on the same source files w/ a little different settings. It still crashes:

D:\work\napa\jnapa\core&gt;ajdoc -source 1.5 -classpath D:\work\napa\jnapa\core\lib\aspectjrt.jar;D:\work\napa\jnapa\core\l
ib\dom4j-1.5.2.jar;D:\work\napa\jnapa\core\lib\groovy-all-1.0-jsr-03.jar -d D:\work\napa\jnapa\core\build\doc\internal -
author -package -sourcepath D:\work\napa\jnapa\core\gen_src;D:\work\napa\jnapa\core\src;D:\work\napa\jnapa\commons\utils
\src fi.napa.legacy.nativeaccess fi.napa fi.napa.core fi.napa.core.geometry fi.napa.core.geometry.basic fi.napa.core.geo
metry.legacy fi.napa.core.loadingconditions fi.napa.core.loadingconditions.lightweight fi.napa.core.loadingconditions.li
ghtweight.legacy fi.napa.core.project fi.napa.core.project.legacy fi.napa.core.referencesystem fi.napa.core.referencesys
tem.legacy fi.napa.core.shipmodel fi.napa.core.shipmodel.legacy fi.napa.core.steel fi.napa.core.steel.legacy fi.napa.cor
e.steel.opt fi.napa.core.tableprocessing fi.napa.core.tableprocessing.legacy fi.napa.core.tableprocessing.transfer fi.na
pa.core.tableprocessing.transfer.bootstrap fi.napa.core.tableprocessing.transfer.link fi.napa.core.tableprocessing.trans
fer.link.napa fi.napa.core.tableprocessing.transfer.link.rdbms fi.napa.core.tableprocessing.transfer.mapping fi.napa.cor
e.topology fi.napa.core.topology.legacy fi.napa.legacy fi.napa.legacy.jservicefunctions fi.napa.legacy.jservicefunctions
.invoker fi.napa.util fi.napa.util.aspects
&gt; Calling ajc...
D:\work\napa\jnapa\commons\utils\src\fi\napa\util\aspects\CachingAspect.aj:72 [warning] advice defined in fi.napa.util.a
spects.CachingAspect has not been applied [Xlint:adviceDidNotMatch]


1 warning
&gt; Building signature files...
An internal error occured in ajdoc
Please copy the following text into an email message and send it,
along with any additional information you can add to:

       aspectj-dev@eclipse.org


java.lang.IndexOutOfBoundsException: Index: 4, Size: 4
java.lang.IndexOutOfBoundsException: Index: 4, Size: 4
        at java.util.ArrayList.RangeCheck(ArrayList.java:546)
        at java.util.ArrayList.get(ArrayList.java:321)
        at org.aspectj.tools.ajdoc.StubFileGenerator.processMembers(StubFileGenerator.java:124)
        at org.aspectj.tools.ajdoc.StubFileGenerator.processTypeDeclaration(StubFileGenerator.java:99)
        at org.aspectj.tools.ajdoc.StubFileGenerator.processMembers(StubFileGenerator.java:113)
        at org.aspectj.tools.ajdoc.StubFileGenerator.processTypeDeclaration(StubFileGenerator.java:99)
        at org.aspectj.tools.ajdoc.StubFileGenerator.processFile(StubFileGenerator.java:61)
        at org.aspectj.tools.ajdoc.StubFileGenerator.doFiles(StubFileGenerator.java:38)
        at org.aspectj.tools.ajdoc.Main.main(Main.java:157)</comment>
		<comment id="2" date="2006-01-05 04:17:37 EST" author="Helen Beeken">Yes, this is the same bug. 

The problem is that we're blowing up in the following loop during the processing of enums:
     
     
if (member.getKind().equals(IProgramElement.Kind.ENUM_VALUE)){
  if (((IProgramElement)members.get(members.indexOf(member)+1)). &lt;--- PROBLEM
           getKind().equals(IProgramElement.Kind.ENUM_VALUE)){
     .....
  }
}


I've therefore been able to recreate this bug with just the following enum:

--------------------------------
package pack;

public enum MyEnum {
 
 A;
 
}
--------------------------------

and running ajdoc against this.</comment>
		<comment id="3" date="2006-01-05 05:56:46 EST" author="Helen Beeken">Created attachment 32513 [details]
patch containing fix and test

Apply this patch to the ajdoc project.

The fix involves adding an extra check to see if there are any more members before checking whether the next member is also an enum.</comment>
		<comment id="4" date="2006-01-05 08:23:19 EST" author="Helen Beeken">Created attachment 32518 [details]
patch containing fix and test

ooops - forgot to add the new testcase EnumTest to the ajdoc test suite. This patch does that and this is the only difference between the two.

Apply to the ajdoc project.</comment>
		<comment id="5" date="2006-01-09 08:32:53 EST" author="Andrew Clement">fix checked in.</comment>
		<comment id="6" date="2006-01-18 02:46:48 EST" author="Andrew Clement">fixes available.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="d69ce9aebb3ed4410f07e9992105748b69a0ff5e" author="aclement" date="2006-01-09 10:31:55"/>
          <file name="ajdoc/src/org/aspectj/tools/ajdoc/StubFileGenerator.java">
              <method name="processMembers" returnType="void" parameters="List PrintWriter boolean"/>
          </file>
          <file name="ajdoc/testdata/pr122728/src/pack/ClassWithInnerEnum.java">
          </file>
          <file name="ajdoc/testdata/pr122728/src/pack/EnumWithMethods.java">
          </file>
          <file name="ajdoc/testdata/pr122728/src/pack/MyEnum.java">
          </file>
          <file name="ajdoc/testsrc/org/aspectj/tools/ajdoc/AjdocTests.java">
              <method name="suite" returnType="Test" parameters=""/>
          </file>
          <file name="ajdoc/testsrc/org/aspectj/tools/ajdoc/EnumTest.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="58520" opendate="2004-4-14 13:29:00" fixdate="2006-1-18 2:46:00">
    <buginformation>
      <summary>ajdoc doesn't navigate to target details in some cases</summary>
      <description>When a file is advised, javadoc uses the following naming convention for 
setting its "A NAME":

  convertCheckedException(java.lang.Throwable)

However, ajdoc uses the unqualified name for the argument, resuting in the 
follwing in-file anchor link:

  &lt;class-name&gt;.html#convertCheckedException(Throwable)?

Which fails to navigate to the anchor within the file, although it does always 
go to the right file.</description>
      <comments>
		<comment id="1" date="2004-04-14 13:33:02 EDT" author="Mik Kersten">This is a low-priority bug, but would be nice to fix in the next round of 
ajdoc updates.  The fix may be a little less straightforward than it sounds 
because fully-qualified parameter names aren't currently in the ASM.</comment>
		<comment id="2" date="2005-12-20 06:47:51 EST" author="Helen Beeken">Created attachment 32016 [details]
zip containing fix and testcase patches

The attached zip file contains two patches:

- pr58520-ajdoc-patch.txt : apply to the ajdoc project. This patch contains a testcase which uses the same sample project as supplied in the patch for bug 119453 (it's included in this patch because the patch for 119453 hasn't been applied yet)
- pr58520-org-aspectj-ajdt-core-patch.txt : apply to the org.aspectj.ajdt.core project. This patch contains the proposed fix.

The fix for this bug required changing the logic in AsmElementFormatter.setParameters(..) to use the fully qualified name when setting the arguments. This resulted in adding an extra check in AsmHierarchyBuilder.visit(MethodDeclaration, ClassScope) to check for main(java.lang.String[]) rather than main(String[]).

A consequence of this fix is that as well as the links mentioned when this bug was raised now working, ajdoc also includes the fully qualified name in the signature. For example, if you declare a constructor ITD on a class C which takes a String argument:

public C.new(String s){ this();};

the ajdoc used to show this as:

C.C(String).

It now shows it as

C.C(java.lang.String)

which is more consistent with javadoc.</comment>
		<comment id="3" date="2005-12-21 04:25:21 EST" author="Andrew Clement">I applied 119453 and have just applied this one (skipping the files that were from 119453) - the new test fails.  Are there definetly no differences between the sample project in each case?

Failure is:
junit.framework.AssertionFailedError: Advice summary should have link to 'C.html#method3(java.lang.String)'
 at junit.framework.Assert.fail(Assert.java:47)
 at junit.framework.Assert.assertTrue(Assert.java:20)
 at org.aspectj.tools.ajdoc.FullyQualifiedArgumentTest.checkContentsOfA(FullyQualifiedArgumentTest.java:93)
 at org.aspectj.tools.ajdoc.FullyQualifiedArgumentTest.testPr58520(FullyQualifiedArgumentTest.java:58)
 at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
 at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
 at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
 at java.lang.reflect.Method.invoke(Method.java:585)
 at junit.framework.TestCase.runTest(TestCase.java:154)
 at junit.framework.TestCase.runBare(TestCase.java:127)
 at junit.framework.TestResult$1.protect(TestResult.java:106)
 at junit.framework.TestResult.runProtected(TestResult.java:124)
 at junit.framework.TestResult.run(TestResult.java:109)
 at junit.framework.TestCase.run(TestCase.java:118)
 at junit.framework.TestSuite.runTest(TestSuite.java:208)
 at junit.framework.TestSuite.run(TestSuite.java:203)
 at junit.framework.TestSuite.runTest(TestSuite.java:208)
 at junit.framework.TestSuite.run(TestSuite.java:203)
 at junit.framework.TestSuite.runTest(TestSuite.java:208)
 at junit.framework.TestSuite.run(TestSuite.java:203)
 at junit.framework.TestSuite.runTest(TestSuite.java:208)
 at junit.framework.TestSuite.run(TestSuite.java:203)
 at junit.framework.TestSuite.runTest(TestSuite.java:208)
 at junit.framework.TestSuite.run(TestSuite.java:203)
 at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:478)
 at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:344)
 at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196)</comment>
		<comment id="4" date="2005-12-21 04:41:17 EST" author="Helen Beeken">Created attachment 32070 [details]
updated ajdoc patch to encorporate fixes for 119453

There is an extra method in C.java that is required for this test:

 public void method3(String s) { 
 }

The attached patch is an updated version which has synchronized against the latest changes in HEAD (i.e. with pr119453 having been applied).

Apply to the ajdoc project.</comment>
		<comment id="5" date="2005-12-21 05:38:20 EST" author="Andrew Clement">fixes checked in.</comment>
		<comment id="6" date="2006-01-18 02:46:10 EST" author="Andrew Clement">fix available.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="bbdd4966a79864ea9979da81ca4725d6471b2fa9" author="aclement" date="2005-12-21 07:37:43"/>
          <file name="ajdoc/testdata/pr119453/src/pack/C.java">
              <method name="method2" returnType="String" parameters=""/>
          </file>
          <file name="ajdoc/testsrc/org/aspectj/tools/ajdoc/AjdocTests.java">
              <method name="suite" returnType="Test" parameters=""/>
          </file>
          <file name="ajdoc/testsrc/org/aspectj/tools/ajdoc/FullyQualifiedArgumentTest.java">
          </file>
          <file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmElementFormatter.java">
              <method name="setParameters" returnType="void" parameters="MethodDeclaration IProgramElement"/>
          </file>
          <file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmHierarchyBuilder.java">
              <method name="visit" returnType="boolean" parameters="MethodDeclaration ClassScope"/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="123612" opendate="2006-1-12 11:08:00" fixdate="2006-1-18 3:16:00">
    <buginformation>
      <summary>ArrayIndexOutOfBoundsException with incremental and declare @type</summary>
      <description>Given the following code:

-------------------------------------------------
public aspect A {
	declare @type : C : @MyAnnotation;
}
@interface MyAnnotation {	
}

class C {
}
-------------------------------------------------

if you comment out the declare @type statement and do an incremental build, then the following ArrayIndexOutOfBoundsException occurs:

java.lang.ArrayIndexOutOfBoundsException: 0
	at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.doDeclareAnnotations(AjLookupEnvironment.java:754)
	at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.weaveInterTypeDeclarations(AjLookupEnvironment.java:571)
	at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.weaveIntertypes(AjLookupEnvironment.java:357)
	at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.completeTypeBindings(AjLookupEnvironment.java:209)
	at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.beginToCompile(Compiler.java:301)
	at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:315)
	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:811)
	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:254)
	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.incrementalBuild(AjBuildManager.java:163)
	at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:117)
	at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)



This is against the latest code in HEAD.</description>
      <comments>
		<comment id="1" date="2006-01-12 11:13:05 EST" author="Helen Beeken">Created attachment 32913 [details]
testcase patch

Patch containing MultiProjectIncrementalTest.

Apply to the tests project.</comment>
		<comment id="2" date="2006-01-17 10:31:42 EST" author="Andrew Clement">fixed - needed to clear the cache of old dec@s so they didn't interfere on a later compile.</comment>
		<comment id="3" date="2006-01-18 03:16:00 EST" author="Andrew Clement">fix available.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="ab2f89bd7314680eda5ff5efeb7e97409ff878d1" author="aclement" date="2006-01-18 12:32:20"/>
          <file name="tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java">
              <method name="testPr113257" returnType="void" parameters=""/>
          </file>
          <file name="weaver/src/org/aspectj/weaver/CrosscuttingMembersSet.java">
              <method name="clearCaches" returnType="void" parameters=""/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="124808" opendate="2006-1-22 11:12:00" fixdate="2006-1-24 6:14:00">
    <buginformation>
      <summary>[generics] detecting field-get of field of parameterized type.</summary>
      <description>Hi,

Here is the second generics issue:

Java code:
==========

public class Test&lt;T extends Integer&gt; {
	Set&lt;T&gt; ints = new HashSet&lt;T&gt;();

	public Set&lt;T&gt; foo() {
		return ints;
	}

	public static void main(String[] args) {
		Test&lt;Integer&gt; t = new Test&lt;Integer&gt;();
		Set&lt;Integer&gt; ints = t.foo();
	}
}

Aspect:
=======
public privileged aspect TestAspect {

    pointcut gettingMemberCollection(Test t) :
                   target(t) &amp;&amp;
                   get(!public Set&lt;Number+&gt; com.mprv.secsph.*.*) &amp;&amp;
                   !within(TestAspect);

	after (Test test) : gettingMemberCollection(test) {
		System.out.println("GO Aspects!");
	}
}

Compiler output:
================
warning at after (Test test) : gettingMemberCollection(test) {
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/IdeaProjects/aspectsTest/src/com/mprv/secsph/TestAspect.aj:19:0::0 advice defined in com.mprv.secsph.TestAspect has not been applied [Xlint:adviceDidNotMatch]


I would expect "gettingMemberCollection" to catch access to "ints" member of "Test" ...

Thanks a lot!
Misha.</description>
      <comments>
		<comment id="1" date="2006-01-23 09:23:49 EST" author="Andrew Clement">fix checked in.  changed: ExactTypePattern and TypePattern.</comment>
		<comment id="2" date="2006-01-23 09:29:56 EST" author="Misha Kantarovich">(In reply to comment #1)
&gt; fix checked in.  changed: ExactTypePattern and TypePattern.

I have no words ... :)

Thanks for the fixes!</comment>
		<comment id="3" date="2006-01-24 06:14:27 EST" author="Andrew Clement">fix available.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="01a8b2eb36e1a34c80697c2034f9657b74dc281a" author="aclement" date="2006-01-23 11:25:06"/>
          <file name="tests/bugs151/pr124808/Test.java">
          </file>
          <file name="tests/bugs151/pr124808/TestAspect.java">
          </file>
          <file name="tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/patterns/ExactTypePattern.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/patterns/TypePattern.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="124654" opendate="2006-1-20 10:32:00" fixdate="2006-1-24 6:15:00">
    <buginformation>
      <summary>Capture method annotation in generic aspect does not compile</summary>
      <description>The following aspect won't compile with aspect 1.5:

package aj;

import java.lang.annotation.Annotation;

public abstract aspect GenericAnnotation&lt;A extends Annotation&gt; {

    pointcut annotatedCall(A a) : call(@A * *.*(..)) &amp;&amp; @annotation(a);

    /* does not compile */
    before(A a) : annotatedCall(a) {
        System.out.println(a.annotationType());
    }
    /* */

    /* OK */
    before(A a) : call(@A * *.*(..)) &amp;&amp; @annotation(a) {
        System.out.println(a.annotationType());
    }

}

----------------------

&gt;ajc -1.5 -d aj src\aj\*
...\src\aj\GenericAnnotation.aj:10 [error] incompatible type, expected java.lang.annotation.Annotation found BindingTypePattern(TA;, 0).  Check the type specified in your pointcut before(A a) : annotatedCall(a) {

1 error

----------------

Commenting out the first advice lets this program run as expected:

package aj;

import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;

public class Main {

    @Retention(RetentionPolicy.RUNTIME)
    @interface MyAnnotation {
    }

    static aspect ConcreteAnnotation extends GenericAnnotation&lt;MyAnnotation&gt; {
    }

    public static void main(String[] args) {
        someMethod();
    }

    @MyAnnotation
    private static void someMethod() {
    }

}</description>
      <comments>
		<comment id="1" date="2006-01-20 12:11:00 EST" author="Andrew Clement">appears the code putting out the message isnt being smart about encountering type variables...</comment>
		<comment id="2" date="2006-01-23 10:20:03 EST" author="Andrew Clement">fix checked in.</comment>
		<comment id="3" date="2006-01-24 06:15:27 EST" author="Andrew Clement">fix available.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="28f8c695ccc8513e9dcbe0c4fb6ebdc71cf84313" author="aclement" date="2006-01-24 12:21:18"/>
          <file name="tests/bugs151/pr124654/GenericAnnotation.java">
          </file>
          <file name="tests/bugs151/pr124654/TestSubAspect.java">
          </file>
          <file name="tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/patterns/ReferencePointcut.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="124999" opendate="2006-1-24 8:41:00" fixdate="2006-1-26 3:36:00">
    <buginformation>
      <summary>[generics] Incorrect call to generic inherited method in around advice</summary>
      <description>The following case produces a runtime error:

package aj;

public abstract aspect GenericInheritedMethod&lt;T&gt; {

    protected final T getSomething() {
        return null;
    }

}


package aj;

aspect UseInheritedMethod extends GenericInheritedMethod&lt;Integer&gt; {

    // works as expected
    before() : execution(void someMethod()) {
        System.out.println(getSomething());
    }

    // Runtime Error
    void around() : execution(void someMethod()) {
        System.out.println(getSomething());
    }

    public static void main(String[] args) {
        someMethod();
    }

    private static void someMethod() {
    }

}


&gt;java aj.UseInheritedMethod
null
Exception in thread "main" java.lang.NoSuchMethodError: aj.UseInheritedMethod.getSomething()Ljava/lang/Integer;
        at aj.UseInheritedMethod.ajc$inlineAccessMethod$aj_UseInheritedMethod$aj_UseInheritedMethod$getSomething(UseInheritedMethod.aj)
        at aj.UseInheritedMethod.ajc$around$aj_UseInheritedMethod$2$c74e36b7(UseInheritedMethod.aj:12)
        at aj.UseInheritedMethod.someMethod(UseInheritedMethod.aj:1)
        at aj.UseInheritedMethod.main(UseInheritedMethod.aj:16)

The "inlineAccessMethod" should call "getSomething()Ljava/lang/Object;" as the before advice does.</description>
      <comments>
		<comment id="1" date="2006-01-26 03:36:43 EST" author="Andrew Clement">fix for this is checked in and available in the latest dev build.</comment>
		<comment id="2" date="2006-01-26 03:36:55 EST" author="Andrew Clement">fixed.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="a4bd19d25597a31e1b76cc5fc188c3112bf0f5ff" author="aclement" date="2006-01-25 01:47:42"/>
          <file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AccessForInlineVisitor.java">
          </file>
          <file name="tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="121395" opendate="2005-12-19 6:28:00" fixdate="2006-1-31 9:19:00">
    <buginformation>
      <summary>invalid aspectj path throws filenotfoundexception</summary>
      <description>An invalid aspectj path (missing jar file) throws an filenotfoundexception:

java.io.FileNotFoundException
at java.io.FileInputStream.open(Native Method)
at java.io.FileInputStream.&lt;init&gt;(FileInputStream.java:106)
at org.aspectj.weaver.bcel.BcelWeaver.addAspectsFromJarFile(BcelWeaver.java:202)
at org.aspectj.weaver.bcel.BcelWeaver.addLibraryJarFile(BcelWeaver.java:192)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.initBcelWorld(AjBuildManager.java:623)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:209)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:185)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.incrementalBuild(AjBuildManager.java:163)
at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:117)
at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)

FileNotFoundException thrown: /Users/frankstolle/Documents/workspace/lib_aspects/deploy/lib_aspects.jar (No such file or directory)



should generate an problem entry in the problems-list.</description>
      <comments>
		<comment id="1" date="2005-12-20 06:29:21 EST" author="Sian January">This seems to be ok on the command line - you get a message saying "Bad aspectpath ...".  In the AJDT environment we'd like the compiler to return a compile problem rather than throw an exception.</comment>
		<comment id="2" date="2006-01-27 07:28:50 EST" author="Andrew Clement">command line verification is done in BuildArgParser.  AJDT takes a different route into the weaver. I've changed AjBuildManager to report a problem for entries on the aspectpath that don't exist.

I also upgraded the AJDT-like test harness we had to allow setting of an aspectpath for a project.

fix checked in, waiting on build.</comment>
		<comment id="3" date="2006-01-31 09:19:40 EST" author="Andrew Clement">fix available.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="551b446bec83bef0f7df1f57353fdb4297bc14a6" author="aclement" date="2006-01-27 09:30:21"/>
          <file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java">
              <method name="initBcelWorld" returnType="void" parameters="IMessageHandler"/>
          </file>
          <file name="tests/src/org/aspectj/systemtest/incremental/tools/AjdeInteractionTestbed.java">
              <method name="configureNonStandardCompileOptions" returnType="void" parameters="String"/>
          </file>
          <file name="tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="125101" opendate="2006-1-24 19:40:00" fixdate="2006-1-31 9:20:00">
    <buginformation>
      <summary>StackOverFlow in ReferenceType.isAssignableFrom()</summary>
      <description>Hi.

I am weaving two aspects into a jar file "jar-to-jar". ajc 1.5.0 gives me a huge error message (see attachement). Would be great if I could get any recommendations on this.

Thanks!
Eric</description>
      <comments>
		<comment id="1" date="2006-01-24 19:41:40 EST" author="Eric Bodden">Created attachment 33558 [details]
the output generated by ajc

first 4 lines might be caused by the javac compilation that happens before and builds the jar (not to confuse you)</comment>
		<comment id="2" date="2006-01-24 19:42:40 EST" author="Eric Bodden">Created attachment 33559 [details]
the jar I weave into</comment>
		<comment id="3" date="2006-01-24 19:46:39 EST" author="Eric Bodden">Comment on attachment 33559 [details]
the jar I weave into

I will replace this...</comment>
		<comment id="4" date="2006-01-24 19:47:26 EST" author="Eric Bodden">Created attachment 33560 [details]
this contains the jar I weave into and all dependencies (I hope)</comment>
		<comment id="5" date="2006-01-24 19:48:11 EST" author="Eric Bodden">The commandline I use:

ajc -sourceroots "/home/user/ebodde/bin/sabs/install/benchmarks/Java/jlo-rt/aspects:/home/user/ebodde/bin/sabs/install/benchmarks/Java/jlo-rt/perf-tests" -classpath "/home/user/ebodde/bin/sabs/install/benchmarks/Java/jlo-rt/util/jasminclasses-2.2.2.jar:${CLASSPATH}:/home/user/ebodde/bin/sabs/local/system/temp/Java/jlo-rt/jlo-rt.jar:/home/user/ebodde/bin/sabs/install/benchmarks/Java/jlo-rt/lib/junit.jar:/home/user/ebodde/bin/sabs/install/benchmarks/Java/jlo-rt/lib/commons-collections-3.1.jar" -injars "/home/user/ebodde/bin/sabs/local/system/temp/Java/jlo-rt/jlo-rt.jar" -outjar "/home/user/ebodde/bin/sabs/local/system/temp/Java/jlo-rt/jlo-rt-instr.jar"

So - last mail for today. I promise :-)</comment>
		<comment id="6" date="2006-01-24 20:59:41 EST" author="Eric Bodden">Created attachment 33566 [details]
still found this aj core dump</comment>
		<comment id="7" date="2006-01-25 10:36:08 EST" author="Andrew Clement">It appears java.util.Collection is coming into the system as a 'simple' type - neither in its generic form or raw form - so it gets put into the typemap as a simple type.  this gets us horribly confused later when we are working with a subclass of it that treats it as raw.

(thanks for the code - I was able to recreate it here...)</comment>
		<comment id="8" date="2006-01-25 11:47:35 EST" author="Eric Bodden">thanks for finding that out so quickly. could you please let me know ASAP when a fix is available - we are doing some benchmarks on AJ compilers and it would be a pity ajc not being one of them. Thanks!</comment>
		<comment id="9" date="2006-01-25 11:50:04 EST" author="Andrew Clement">do you have to use a 1.5 VM for this? If you use an earlier one with a non-generic form of Collection in it, it will probably work.</comment>
		<comment id="10" date="2006-01-25 12:06:13 EST" author="Andrew Clement">or ... compile with the -1.5 flag - but I suspect that will affect performance numbers you collect as we have more type analysis to do. </comment>
		<comment id="11" date="2006-01-25 12:28:46 EST" author="Eric Bodden">Oh great, that worked! We are testing the runtime performance of the generated code, so that should be fine. I thought -1.5 would be a default option (at least if you encounter Java 5 code) ...</comment>
		<comment id="12" date="2006-01-25 12:36:21 EST" author="Andrew Clement">fix checked in for the problem.

-1.5 is not default unless LTW.</comment>
		<comment id="13" date="2006-01-26 03:34:31 EST" author="Andrew Clement">build failed to upload last night, should be there a little later this morning.  Anyway, the real problem here was processing code built with 1.5 when running ajc in 1.4 mode.  We didn't do the right thing and attempted to create raw types rather than simple types in the weaver where the compiler had done the right thing and created simple types.  Basically the fix was to put a check in our weaver to only build raw types if the system was running in 1.5 mode.</comment>
		<comment id="14" date="2006-01-31 09:20:55 EST" author="Andrew Clement">fix available.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="efb20c5a3eeecb85c059110b3494f7b39593ab28" author="aclement" date="2006-01-26 02:41:21"/>
          <file name="weaver/src/org/aspectj/weaver/bcel/BcelWorld.java">
              <method name="addSourceObjectType" returnType="BcelObjectType" parameters="JavaClass"/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="125405" opendate="2006-1-26 17:09:00" fixdate="2006-1-31 9:21:00">
    <buginformation>
      <summary>Bad user template code can lead to exception thrown message</summary>
      <description>To reproduce: Create a new AspectJ project, and create a new aspect:

package test;

public aspect ATest
{
    // main
    public static void main(String[] args) {

    }
}
====
Then, write ATest&lt;T&gt; instead of just ATest and then save.

You should now get the warning:
2	only abstract aspects can have type parameters	ATest.aj

So far so good. Now, remove the newly added "&lt;T&gt;" and save again. This should happen:

java.lang.IllegalStateException
at org.aspectj.weaver.ResolvedMemberImpl.parameterizedWith(ResolvedMemberImpl.java:605)
at org.aspectj.weaver.ResolvedMemberImpl.parameterizedWith(ResolvedMemberImpl.java:590)
at org.aspectj.weaver.ReferenceType.getDeclaredMethods(ReferenceType.java:421)
at org.aspectj.weaver.ResolvedType.getDeclaredAdvice(ResolvedType.java:699)
at org.aspectj.weaver.ResolvedType.getDeclaredShadowMungers(ResolvedType.java:736)
at org.aspectj.weaver.ResolvedType.collectShadowMungers(ResolvedType.java:572)
at org.aspectj.weaver.ResolvedType.collectCrosscuttingMembers(ResolvedType.java:501)
at org.aspectj.weaver.CrosscuttingMembersSet.addOrReplaceAspect(CrosscuttingMembersSet.java:66)
at org.aspectj.weaver.bcel.BcelWeaver.prepareForWeave(BcelWeaver.java:439)
at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave(AjCompilerAdapter.java:283)
at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling(AjCompilerAdapter.java:178)
at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$afterReturning$org_aspectj_ajdt_internal_compiler_CompilerAdapter$2$f9cc9ca0(CompilerAdapter.aj:70)
at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:367)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:811)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:254)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.incrementalBuild(AjBuildManager.java:163)
at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:117)
at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)

IllegalStateException thrown: Can't ask to parameterize a member of non-generic type: test.ATest  kind(raw)</description>
      <comments>
		<comment id="1" date="2006-01-27 03:40:24 EST" author="Andrew Clement">I think the problem here is that after the failed build we don't discard the ATest type properly, leaving an entry in the type map for its incorrect generic form.  On the subsequent compile we then treat it as the raw form of the generic type - it isnt, it is just a simple type so we go bang.</comment>
		<comment id="2" date="2006-01-27 05:28:24 EST" author="Andrew Clement">damn I'm good.  Exactly as suspected - although it is invalid as a generic aspect (since its non-abstract), the simple type that was in the typemap is promoted during the failing compile by the code in EclipseFactory.addSourceTypeBinding() - this process is never undone and the typemap entry is not replaced.  I am currently testing a demotion scheme so that if it goes back to being non-generic we repair the typemap entry.</comment>
		<comment id="3" date="2006-01-27 06:56:48 EST" author="Andrew Clement">fix checked in. waiting on build.</comment>
		<comment id="4" date="2006-01-31 09:21:40 EST" author="Andrew Clement">fix available.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="a723cc27959dbb9b6e3eb3eea797163bd4ac7102" author="aclement" date="2006-01-27 08:11:34"/>
          <file name="tests/multiIncremental/PR125405/base/test/ATest.java">
          </file>
          <file name="tests/multiIncremental/PR125405/inc1/test/ATest.java">
          </file>
          <file name="tests/multiIncremental/PR125405/inc2/test/ATest.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="125810" opendate="2006-1-31 6:26:00" fixdate="2006-2-2 3:07:00">
    <buginformation>
      <summary>Missing error when inherited abstract pointcut not made concrete in sub-@aspect</summary>
      <description>An error is issued when a sub-aspect does not implement an inherited abstract pointcut. This is missing for a sub-@aspect.</description>
      <comments>
		<comment id="1" date="2006-01-31 06:33:14 EST" author="Matthew Webster">Created attachment 33852 [details]
Testcase

Includes bug 125699</comment>
		<comment id="2" date="2006-02-01 04:29:35 EST" author="Andrew Clement">Straightforward (hopefully) one for you Helen.</comment>
		<comment id="3" date="2006-02-01 06:14:24 EST" author="Helen Beeken">The reason the error message isn't coming out is in AjLookupEnvironment.resolvePointcutDeclarations(..). The pointcut declarations are only checked if the aspect has pointcuts or it's an AspectDeclaration. In the case of the supplied testcase, there are no pointcuts in the SubAtAspect and its not an AspectDeclaration (it's a TypeDeclaration instead). If you add another pointcut to the SubAtAspect then the testcase passes and the expected error message appears. 

The fix is therefore to augment the check to see if we're an @Aspect TypeDeclaration and if so then check the pointcut declarations.</comment>
		<comment id="4" date="2006-02-01 08:16:03 EST" author="Helen Beeken">Created attachment 33933 [details]
proposed fix

Patch containing a proposed fix - apply this to the org.aspectj.ajdt.core project.</comment>
		<comment id="5" date="2006-02-02 03:07:36 EST" author="Andrew Clement">fix available.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="1d41626c3d8489acf9a630d9236a9ecdf912363d" author="aclement" date="2006-02-02 12:20:37"/>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="126328" opendate="2006-2-3 6:17:00" fixdate="2006-2-6 14:27:00">
    <buginformation>
      <summary>IlegalStateException : zip file closed</summary>
      <description>If there are &gt; 1000 jars on the combination of classpath, aspectpath, and inpath, it is possible for a ZipFile to be closed and not successfully reopened before trying to read from it again.</description>
      <comments>
		<comment id="1" date="2006-02-03 06:50:51 EST" author="Adrian Colyer">fix committed in tree. waiting on build.</comment>
		<comment id="2" date="2006-02-06 14:27:31 EST" author="Adrian Colyer">fix now available</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="8933b6a6c18860da97a4c89eb113d44bc67525ad" author="acolyer" date="2006-02-03 08:52:01"/>
          <file name="weaver/src/org/aspectj/weaver/bcel/ClassPathManager.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="123212" opendate="2006-1-10 4:12:00" fixdate="2006-2-10 5:45:00">
    <buginformation>
      <summary>Skip subversion resources when copying files from input to output folders</summary>
      <description>Exception when compile a project under svn.

java.io.FileNotFoundException
at java.io.FileOutputStream.open(Native Method)
at java.io.FileOutputStream.&lt;init&gt;(FileOutputStream.java:179)
at java.io.FileOutputStream.&lt;init&gt;(FileOutputStream.java:131)
at org.aspectj.util.FileUtil.makeOutputStream(FileUtil.java:1258)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.writeResource(AjBuildManager.java:466)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.copyResourcesFromFile(AjBuildManager.java:444)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.copyResourcesToDestination(AjBuildManager.java:386)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:298)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:185)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.incrementalBuild(AjBuildManager.java:163)
at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:117)
at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)

FileNotFoundException thrown: /home/chomats/Fede/svn/fede-repos/Tool.Product.ProductServer/classes/.svn/format (Permission non accord?)</description>
      <comments>
		<comment id="1" date="2006-01-11 04:16:28 EST" author="Andrew Clement">I presume svn is subversion.

the compiler appears to be failing to copy a resource from input to output because of a permissions problem.  Are the permissions on that file set such that the compiler should be able to access it?</comment>
		<comment id="2" date="2006-02-09 08:42:18 EST" author="Andrew Clement">Comment from Stephane that didnt get on the bug:

&gt; Yes,the project is under subversion control but in this cas, svn
&gt; plugin is not installed. The file 'format' is read only. but it's
&gt; allready present in output folder.
&gt; -r--r--r--  1 chomats users   2 d?c 23 11:11 format
&gt; The aspecj compiler must not copy the .svn resource form input to
&gt; output.

It looks like I just need to augment our ignore list with svn information, it currently reads that we ignore:

(resourceName.startsWith("CVS/")) ||
(resourceName.indexOf("/CVS/") != -1) ||
(resourceName.endsWith("/CVS")) ||
(resourceName.endsWith(".class")) ||   (resourceName.toUpperCase().equals(MANIFEST_NAME))
      
can you tell me if there is a suitable pattern for svn files, are they always in a .svn directory? in which case this will work:

resourceName.indexOf("/.svn/") != -1) ||
resourceName.indexOf(".svn/") != -1) ||
resourceName.indexOf("/.svn") != -1) ||</comment>
		<comment id="3" date="2006-02-09 11:35:31 EST" author="Adrian Colyer">SVN uses directories named ".svn" (with a whole bunch of files and folders underneath them).</comment>
		<comment id="4" date="2006-02-10 02:54:24 EST" author="Andrew Clement">thx Adrian.  Proposed fix committed. waiting on build.</comment>
		<comment id="5" date="2006-02-10 05:45:28 EST" author="Andrew Clement">fix available in latest AspectJ build - will be in AJDT shortly.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="d856e4fedb65e12104851967690ef751b2c7b09b" author="aclement" date="2006-02-10 04:55:32"/>
          <file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java">
              <method name="acceptResource" returnType="boolean" parameters="String"/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="120356" opendate="2005-12-12 7:07:00" fixdate="2006-2-10 8:25:00">
    <buginformation>
      <summary>@AJ decl err/warn does not show cross structure view</summary>
      <description>Perhaps an issue in the ASM struct for DEOW
since cross struct. is empty in AJDT , despite error / warning gutter and message is ok.</description>
      <comments>
		<comment id="1" date="2006-02-08 05:36:37 EST" author="Helen Beeken">Created attachment 34335 [details]
patch containing failing testcase

Apply the patch to the tests project.

Even though the @AJ deow are showing up in the gutters in AJDT the related location is wrong - it points to the first line in the @AJ java file. This mismatch is the reason the relationships are not showing in the xref view. Dumping out the structure model (with only the @DeclareWarning) gives:

--------------------------------------------------------------------------------------------------------------------------------------------------

=== MODEL STATUS REPORT ========= After a batch build
&lt;root&gt;  [java source file] 
  C.java  [java source file] C:\temp\ajcSandbox\ajcTest55011.tmp\C.java:1::0
    import declarations  [import reference] 
    C  [class] C:\temp\ajcSandbox\ajcTest55011.tmp\C.java:3::17
      warningMethod()  [method] C:\temp\ajcSandbox\ajcTest55011.tmp\C.java:5::37
      badMethod()  [method] C:\temp\ajcSandbox\ajcTest55011.tmp\C.java:8::76
  A.java  [java source file] C:\temp\ajcSandbox\ajcTest55011.tmp\A.java:1::0
    import declarations  [import reference] 
      org.aspectj.lang.annotation.DeclareError  [import reference] C:\temp\ajcSandbox\ajcTest55011.tmp\A.java:4::105
      org.aspectj.lang.annotation.DeclareWarning  [import reference] C:\temp\ajcSandbox\ajcTest55011.tmp\A.java:3::53
      org.aspectj.lang.annotation.Aspect  [import reference] C:\temp\ajcSandbox\ajcTest55011.tmp\A.java:2::9
    A  [aspect] C:\temp\ajcSandbox\ajcTest55011.tmp\A.java:7::172
      warning  [field] C:\temp\ajcSandbox\ajcTest55011.tmp\A.java:10::255
=== END OF MODEL REPORT =========
=== RELATIONSHIPS REPORT ========= After a batch build
Hid:1:(targets=1) C:\temp\ajcSandbox\ajcTest55011.tmp\C.java|5|0|37 (matches declare) C:\temp\ajcSandbox\ajcTest55011.tmp\A.java|1|0|-1
Hid:2:(targets=1) C:\temp\ajcSandbox\ajcTest55011.tmp\A.java|1|0|-1 (matched by) C:\temp\ajcSandbox\ajcTest55011.tmp\C.java|5|0|37
=== END OF RELATIONSHIPS REPORT ==
=== Properties of the model and relationships map =====
FileMapSize=2
aspect=1
RelationshipMapSize=2
java source file=3
import reference=5
class=1
field=1
method=2

---------------------------------------------------------------------------------------------------

The offending thing here is that in the relationship report it says that the java source file, rather than the warning [field], is matched by the warningMethod. This is due to the setting of the location of the DeclareErrorOrWarning in AtAjAttributes.handleDeclareErrorOrWarningAnnotation(..). In both error and warning cases this is set to:

deow.setLocation(struct.context, -1, -1);

whereas it should be set to (in the above example)

deow.setLocation(struct.context, 255, 269 );

The problem is how to get hold of the correct start and end position...........</comment>
		<comment id="2" date="2006-02-08 12:21:25 EST" author="Helen Beeken">Created attachment 34355 [details]
zip containing updated tests and proposed short-term fix

This zip contains two patchts:

* pr120356-tests-patch2.txt - apply to the tests project. This includes the previous tests patch plus an added test for running without the -emacssym flag
* pr120356-weaver-patch2.txt - apply to the weaver project. 

The weaver patch contains a proposed short-term fix for this bug. When the structure model is created all the IProgramElements have the correct location. By querying the structure model for the IProgramElement corresponding to the @DeclareWarning or @DeclareError field we can use the ISourceLocation to get the offset and set the location on the DeclareErrorOrWarning correctly. This clearly only fixes the problem when the structure model is generated, however, this means that when used within AJDT the cross references view shows the correct information and the navigation from the markers is correct.

There are other possibilities for a more long-term fix:

1. The information within ajcDeclareSoft could be used. This requires that the possition of the message is set correctly (I'm not sure if it is or isn't - I haven't investigated this yet). This would also only fix the case when compiled with ajc but not when compiled with javac.
2. Creating a new AjAttribute called FieldDeclarationLineNumberAttribute (much like MethodDeclarationLineNumberAttribute) which we could ask for the offset. This would fix both cases, when compiled with ajc and javac.</comment>
		<comment id="3" date="2006-02-08 14:57:04 EST" author="Andrew Clement">Just a quick comment whilst its fresh in my mind, after Helen and I discussed it:

&gt; 1. The information within ajcDeclareSoft could be used. This requires that...
I think thats ajcDeclareEow - seems this is something ajcDeclareEow should have been designed for, but we have to be very careful with supporting old format annotations if we change it (whole new can-o-worms)

&gt; 2. Creating a new AjAttribute called FieldDeclarationLineNumberAttribute (much
&gt; like MethodDeclarationLineNumberAttribute) which we could ask for the offset.
&gt; This would fix both cases, when compiled with ajc and javac.

It would fix the case for ajc compilation with or without -emacssym, it wouldn't fix javac compilation unfortunately.</comment>
		<comment id="4" date="2006-02-09 06:52:58 EST" author="Helen Beeken">The ajcDeclareEow annotation is created in DeclareDeclaration.addAtAspectJAnnotations(), which itself is called from AddAtAspectJAnnotationsVisitor.visit(MethodDeclaration, ClassScope). Within this method there are instance checks as to whether the MethodDeclaration is an AdviceDeclaration, PointcutDeclaration, DeclareDeclaration or InterTypeDeclaration. If the instance check returns true then the corresponding addAtAspectJAnnotations() method is called. However, in the case of @AJ aspects the advice is an AjMethodDeclaration rather than any of the subtypes. Moreover, the @DeclareError and @DeclareWarning's are FieldDeclarations. Therefore, none of the addAtAspecTJAnnotations() methods are called.</comment>
		<comment id="5" date="2006-02-10 05:23:06 EST" author="Helen Beeken">Looking into what is required to create a FieldDeclarationLineNumberAttribute this is not straightforward and requires a lot of new code and infrastructure. For starters, a new AjFieldDeclaration ASTNode would need to be created, as well as extra methods on the IDeclarationFactory interface. Moreover, there is no obvious mechanism for adding the attribute (unlike in the method case) so would required quite a bit of work. Finally, as Andy pointed out in comment #3, at the end of the day, this wouldn't fix the javac case.

All of this (including comment #3 and comment #4), plus the fact that the fix using the IProgramElement (comment #2) is straight forward and enables users within AJDT to see the xrefs in the cross reference view, means that if that fix is integrated, this bug should probably be closed as fixed and only revisited if users ask for it.</comment>
		<comment id="6" date="2006-02-10 08:25:09 EST" author="Andrew Clement">fix checked in - i agree we shouldn't do any more until someone starts complaining.
waiting on build.</comment>
		<comment id="7" date="2006-02-10 08:25:39 EST" author="Andrew Clement">fix available in latest build.</comment>
		<comment id="8" date="2006-02-10 08:25:41 EST" author="Helen Beeken">Created attachment 34490 [details]
patch containing comment fix

Apply this patch to the weaver project.

This patch fixes the wrong statement in the comment for AtAjAttributes.setDeclareErrorOrWarningLocation(..) made in the last patch.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="f743fb210e1b7aa8cdb45e7bda53aa336f912edf" author="aclement" date="2006-02-10 08:25:44"/>
          <file name="tests/bugs151/pr120356/A.java">
          </file>
          <file name="tests/bugs151/pr120356/C.java">
          </file>
          <file name="tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/bcel/AtAjAttributes.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="125475" opendate="2006-1-27 9:38:00" fixdate="2006-2-10 8:41:00">
    <buginformation>
      <summary>[@AspectJ] ajc cannot compile empty @Pointcut</summary>
      <description>I get this error:

C:\temp\ajcSandbox\ajcTest27856.tmp\TestEmptyPointcutAtAspect.java:8:0::0 Method annotated with @Pointcut() for abstract pointcut must be abstract

when compiling this aspect with ajc (it's fine with javac):

@Aspect
public class TestEmptyPointcutAtAspect {

	@Pointcut("")
	protected void scope () {}
}</description>
      <comments>
		<comment id="1" date="2006-01-27 09:53:06 EST" author="Matthew Webster">Created attachment 33703 [details]
Testcase (combined with 125480)</comment>
		<comment id="2" date="2006-01-27 10:11:58 EST" author="Andrew Clement">I presume you are trying to define an empty (matches nothing but overridable) scope pointcut rather than an abstract scope pointcut?</comment>
		<comment id="3" date="2006-01-30 04:19:03 EST" author="Matthew Webster">The testcase tries to implement an inherited abstract pointcut defined in a parent code-style aspect.</comment>
		<comment id="4" date="2006-01-30 05:27:32 EST" author="Andrew Clement">Another way to express this is of course:

@Pointcut
protected void scope () {}

which doesnt work either.

I see in the patch several files duplicated in a tests/ltw directory that are also in the tests/bugs151/pr125480 directory.  I'm ignoring the ones in the tests/ltw directory - they don't seem to be referenced from the test XML.  I'm assuming they are just leftover after moving the code to the bugs folder.

The basic problem here seems to be @AJ doesnt understand empty matches nothing pointcut expressions.  I've rectified this - it isn't as clean as it could be but it works ok (the tests for 125475 and 125480 work for me).</comment>
		<comment id="5" date="2006-02-10 08:41:45 EST" author="Andrew Clement">fix available.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="693945fed3ea7482c5c312063dfac881f0d0d1c9" author="aclement" date="2006-01-29 07:12:10"/>
          <file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AccessForInlineVisitor.java">
          </file>
          <file name="tests/bugs151/pr123901/A.java">
          </file>
          <file name="tests/bugs151/pr123901/B.java">
          </file>
          <file name="tests/bugs151/pr125475/TestEmptyPointcutAtAspect.java">
          </file>
          <file name="tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="122370" opendate="2005-12-30 0:54:00" fixdate="2006-2-17 7:42:00">
    <buginformation>
      <summary>[@AspectJ] @DeclareParents/declare parents not equivalent</summary>
      <description>Adding a setter to the Moody example makes it clear that the annotation style (@DeclareParents) results in different behavior than the classic (declare parents) style.

Calling the setter in a "declare parents"-advised object behaves as one would expect.  However, calling the setter with a "@DeclareParents"-advised object has no effect -- that is, you can call the setter (and see that it's been called) and immediately call the getter, only to find that the value didn't change.  The following examples (all in "package moody;") illustrate:

public enum Mood { HAPPY, JOLLY }

Classic style:
-------------
public aspect ClassicMoodIndicator {
   public interface Moody {
      Mood getMood();
      void setMood(Mood mood);
   }

   private Mood Moody.mood = Mood.HAPPY;

   public Mood Moody.getMood() { return mood; }
   public void Moody.setMood(Mood mood) { this.mood = mood; }

   declare parents : moody.ClassicMoodImplementor implements Moody;
}

public class ClassicMoodImplementor { }

Annotation style:
----------------
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.DeclareParents;

@Aspect
public class AnnotationMoodIndicator {
   public interface Moody {
      Mood getMood();
      void setMood(Mood mood);
   }

   public static class MoodyImpl implements Moody {
      private Mood mood = Mood.HAPPY;

      public Mood getMood() { return mood; }
      public void setMood(Mood mood) { this.mood = mood; }
   }

   @DeclareParents(value="moody.AnnotationMoodImplementor",defaultImpl=MoodyImpl.class)
   private Moody implementedInterface;
}

public class AnnotationMoodImplementor { }

JUnit TestCase:
--------------
import junit.framework.TestCase;

public class MoodTester extends TestCase {
   public MoodTester(String name) { super(name); }

   public void testClassic() {
      ClassicMoodImplementor cmi0 = new ClassicMoodImplementor();
      ClassicMoodImplementor cmi1 = new ClassicMoodImplementor();
      
      assertEquals("cmi0 should be HAPPY", Mood.HAPPY, cmi0.getMood());
      
      cmi1.setMood(Mood.JOLLY);
      assertEquals("cmi1 should be JOLLY", Mood.JOLLY, cmi1.getMood());
      assertEquals("cmi0 should be *still* be HAPPY", Mood.HAPPY, cmi0.getMood());
   }
   
   public void testAnnotation() {
      AnnotationMoodImplementor ami0 = new AnnotationMoodImplementor();
      AnnotationMoodImplementor ami1 = new AnnotationMoodImplementor();
      
      assertEquals("ami0 should be HAPPY", Mood.HAPPY, ((AnnotationMoodIndicator.Moody) ami0).getMood());
      
      ((AnnotationMoodIndicator.Moody) ami1).setMood(Mood.JOLLY);
      assertEquals("ami1 should be JOLLY", Mood.JOLLY, ((AnnotationMoodIndicator.Moody) ami1).getMood());
      assertEquals("ami0 should be *still* be HAPPY", Mood.HAPPY, ((AnnotationMoodIndicator.Moody) ami0).getMood());
   }
}

Result:
------
The test run is as follows:
..F
Time: 0.021
There was 1 failure:
1) testAnnotation(moody.MoodTester)junit.framework.AssertionFailedError: ami1 should be JOLLY expected:&lt;JOLLY&gt; but was:&lt;HAPPY&gt;
       at moody.MoodTester.testAnnotation(MoodTester.java:27)
       at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
       at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
       at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
       at moody.MoodTester.main(MoodTester.java:7)

FAILURES!!!
Tests run: 2,  Failures: 1,  Errors: 0

For classic, you can see that cmi1.setMood was successful and cmi0/cmi1 are decoupled (that is, calling setMood on cmi1 has no impact on cmi0).  The annotation style, however, fails because ami1.setMood appears to have done nothing.  The result should have been that ami1 is JOLLY and ami0 HAPPY (I include the second assert because both ami0 &amp; ami1 ended up JOLLY in RC1).

The current behavior makes @DeclareParents unusable for retaining field state (near as I can tell, it retains state throughout the method invocation, but not beyond it, like it is creating and discarding a backing object with each method invocation).</description>
      <comments>
		<comment id="1" date="2006-02-16 09:41:46 EST" author="Helen Beeken">Created attachment 34841 [details]
patch containing failing testcase

Apply this patch to the test project.

This patch contains two tests converted from the supplied testcase. The first is the failing case with @AspectJ style and the second is the code style. The code style test is only there for investigation and shouldn't be checked into HEAD.</comment>
		<comment id="2" date="2006-02-16 10:38:47 EST" author="Helen Beeken">Decompiling AnnotationMoodIndicator we see the following:

   0:   aload_0
   1:   getfield        #19; //Field ajc$moody_AnnotationMoodIndicator$moody_Ann
otationMoodIndicator$Moody:Lmoody/AnnotationMoodIndicator$Moody;
   4:   ifnull  7                                       &lt;---- cause of failure
   7:   aload_0
   8:   new     #21; //class moody/AnnotationMoodIndicator$MoodyImpl
   11:  dup
   12:  invokespecial   #22; //Method moody/AnnotationMoodIndicator$MoodyImpl."&lt;
init&gt;":()V
   15:  putfield        #19; //Field ajc$moody_AnnotationMoodIndicator$moody_Ann
otationMoodIndicator$Moody:Lmoody/AnnotationMoodIndicator$Moody;
   18:  aload_0

for both the getMood() and setMood(moody.Mood) methods. In other words, no matter what, we always create a new instance of MoodyImpl rather than using the one we've got. Instead what we want to do is to only create a new one if we don't already have one. Changing BcelTypeMunger.mungeMethodDelegate(..) to do this results in:

   0:   aload_0
   1:   getfield        #19; //Field ajc$moody_AnnotationMoodIndicator$moody_Ann
otationMoodIndicator$Moody:Lmoody/AnnotationMoodIndicator$Moody;
   4:   ifnonnull       18
   7:   aload_0
   8:   new     #21; //class moody/AnnotationMoodIndicator$MoodyImpl
   11:  dup
   12:  invokespecial   #22; //Method moody/AnnotationMoodIndicator$MoodyImpl."&lt;
init&gt;":()V
   15:  putfield        #19; //Field ajc$moody_AnnotationMoodIndicator$moody_Ann
otationMoodIndicator$Moody:Lmoody/AnnotationMoodIndicator$Moody;
   18:  aload_0

and everything works as expected.</comment>
		<comment id="3" date="2006-02-16 10:40:13 EST" author="Helen Beeken">Created attachment 34845 [details]
failing testcase

Apply this patch to the tests project.

Replaces the previous testcase patch as removes the code style case.</comment>
		<comment id="4" date="2006-02-16 10:43:27 EST" author="Helen Beeken">Created attachment 34846 [details]
patch containing fix

Apply this patch to the weaver project.

This patch contains the fix described in comment #2.</comment>
		<comment id="5" date="2006-02-16 11:52:10 EST" author="Andrew Clement">patch is committed - I dont think the code gen can have been tested, this is a very serious bug.  Luckily our 1.5.1 release is imminent.

It now correctly creates and *keeps* an instance for the multiple calls to get/set.

The fix will be available in a development build soon.</comment>
		<comment id="6" date="2006-02-17 07:42:34 EST" author="Andrew Clement">fix available.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="e87458179ab929aae2bc6966a6e092813bdd14a3" author="aclement" date="2006-02-17 01:50:34"/>
          <file name="tests/bugs151/pr122370/moody/AnnotationMoodImplementor.java">
          </file>
          <file name="tests/bugs151/pr122370/moody/AnnotationMoodIndicator.java">
          </file>
          <file name="tests/bugs151/pr122370/moody/MainClass.java">
          </file>
          <file name="tests/bugs151/pr122370/moody/Mood.java">
          </file>
          <file name="tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java">
              <method name="testAtAspectWithoutJoinPointImport_pr121616" returnType="void" parameters=""/>
          </file>
          <file name="weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java">
              <method name="mungeMethodDelegate" returnType="boolean" parameters="BcelClassWeaver MethodDelegateTypeMunger"/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="128128" opendate="2006-2-15 19:39:00" fixdate="2006-2-17 14:45:00">
    <buginformation>
      <summary>iajc doesn't fail Ant build when compile errors occur.</summary>
      <description>The iajc ant task doesn't failonerror anymore.

The most relevant line is AjcTask.java:1256 with holder.numMessages(IMessage.ERROR, false) always returning 0.

The holder:MessageHandler instance delegates messages to an interceptor AntMessageHandler. The AntMessageHandler is (almost) always consuming the messages, leaving the MessageHandler.java:108 to return without recording any messages itself.

I would have liked to submit a patch with this bug report but I'm not yet sure what the correct interceptor.handleMessage(message) behavior should be in this case.

Note: The AntMessageHandler properly reporting message priorities ("error" vs. "warn") is welcome functionality - thanks.</description>
      <comments>
		<comment id="1" date="2006-02-16 15:05:37 EST" author="Wes Isberg">wrt patch question on-list, for this situation I use a CountingMessageHandler which counts but delegates message-holding (which means it needs to be the delegator, not the delegatee).  The proposed solution means that there may be two copies of each message - not the worst thing.  (In the old harness we ran with ant task and AJDE delegates to pick up this kind of regression.)</comment>
		<comment id="2" date="2006-02-16 17:58:49 EST" author="Wes Isberg">Fixed in AjcTask.java:1.47 per suggestion (CountingMessageHandler makes too many wrappers).  Still no guarantee for forked compiles.</comment>
		<comment id="3" date="2006-02-17 12:39:35 EST" author="Wes Isberg">Fix in tree per last comment.  Message handling undertested.  I suspect this is the only case where the return value of handleMessage(..) is used, so it should probably be made void instead, but that's a pretty extensive change.</comment>
		<comment id="4" date="2006-02-17 14:45:06 EST" author="Wes Isberg">Sorry, forgot milestone when fixed.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="da562415d5349c7e1bb7e7d794cbc7c463e5a5ca" author="wisberg" date="2006-02-17 07:57:18"/>
          <file name="taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java">
              <method name="executeInSameVM" returnType="void" parameters="String[]"/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="128699" opendate="2006-2-20 13:08:00" fixdate="2006-2-20 14:31:00">
    <buginformation>
      <summary>"Incorrect error on ""declare"" statements"</summary>
      <description>The error associated with the declare construct is incorrect. 
The current message is:

"expected one of error, warning, parents, soft, dominates"

dominates should be changed to "precendence" and new annotation related declararions should be mentioned. Here is a suggestion:

"expected one of error, warning, parents, soft, precedence, @type, @method, @constructor, @field"</description>
      <comments>
		<comment id="1" date="2006-02-20 14:31:53 EST" author="Andrew Clement">Fixed - as per the suggestion (thanks!) - will be in next dev build of AJ and AJDT soon...</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="f95d2c96edd293b98c27a19bb9f3cc2748b365cb" author="aclement" date="2006-02-21 04:32:59"/>
          <file name="weaver/src/org/aspectj/weaver/patterns/PatternParser.java">
              <method name="parseDeclare" returnType="Declare" parameters=""/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="128655" opendate="2006-2-20 9:53:00" fixdate="2006-2-21 7:05:00">
    <buginformation>
      <summary>[annotations]Compiler crashes (possibly due to declare @type)</summary>
      <description>AJDT version: 1.3.1 (20060214104738)
AspectJ version: 1.5.1.20060131132251

Not very sure of the reason and couldn't reproduce on a smaller code base.

The compiler crashes on incremental compilation, but never when I do full "clean" build. Here is the stack trace:
java.lang.NullPointerException
at org.aspectj.org.eclipse.jdt.internal.compiler.lookup.MethodBinding.getAnnotationTagBits(MethodBinding.java:447)
at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.doDeclareAnnotations(AjLookupEnvironment.java:754)
at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.weaveInterTypeDeclarations(AjLookupEnvironment.java:571)
at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.weaveInterTypeDeclarations(AjLookupEnvironment.java:498)
at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.doPendingWeaves(AjLookupEnvironment.java:365)
at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.completeTypeBindings(AjLookupEnvironment.java:179)
at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.beginToCompile(Compiler.java:301)
at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:315)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:824)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:258)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.incrementalBuild(AjBuildManager.java:164)
at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:117)
at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)

NullPointerException thrown: null</description>
      <comments>
		<comment id="1" date="2006-02-20 10:14:40 EST" author="Andrew Clement">Line 769 in the latest version of AjLookupEnvironment I think.

Can I ask which file you are incrementally compiling ramnivas?  I assume it is not the file containing the declare - but is it a file affected by the declare or not?</comment>
		<comment id="2" date="2006-02-20 10:20:00 EST" author="Andrew Clement">nevermind, recreated.</comment>
		<comment id="3" date="2006-02-21 05:55:57 EST" author="Andrew Clement">Sometimes I amaze even myself.  I went home yesterday wondering if we could ever fix this (i.e. do the right thing - stopping the NPE is of course straightforward).  This morning I've fixed it.  The problem is to do with retrieving the annotation for the declare @type.  We NPE because we try and retrieve it off a binary type binding and eclipse binary type bindings dont know about annotations.  We have a binary type binding because it is an incremental compile so the 'supporting' types required by the one source file we are building come in as binary type bindings rather than as source type bindings.  What we have to do is access the annotations on the binary type binding through bcel, then construct a minimal eclipse annotation containing the type of the annotation and stick it onto the matched type.

I've put a few comments in the code about other bugs lurking but this was so serious I wanted to get the fix for the original discovered problem out asap.</comment>
		<comment id="4" date="2006-02-21 07:05:01 EST" author="Andrew Clement">fix available.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="67a3319816f88e64f933f1ab3d87f02ca446bc15" author="aclement" date="2006-02-21 06:25:09"/>
          <file name="tests/multiIncremental/pr128655/A.java">
          </file>
          <file name="tests/multiIncremental/pr128655/Foo.java">
          </file>
          <file name="tests/multiIncremental/pr128655/T.java">
          </file>
          <file name="tests/multiIncremental/pr128655/base/A.java">
          </file>
          <file name="tests/multiIncremental/pr128655/base/Foo.java">
          </file>
          <file name="tests/multiIncremental/pr128655/base/T.java">
          </file>
          <file name="tests/multiIncremental/pr128655/inc1/T.java">
          </file>
          <file name="tests/multiIncremental/pr128655_2/base/A.java">
          </file>
          <file name="tests/multiIncremental/pr128655_2/base/Foo.java">
          </file>
          <file name="tests/multiIncremental/pr128655_2/base/T.java">
          </file>
          <file name="tests/multiIncremental/pr128655_2/inc1/T.java">
          </file>
          <file name="tests/src/org/aspectj/systemtest/incremental/tools/AjdeInteractionTestbed.java">
          </file>
          <file name="tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="128744" opendate="2006-02-20 23:38:00" fixdate="2006-02-22 02:50:00">
    <buginformation>
      <summary>LTW doesn't work using JRE1.4 in Eclipse</summary>
      <description>LTW doesn't work using JRE1.4 in Eclipse

now I want to support JRE1.4 when LTW.
I defined a aop.xml file in application META-INF path, it works fine using JRE1.4 in command-line, aop.xml file is used when LTW, the command as below:

"D:\work\BTM\eclipse 3.1.1\eclipse-SDK-3.1.1-win32\eclipse-1.4.2\jre\bin\java" -classpath "C:\aspectj1.5\lib\aspectjweaver.jar" "-Djava.system.class.loader=org.aspectj.weaver.loadtime.WeavingURLClassLoader" "-Daj.class.path=D:\work\BTM\eclipse 3.1.1\jre1.4.2\myTest;C:\aspectj1.5\doc\examples\armtest\jar\btm-deps-e3.1.jar;C:\aspectj1.5\doc\examples\armtest\jar\btm-rt.jar" Hello


but it doesn't work in Eclipse, I added upper command to VM arguments, it can't find aop.xml, because if I changed aop.xml to be wrong, there is no any error when execute the application in Eclipse , but there will be error when execute it in command-line, based on this point, I think that aop.xml didn't be used in Eclipse, I also tried to add "-Daj.aspect.path=D:\work\BTM\eclipse 3.1.1\jre1.4.2\myTest", but it is still. so I want to confirm if AspectJ only supports command-line for JRE1.4? doesn't support Eclipse for JRE1.4?

BTW, my Eclipse env: eclipse 3.1.1 + ajdt_1.3_for_eclipse_3.1 + Sun JDK 1.4.2.
I also tried to use eclipse 3.1.2, but this problem is still existed.</description>
      <comments>
		<comment id="1" date="2006-02-21 05:31:29 EST" author="liu wen zhong">Created attachment 35059 [details]
my test application

the attached file Test.jar(only 3KB) is my test application, which includes four files: Hello.java, World.aj, run.bat and aop.xml in META-INF, Hello.java only prints "Hello", and World.aj and aop.xml will print "World". if I execute run.bat, there will print "Hello" and "World". but I run the class Hello in Eclipse, there is only print "Hello". snapshot.doc is my executed result in my env, you can refer to it.</comment>
		<comment id="2" date="2006-02-21 05:34:04 EST" author="liu wen zhong">Created attachment 35060 [details]
executed result snapshot</comment>
		<comment id="3" date="2006-02-21 09:18:44 EST" author="Sian January">I think you just need to adjust your launch configuration slightly.  Could you try this one that I'm about to attach?  Put it in your project and then right click &gt; Run As &gt; Run.. and select "Hello".</comment>
		<comment id="4" date="2006-02-21 09:19:34 EST" author="Sian January">Created attachment 35067 [details]
Launch configuration</comment>
		<comment id="5" date="2006-02-22 02:50:37 EST" author="liu wen zhong">Based on you attached file , I fixed this problem, the cause is to must add aspectjweaver.jar to User Entries even if already added it to Java Build Path, and remove current project in User Entries in run Classpath tab,  Thanks for you helps</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="7a2087ef985e8af73045bac1e7e0195bb87c7f40" author="aclement" date="2006-02-22 12:52:36"/>
          <file name="loadtime/src/org/aspectj/weaver/loadtime/ConcreteAspectCodeGen.java">
              <method name="validate" returnType="boolean" parameters=""/>
          </file>
          <file name="tests/bugs151/pr128744/Hello.java">
          </file>
          <file name="tests/bugs151/pr128744/World.java">
          </file>
          <file name="tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="122742" opendate="2006-1-5 6:31:00" fixdate="2006-2-22 4:03:00">
    <buginformation>
      <summary>[@AspectJ] VerifyError with @AfterThrowing/@AfterReturning and extra JoinPoint argument</summary>
      <description>If an @AspectJ aspect advises itself using after throwing advice that itself throws an exception running the resulting program causes a VerifyError:

java.lang.VerifyError: (class: A, method: stop signature: ()V) catch_type not a subclass of Throwable
	at java.lang.Class.getDeclaredMethods0(Native Method)
	at java.lang.Class.privateGetDeclaredMethods(Class.java:2365)
	at java.lang.Class.getMethod0(Class.java:2611)
	at java.lang.Class.getMethod(Class.java:1579)
	at org.aspectj.tools.ajc.AjcTestCase.run(AjcTestCase.java:608)
	at org.aspectj.testing.RunSpec.execute(RunSpec.java:56)
	at org.aspectj.testing.AjcTest.runTest(AjcTest.java:68)
	at org.aspectj.testing.XMLBasedAjcTestCase.runTest(XMLBasedAjcTestCase.java:111)
	at org.aspectj.systemtest.ajc150.Ajc150Tests.testError(Ajc150Tests.java:877)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:585)
	at junit.framework.TestCase.runTest(TestCase.java:154)
	at junit.framework.TestCase.runBare(TestCase.java:127)
	at junit.framework.TestResult$1.protect(TestResult.java:106)
	at junit.framework.TestResult.runProtected(TestResult.java:124)
	at junit.framework.TestResult.run(TestResult.java:109)
	at junit.framework.TestCase.run(TestCase.java:118)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:478)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:344)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196)</description>
      <comments>
		<comment id="1" date="2006-01-05 06:41:03 EST" author="Matthew Webster">Created attachment 32514 [details]
Testcase</comment>
		<comment id="2" date="2006-02-17 09:21:01 EST" author="Helen Beeken">I'm not sure this verify error only occurs when the @AfterReturning advice affects itself that throws an exception. I think it's to do with the extra JoinPoint argument in the list of method args. I've been able to reproduce the problem by running the following:

---------------------------------------------------------------------------

import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.annotation.AfterThrowing;
import org.aspectj.lang.annotation.Aspect;

@Aspect
public class A {
 
 public static void main(String[] args) {
  try {
   new B().start();
  } catch (Exception e) {
   e.printStackTrace();
  }
 }
 
 @AfterThrowing(pointcut = "execution(public void B.start())", throwing = "ex")
 public void handleException(JoinPoint jp, Exception ex) { 
 }

}

class B implements I {
 public void start() throws Exception {
  throw new IllegalArgumentException();
 } 
}

interface I {
 public void start() throws Exception;
}

---------------------------------------------------------------------------------------------------

Changing the @AfterThrowing advice to:

 @AfterThrowing(pointcut = "execution(public void B.start())", throwing = "ex")
 public void handleException(Exception ex) { 
 }

and then rerunning does not result in a verify error.

Looking at the output from decompiling B when there is a verify error, the Exception table for the start() method has 

  Exception table:
   from   to  target type
     9    17    17   Class org/aspectj/lang/JoinPoint

which would result in a verify error saying that the type isn't a subclass of Throwable.</comment>
		<comment id="3" date="2006-02-17 09:30:22 EST" author="Helen Beeken">Created attachment 34912 [details]
patch containing failing testcase

Apply to the tests project.

Testcase mentioned in previous comment.</comment>
		<comment id="4" date="2006-02-20 05:23:21 EST" author="Helen Beeken">The problem is that Advice.getExtraParameterType() returns the UnresolvedType corresponding to the first argument, so in the example aspect this is org.aspectj.lang.JoinPoint. The fix is to make allowances for the extra parameter corresponding to JoinPoint in the case of annotation style aspects.

Advice.getExtraParameterType() is used in the processing of the extra parameter both for after throwing and after returning advice. Currently if used with the following advice:

@AfterReturning(pointcut = "execution(public B1 B1.start())", returning = "r")
public void afterJP(JoinPoint jp, B1 r) {
     r.stop();
}

it results in a verify error of the form:

Exception in thread "main" java.lang.VerifyError: (class: B1, method: start signature: ()LB1;) Incompatible argument to function at A1.main(A1.java:9)</comment>
		<comment id="5" date="2006-02-20 05:26:36 EST" author="Helen Beeken">Created attachment 34995 [details]
patch containing failing testcase for @AfterThrowing and @AfterReturning

Apply this patch to the tests project.

This patch replaces the previously attached one as it improves on the tests for @AfterThrowing and adds tests for @AfterReturning.</comment>
		<comment id="6" date="2006-02-20 05:36:29 EST" author="Helen Beeken">Created attachment 34996 [details]
patch containing proposed fix

Apply to the weaver project.

Patch containing proposed fix mentioned above.</comment>
		<comment id="7" date="2006-02-21 11:11:39 EST" author="Andrew Clement">fix committed.</comment>
		<comment id="8" date="2006-02-22 04:03:15 EST" author="Andrew Clement">fix available.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="3fa1bddb79a5e20a38cb39555e932df46f3d4dfa" author="aclement" date="2006-02-22 01:13:44"/>
          <file name="tests/bugs151/pr122742/AfterReturningTest.java">
          </file>
          <file name="tests/bugs151/pr122742/AfterThrowingTest.java">
          </file>
          <file name="tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java">
              <method name="testSwallowedException" returnType="void" parameters=""/>
          </file>
          <file name="weaver/src/org/aspectj/weaver/Advice.java">
              <method name="getExtraParameterType" returnType="UnresolvedType" parameters=""/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="128618" opendate="2006-2-20 6:36:00" fixdate="2006-2-22 4:03:00">
    <buginformation>
      <summary>[incremental] XLint warnings in the wrong place with incremental compilation</summary>
      <description>The zip file I am about to attach contains two AspectJ  project, one depending on the other.  If you make a small change to MainClass.java in 'Test Project' and save you will see a strange warning in that class - "advice defined in ras.FFDC has not been applied [Xlint:adviceDidNotMatch]".  If you do a full build the warning goes away.  Note that the error would be on line 36 if there were 36 lines in the class, which relates to a line in the FFDC aspect that contains advice.</description>
      <comments>
		<comment id="1" date="2006-02-20 06:37:14 EST" author="Sian January">Created attachment 34998 [details]
Test projects</comment>
		<comment id="2" date="2006-02-20 09:11:19 EST" author="Sian January">Note that this is only reproducible with a 1.5 JRE and a 5.0 compliance setting on both projects because the XLint warning is 5.0 specific.</comment>
		<comment id="3" date="2006-02-20 09:34:15 EST" author="Helen Beeken">Looking at the warning message it's saying:

message: advice defined in ras.FFDC has not been applied [Xlint:adviceDidNotMatch]
resource: MainClass.java 
line: 45 

There is already a warning with exactly the same message and line number against the SubFFDCAspect. When you do a full build it realises this. The problem with the incremental build is that it's placing the warning against the wrong resource. The warning marker is appearing at the top of the file because there aren't 45 lines in the MainClass.java file.</comment>
		<comment id="4" date="2006-02-20 11:19:55 EST" author="Helen Beeken">After more investigation on two even smaller projects this is what I see happening:

test setup
----------

* aj project pr128618_1 containing abstract FFDC aspect (ras.FFDC.aj) with an abstract pointcut and some before advice using the pointcut.
* aj project pr128618_2 depending on pr128618_1. This contains ras.concrete.SubFFDCAspect.aj which extends ras.FFDC and provides a concrete version of the abstract pointcut. There is also a mainpackage.MainClass which has some methods in it which aren't going to be matched by the advice in ras.FFDC

After full build
----------------

This results in an adviceDidNotMatch message of the form "advice defined in ras.FFDC has not been applied". This has the line number corresponding to the before advice in ras.FFDC, however is marked against resource SubFFDCAspect.aj. When viewed in AJDT this is clearly wrong since the warning icon is against an empty line.

After incremental build (resulting in making a change in MainClass)
-----------------------

This results in a new adviceDidNotMatch warning with the same message and line number. However, this time it is marked against resource MainClass. Again this is clearly wrong when viewed in AJDT.



What I think is happening is that the warnings are being marked against the last CompilationUnitResult. In the case of the incremental build, the only thing which is being built is the MainClass which is why the warning is marked against that. Similarly in the full build case it is the SubFFDCAspect which is the CompilationUnitResult. Therefore, my previous comment is wrong (comment #3) in that the resource shouldn't be SubFFDCAspect it should be the ras.FFDC aspect. This is also not strictly an incremental bug since if we can get it to use the correct resource on the full build it should be able to on the incremental one.

As a further note - if everything is in the same project then the warning is marked against the ras.FFDC aspect. Interestingly though, if you make similar changes to the MainClass to force an incremental build, you get duplicate adviceDidNotMatch messages in the problems view. This duplication should not happen.</comment>
		<comment id="5" date="2006-02-20 11:31:42 EST" author="Helen Beeken">Created attachment 35013 [details]
failing testcase

Apply this patch to the tests project.

This patch contains a failing MultiProjectIncrementalTest which follows the scenario mentioned in the above comment.</comment>
		<comment id="6" date="2006-02-21 04:21:19 EST" author="Helen Beeken">There have been other bugs opened for different warning messages which show the correct message and line number, just the wrong file - see bug 60015 and bug 62073. In particular, a comment in bug 62073 explains what is happening and why:

"There is an unasserted rule in the message handling code (ours and the JDTs) 
that goes something like this:

If you log an error whilst processing a resource, the primary sourcelocation 
must be in that resource and not in some other resource.  

If you violate this rule you get the bizarre source contexts that this bug 
highlights.  It is a reasonable rule as when we log errors, we record them 
against the compilation result that the source location points to and when we 
have finished processing the resource we ask the infrastructure to 'accept' 
the compilation result and thats when the messages get put out."

It may even be that this bug is covered under bug 62073 which was moved out to be an enhancement to sort out the error handling and fix the unhelpful source locations - to do after the release of 1.5.0 final.</comment>
		<comment id="7" date="2006-02-21 04:41:43 EST" author="Helen Beeken">Actually I think bug 62073 wasn't refering to 1.5.0 final...it was referring to 1.2.0 final :-)</comment>
		<comment id="8" date="2006-02-21 08:39:10 EST" author="Helen Beeken">Created attachment 35065 [details]
patch containing proposed fix

Apply this patch to the org.aspectj.ajdt.core project.

This bug can be fixed in a similar way to the fix for bug 62073. The fix in that case was to check whether the sourceLocation was an EclipseSourceLocation. If so then check whether what we were current weaving was the same as the compilationUnitResult associated with the EclipseSourceLocation. If not, then do less processing with the message. The reason that fix doesn't fix the current bug is that we're not an EclipseSourceLocation. Instead we're a SourceLocation. The fix, however, is a variation on the above. Rather than using the compilationUnitResult (which SourceLocation's don't have) it is possible to check that the filename of what we're currently weaving matches the filename in the SourceLocation. If they're not equal then we do less processing with the message and the warning has the correct resource.</comment>
		<comment id="9" date="2006-02-21 09:22:19 EST" author="Helen Beeken">I believe the duplication issue mentioned at the end of comment #4 is an ajdt bug - I've raised bug 128803 to cover this. </comment>
		<comment id="10" date="2006-02-21 11:05:04 EST" author="Andrew Clement">fix committed.</comment>
		<comment id="11" date="2006-02-22 04:03:40 EST" author="Andrew Clement">fix available.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="89d66dc89110db0f89538a7b78308db61e5539cc" author="aclement" date="2006-02-22 01:07:04"/>
          <file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/WeaverMessageHandler.java">
          </file>
          <file name="tests/multiIncremental/PR128618_2/base/mainpackage/MainClass.java">
          </file>
          <file name="tests/multiIncremental/PR128618_2/inc1/mainpackage/MainClass.java">
          </file>
          <file name="tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java">
              <method name="testPr125405" returnType="void" parameters=""/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="128237" opendate="2006-2-16 11:21:00" fixdate="2006-2-22 4:04:00">
    <buginformation>
      <summary>[@AspectJ] NPE on @AJ code with pointcut which contains logical OR operation.</summary>
      <description>I got NullPointerException during compilation of any @AspectJ code with pointcut which contains logical OR operation.

-----Here is my test case for this bug----------------

import java.io.IOException;

import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Pointcut;

@Aspect
class AbstractTracer 
{
	@Pointcut("(execution(public * Foo+.* (..)) || execution(public * Foo+.blablabla (..)))&amp;&amp; !execution(public Foo+.new (..))")
//	@Pointcut("(execution(public * Foo+.* (..)))&amp;&amp; !execution(public Foo+.new (..))")
	protected void methodCall(){};

	@Pointcut("methodCall()&amp;&amp; this(obj)")
	private void objectCall(Object obj) {
	};

	@Around("objectCall(obj)")
	public Object aroundMethodCall(ProceedingJoinPoint thisJoinPoint,
			Object obj) throws Throwable {
		System.out.println("Before "+thisJoinPoint.getSignature().toString());
		if ( thisJoinPoint.getSignature().toString().indexOf("A")!= -1)
		{
			throw new IOException("Hello from Aspect!");
//			throw new Exception("Hello from Aspect!");
		}
		Object result = thisJoinPoint.proceed();
		System.out.println("After "+thisJoinPoint.getSignature().toString());
		return result;
	}

}


public class Foo {
	public void methodA() throws IOException {
		throw new IOException("Foo.methodA");
	}

	public void methodB(boolean b) throws Exception
	{
		if ( b )
		{
			throw new Exception("Foo.methodB");
		}
	}
	/**
	 * @param args
	 */
	public static void main(String[] args) {
		Foo obj = new Foo();
		try
		{
			obj.methodA();
			System.out.println("Something going wrong!");
		}
		catch ( IOException e)
		{
			System.out.println("All right! We got exception");
			e.printStackTrace(System.out);
		}
		try
		{
			obj.methodB(false);
			System.out.println("All right!");
		}
		catch ( Exception e)
		{
			System.out.println("Something going wrong! We got exception");
			e.printStackTrace(System.out);
		}
		
	}

}

------------------------------------------------------

and here is acj error log
------------------------------------------------------
---- AspectJ Properties ---
AspectJ Compiler 1.5.0 built on Tuesday Dec 20, 2005 at 12:05:54 GMT
---- Dump Properties ---
Dump file: ajcore.20060216.175147.608.txt
Dump reason: java.lang.NullPointerException
Dump on exception: true
Dump at exit condition: abort
---- Exception Information ---
java.lang.NullPointerException
	at org.aspectj.weaver.bcel.BcelWeaver.validateOrBranch(BcelWeaver.java:611)
	at org.aspectj.weaver.bcel.BcelWeaver.validateBindings(BcelWeaver.java:579)
	at org.aspectj.weaver.bcel.BcelWeaver.rewritePointcuts(BcelWeaver.java:511)
	at org.aspectj.weaver.bcel.BcelWeaver.prepareForWeave(BcelWeaver.java:449)
	at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave(AjCompilerAdapter.java:283)
	at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling(AjCompilerAdapter.java:178)
	at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$afterReturning$org_aspectj_ajdt_internal_compiler_CompilerAdapter$2$f9cc9ca0(CompilerAdapter.aj:70)
	at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:367)
	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:811)
	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:230)
	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:156)
	at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:112)
	at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:60)
	at org.aspectj.tools.ajc.Main.run(Main.java:326)
	at org.aspectj.tools.ajc.Main.runMain(Main.java:240)
	at org.aspectj.tools.ajc.Main.main(Main.java:83)
---- System Properties ---
java.runtime.name=Java(TM) 2 Runtime Environment, Standard Edition
sun.boot.library.path=/opt/Java/jdk1.5.0_04/jre/lib/i386
java.vm.version=1.5.0_04-b05
java.vm.vendor=Sun Microsystems Inc.
java.vendor.url=http://java.sun.com/
path.separator=:
java.vm.name=Java HotSpot(TM) Client VM
file.encoding.pkg=sun.io
user.country=RU
sun.os.patch.level=unknown
java.vm.specification.name=Java Virtual Machine Specification
user.dir=/home/kei/ajdt-workspace/AspectJTests
java.runtime.version=1.5.0_04-b05
java.awt.graphicsenv=sun.awt.X11GraphicsEnvironment
java.endorsed.dirs=/opt/Java/jdk1.5.0_04/jre/lib/endorsed
os.arch=i386
java.io.tmpdir=/tmp
line.separator=

java.vm.specification.vendor=Sun Microsystems Inc.
os.name=Linux
sun.jnu.encoding=UTF-8
java.library.path=/opt/Java/jdk1.5.0_04/jre/lib/i386/client:/opt/Java/jdk1.5.0_04/jre/lib/i386:/opt/Java/jdk1.5.0_04/jre/../lib/i386:.:
java.specification.name=Java Platform API Specification
java.class.version=49.0
sun.management.compiler=HotSpot Client Compiler
os.version=2.6.15-1.1831_FC4
user.home=/home/kei
user.timezone=Europe/Kiev
java.awt.printerjob=sun.print.PSPrinterJob
file.encoding=UTF-8
java.specification.version=1.5
java.class.path=components/aspectjweaver.jar:components/aspectjtools.jar:components/aspectjrt.jar:components/aspectjlib.jar:/build/auroratest.jar:/opt/Java/aspectj1.5/lib/aspectjtools.jar:/opt/Java/jdk1.5.0_04/lib/tools.jar
user.name=kei
java.vm.specification.version=1.0
java.home=/opt/Java/jdk1.5.0_04/jre
sun.arch.data.model=32
user.language=ru
java.specification.vendor=Sun Microsystems Inc.
java.vm.info=mixed mode, sharing
java.version=1.5.0_04
java.ext.dirs=/opt/Java/jdk1.5.0_04/jre/lib/ext
sun.boot.class.path=/opt/Java/jdk1.5.0_04/jre/lib/rt.jar:/opt/Java/jdk1.5.0_04/jre/lib/i18n.jar:/opt/Java/jdk1.5.0_04/jre/lib/sunrsasign.jar:/opt/Java/jdk1.5.0_04/jre/lib/jsse.jar:/opt/Java/jdk1.5.0_04/jre/lib/jce.jar:/opt/Java/jdk1.5.0_04/jre/lib/charsets.jar:/opt/Java/jdk1.5.0_04/jre/classes
java.vendor=Sun Microsystems Inc.
file.separator=/
java.vendor.url.bug=http://java.sun.com/cgi-bin/bugreport.cgi
sun.io.unicode.encoding=UnicodeLittle
sun.cpu.endian=little
sun.cpu.isalist=
---- Command Line ---
-1.5
Foo.java
---- Full Classpath ---
/opt/Java/jdk1.5.0_04/jre/lib/rt.jar(39713589 bytes)
/opt/Java/jdk1.5.0_04/jre/lib/i18n.jar(missing)
/opt/Java/jdk1.5.0_04/jre/lib/sunrsasign.jar(missing)
/opt/Java/jdk1.5.0_04/jre/lib/jsse.jar(549315 bytes)
/opt/Java/jdk1.5.0_04/jre/lib/jce.jar(81799 bytes)
/opt/Java/jdk1.5.0_04/jre/lib/charsets.jar(8627836 bytes)
/opt/Java/jdk1.5.0_04/jre/classes(missing)
/opt/Java/jdk1.5.0_04/jre/lib/ext/localedata.jar(802502 bytes)
/opt/Java/jdk1.5.0_04/jre/lib/ext/sunpkcs11.jar(175414 bytes)
/opt/Java/jdk1.5.0_04/jre/lib/ext/dnsns.jar(8176 bytes)
/opt/Java/jdk1.5.0_04/jre/lib/ext/sunjce_provider.jar(153235 bytes)
/opt/Java/jdk1.5.0_04/jre/lib/ext/bctsp-jdk15-129.jar(38357 bytes)
/opt/Java/jdk1.5.0_04/jre/lib/ext/bcprov-jdk15-129.jar(1168795 bytes)
/opt/Java/jdk1.5.0_04/jre/lib/ext/j3daudio.jar(1386793 bytes)
/opt/Java/jdk1.5.0_04/jre/lib/ext/bcmail-jdk15-129.jar(124831 bytes)
/opt/Java/jdk1.5.0_04/jre/lib/ext/j3dcore.jar(2514820 bytes)
/opt/Java/jdk1.5.0_04/jre/lib/ext/j3dutils.jar(1401997 bytes)
/opt/Java/jdk1.5.0_04/jre/lib/ext/vecmath.jar(290018 bytes)
/opt/Java/jdk1.5.0_04/jre/lib/ext/bcprov-jdk14-129.jar(1157625 bytes)
/opt/Java/jdk1.5.0_04/jre/lib/ext/bcmail-jdk14-129.jar(126679 bytes)
/home/kei/ajdt-workspace/AspectJTests/components/aspectjweaver.jar(1746917 bytes)
/home/kei/ajdt-workspace/AspectJTests/components/aspectjrt.jar(108647 bytes)
/home/kei/ajdt-workspace/AspectJTests/components/aspectjlib.jar(7845 bytes)
/build/auroratest.jar(missing)
/opt/Java/jdk1.5.0_04/lib/tools.jar(7015499 bytes)
/opt/Java/jdk1.5.0_04/jre/lib/ext/localedata.jar(802502 bytes)
/opt/Java/jdk1.5.0_04/jre/lib/ext/sunpkcs11.jar(175414 bytes)
/opt/Java/jdk1.5.0_04/jre/lib/ext/dnsns.jar(8176 bytes)
/opt/Java/jdk1.5.0_04/jre/lib/ext/sunjce_provider.jar(153235 bytes)
/opt/Java/jdk1.5.0_04/jre/lib/ext/bctsp-jdk15-129.jar(38357 bytes)
/opt/Java/jdk1.5.0_04/jre/lib/ext/bcprov-jdk15-129.jar(1168795 bytes)
/opt/Java/jdk1.5.0_04/jre/lib/ext/j3daudio.jar(1386793 bytes)
/opt/Java/jdk1.5.0_04/jre/lib/ext/bcmail-jdk15-129.jar(124831 bytes)
/opt/Java/jdk1.5.0_04/jre/lib/ext/j3dcore.jar(2514820 bytes)
/opt/Java/jdk1.5.0_04/jre/lib/ext/j3dutils.jar(1401997 bytes)
/opt/Java/jdk1.5.0_04/jre/lib/ext/vecmath.jar(290018 bytes)
/opt/Java/jdk1.5.0_04/jre/lib/ext/bcprov-jdk14-129.jar(1157625 bytes)
/opt/Java/jdk1.5.0_04/jre/lib/ext/bcmail-jdk14-129.jar(126679 bytes)
/home/kei/ajdt-workspace/AspectJTests/components/aspectjweaver.jar(1746917 bytes)
/home/kei/ajdt-workspace/AspectJTests/components/aspectjrt.jar(108647 bytes)
/home/kei/ajdt-workspace/AspectJTests/components/aspectjlib.jar(7845 bytes)
/build/auroratest.jar(missing)
/opt/Java/jdk1.5.0_04/lib/tools.jar(7015499 bytes)
---- Compiler Messages ---
abort ABORT -- (NullPointerException) null
null
java.lang.NullPointerException
	at org.aspectj.weaver.bcel.BcelWeaver.validateOrBranch(BcelWeaver.java:611)
	at org.aspectj.weaver.bcel.BcelWeaver.validateBindings(BcelWeaver.java:579)
	at org.aspectj.weaver.bcel.BcelWeaver.rewritePointcuts(BcelWeaver.java:511)
	at org.aspectj.weaver.bcel.BcelWeaver.prepareForWeave(BcelWeaver.java:449)
	at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave(AjCompilerAdapter.java:283)
	at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling(AjCompilerAdapter.java:178)
	at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$afterReturning$org_aspectj_ajdt_internal_compiler_CompilerAdapter$2$f9cc9ca0(CompilerAdapter.aj:70)
	at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:367)
	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:811)
	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:230)
	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:156)
	at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:112)
	at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:60)
	at org.aspectj.tools.ajc.Main.run(Main.java:326)
	at org.aspectj.tools.ajc.Main.runMain(Main.java:240)
	at org.aspectj.tools.ajc.Main.main(Main.java:83)

---- org.aspectj.weaver.bcel.BcelWorld ----
Shadow mungers:
(around(extraFlags: 2): (persingleton(AbstractTracer) &amp;&amp; (((execution(public * Foo+.*(..)) || execution(public * Foo+.blablabla(..))) &amp;&amp; !execution(public Foo+.new(..))) &amp;&amp; this(BindingTypePattern(java.lang.Object, 1))))-&gt;java.lang.Object AbstractTracer.aroundMethodCall(org.aspectj.lang.ProceedingJoinPoint, java.lang.Object))
Type mungers:
(BcelTypeMunger null)
(BcelTypeMunger ResolvedTypeMunger(PrivilegedAccess, void java.lang.Object.()))
Late Type mungers:
(BcelTypeMunger null)
------------------------------------------------------------------

I got same error with latest (aspectj-DEVELOPMENT-20060216105006) night build.</description>
      <comments>
		<comment id="1" date="2006-02-17 05:15:23 EST" author="Helen Beeken">For this bug to materialize we require the following:

* a pointcut of the form "(pc1 || pc2) &amp;&amp; this(Type)" where pc1 includes a wildcard
* advice which uses the Type in "this" and also has the extra argument required for use of JoinPoint. 

i.e.:

    @Pointcut("(execution(public * Foo.anotherMethod*(..)) || execution(public * 
                Foo.methodA(..))) &amp;&amp; this(obj)")
    protected void methodExec(Object obj){};
        
    @Before("methodExec(obj)")
    public void beforeMethodExec(JoinPoint thisJoinPoint, Object obj) {
       System.out.println("Before " + thisJoinPoint.getSignature().toString());
    }</comment>
		<comment id="2" date="2006-02-17 06:51:52 EST" author="Helen Beeken">Created attachment 34907 [details]
patch containing failing testcase

Apply this patch to the tests project.</comment>
		<comment id="3" date="2006-02-17 06:57:21 EST" author="Helen Beeken">Created attachment 34908 [details]
patch containing proposed fix

Apply to the weaver project.

When rewritten the pointcut becomes

LHS = (execution(public * Foo.anotherMethod*(..)) &amp;&amp; this(BindingTypePattern(java.lang.Object,1))) &amp;&amp; persingleton(AbstractTracer)

RHS = (execution(public * Foo.methodA(..)) &amp;&amp; this(BindingTypePattern(java.lang.Object,1))) &amp;&amp; persingleton(AbstractTracer)

When we come to see if the LHS and RHS could ever match the same join points we return true. If the wildcard isn't there this returns false. Because it's true we then check the name of the binding associated with the LHS with that associated with the RHS. If they're not equal then we add this to the list of ambiguousNames and raise an error. This is where the NPE is coming from because the binding associated with the LHS is null.

The reason we're failing here with the @AJ aspect in comment #1 is the addition of the "thisJoinPoint" in the method signature. When we come to validate the bindings we include this extra argument. Consequently, the array of bindings has 2 entries rather than 1. We find the BindingTypePattern(java.lang.Object,1)) and enter this as the second entry in the array of bindings. However, there aren't any others so the first entry in the array of bindings remains null. This causes the NPE when we ask if it's name is the same as the corresponding entry for the RHS (which is also null).

I think it's reasonable to add a null check here. If the entry in the LHS array of bindings is null then add the corresponding name to the list of ambiguousNames iff the corresponding entry in the RHS array of bindings isn't null. If they're both null then this is ok.</comment>
		<comment id="4" date="2006-02-21 10:55:14 EST" author="Andrew Clement">fix committed.</comment>
		<comment id="5" date="2006-02-22 04:04:23 EST" author="Andrew Clement">fix available</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="ba42a09551519a4b611ab06edb161ecb0c629f53" author="aclement" date="2006-02-22 12:55:33"/>
          <file name="tests/bugs151/pr128237.java">
          </file>
          <file name="tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java">
              <method name="testAtAspectDeclareParentsRetainsFieldState_pr122370" returnType="void" parameters=""/>
          </file>
          <file name="weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java">
              <method name="validateOrBranch" returnType="void" parameters="OrPointcut Pointcut int String[] Pointcut[] Pointcut[]"/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="121616" opendate="2005-12-20 14:58:00" fixdate="2006-3-10 11:16:00">
    <buginformation>
      <summary>[@AspectJ]Lacking import for JoinPoint crahes the compiler</summary>
      <description>Encountered during a JavaPolis demo. I was using a pre-release 
development version. However, reproducable with latest post-release 
development version as well.

Create the following source file:

package banking;

import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Pointcut;

public class Main {
	public static void main(String[] args) {
		System.out.println("Main");
	}
}

@Aspect
class MainLogger {
	@Pointcut("execution(* main(..))")
	public void log(JoinPoint thisJoinPoint) {
		System.out.println("Before " thisJoinPoint");
	}
}

Note that the import statement for JoinPoint is lacking. Compiling this 
source file crahses the compiler. Adding import statement for JoinPoint 
makes it work fine.

C:\work\aop\src\workspace\CallDebugBug&gt;ajc -version
AspectJ Compiler DEVELOPMENT built on Tuesday Dec 20, 2005 at 13:58:29 GMT

C:\work\aop\src\workspace\CallDebugBug&gt;ajc -1.5 banking\Main.java
C:\work\aop\src\workspace\CallDebugBug\banking\Main.java [error] Internal compiler error
java.lang.NullPointerException
        at org.aspectj.ajdt.internal.compiler.ast.ValidateAtAspectJAnnotationsVisitor.buildFormalAdviceBindingsFrom(ValidateAtAspectJAnnotationsVisitor.java:417)
        at org.aspectj.ajdt.internal.compiler.ast.ValidateAtAspectJAnnotationsVisitor.convertToPointcutDeclaration(ValidateAtAspectJAnnotationsVisitor.java:513)
        at org.aspectj.ajdt.internal.compiler.ast.ValidateAtAspectJAnnotationsVisitor.visit(ValidateAtAspectJAnnotationsVisitor.java:188)
        at org.aspectj.org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.traverse(MethodDeclaration.java:185)
        at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.traverse(TypeDeclaration.java:1195)
        at org.aspectj.org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.traverse(CompilationUnitDeclaration.java:339)
        at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.beforeAnalysing(AjCompilerAdapter.java:154)
        at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$before$org_aspectj_ajdt_internal_compiler_CompilerAdapter$7$db78446d(CompilerAdapter.aj:101)
        at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:517)
        at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:329)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:811)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:230)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:156)
        at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:112)
        at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:60)
        at org.aspectj.tools.ajc.Main.run(Main.java:326)
        at org.aspectj.tools.ajc.Main.runMain(Main.java:240)
        at org.aspectj.tools.ajc.Main.main(Main.java:83)

(no source information available)
C:\work\aop\src\workspace\CallDebugBug\banking\Main.java:16 [error] JoinPoint cannot be resolved to a type
public void log(JoinPoint thisJoinPoint) {
                ^^^^^^^
C:\work\aop\src\workspace\CallDebugBug\banking\Main.java:17 [error] Syntax error, insert ")" to complete MethodInvocation
System.out.println("Before " thisJoinPoint");

C:\work\aop\src\workspace\CallDebugBug\banking\Main.java:17 [error] Syntax error, insert ";" to complete BlockStatements
System.out.println("Before " thisJoinPoint");

ABORT

Exception thrown from AspectJ DEVELOPMENT

This might be logged as a bug already -- find current bugs at
  http://bugs.eclipse.org/bugs/buglist.cgi?product=AspectJ&amp;component=Compiler

Bugs for exceptions thrown have titles File:line from the top stack,
e.g., "SomeFile.java:243"

If you don't find the exception below in a bug, please add a new bug
at http://bugs.eclipse.org/bugs/enter_bug.cgi?product=AspectJ
To make the bug a priority, please include a test program
that can reproduce this exception.

when validating @AspectJ annotations log
when analysing types defined in compilation unit C:\work\aop\src\workspace\CallD
ebugBug\banking\Main.java
when processing compilation unit C:\work\aop\src\workspace\CallDebugBug\banking\
Main.java
when batch building with classpath: c:\java\jdk1.5.0_04\jre\lib\ext\dnsns.jar;c:
\java\jdk1.5.0_04\jre\lib\ext\localedata.jar;c:\java\jdk1.5.0_04\jre\lib\ext\sun
jce_provider.jar;c:\java\jdk1.5.0_04\jre\lib\ext\sunpkcs11.jar;c:\java\jdk1.5.0_
04\lib\tools.jar;c:\java\jdk1.5.0_04\jre\lib\rt.jar;C:\java\aspectj\aspectj5\lib
\aspectjrt.jar;C:\java\log4j\jakarta-log4j-1.2.8\dist\lib\log4j-1.2.8.jar;C:\jav
a\jess\Jess61p5\jess.jar;c:\java\j2sdkee1.3.1\lib\system\cloudscape.jar;c:\java\
j2sdkee1.3.1\lib\system\tools.jar;c:\java\j2sdkee1.3.1\lib\cloudscape\RmiJdbc.ja
r;c:\java\j2sdkee1.3.1\lib\cloudscape\cloudclient.jar;c:\java\j2sdkee1.3.1\lib\c
lasses;c:\java\j2sdkee1.3.1\classes;c:\java\j2sdkee1.3.1\lib\j2ee.jar;c:\java\j2
sdkee1.3.1\lib\toolclasses;c:\java\j2sdkee1.3.1\lib\j2eetools.jar;c:\java\j2sdke
e1.3.1\lib\locale;c:\java\j2sdkee1.3.1\lib\j2ee.jar;c:\java\j2sdkee1.3.1\lib\jha
ll.jar;c:\java\j2sdkee1.3.1\lib\locale;c:\java\jdk1.5.0_04\lib\tools.jar;c:\java
\j2sdkee1.3.1\lib\jhall.jar;C:\java\ws\axis\axis-1_1\lib\axis.jar;C:\java\ws\axi
s\axis-1_1\lib\axis-ant.jar;C:\java\ws\axis\axis-1_1\lib\commons-discovery.jar;C
:\java\ws\axis\axis-1_1\lib\commons-logging.jar;C:\java\ws\axis\axis-1_1\lib\jax
rpc.jar;C:\java\ws\axis\axis-1_1\lib\saaj.jar;C:\java\ws\axis\axis-1_1\lib\log4j
-1.2.8.jar;C:\java\ws\axis\axis-1_1\lib\wsdl4j.jar;C:\java\concurrency\concurren
cy.jar;C:\java\junit\junit3.8.1\junit.jar;.;
null
java.lang.NullPointerException
        at org.aspectj.ajdt.internal.compiler.ast.ValidateAtAspectJAnnotationsVisitor.buildFormalAdviceBindingsFrom(ValidateAtAspectJAnnotationsVisitor.java:417)
        at org.aspectj.ajdt.internal.compiler.ast.ValidateAtAspectJAnnotationsVisitor.convertToPointcutDeclaration(ValidateAtAspectJAnnotationsVisitor.java:513)
        at org.aspectj.ajdt.internal.compiler.ast.ValidateAtAspectJAnnotationsVisitor.visit(ValidateAtAspectJAnnotationsVisitor.java:188)
        at org.aspectj.org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.traverse(MethodDeclaration.java:185)
        at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.traverse(TypeDeclaration.java:1195)
        at org.aspectj.org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.traverse(CompilationUnitDeclaration.java:339)
        at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.beforeAnalysing(AjCompilerAdapter.java:154)
        at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$before$org_aspectj_ajdt_internal_compiler_CompilerAdapter$7$db78446d(CompilerAdapter.aj:101)
        at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:517)
        at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:329)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:811)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:230)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:156)
        at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:112)
        at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:60)
        at org.aspectj.tools.ajc.Main.run(Main.java:326)
        at org.aspectj.tools.ajc.Main.runMain(Main.java:240)
        at org.aspectj.tools.ajc.Main.main(Main.java:83)


1 fail|abort, 4 errors</description>
      <comments>
		<comment id="1" date="2005-12-21 02:13:55 EST" author="Adrian Colyer">That's one for me...</comment>
		<comment id="2" date="2006-02-16 03:54:13 EST" author="Helen Beeken">Created attachment 34833 [details]
zip containing test and fix patches

The attached zip file contains two patches:

* pr121616-org-aspectj-ajdt-core-patch.txt - apply to the org.aspectj.ajdt.core project - contains the proposed fix
* pr121616-tests-patch.txt - apply to the tests project - contains the testcase


The problem is occuring when the only error is the lack of import for JoinPoint. In this case there are no errors marked against any other types and we visit the MethodDeclaration's using a ValidateAtAspectJAnnotationsVisitor. When we come to the MethodDeclaration corresponding to 

public @Before("execution(* main(..))") void log(JoinPoint thisJoinPoint) {
}

we go ahead without checking first whether there are any errors marked against it and then blow up with the NPE. In the case of there not being an import for @Aspect as well as JoinPoint, we don't get this far because the traverse() method in TypeDeclaration has a check first to see if there's an error reported against the typedeclaration (which there is because the import of @Aspect is missing) and if there is it just returns (and hence no NPE). In the case of there just being no import for @Before then everything is ok because no adviceAnnotations or pointcutAnnotations have been added and so we don't enter the code which is causing the NPE. 

Therefore the proposed fix is to add a check for errors at the start of the ValidateAtAspectJAnnotationsVisitor.visit(MethodDeclaration, ClassScope). If there are errors, then just return false.</comment>
		<comment id="3" date="2006-02-16 04:32:24 EST" author="Andrew Clement">fix checked in.</comment>
		<comment id="4" date="2006-03-10 11:16:25 EST" author="Helen Beeken">Closing this bug as fixed as the patch has been integrated into AspectJ. Moreover,  AJDT 1.3.1.20060309111525 for Eclipse 3.1 includes an AspectJ which contains this fix and the next build of AJDT for Eclipse 3.2M5 will also contain the fix.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="d4219e12eaa86ed810392364931a92324dc2a67f" author="aclement" date="2006-02-16 06:33:38"/>
          <file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/ValidateAtAspectJAnnotationsVisitor.java">
          </file>
          <file name="tests/bugs151/pr121616.java">
          </file>
          <file name="tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java">
              <method name="testAtAspectNoNPEWithDEOWWithoutStructureModel_pr120356" returnType="void" parameters=""/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="125699" opendate="2006-1-30 9:54:00" fixdate="2006-02-23 03:12:34">
    <buginformation>
      <summary>[@AspectJ]@Aspect cannot inherit advice using this PCD and thisJoinPoint</summary>
      <description>Inherting the following advice in an @aspect causes an unexpected error.

	before (Object obj) : execution(* *(..)) &amp;&amp; this(obj) {
		System.out.println(thisJoinPoint);
	}

"erre the parameter thisJoinPoint is not bound in [all branches of] pointcut"</description>
      <comments>
		<comment id="1" date="2006-01-30 12:25:38 EST" author="Matthew Webster">Created attachment 33796 [details]
Testcase</comment>
		<comment id="2" date="2006-02-01 11:24:54 EST" author="Helen Beeken">The problem is occuring because the @AJ style includes the thisJoinPoint in the list of things it wants to validate in BcelWeaver.rewritePointcuts(..) for the following piece of advice:

 before (Object obj) : execution(* *(..)) &amp;&amp; this(obj) {
  System.out.println(thisJoinPoint);
 }

After the processing in BcelWeaver.validateSingleBranchRecursion(..) we're left with an extra formal which hasn't been found. There is then a check for the @AJ style which sees if it has been recorded that any unbound bindings should be ignored. This has been put in specifically for the cases like thisJoinPoint. Unfortunately, in the given testcase, this hasn't been set. Therefore, we fall through and throw the unbound formal error.</comment>
		<comment id="3" date="2006-02-03 06:13:56 EST" author="Helen Beeken">Created attachment 34065 [details]
patch containing testcase and possible fix

This zip contains two patches:

* pr125699-tests-patch.txt - apply to the tests project - this patch includes the supplied testcase, as well as adding an extra one where the @AJ style aspect extends an abstract code style aspect, which itself extends an abstract aspect where the advice is defined.
* pr125699-weaver-patch.txt - apply to the weaver project - this patch includes a possible fix.

There are several ways to fix this bug:

1. make sure that when the advice in the code style abstract aspect is being analysed that the AndPointcut (in the case of the provided testcase) has its m_ignoreUnboundBindingForNames set to be thisJoinPoint. If this was set correctly, then the existing logic in BcelWeaver.validateSingleBranch(..) would pick up the fact that we actually want to ignore this and continue without throwing the unbound error.

2. Before making the call to validateBindings within BcelWeaver.rewritePointcuts(..) check whether the Advice was declared in an @AJ style aspect. If it was then thisJoinPoint has already been handled as part of the AtAjAttributes.handleBeforeAnnotation(..) method and has been added to the AndPointcuts m_ignoreUnboundBindingForNames. Consequently, no unbound error is thrown. If it's not, then don't include the extra thisJoinPoint argument and call validateBindings with the same parameters as you would with a code style aspect. This would still catch any legitimate unbound errors since the pointcut is just being validated as though it was in a code style aspect - which it was declared in. 

3. Before making the call to validateBindings within BcelWeaver.rewritePointcuts(..), if we're a code style aspect then check whether one of the extra arguments is thisJoinPoint or one of the varients.

The fix I've put in is (2). This is because the advice was defined in a code style aspect, therefore it seems reasonable to validate the pointcuts as though they were in a code style aspect. Also, adding thisJoinPoint (or its variants) to the list of things to ignore for the AndPointcut would only mean that we ignore it anyway and consequently wouldn't do anything different than validating the pointcuts as though they were in a code style aspect. However, I'm not sure about the other implications of not adding thisJoinPoint etc to the list of things to ignore for the AndPointcut. The comment in the code says that for @AJ style thisJoinPoint presence or not can have side affects - I haven't been able to find out what these are. My other concern is that I check whether the advice is defined in an @AJ style aspect by doing the following:

boolean declaredInAtAJAspect = false;
if (advice.getDeclaringAspect() instanceof ResolvedType) {
        declaredInAtAJAspect = ((ResolvedType)advice.getDeclaringAspect()).isAnnotationStyleAspect();
}

Can it always be guarenteed that advice.getDeclaringAspect() is an instance of ResolvedType? If this instance check is false then the logic I've put in means that the bindings are validated as though this is a code style aspect. This means that any "extra" arguments which have been set are ignored. This could cause an ArrayOutOfBoundsException if the advice is declared in an @AJ style aspect. The question is also, what are the cases for these extra arguments being there and what does this mean later on when the @AJ style aspect uses them. Since this bug is only about validating the bindings, if everything was defined in @AJ style these extra arguments would have been flagged to be ignored so the outcome would be the same. The logic could be moved to after the check for whether or not we're an @AJ style aspect - in which case, if its not an instance of ResolvedType then we call validate the bindings with the extra argument - this would lead to the unbound error reported in this bug if it's not an instance of ResolvedType and the advice has been declared in a code syle aspect.</comment>
		<comment id="4" date="2006-02-16 04:03:09 EST" author="Andrew Clement">I've put in a slight variation of the fix.  It is highly similar to a situation I fixed in BcelShadow, weaveAroundInline, line 2277 which was to do with inheriting advice from a code style aspect and doing the wrong thing.  Helens fix is similar to what I did, but I know how to always ensure I get a ResolvedType which I can query as to whether its a code style aspect.  To go from an UnresolvedType to a ResolvedType, you just have to ask the world to resolve it.

Extra arguments are added to advice signatures in code style if the advice uses the thisJoinPoint or similar constructs - @AJ written code has to specify them directly in the declaration as without them the code would fail type checking under a pure java compiler.

fix checked in.</comment>
		<comment id="5" date="2006-02-23 03:12:34 EST" author="Andrew Clement">fix available.</comment>
		<comment id="6" date="2006-03-16 10:34:40 EST" author="Ron Bodkin">*** Bug 132086 has been marked as a duplicate of this bug. ***</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="1d41626c3d8489acf9a630d9236a9ecdf912363d" author="aclement" date="2006-02-02 12:20:37"/>
          <file name="tests/bugs151/pr125699/AtTestTracing.java">
          </file>
          <file name="tests/bugs151/pr125810/SubAtAspect.java">
          </file>
          <file name="tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="131933" opendate="2006-3-15 9:46:00" fixdate="2006-3-20 11:07:00">
    <buginformation>
      <summary>grotty ClassCastException on referring to pointcut in generic type</summary>
      <description>import java.util.List;

public aspect Slide71 {
	before(): GenericType&lt;String&gt;.foo() {}
	before(): GenericType&lt;MyList&gt;.foo() {}
	//before(): GenericType.foo() {}
}
	
class GenericType&lt;T&gt; {
	public pointcut foo(): execution(* T.*(..));
}

that programs gives:  (because MyList is not a known type)

java.lang.ClassCastException
at org.aspectj.weaver.patterns.TypePattern.resolveExactType(TypePattern.java:193)
at org.aspectj.weaver.patterns.ReferencePointcut.resolveBindings(ReferencePointcut.java:130)
at org.aspectj.weaver.patterns.Pointcut.resolve(Pointcut.java:194)
at org.aspectj.ajdt.internal.compiler.ast.PointcutDesignator.finishResolveTypes(PointcutDesignator.java:84)
at org.aspectj.ajdt.internal.compiler.ast.AdviceDeclaration.resolveStatements(AdviceDeclaration.java:118)
at org.aspectj.org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:400)
at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1088)
at org.aspectj.ajdt.internal.compiler.ast.AspectDeclaration.resolve(AspectDeclaration.java:116)
at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1137)
at org.aspectj.org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:305)
at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:514)
at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:329)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:843)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:268)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.incrementalBuild(AjBuildManager.java:170)
at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:117)
at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)

ClassCastException thrown: org.aspectj.weaver.patterns.WildTypePattern</description>
      <comments>
		<comment id="1" date="2006-03-16 03:59:39 EST" author="Helen Beeken">Created attachment 36393 [details]
patch containing failing testcase

Apply this patch to the tests project.</comment>
		<comment id="2" date="2006-03-16 04:02:16 EST" author="Helen Beeken">Created attachment 36394 [details]
patch containing proposed fix

Apply this patch to the weaver project.

The fix is to return ResolvedType.MISSING if the typePattern isn't an ExactTypePattern. This causes the supplied testcase to produce a compiler error of the form "can't bind type name 'MyList'".</comment>
		<comment id="3" date="2006-03-16 05:59:23 EST" author="Andrew Clement">patches committed.</comment>
		<comment id="4" date="2006-03-20 11:07:22 EST" author="Helen Beeken">Closing as fixed - fix available in latest build.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="f2cd94f88a9976fc98786955a764522a8ccb37f1" author="aclement" date="2006-03-16 08:01:54"/>
          <file name="tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java">
              <method name="testSwallowedExceptionIgnored" returnType="void" parameters=""/>
          </file>
          <file name="weaver/src/org/aspectj/weaver/patterns/TypePattern.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="131932" opendate="2006-3-15 9:45:00" fixdate="2006-3-20 11:10:00">
    <buginformation>
      <summary>structure model bug: generic method ITD</summary>
      <description>import java.util.List;

public aspect Slide74 {

	public X Bar&lt;X&gt;.getFirst() {
		return lts.get(0);
	}
	
	static class Bar&lt;T&gt; {
		List&lt;T&gt; lts;
	}
}

in AJDT, this program incorrectly shows the relationship from the TYPE to the Bar class rather than from the ITD to the Bar class.</description>
      <comments>
		<comment id="1" date="2006-03-16 06:36:49 EST" author="Helen Beeken">The problem is occuring because the ResolvedTypeMunger used when adding the ITD relationships doesn't have a sourcelocation. The sourcelocation of the originating aspect is then used which is why the arrows appear against the type rather than the itd.

The reason this is happening is the call to ResolvedType.fillInAnyTypeParameters(munger) during the weaving process. Within this method we replace munger with the value of munger.parameterizedFor(actualTarget). At this point, munger is a BcelTypeMunger whose parameterizedFor(..) method returns a new BcelTypeMunger whose own munger is calculated via the NewMethodTypeMunger.parameterizeFor(..) method. This creates a new NewMethodTypeMunger with the correct signature, however, doesn't set the sourcelocation. The constructor for the BcelTypeMunger doesn't do anything with sourcelocations (unlike the EclipseTypeMunger which we are the first time we do all this) and so the sourcelocation remains null. The fix is to set the sourcelocation before returning from NewMethodTypeMunger.parameterizeFor(..).</comment>
		<comment id="2" date="2006-03-16 06:38:10 EST" author="Helen Beeken">Created attachment 36400 [details]
patch containing failing testcase

Apply this patch to the tests project.</comment>
		<comment id="3" date="2006-03-16 06:38:55 EST" author="Helen Beeken">Created attachment 36401 [details]
patch containing fix

Apply this patch to the weaver project.

Contains the fix described in previous comment.</comment>
		<comment id="4" date="2006-03-16 06:47:17 EST" author="Helen Beeken">Note that this is probably also going to happen for the other types of itds....this too needs fixing in the same way.</comment>
		<comment id="5" date="2006-03-16 08:27:25 EST" author="Helen Beeken">Created attachment 36404 [details]
failing testcase patch

Apply this patch to the tests project.

This testcase tests method, constructor and field itds...it's a little large :-(</comment>
		<comment id="6" date="2006-03-16 08:28:15 EST" author="Helen Beeken">Created attachment 36405 [details]
patch containing fix

apply this patch to the weaver project.

This patch fixes the method,constructor and field itd cases.</comment>
		<comment id="7" date="2006-03-16 10:32:17 EST" author="Andrew Clement">fixes checked in.</comment>
		<comment id="8" date="2006-03-20 11:10:44 EST" author="Helen Beeken">Closing as fixed - fixes available in latest aspectj build. Will soon be in AJDT.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="e2703cf67fe6c68cc0e91aecdbfa4e07e51c6fc7" author="aclement" date="2006-03-17 12:34:26"/>
          <file name="tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/NewConstructorTypeMunger.java">
              <method name="parameterizedFor" returnType="ResolvedTypeMunger" parameters="ResolvedType"/>
          </file>
          <file name="weaver/src/org/aspectj/weaver/NewFieldTypeMunger.java">
              <method name="parameterizedFor" returnType="ResolvedTypeMunger" parameters="ResolvedType"/>
          </file>
          <file name="weaver/src/org/aspectj/weaver/NewMethodTypeMunger.java">
              <method name="parameterizedFor" returnType="ResolvedTypeMunger" parameters="ResolvedType"/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="132130" opendate="2006-3-16 6:24:00" fixdate="2006-3-20 11:14:00">
    <buginformation>
      <summary>Missing relationship for declare @method when annotating a co-located method</summary>
      <description>For this program (when all entered into *one* file) I don't see a marker from the declare to the annotated method.  If the annotated method is in another file, I do... (not sure if fields/ctors/types are also a problem..)

public aspect basic {

        declare @method:
                 * debit(..):
                 @Secured(role="supervisor");

}

class BankAccount {
        public void debit(long accId,long amount) {
        }
}

@interface Secured {
        String role();
}</description>
      <comments>
		<comment id="1" date="2006-03-17 04:33:51 EST" author="Helen Beeken">I'm seeing the reported behaviour both when everything is in one file and when the annotated method is in a different file. The reason it's failing is that when we come to add the declare annotation relationship we look for the IProgramElement with signature "debit(long,long)". Unfortunately, the IProgramElement corresponding to the debit method has signature "debit(long, long)". Therefore we fail quietly because we can't find the method.</comment>
		<comment id="2" date="2006-03-17 05:25:55 EST" author="Helen Beeken">Due to the way the previous comment was formatted, the difference didn't show up :-( To emphasise...we look for

debug(long,long)
          ^

whereas the ipe has signature:


debug(long, long)
           ^</comment>
		<comment id="3" date="2006-03-17 08:24:15 EST" author="Helen Beeken">Note this isn't a problem with fields, types or constructors, just methods. The reason for this:

fields: we use field.getName() for the signature to look for
types: we dont use signatures
constructors: the signatures of these don't have the extra space in them

The fix is to make the comparison within AspectJElementHierarchy more robust by stripping out the extra spaces before we check for string equality.</comment>
		<comment id="4" date="2006-03-17 08:24:48 EST" author="Helen Beeken">Created attachment 36479 [details]
testcase patch

Apply to the tests project.</comment>
		<comment id="5" date="2006-03-17 08:25:26 EST" author="Helen Beeken">Created attachment 36480 [details]
patch containing fix

Apply this patch to the asm project.</comment>
		<comment id="6" date="2006-03-17 08:27:12 EST" author="Helen Beeken">Created attachment 36481 [details]
testcase patch without dumping structure model

Apply this patch to the tests project</comment>
		<comment id="7" date="2006-03-17 11:48:34 EST" author="Andrew Clement">testcase committed - and I reworked the fix a bit.  I changed it to ensure the signature for programelements doesnt have a space (methods now match ctors in this respect).  This makes things consistent and avoids any string processing (removing spaces) when looking through the programelements.  It does mean I had to change a couple of test programs that had the space in...</comment>
		<comment id="8" date="2006-03-20 11:14:37 EST" author="Helen Beeken">Closing as fixed - fix available in latest aspectj dev build.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="9dca72e7c63a5623f3d442bf43bb88810368a65a" author="aclement" date="2006-03-18 01:47:06"/>
          <file name="ajde/testsrc/org/aspectj/ajde/AsmDeclarationsTest.java">
              <method name="testInterTypeMemberDeclares" returnType="void" parameters=""/>
          </file>
          <file name="ajde/testsrc/org/aspectj/ajde/AsmRelationshipsTest.java">
              <method name="testInterTypeDeclarations" returnType="void" parameters=""/>
          </file>
          <file name="ajdoc/testsrc/org/aspectj/tools/ajdoc/CoverageTestCase.java">
              <method name="testAdviceNamingCoverage" returnType="void" parameters=""/>
          </file>
          <file name="asm/src/org/aspectj/asm/internal/ProgramElement.java">
              <method name="toSignatureString" returnType="String" parameters="boolean"/>
          </file>
          <file name="tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java">
              <method name="testIProgramElementMethods_pr125295" returnType="void" parameters=""/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="129566" opendate="2006-2-27 8:43:00" fixdate="2006-3-20 11:15:00">
    <buginformation>
      <summary>ArrayIndexOutOfBoundsException with regular Java class</summary>
      <description>After "upgrading" to eclipse 3.2M5a and AJDT 20060224163227 I repeatedly get the following stack trace on a regular Java class:

java.lang.ArrayIndexOutOfBoundsException
at org.aspectj.weaver.ReferenceType.determineThoseTypesToUse(ReferenceType.java:465)
at org.aspectj.weaver.ReferenceType.getDeclaredInterfaces(ReferenceType.java:411)
at org.aspectj.weaver.bcel.BcelWeaver.weaveParentsFor(BcelWeaver.java:1199)
at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1047)
at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave(AjCompilerAdapter.java:300)
at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling(AjCompilerAdapter.java:178)
at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$afterReturning$org_aspectj_ajdt_internal_compiler_CompilerAdapter$2$f9cc9ca0(CompilerAdapter.aj:70)
at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:367)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:824)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:234)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:157)
at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:122)
at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)

ArrayIndexOutOfBoundsException thrown: -1

This happens even when the class is the only file in a fresh project (without any aspects!); existing AJ projects work fine as soon as this class is excluded from the build path. When the class is moved into a different project and referenced as dependency everything works as expected.
This used to work fine with previous versions of AJDT up to the last release for eclipse 3.1.</description>
      <comments>
		<comment id="1" date="2006-02-27 08:45:20 EST" author="Holger HoffstÃ¤tte">Created attachment 35403 [details]
eclipse project demonstrating the AIOOB

small eclipse project with a single Java class that causes AJDT to hiccup. The class works fine otherwise.</comment>
		<comment id="2" date="2006-02-28 10:23:06 EST" author="Matt Chapman">Reproduced on the command line:
ajc -1.5 common/SkipList.java
ABORT

Exception thrown from AspectJ DEVELOPMENT

This might be logged as a bug already -- find current bugs at
  http://bugs.eclipse.org/bugs/buglist.cgi?product=AspectJ&amp;component=Compiler

Bugs for exceptions thrown have titles File:line from the top stack,
e.g., "SomeFile.java:243"

If you don't find the exception below in a bug, please add a new bug
at http://bugs.eclipse.org/bugs/enter_bug.cgi?product=AspectJ
To make the bug a priority, please include a test program
that can reproduce this exception.
-1

when processing type mungers
when weaving
when batch building BuildConfig[null] #Files=1
-1
java.lang.ArrayIndexOutOfBoundsException: -1
        at org.aspectj.weaver.ReferenceType.determineThoseTypesToUse(ReferenceType.java:473)
        at org.aspectj.weaver.ReferenceType.getDeclaredInterfaces(ReferenceType.java:419)
        at org.aspectj.weaver.bcel.BcelWeaver.weaveParentsFor(BcelWeaver.java:1215)
        at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1058)
        at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave(AjCompilerAdapter.java:312)
        at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling(AjCompilerAdapter.java:184)
        at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$afterReturning$org_aspectj_ajdt_internal_compiler_CompilerAdapter$2$f9cc9ca0(CompilerAdapter.aj:70)
        at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:367)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:843)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:243)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:163)
        at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:112)
        at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:60)
        at org.aspectj.tools.ajc.Main.run(Main.java:356)
        at org.aspectj.tools.ajc.Main.runMain(Main.java:246)
        at org.aspectj.tools.ajc.Main.main(Main.java:86)


1 fail|abort

ajc -version:
AspectJ Compiler DEVELOPMENT built on Friday Feb 24, 2006 at 17:44:57 GMT</comment>
		<comment id="3" date="2006-02-28 12:31:52 EST" author="Andrew Clement">I think it used to work 'by accident' - and improvements to generics handling are now causing the attached source code to expose a bug.  The problem is with the reference to T.

We have the generic type:

public class SkipList&lt;T extends Comparable&gt; extends Object implements Set&lt;T&gt;, Iterable&lt;T&gt;

with an inner class:

protected class SkipListIterator&lt;E&gt; implements Iterator&lt;T&gt;

we just get confused with the 'T' reference as it isnt a type variable in the subtype, it is from the enclosing type.

fix about to be committed if it passes all the tests.</comment>
		<comment id="4" date="2006-03-01 03:33:31 EST" author="Andrew Clement">fix committed.</comment>
		<comment id="5" date="2006-03-13 03:28:05 EST" author="Helen Beeken">This fix is now available in the latest AJDT (both for Eclipse 3.1 and Eclipse 3.2M5a).</comment>
		<comment id="6" date="2006-03-13 03:47:22 EST" author="Holger HoffstÃ¤tte">Been running it since Friday ;-) and everything seems to work as expected; the class in question compiles fine again. Thanks!</comment>
		<comment id="7" date="2006-03-20 11:15:34 EST" author="Helen Beeken">Closing as fixed since fix is available in latest builds.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="5053f266ee41bce94fa7f2d34c5b83992bd3ff13" author="aclement" date="2006-03-01 05:21:56"/>
          <file name="tests/bugs151/pr129566/SkipList.java">
          </file>
          <file name="tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="133307" opendate="2006-3-26 21:05:00" fixdate="2006-3-27 10:59:00">
    <buginformation>
      <summary>declare parents implementing generic interface referencing same type</summary>
      <description>I have the following construct:

public interface TestIF&lt;T extends TestIF&gt; {}

public class TestClass {}

public aspect TestAspect {

    declare parents: TestClass implements TestIF&lt;TestClass&gt;; 

}



The later aspect does not compile, although 

public class TestClass implements TestIF&lt;TestClass&gt; {

}
is a valid class.</description>
      <comments>
		<comment id="1" date="2006-03-27 03:32:45 EST" author="Andrew Clement">As I expected - it's a problem with not allowing for this 'recursive' case.  The problem is that we check bounds during the completion of type bindings, when we should in fact complete the type bindings and then verify the system is coherent...</comment>
		<comment id="2" date="2006-03-27 09:00:34 EST" author="Andrew Clement">fix checked in.</comment>
		<comment id="3" date="2006-03-27 10:59:22 EST" author="Andrew Clement">fix available in AJ:

BUILD COMPLETE -  build.732
Date of build: 03/27/2006 15:13:01
Time to build: 87 minutes 56 seconds
Last changed: 03/27/2006 14:42:37</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="c9a60e519d73bb7aa4d8cf4615445089202bd3ad" author="aclement" date="2006-03-27 10:42:23"/>
          <file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java">
              <method name="completeTypeBindings" returnType="void" parameters=""/>
          </file>
          <file name="tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/CrosscuttingMembersSet.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/patterns/IVerificationRequired.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="131505" opendate="2006-3-13 5:37:00" fixdate="2006-3-27 16:42:00">
    <buginformation>
      <summary>Generated aop.xml files contain aspects for all the projects ever built</summary>
      <description>Using the -outxml option in AJDT the generated aop.xml files are not correct after the first build and contain all the aspects that have ever been built (including those in different projects and duplicates if an aspect has been built twice).  It seems that there is a global list of aspects (aspectNames in AjBuildManager) that is never cleared.</description>
      <comments>
		<comment id="1" date="2006-03-13 05:43:03 EST" author="Sian January">I have also just noticed that the generated names are wrong for inner classes.  I think "spacewar.Display2$SpaceObjectPainting" should be "spacewar.Display2.SpaceObjectPainting".</comment>
		<comment id="2" date="2006-03-13 06:11:42 EST" author="Andrew Clement">The aspectNames list should either be moved into AjState or removed entirely.  If moved into AjState we will need it to be aware of file deletions as that may affect the set of aspects - hmmm, but now I come to type that, it might be that aspect deletions force a full build anyway, which creates a new state and would empty the set of aspects.

The alternative would be to remove the list entirely and just work it out at the point we create the xml file.</comment>
		<comment id="3" date="2006-03-15 06:51:18 EST" author="Helen Beeken">Created attachment 36324 [details]
patch containing testcase

Apply this patch to the tests project.</comment>
		<comment id="4" date="2006-03-15 06:53:07 EST" author="Helen Beeken">Created attachment 36325 [details]
patch containing fix

Apply this patch to the org.aspectj.ajdt.core project.

This patch contains a proposed fix. Namely, to move the list of aspectNames to the AjState. Note that when any changes are made to an aspect (including the deletion of one) we go back to source and do a full build. This creates a new AjState and consequently a new aspectNames list.</comment>
		<comment id="5" date="2006-03-15 07:33:03 EST" author="Andrew Clement">patches committed.</comment>
		<comment id="6" date="2006-03-27 16:42:21 EST" author="Andrew Clement">fix available.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="b3cd01d587219969e7c7b58ecda5b1aeb7722c2e" author="aclement" date="2006-03-15 09:34:48"/>
          <file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java">
          </file>
          <file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java">
          </file>
          <file name="tests/multiIncremental/PR131505/base/C.java">
          </file>
          <file name="tests/multiIncremental/PR131505/inc2/C.java">
          </file>
          <file name="tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="130869" opendate="2006-3-8 4:05:00" fixdate="2006-3-28 2:51:00">
    <buginformation>
      <summary>Pointcut resolution fails against type variables</summary>
      <description>Ok, so I'm on the bleeding edge of aspect design here... but I have a generic aspect of the form

public abstract aspect MyAspect&lt;T extends Bar&gt; { 

  declare warning : T.somePC() : "a match";

}

and Bar is defined as:

public abstract aspect Bar {

  public abstract pointcut somePC();

}

(yes, what that enables is indeed unbelievably cool).

We fail (perhaps unsurprisingly) when compiling the generic aspect because we can't find the pointcut somePC in T. We should of course be looking in the upper bound when searching for a pointcut in a type variable...</description>
      <comments>
		<comment id="1" date="2006-03-08 04:05:57 EST" author="Adrian Colyer">I'll take this one...</comment>
		<comment id="2" date="2006-03-08 05:59:19 EST" author="Adrian Colyer">fix committed in CVS, waiting on build.
This gives us a capability I've been wanting for several years now...</comment>
		<comment id="3" date="2006-03-28 02:51:56 EST" author="Andrew Clement">fix available.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="103733b9c277f980d30db27710ea359974e45c81" author="acolyer" date="2006-03-08 07:59:06"/>
          <file name="tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java">
              <method name="testLTWGeneratedAspectWithAbstractMethod_pr125480" returnType="void" parameters=""/>
          </file>
          <file name="weaver/src/org/aspectj/weaver/patterns/ReferencePointcut.java">
              <method name="resolveBindings" returnType="void" parameters="IScope Bindings"/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="130837" opendate="2006-3-7 19:52:00" fixdate="2006-3-28 8:52:00">
    <buginformation>
      <summary>Exception while trying to edit Annotation based Aspect Class (normal Java class)</summary>
      <description>java.lang.NullPointerException
at org.aspectj.ajdt.internal.compiler.ast.ValidateAtAspectJAnnotationsVisitor.buildFormalAdviceBindingsFrom(ValidateAtAspectJAnnotationsVisitor.java:417)
at org.aspectj.ajdt.internal.compiler.ast.ValidateAtAspectJAnnotationsVisitor.resolveAndSetPointcut(ValidateAtAspectJAnnotationsVisitor.java:364)
at org.aspectj.ajdt.internal.compiler.ast.ValidateAtAspectJAnnotationsVisitor.validateAdvice(ValidateAtAspectJAnnotationsVisitor.java:336)
at org.aspectj.ajdt.internal.compiler.ast.ValidateAtAspectJAnnotationsVisitor.visit(ValidateAtAspectJAnnotationsVisitor.java:186)
at org.aspectj.org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.traverse(MethodDeclaration.java:185)
at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.traverse(TypeDeclaration.java:1195)
at org.aspectj.org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.traverse(CompilationUnitDeclaration.java:339)
at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.beforeAnalysing(AjCompilerAdapter.java:154)
at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$before$org_aspectj_ajdt_internal_compiler_CompilerAdapter$7$db78446d(CompilerAdapter.aj:101)
at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:517)
at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:329)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:824)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:234)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:189)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.incrementalBuild(AjBuildManager.java:164)
at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:117)
at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)

NullPointerException thrown: null</description>
      <comments>
		<comment id="1" date="2006-03-08 03:21:25 EST" author="Andrew Clement">Looks like it is this line:

TypeBinding argTypeBinding = mDecl.binding.parameters[i];

and the binding is null.</comment>
		<comment id="2" date="2006-03-28 03:09:16 EST" author="Andrew Clement">fix for NPE committed.</comment>
		<comment id="3" date="2006-03-28 08:52:59 EST" author="Andrew Clement">fix available in latest AJ.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="41f1f3a4174de86413942cd8f2c2e7c45d9824d7" author="aclement" date="2006-03-28 05:09:10"/>
          <file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/ValidateAtAspectJAnnotationsVisitor.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="132926" opendate="2006-3-22 20:05:00" fixdate="2006-4-4 14:01:00">
    <buginformation>
      <summary>Compiler crashes processing annotations</summary>
      <description>Just upgraded to latest AJDT (Version: 1.3.1, Build id: 20060322082516
AspectJ version: 1.5.1.20060320075953)
and the compiler crashed while rebulding the project (which used to work fine 
using using the March 16th version). Retrying with 'clean' build produced the
same crash.

java.lang.NullPointerException
at org.aspectj.weaver.AnnotationX.ensureAtTargetInitialized(AnnotationX.java:158)
at org.aspectj.weaver.AnnotationX.specifiesTarget(AnnotationX.java:98)
at org.aspectj.weaver.bcel.BcelWeaver.verifyTargetIsOK(BcelWeaver.java:1450)
at org.aspectj.weaver.bcel.BcelWeaver.applyDeclareAtType(BcelWeaver.java:1417)
at org.aspectj.weaver.bcel.BcelWeaver.weaveParentTypeMungers(BcelWeaver.java:1366)
at org.aspectj.weaver.bcel.BcelWeaver.weaveParentsFor(BcelWeaver.java:1223)
at org.aspectj.weaver.bcel.BcelWeaver.weaveParentsFor(BcelWeaver.java:1211)
at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1058)
at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave(AjCompilerAdapter.java:311)
at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling(AjCompilerAdapter.java:183)
at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$afterReturning$org_aspectj_ajdt_internal_compiler_CompilerAdapter$2$f9cc9ca0(CompilerAdapter.aj:70)
at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:367)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:845)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:241)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:161)
at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:122)
at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)

NullPointerException thrown: null</description>
      <comments>
		<comment id="1" date="2006-03-22 20:25:34 EST" author="Ramnivas Laddad">I wonder if this is related to #128655. There is one major difference, though. #128655 crahsed only during incremental compilation, whereas this one crahses on full build.</comment>
		<comment id="2" date="2006-03-23 03:55:32 EST" author="Andrew Clement">this is no doubt because of the ASM support I added recently which has only just made it into an AJDT build.  Can you try putting this in the 'non standard options' field for the offending project?

-Xset:activateLightweightDelegates=false

does it help it get past the NPE?</comment>
		<comment id="3" date="2006-03-23 04:42:44 EST" author="Andrew Clement">after looking a little further at it - I'm even more convinced its the ASM code since now annotations can be of two types depending on whether we loaded an ASM delegate for a type or a BCEL delegate for a type.  I missed a path in the annotation processing code that should have done different things based on the kind of delegate loaded.</comment>
		<comment id="4" date="2006-03-23 12:18:17 EST" author="Ramnivas Laddad">I just tried the suggested "-Xset:activateLightweightDelegates=false" option and could get a successful compilation.</comment>
		<comment id="5" date="2006-03-24 03:44:15 EST" author="Andrew Clement">Excellent - the option is doing exactly what I wanted - it deactivates the loading of classes via the ASM bytecode toolkit which is the problem here. I'll fix the bug soon as I can, now that I've finished doing my 40,000 sessions at AOSD.</comment>
		<comment id="6" date="2006-03-24 05:10:24 EST" author="Andrew Clement">fix for this checked into AJ now.</comment>
		<comment id="7" date="2006-04-04 14:01:39 EDT" author="Andrew Clement">fix available now in 1.5.1 - will be in AJDT shortly.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="2fb86fe604b613774492df5185b1c5717c434d29" author="aclement" date="2006-03-24 07:10:02"/>
          <file name="tests/bugs151/Deca/DecA.java">
          </file>
          <file name="tests/bugs151/pr132926/AffectedType.java">
          </file>
          <file name="tests/bugs151/pr132926/InputAnnotation.java">
          </file>
          <file name="tests/bugs151/pr132926/InputAnnotation2.java">
          </file>
          <file name="tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/AnnotationX.java">
              <method name="ensureAtTargetInitialized" returnType="void" parameters=""/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="135001" opendate="2006-4-5 7:10:00" fixdate="2006-4-6 10:04:00">
    <buginformation>
      <summary>NPE at at org.aspectj.weaver.bcel.BcelShadow.weaveAroundInline</summary>
      <description>java.lang.NullPointerException
at org.aspectj.weaver.bcel.BcelShadow.weaveAroundInline(BcelShadow.java:2109)
at org.aspectj.weaver.bcel.BcelAdvice.implementOn(BcelAdvice.java:232)
at org.aspectj.weaver.Shadow.implementMungers(Shadow.java:639)
at org.aspectj.weaver.Shadow.implement(Shadow.java:456)
at org.aspectj.weaver.bcel.BcelClassWeaver.implement(BcelClassWeaver.java:2236)
at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:491)
at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:109)
at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1560)
at org.aspectj.weaver.bcel.BcelWeaver.weaveWithoutDump(BcelWeaver.java:1511)
at org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify(BcelWeaver.java:1291)
at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1113)
at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave(AjCompilerAdapter.java:311)
at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling(AjCompilerAdapter.java:183)
at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$afterReturning$org_aspectj_ajdt_internal_compiler_CompilerAdapter$2$f9cc9ca0(CompilerAdapter.aj:70)
at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:367)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:862)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:242)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:161)
at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:122)
at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)</description>
      <comments>
		<comment id="1" date="2006-04-05 07:12:54 EDT" author="Matt Chapman">Passing over to the compiler.
Please can you add your exact AJDT and AspectJ version numbers.</comment>
		<comment id="2" date="2006-04-05 12:59:39 EDT" author="Testo Nakada">org.aspectj.weaver_1.5.0.20060405045058
org.eclipse.aspectj_1.3.1.20060405045058</comment>
		<comment id="3" date="2006-04-06 04:29:56 EDT" author="Andrew Clement">*** Bug 135213 has been marked as a duplicate of this bug. ***</comment>
		<comment id="4" date="2006-04-06 05:22:48 EDT" author="Andrew Clement">Antti, can you possibly try something for me on your scenario that might help me narrow things down?

Can you remove the -XnoInline workaround I asked you to use and instead try '-Xset:activateLightweightDelegates=false' - does it still fail?

thanks.</comment>
		<comment id="5" date="2006-04-06 05:26:38 EDT" author="Andrew Clement">Also Antti, can you tell me if your aspects are compiled from source in this build or are they coming from a jar file in binary form?</comment>
		<comment id="6" date="2006-04-06 06:38:52 EDT" author="Andrew Clement">whilst waiting for feedback from Antti - I've put in a guard so the NPE can't happen - a message will be reported that we cant implement inlining and we'll fall back on closure - THIS WILL AFFECT PERFORMANCE OF THE GENERATED CODE - and so hopefully we can resolve what is leading to the NPE.</comment>
		<comment id="7" date="2006-04-06 06:44:57 EDT" author="Antti Karanta">(In reply to comment #4)
&gt; Antti, can you possibly try something for me on your scenario that might help
&gt; me narrow things down?
&gt; 
&gt; Can you remove the -XnoInline workaround I asked you to use and instead try
&gt; '-Xset:activateLightweightDelegates=false' - does it still fail?

  Yes, this seems to fix the problem:

D:\work\napa\jnapa\core&gt;ajc -nowarn -Xlint:ignore -Xset:activateLightweightDelegates=false -source 1.5 -target 1.5 -d bu
ild\classes -cp ..\commons\utils\build\napa_utils.jar;lib\aspectjrt.jar;lib\dom4j-1.5.2.jar;lib\groovy-all-1.0-jsr-05.ja
r;..\commons\test_commons\lib\junit.jar -sourceroots src;gen_src;test_src

D:\work\napa\jnapa\core&gt;

  I added the -nowarn and -Xlint:ignore, but also tried w/out them, so they do not seem to affect this bug.


  As for your other question, some aspects are in source form and some come from a jar, though not via inpath but via aspects in this project extending abstract aspects contained in one of the jars.</comment>
		<comment id="8" date="2006-04-06 06:56:01 EDT" author="Andrew Clement">thanks for responding quickly! I think that description tells me what it is - i'll write a test program to verify.</comment>
		<comment id="9" date="2006-04-06 07:01:21 EDT" author="Andrew Clement">yey! recreated</comment>
		<comment id="10" date="2006-04-06 07:20:32 EDT" author="Andrew Clement">thanks to Antti I have recreated this and fixed it.  The problem is due to the fast delegates we support that are based on the ASM bytecode toolkit.  Fast delegates don't have any instructions loaded for methods within them - this causes a problem if the weaver attempts to inline around advice.  Normally we know which types it is safe to create fast delegates for but this was a case we hadn't been testing, you need to have:
- an abstract super aspect containing *inlinable around advice*
- a concrete sub aspect

The abstract super aspect needs to be on the classpath, not on the aspectpath or in source form.

In this situation when the super aspect is resolved we see it on the classpath and think we can create a fast delegate - but we can't because we may want to extract the instructions from the around advice and inline them at some matched join point.

The fix is a little ugly right now but this is quite serious and I wanted to get something minimal through so AJDT can ship its 1.3.1 version.  The fix is to fallback to BCEL if we create a fast delegate and discover it is an aspect, ideally we could know if we were loading the supertype for an aspect and ensure it was loaded via BCEL but that's a little messier as when the resolution occurs we don't know the context in which it is occurring.

couple of tests are failing now due to expecting ASM types for aspects sometimes, I'm working on fixing those then i'll commit.</comment>
		<comment id="11" date="2006-04-06 10:04:29 EDT" author="Andrew Clement">fix available in latest dev build.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="1a6f69583137f03d2a8052148a17eebe8e79e162" author="aclement" date="2006-04-06 08:45:02"/>
          <file name="tests/bugs152/pr135001/AbstractAspect.java">
          </file>
          <file name="tests/bugs152/pr135001/ConcreteAspect.java">
          </file>
          <file name="tests/bugs152/pr135001/Foo.java">
          </file>
          <file name="tests/src/org/aspectj/systemtest/AllTests15.java">
          </file>
          <file name="tests/src/org/aspectj/systemtest/ajc152/Ajc152Tests.java">
          </file>
          <file name="tests/src/org/aspectj/systemtest/ajc152/AllTestsAspectJ152.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/bcel/BcelShadow.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/bcel/BcelWorld.java">
          </file>
          <file name="weaver/testsrc/org/aspectj/weaver/bcel/AsmDelegateTests.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="134541" opendate="2006-4-3 12:03:00" fixdate="2006-4-7 6:04:00">
    <buginformation>
      <summary>adviceDidNotMatch's line number doesn't keep up with line number of advice</summary>
      <description>When advice doesn't match in a 1.5.0 enabled project, there is an adviceDidNotMatch warning against the line number of the advice. If you insert a line before this advice and save then the warning stays associated with the original line and not the new one. Full building puts the warning against the new line. 

This is a regression and didn't happen in AJ 1.5.0.</description>
      <comments>
		<comment id="1" date="2006-04-03 12:21:09 EDT" author="Helen Beeken">Created attachment 37544 [details]
failing testcase

Apply this patch to the tests project.</comment>
		<comment id="2" date="2006-04-04 09:08:20 EDT" author="Helen Beeken">I think part of the fix for bug 129163 caused this bug. Within CrosscuttingMembers.replaceWith(..) we only calculate the changes to the shadowmungers and typemungers if we careAboutShadowMungers. If we change to always  calculate the changes to the shadowmungers and typemungers then this bug no longer occurs.</comment>
		<comment id="3" date="2006-04-04 09:50:33 EDT" author="Helen Beeken">The problem is the equals method in Advice. At the moment its only using kind, pointcut and signature to see if two pieces of advice are the same. In the case of this bug they are the same, however, they have different sourceLocations. Because we're thinking they're equal we're not updating the list of shadowMungers and so the original one is used in the calculation of the xlint warning (which gives the original line number). The reason part of the fix for bug 129163 causes this problem is that if we always check shadowmunger equality the first time we compare we compare something with nothing which is a change and the second time we check nothing against something. This forces the update. This is a regression because for 1.5.0 we always thought there was a change so we always updated (due to various implementations of equals).</comment>
		<comment id="4" date="2006-04-05 07:00:18 EDT" author="Helen Beeken">The fix is to add implementation of the equals and hashcode methods within Advice and EclipseSourceLocation. Within Advice I've added a check for the equality of the SourceLocation to the equals method and in EclipseSourceLocation I've said that two are equal if they have the same start position, same end position and if their sourceFiles are equal.</comment>
		<comment id="5" date="2006-04-05 07:01:32 EDT" author="Helen Beeken">Created attachment 37720 [details]
patch implementing equals and hashcode in EclipseSourceLocation

Apply this patch to the org.aspectj.ajdt.core project.</comment>
		<comment id="6" date="2006-04-05 07:02:41 EDT" author="Helen Beeken">Created attachment 37721 [details]
patch improving equals and hashcode methods in Advice

Apply this patch to the weaver project.</comment>
		<comment id="7" date="2006-04-05 07:04:42 EDT" author="Helen Beeken">Created attachment 37722 [details]
testcase patch synchronized with the latest version in HEAD

Apply this patch to the tests project.</comment>
		<comment id="8" date="2006-04-05 09:30:17 EDT" author="Helen Beeken">Created attachment 37727 [details]
testcase patch which tests that adding whitespace doesn't force full build

Apply this patch to the tests project.</comment>
		<comment id="9" date="2006-04-05 09:31:22 EDT" author="Helen Beeken">Created attachment 37728 [details]
patch which doesn't force full build if there's a whitespace change

Apply this patch to the weaver project.</comment>
		<comment id="10" date="2006-04-05 09:35:32 EDT" author="Helen Beeken">An explanation for the previous two patches (comment #8 and comment #9)...

By changing the equals methods as described in comment #4 this does have the knock on effect of thinking there's been a change if the sourcelocation changes. Which means that if there's a whitespace change then we force a full build...not really something we want to be doing......An alternative solution is to go ahead and work out whether there's been a change as we have been doing previously, however, to copy over the new list of shadowmungers regardless of whether we think there's been a change (this is all in CrosscuttingMembers.replaceWith(..)). That way we pick up any changes in sourcelocation without forcing a full build. This does require us to reset the list of shadowmungers in CrosscuttingMembersSet if we care about the shadowmungers otherwise we wont pick up the new ones. </comment>
		<comment id="11" date="2006-04-07 06:04:08 EDT" author="Helen Beeken">The fix for this has been checked in and is available in both the latest AJ and AJDT dev builds. Therefore, closing this as fixed.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="94d8b82fbf3cb18a14d77508b3adad6d50434080" author="aclement" date="2006-04-06 07:44:14"/>
          <file name="tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java">
              <method name="testPr133532_2" returnType="void" parameters=""/>
          </file>
          <file name="weaver/src/org/aspectj/weaver/CrosscuttingMembers.java">
              <method name="replaceWith" returnType="boolean" parameters="CrosscuttingMembers boolean"/>
          </file>
          <file name="weaver/src/org/aspectj/weaver/CrosscuttingMembersSet.java">
              <method name="addOrReplaceAspect" returnType="boolean" parameters="ResolvedType boolean"/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="136665" opendate="2006-4-13 11:34:00" fixdate="2006-4-18 9:04:00">
    <buginformation>
      <summary>Bug: ajc fails on missing classpath entries with fix</summary>
      <description>[iajc] error at (no source information available)
     [iajc] File.aj:0::0 Internal compiler error
     [iajc] org.aspectj.weaver.BCException: Can't open archive: missingjar

     [iajc] when resolving types defined in compilation unit File.aj
     [iajc] when processing compilation unit File.aj
     [iajc] when batch building BuildConfig[null] #Files=14
     [iajc]
     [iajc]     at org.aspectj.weaver.bcel.ClassPathManager$ZipFileEntry.ensureOpen(ClassPathManager.java:258)
     [iajc]     at org.aspectj.weaver.bcel.ClassPathManager$ZipFileEntry.find(ClassPathManager.java:225)
     [iajc]     at org.aspectj.weaver.bcel.ClassPathManager.find(ClassPathManager.java:92)
     [iajc]     at org.aspectj.weaver.bcel.BcelWorld.resolveDelegate(BcelWorld.java:287)
     [iajc]     at org.aspectj.weaver.World.resolveToReferenceType(World.java:335)
     [iajc]     at org.aspectj.weaver.World.resolve(World.java:251)
     [iajc]     at org.aspectj.weaver.patterns.WildTypePattern.lookupTypeInWorld(WildTypePattern.java:716)
     [iajc]     at org.aspectj.weaver.patterns.WildTypePattern.resolveBindingsFromFullyQualifiedTypeName(WildTypePattern.java:690)
     [iajc]     at org.aspectj.weaver.patterns.WildTypePattern.resolveBindings(WildTypePattern.java:623)
     [iajc]     at org.aspectj.weaver.patterns.SignaturePattern.resolveBindings(SignaturePattern.java:82)
     [iajc]     at org.aspectj.weaver.patterns.KindedPointcut.resolveBindings(KindedPointcut.java:259)
     [iajc]     at org.aspectj.weaver.patterns.AndPointcut.resolveBindings(AndPointcut.java:74)
     [iajc]     at org.aspectj.weaver.patterns.Pointcut.resolve(Pointcut.java:194)
     [iajc]     at org.aspectj.ajdt.internal.compiler.ast.PointcutDesignator.finishResolveTypes(PointcutDesignator.java:84)
     [iajc]     at org.aspectj.ajdt.internal.compiler.ast.AdviceDeclaration.resolveStatements(AdviceDeclaration.java:118)
     [iajc]     at org.aspectj.org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:400)
     [iajc]     at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1088)
     [iajc]     at org.aspectj.ajdt.internal.compiler.ast.AspectDeclaration.resolve(AspectDeclaration.java:116)
     [iajc]     at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1137)
     [iajc]     at org.aspectj.org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:305)
     [iajc]     at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:514)
     [iajc]     at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:329)
     [iajc]     at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:845)
     [iajc]     at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:241)
     [iajc]     at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:161)
     [iajc]     at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:112)
     [iajc]     at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:60)
     [iajc]     at org.aspectj.tools.ajc.Main.run(Main.java:356)
     [iajc]     at org.aspectj.tools.ajc.Main.runMain(Main.java:246)
     [iajc]     at org.aspectj.tools.ant.taskdefs.AjcTask.executeInSameVM(AjcTask.java:1262)
     [iajc]     at org.aspectj.tools.ant.taskdefs.AjcTask.execute(AjcTask.java:1056)
     [iajc]     at org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:275)
     [iajc]     at org.apache.tools.ant.Task.perform(Task.java:364)
     [iajc]     at org.apache.tools.ant.Target.execute(Target.java:341)
     [iajc]     at org.apache.tools.ant.Target.performTasks(Target.java:369)
     [iajc]     at org.apache.tools.ant.Project.executeTarget(Project.java:1214)
     [iajc]     at org.apache.tools.ant.taskdefs.Ant.execute(Ant.java:386)
     [iajc]     at org.apache.tools.ant.taskdefs.CallTarget.execute(CallTarget.java:106)
     [iajc]     at org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:275)
     [iajc]     at org.apache.tools.ant.Task.perform(Task.java:364)
     [iajc]     at org.apache.tools.ant.Target.execute(Target.java:341)
     [iajc]     at org.apache.tools.ant.Target.performTasks(Target.java:369)
     [iajc]     at org.apache.tools.ant.Project.executeTarget(Project.java:1214)
     [iajc]     at org.apache.tools.ant.Project.executeTargets(Project.java:1062)
     [iajc]     at org.apache.tools.ant.Main.runBuild(Main.java:673)
     [iajc]     at org.apache.tools.ant.Main.startAnt(Main.java:188)
     [iajc]     at org.apache.tools.ant.launch.Launcher.run(Launcher.java:196)
     [iajc]     at org.apache.tools.ant.launch.Launcher.main(Launcher.java:55)
     [iajc] Caused by: java.util.zip.ZipException: error in opening zip file
     [iajc] java.util.zip.ZipException: error in opening zip file
     [iajc]     at java.util.zip.ZipFile.open(Native Method)
     [iajc]     at java.util.zip.ZipFile.&lt;init&gt;(ZipFile.java:111)
     [iajc]     at java.util.zip.ZipFile.&lt;init&gt;(ZipFile.java:127)
     [iajc]     at org.aspectj.weaver.bcel.ClassPathManager$ZipFileEntry.ensureOpen(ClassPathManager.java:252)
     [iajc]     at org.aspectj.weaver.bcel.ClassPathManager$ZipFileEntry.find(ClassPathManager.java:225)
     [iajc]     at org.aspectj.weaver.bcel.ClassPathManager.find(ClassPathManager.java:92)
     [iajc]     at org.aspectj.weaver.bcel.BcelWorld.resolveDelegate(BcelWorld.java:287)
     [iajc]     at org.aspectj.weaver.World.resolveToReferenceType(World.java:335)
     [iajc]     at org.aspectj.weaver.World.resolve(World.java:251)
     [iajc]     at org.aspectj.weaver.patterns.WildTypePattern.lookupTypeInWorld(WildTypePattern.java:716)
     [iajc]     at org.aspectj.weaver.patterns.WildTypePattern.resolveBindingsFromFullyQualifiedTypeName(WildTypePattern.java:690)
     [iajc]     at org.aspectj.weaver.patterns.WildTypePattern.resolveBindings(WildTypePattern.java:623)
     [iajc]     at org.aspectj.weaver.patterns.SignaturePattern.resolveBindings(SignaturePattern.java:82)
     [iajc]     at org.aspectj.weaver.patterns.KindedPointcut.resolveBindings(KindedPointcut.java:259)
     [iajc]     at org.aspectj.weaver.patterns.AndPointcut.resolveBindings(AndPointcut.java:74)
     [iajc]     at org.aspectj.weaver.patterns.Pointcut.resolve(Pointcut.java:194)
     [iajc]     at org.aspectj.ajdt.internal.compiler.ast.PointcutDesignator.finishResolveTypes(PointcutDesignator.java:84)
     [iajc]     at org.aspectj.ajdt.internal.compiler.ast.AdviceDeclaration.resolveStatements(AdviceDeclaration.java:118)
     [iajc]     at org.aspectj.org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:400)
     [iajc]     at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1088)
     [iajc]     at org.aspectj.ajdt.internal.compiler.ast.AspectDeclaration.resolve(AspectDeclaration.java:116)
     [iajc]     at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1137)
     [iajc]     at org.aspectj.org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:305)
     [iajc]     at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:514)
     [iajc]     at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:329)
     [iajc]     at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:845)
     [iajc]     at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:241)
     [iajc]     at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:161)
     [iajc]     at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:112)
     [iajc]     at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:60)
     [iajc]     at org.aspectj.tools.ajc.Main.run(Main.java:356)
     [iajc]     at org.aspectj.tools.ajc.Main.runMain(Main.java:246)
     [iajc]     at org.aspectj.tools.ant.taskdefs.AjcTask.executeInSameVM(AjcTask.java:1262)
     [iajc]     at org.aspectj.tools.ant.taskdefs.AjcTask.execute(AjcTask.java:1056)
     [iajc]     at org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:275)
     [iajc]     at org.apache.tools.ant.Task.perform(Task.java:364)
     [iajc]     at org.apache.tools.ant.Target.execute(Target.java:341)
     [iajc]     at org.apache.tools.ant.Target.performTasks(Target.java:369)
     [iajc]     at org.apache.tools.ant.Project.executeTarget(Project.java:1214)
     [iajc]     at org.apache.tools.ant.taskdefs.Ant.execute(Ant.java:386)
     [iajc]     at org.apache.tools.ant.taskdefs.CallTarget.execute(CallTarget.java:106)
     [iajc]     at org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:275)
     [iajc]     at org.apache.tools.ant.Task.perform(Task.java:364)
     [iajc]     at org.apache.tools.ant.Target.execute(Target.java:341)
     [iajc]     at org.apache.tools.ant.Target.performTasks(Target.java:369)
     [iajc]     at org.apache.tools.ant.Project.executeTarget(Project.java:1214)
     [iajc]     at org.apache.tools.ant.Project.executeTargets(Project.java:1062)
     [iajc]     at org.apache.tools.ant.Main.runBuild(Main.java:673)
     [iajc]     at org.apache.tools.ant.Main.startAnt(Main.java:188)
     [iajc]     at org.apache.tools.ant.launch.Launcher.run(Launcher.java:196)
     [iajc]     at org.apache.tools.ant.launch.Launcher.main(Launcher.java:55)
     [iajc] abort ABORT -- (BCException) Can't open archive: wissing.jar
     [iajc] when resolving types defined in compilation unit File.aj
     [iajc] when processing compilation unit File.aj
     [iajc] when batch building BuildConfig[null] #Files=14</description>
      <comments>
		<comment id="1" date="2006-04-13 11:36:23 EDT" author="Ron Bodkin">Created attachment 38517 [details]
Changes classpath manager to just remove missing classpath entries instead of failing when they are discovered

This patch makes the failing code I tested work in practice. Otherwise, it can be horrid to manage classpaths in a build, where you have to have each module explicitly include the jars that have been already built.</comment>
		<comment id="2" date="2006-04-18 07:03:33 EDT" author="Andrew Clement">reasonable change - committed.  We have other bugs where crazy people run with missing jars on the classpath ....</comment>
		<comment id="3" date="2006-04-18 09:04:22 EDT" author="Andrew Clement">build available.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="d1a252e911bd19747b0cd6815291f62706f202d6" author="aclement" date="2006-04-18 07:51:38"/>
          <file name="weaver/src/org/aspectj/weaver/bcel/ClassPathManager.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="138143" opendate="2006-4-23 12:03:00" fixdate="2006-4-26 8:09:00">
    <buginformation>
      <summary>NullPointerException when duplicated method name is used</summary>
      <description>When developing aspects as annotations, i get a NullPointerException when saving a source file which has duplicated method names. Obviously that also breaks the java code itself but it also pops up an aspectj message info.

Here is a sample code:

@Aspect
public class AspectClass{
	
	@Pointcut("call(@Incoming * *(..))")
	public void incomingMessage() {
	}

	
	@Pointcut("call(@Activity * *(..))")
	public void incomingMessage() {
	}
	
}

The npe is the following:

java.lang.NullPointerException
at org.aspectj.ajdt.internal.compiler.lookup.EclipseSourceType.makeResolvedPointcutDefinition(EclipseSourceType.java:217)
at org.aspectj.ajdt.internal.compiler.lookup.EclipseSourceType.fillDeclaredMembers(EclipseSourceType.java:188)
at org.aspectj.ajdt.internal.compiler.lookup.EclipseSourceType.getDeclaredPointcuts(EclipseSourceType.java:250)
at org.aspectj.ajdt.internal.compiler.lookup.EclipseSourceType.checkPointcutDeclarations(EclipseSourceType.java:267)
at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.resolvePointcutDeclarations(AjLookupEnvironment.java:433)
at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.completeTypeBindings(AjLookupEnvironment.java:236)
at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.beginToCompile(Compiler.java:301)
at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:315)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:862)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:269)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.incrementalBuild(AjBuildManager.java:168)
at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:117)
at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)

NullPointerException thrown: null

regards
Moritz Post</description>
      <comments>
		<comment id="1" date="2006-04-24 10:52:00 EDT" author="Andrew Clement">testcase and fix committed. thanks for the clear bug report.</comment>
		<comment id="2" date="2006-04-26 08:09:56 EDT" author="Andrew Clement">fix available in latest AJ, will be in AJDT in a few days.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="71bba6c3746ecb3cf64e204372e367ade78da050" author="aclement" date="2006-04-24 05:17:08"/>
          <file name="tests/bugs152/pr137568/C.java">
          </file>
          <file name="tests/bugs152/pr138143/AspectClass.java">
          </file>
          <file name="tests/bugs152/pr138158/Boo.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="138540" opendate="2006-4-25 20:18:00" fixdate="2006-4-26 8:11:00">
    <buginformation>
      <summary>Patch to add support for -Xset: options</summary>
      <description>I needed to add X="set:activateLightweightDelegates=false" to my ant build configuration, to troubleshoot the out of memory permgen condition. However, the ant task support doesn't currently support adding the new -Xset style options Andy added.

Here is a small patch to pass any -Xset: options through, that worked for me.</description>
      <comments>
		<comment id="1" date="2006-04-25 20:21:41 EDT" author="Ron Bodkin">Created attachment 39494 [details]
add -Xset option support for AspectJ ant task

I didn't see any place to add a test for this kind of thing.</comment>
		<comment id="2" date="2006-04-26 03:38:51 EDT" author="Andrew Clement">patch committed. thanks.</comment>
		<comment id="3" date="2006-04-26 08:11:15 EDT" author="Andrew Clement">fix available.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="99882cb91a94c468c185cf11cd6a728604e95bdb" author="aclement" date="2006-04-26 04:25:49"/>
          <file name="taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java">
              <method name="setX" returnType="void" parameters="String"/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="138286" opendate="2006-4-24 18:29:00" fixdate="2006-4-27 6:16:00">
    <buginformation>
      <summary>perthis() causes ClassCastException</summary>
      <description>When using perthis() with an aspect, I see the following Internal Compiler 

AJDT 1.3.1 / AspectJ 1.5.1a
Build 20060406092046
Eclipse 3.1.2, Windows XP, JDK 1.5


Error:

java.lang.ClassCastException
at org.aspectj.weaver.patterns.PerThisOrTargetPointcutVisitor.getPerTypePointcut(PerThisOrTargetPointcutVisitor.java:41)
at org.aspectj.weaver.patterns.PerThisOrTargetPointcutVisitor.visit(PerThisOrTargetPointcutVisitor.java:108)
at org.aspectj.weaver.patterns.AndPointcut.accept(AndPointcut.java:119)
at org.aspectj.weaver.patterns.PerThisOrTargetPointcutVisitor.getPerTypePointcut(PerThisOrTargetPointcutVisitor.java:41)
at org.aspectj.weaver.PerObjectInterfaceTypeMunger.getTestTypePattern(PerObjectInterfaceTypeMunger.java:64)
at org.aspectj.weaver.PerObjectInterfaceTypeMunger.matches(PerObjectInterfaceTypeMunger.java:85)
at org.aspectj.weaver.ConcreteTypeMunger.matches(ConcreteTypeMunger.java:65)
at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:508)
at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:109)
at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1560)
at org.aspectj.weaver.bcel.BcelWeaver.weaveWithoutDump(BcelWeaver.java:1511)
at org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify(BcelWeaver.java:1291)
at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1089)
at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave(AjCompilerAdapter.java:311)
at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling(AjCompilerAdapter.java:183)
at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$afterReturning$org_aspectj_ajdt_internal_compiler_CompilerAdapter$2$f9cc9ca0(CompilerAdapter.aj:70)
at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:367)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:862)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:242)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:161)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:278)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.incrementalBuild(AjBuildManager.java:168)
at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:117)
at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)

trouble in: 
public abstract class org.apache.tapestry.internal.aspects.AbstractClassTargetting extends java.lang.Object:
  public void &lt;init&gt;():
                    ALOAD_0     // Lorg/apache/tapestry/internal/aspects/AbstractClassTargetting; this   (line 10)
                    INVOKESPECIAL java.lang.Object.&lt;init&gt; ()V
    initialization(void org.apache.tapestry.internal.aspects.AbstractClassTargetting.&lt;init&gt;())
    |               ALOAD_0
    |               INVOKEVIRTUAL java.lang.Object.getClass ()Ljava/lang/Class;
    |               LDC org.apache.tapestry.internal.annotations.Synchronized
    |               INVOKEVIRTUAL java.lang.Class.isAnnotationPresent (Ljava/lang/Class;)Z
    |               IFEQ L0
    |               ALOAD_0
    |               INVOKESTATIC org.apache.tapestry.internal.aspects.InternalSynchronization.ajc$perObjectBind (Ljava/lang/Object;)V
    | constructor-execution(void org.apache.tapestry.internal.aspects.AbstractClassTargetting.&lt;init&gt;())
    | |         L0: ALOAD_0
    | |             INVOKEVIRTUAL java.lang.Object.getClass ()Ljava/lang/Class;
    | |             LDC org.apache.tapestry.internal.annotations.Synchronized
    | |             INVOKEVIRTUAL java.lang.Class.isAnnotationPresent (Ljava/lang/Class;)Z
    | |             IFEQ L1
    | |             ALOAD_0
    | |             INVOKESTATIC org.apache.tapestry.internal.aspects.InternalSynchronization.ajc$perObjectBind (Ljava/lang/Object;)V
    | |         L1: RETURN
    | constructor-execution(void org.apache.tapestry.internal.aspects.AbstractClassTargetting.&lt;init&gt;())
    initialization(void org.apache.tapestry.internal.aspects.AbstractClassTargetting.&lt;init&gt;())
  end public void &lt;init&gt;()

  abstract void ajc$pointcut$$targetClasses$274()    org.aspectj.weaver.MethodDeclarationLineNumber: 16:628
;

end public abstract class org.apache.tapestry.internal.aspects.AbstractClassTargetting

when weaving type org.apache.tapestry.internal.aspects.AbstractClassTargetting
when weaving aspects 
when weaving 
when batch building BuildConfig[C:\workspace\.metadata\.plugins\org.eclipse.ajdt.core\tapestry5.generated.lst] #Files=70



I'll attach the corresponding files.</description>
      <comments>
		<comment id="1" date="2006-04-24 18:30:23 EDT" author="Howard M. Lewis Ship">Created attachment 39367 [details]
Abstract aspect</comment>
		<comment id="2" date="2006-04-24 18:30:48 EDT" author="Howard M. Lewis Ship">Created attachment 39368 [details]
Concrete aspect</comment>
		<comment id="3" date="2006-04-24 18:31:10 EDT" author="Howard M. Lewis Ship">Created attachment 39369 [details]
Annotation</comment>
		<comment id="4" date="2006-04-26 11:35:49 EDT" author="Helen Beeken">Created attachment 39541 [details]
patch containing failing testcase

From the supplied testcase I've narrowed it down to a smaller version which reproduces the problem. Apply the attached patch to the tests project.</comment>
		<comment id="5" date="2006-04-26 12:58:38 EDT" author="Andrew Clement">I've fixed this - based on the fix I've slightly reworked the testcase to confirm it's behaving as expected when the code runs.  The problem is that the perthis() is entirely depending on annotation existence - which (somewhere in the depths) causes us problems when we try and treat an AnnotationTypePattern as a TypePattern, when they are different things.  We have to create an 'AnyWithAnnotationTypePattern()' whose contents are the AnnotationTypePattern - then we can treat this new object as a standard TypePattern. clear ;)</comment>
		<comment id="6" date="2006-04-27 06:16:08 EDT" author="Andrew Clement">fix available, will be in AJDT shortly.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="c667bcb5088379d74b89c3dc8556b87429e4efb7" author="aclement" date="2006-04-27 01:45:17"/>
          <file name="tests/src/org/aspectj/systemtest/ajc152/Ajc152Tests.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/patterns/PerThisOrTargetPointcutVisitor.java">
              <method name="visit" returnType="Object" parameters="WithinAnnotationPointcut Object"/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="135780" opendate="2006-4-9 22:27:00" fixdate="2006-5-5 5:59:00">
    <buginformation>
      <summary>Java 1.2 dependency in aspectjrt.jar bug with fix</summary>
      <description>The thisJoinPoint.printString() fails on a 1.1 VM because it relies on a java.lang.ref.SoftReference. I need this to work because we're using AspectJ on an embedded device that is still using a pre-1.2 VM.

The problem lies in org.aspectj.runtime.reflect.SignatureImpl. The attached patch fixes it and passes all the tests. I tested the failing program manually on a 1.1 VM, but automating the test would require adding a 1.1 VM to the regression test infrastructure.

Sample:

public aspect Java11Test {
    before() : execution(* *(..)) {
        System.out.println(thisJoinPoint.toString());
    }
    public static void main(String args[]) {}
}

&gt;ajc -target 1.1 Java11Test.aj

&gt;\java\jre1.1.8_010\bin\jre -cp .;%CLASSPATH% Java11Test
Exception in thread "main" java.lang.NoClassDefFoundError: java/lang/ref/SoftReference
        at org.aspectj.runtime.reflect.JoinPointImpl$StaticPartImpl.toString(JoinPointImpl.java:43)
        at org.aspectj.runtime.reflect.JoinPointImpl$StaticPartImpl.toString(JoinPointImpl.java:48)
        at Java11Test.ajc$before$Java11Test$1$3444dde4(Java11Test.aj:3)
        at Java11Test.main(Java11Test.aj)</description>
      <comments>
		<comment id="1" date="2006-04-09 22:30:24 EDT" author="Ron Bodkin">Created attachment 38106 [details]
Patch to the runtime module (in SignatureImpl) to fix this bug.

The patch adds a cache private static inner interface and class that encapsulates the dependency on SoftReference. For a 1.1 VM, failure to find the SoftReference class results in disabling caching but the code still functions.</comment>
		<comment id="2" date="2006-05-03 12:19:42 EDT" author="Andrew Clement">patches integrated.  relevant aspectjrt.jars upgraded in the build system.</comment>
		<comment id="3" date="2006-05-05 05:59:23 EDT" author="Andrew Clement">fixed</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="cb5dfe759852d4965c692934ed7e14c41f61b715" author="aclement" date="2006-05-04 01:18:25"/>
          <file name="runtime/src/org/aspectj/runtime/reflect/SignatureImpl.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="118781" opendate="2005-12-1 3:43:00" fixdate="2005-12-01 11:49:42">
    <buginformation>
      <summary>[waiting-on-build]VerifyError in AspectJ</summary>
      <description>I'm fairly new to AspectJ, so this is probably not going to be well explained. I've started working on a project that was working fine. Then I added methods to classes that take a 2-dimensional string array parameter and suddenly I'm getting a VerifyError exception.

java.lang.VerifyError: (class: com/drkw/cpds/obligor/facades/version_1_00/ObligorDetailFacade_1_00, method: searchForObligorSummariesByGroup_aroundBody24 signature: (Lcom/drkw/cpds/obligor/facades/version_1_00/ObligorDetailFacade_1_00;[[[Ljava/lang/String;Ljava/lang/String;Ljava?&amp;#130;
	at com.drkw.cpds.obligor.facades.version_1_00.obligor.ObligorManager.&lt;clinit&gt;(ObligorManager.java:48)
	at com.drkw.cpds.obligor.integration.version_1_00.obligor.GetObligorDetailsGroupingTest.testGetObligorDetailsUsingGroups(GetObligorDetailsGroupingTest.java:45)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)</description>
      <comments>
		<comment id="1" date="2005-12-01 03:52:23 EST" author="Andrew Clement">Are you able to attach any of the code that leads to this problem?  perhaps at least the ITD statements you are using?

Are you working with Java5 constructs (generics?) or just regular 1.4 java?

What level of the compiler are you on, the latest?</comment>
		<comment id="2" date="2005-12-01 04:03:45 EST" author="Ian Orford">I'm using:
Java 1.4.2_07
Eclipse 3.1.1
AspectJ dev tools 1.3.0 build 20051130095036

Sorry - dont know what you mean by ITD.

I think the method I've added that's causing the problem is 
public ObligorDetail[] searchForObligorDetailsByGroup(String[][] mistralId, String name, String country, String legalEntity, Integer startPosition, Integer pageSize, SortKey[] sortKeys) throws BusinessException;

We have a similar method that takes a single-dimension array as the first parameter instead of this 2-dimension array but is the same otherwise. That's been working fine for ages.</comment>
		<comment id="3" date="2005-12-01 04:26:03 EST" author="Andrew Clement">Oh, I see from the code, you have advised the method with around advice.  I initially assumed when you said 'added a method to a class' that you had made an inter-type declaration ITD, something like:

public void SomeClass.newMethod() {}

Can you tell me the signature for the around advice (and the pointcut) that you are using to match this?

public ObligorDetail[] searchForObligorDetailsByGroup(String[][] mistralId,
String name, String country, String legalEntity, Integer startPosition, Integer
pageSize, SortKey[] sortKeys) throws BusinessException;

In the meantime, I'll try a similar method with two dimensional params.</comment>
		<comment id="4" date="2005-12-01 05:17:44 EST" author="Ian Orford">I said I wouldnt explain it well, didnt I ;-)
Hope this makes sense. I'm also trying to start with a simplest case of a class and an aspect to try to isolate this, but at the moment I'm getting other exceptions.


The java method is:
public ObligorSummary[] searchForObligorSummariesByGroup(String[][] mistralId, String name, String country, String legalEntity, Integer startPosition, Integer pageSize, SortKey[] keys) throws BusinessException;

The classname is ObligorDetailFacade_1_00 which extends abstract class ObligorManager

There are 2 around advices:

a) 
Object around() throws AspectException : no_transaction_required_calls()
with pointcut
pointcut no_transaction_required_calls(): all_1_00_Calls() &amp;&amp; !transaction_required_calls();

b) Object around() throws AspectException, SystemException : all_1_00_Calls();

pointcut all_1_00_Calls is defined as:
pointcut all_1_00_Calls(): !callGetInstance() &amp;&amp; (callXref_1_00() || callObligor_1_00() || callVerify_1_00());

where the callObligor_1_00 is the one that matches here...
pointcut callObligor_1_00(): execution(public * com.drkw.cpds.obligor.facades.version_1_00.obligor.ObligorManager+.*(..));</comment>
		<comment id="5" date="2005-12-01 06:09:51 EST" author="Ian Orford">I've now reproduced this with a simple class...

--- Class ---
package blah;

import java.util.Random;

public class MyClass {
 public Integer[] getRandomInt(String[][] param)
 {
  for (int i = 0; i &lt; param.length; i++)
  {
   System.out.print("[" + i + "] = [");
   for (int j = 0; j &lt; param[i].length; j++)
   {
    System.out.print(param[i][j]);
    if (j != param[i].length-1)
     System.out.print(',');
   }
   System.out.println(']');
  }
  return new Integer[] { new Integer(new Random().nextInt())};
 }
}


--- Aspect ---
package blah;

public aspect MyAspect {

 pointcut callPointCut(): call(public * blah.MyClass+.*(..));
 
 Object around() : callPointCut() {
  System.out.println("start of around");
  Object result = proceed();
  System.out.println("end of around");
  return result;
 }
}

--- Main class ---
package blah;

/** */
public class MyMain {

 /**
  * @param args
  */
 public static void main(String[] args)
 {
  MyClass mc = new MyClass();
  mc.getRandomInt(new String[][]{{ "a", "b", "c"},{"x","y","z"}});
 }
}


--- Exception --- 
java.lang.VerifyError: (class: blah/MyMain$AjcClosure3, method: run signature: ([Ljava/lang/Object;)Ljava/lang/Object;) Incompatible argument to function
 at blah.MyMain.main(MyMain.java:15)
Exception in thread "main" </comment>
		<comment id="6" date="2005-12-01 06:46:35 EST" author="Andrew Clement">thanks for the simple testcase Ian ... but ... I still can't get it to fail for me :(

I've tried in AJDT and from the command line, I've switched to a 1.4.2 vm from my usual 1.5 (although I'm on an earlier version of 1.4.2 than you).  Do you have any   options configured in the AspectJ pages for the project?  I'm just trying to work out the difference between your environment and mine...

my ajdt is a little older than yours - i'll try updating that now to see if it makes a difference.</comment>
		<comment id="7" date="2005-12-01 06:59:08 EST" author="Ian Orford">Progress - sort of.

I have Advanced/No Inline switched on. As soon as I turn it off and recompile, my simple case works.

However it appears to make no difference to my main project. I'm still investigating.</comment>
		<comment id="8" date="2005-12-01 07:11:27 EST" author="Andrew Clement">thats it!!  I can recreate it with -XnoInline turned on :)</comment>
		<comment id="9" date="2005-12-01 07:21:22 EST" author="Ian Orford">Good, that's pinpointed it. 

However I'm still not able to get past it in my real application, so all I've done is invalidate my simple test case.
Any other suggestions welcome!</comment>
		<comment id="10" date="2005-12-01 10:06:04 EST" author="Andrew Clement">Fix checked in ... we incorrectly handled multi-dimensional array signatures.  In fact String[][] was turning into String[][][] !!

Fix will be in next aspectj dev build and in AJDT in a couple of days.</comment>
		<comment id="11" date="2005-12-01 11:49:42 EST" author="Andrew Clement">fix available in latest AspectJ dev build - will probably be in AJDT on Monday.</comment>
		<comment id="12" date="2006-05-10 10:54:44 EDT" author="Wes Isberg">*** Bug 119408 has been marked as a duplicate of this bug. ***</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="a75b7fa48b233e41ed7aeb7d50fbdd411eadd8e6" author="aclement" date="2005-12-02 12:00:22"/>
          <file name="tests/bugs150/pr118781/MyAspect.java">
          </file>
          <file name="tests/bugs150/pr118781/MyClass.java">
          </file>
          <file name="tests/bugs150/pr118781/MyMain.java">
          </file>
          <file name="tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/World.java">
              <method name="resolve" returnType="ResolvedType" parameters="UnresolvedType boolean"/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="133117" opendate="2006-3-24 4:47:00" fixdate="2006-5-15 3:26:00">
    <buginformation>
      <summary>Lots of warnings with noGuardForLazyTjp</summary>
      <description>When the noGuardForLazyTjp compiler option is set to warning or error and a piece of advice causes this warning to show up, you get one warning for every join point matched by the advice.  I think just one would probably be enough...</description>
      <comments>
		<comment id="1" date="2006-03-24 04:52:02 EST" author="Sian January">Created attachment 36876 [details]
Test project</comment>
		<comment id="2" date="2006-04-06 06:39:28 EDT" author="Helen Beeken">I've recreated this within the MultiprojectIncrementalTests (although this is nothing to do with incremental building you have more control to test the number of warning messages). The current situation, for the provided test project, is that you get three xlint messages:


[warning at before() : publicMethods() {
^^^^^^^^^^^^^^^^^^^^^
C:\temp\ajcSandbox\ajcTest16013.tmp\PR133117\Tracing.aj:5:0::0 can not build thisJoinPoint lazily for this advice since it has no suitable guard.  The advice applies at method-execution(int MainClass.hashCode()) [Xlint:noGuardForLazyTjp]
 see also: C:\temp\ajcSandbox\ajcTest16013.tmp\PR133117\Tracing.aj:22::0, 


warning at before() : publicMethods() {
^^^^^^^^^^^^^^^^^^^^^
C:\temp\ajcSandbox\ajcTest16013.tmp\PR133117\Tracing.aj:5:0::0 can not build thisJoinPoint lazily for this advice since it has no suitable guard.  The advice applies at method-execution(java.lang.String MainClass.toString()) [Xlint:noGuardForLazyTjp]
 see also: C:\temp\ajcSandbox\ajcTest16013.tmp\PR133117\Tracing.aj:17::0, 


warning at before() : publicMethods() {
^^^^^^^^^^^^^^^^^^^^^
C:\temp\ajcSandbox\ajcTest16013.tmp\PR133117\Tracing.aj:5:0::0 can not build thisJoinPoint lazily for this advice since it has no suitable guard.  The advice applies at method-execution(void MainClass.main(java.lang.String[])) [Xlint:noGuardForLazyTjp]
 see also: C:\temp\ajcSandbox\ajcTest16013.tmp\PR133117\Tracing.aj:13::0]


Each one is associated with the piece of advice (so warning icon in AJDT is marked against the advice and the same goes for the problems view), however, each warning is different. They each specify the joinpoint which is affected by the advice.

The question is is this reasonable behaviour? It does seem a little messy to have multiple warnings against the same piece of advice all pretty much saying the same thing. This clutter could obscure other messages within the problems view when run within AJDT. </comment>
		<comment id="3" date="2006-04-06 11:29:44 EDT" author="Helen Beeken">A possible fix is to remove the information about where the advice is matching from the xlint warning and then within BcelAdvice remember whether the warning has already been applied to the advice and only add it if it hasn't been done before. This requires changes to the Xlint tests for those which look for messages including the joinpoint information.</comment>
		<comment id="4" date="2006-04-06 11:31:24 EDT" author="Helen Beeken">Created attachment 37891 [details]
testcase patch

Apply this patch to the tests project.

This patch contains both a failing testcase for this bug as well as the changes to the xlint tests due to the change in xlint message.</comment>
		<comment id="5" date="2006-04-06 11:32:18 EDT" author="Helen Beeken">Created attachment 37893 [details]
patch containing possible fix

Apply this patch to the weaver project.</comment>
		<comment id="6" date="2006-05-12 11:32:03 EDT" author="Andrew Clement">patches committed.</comment>
		<comment id="7" date="2006-05-15 03:26:41 EDT" author="Andrew Clement">fixes available.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="3fa4d24ac16e94ee40b824fe27830fe7a34866a3" author="aclement" date="2006-05-13 12:34:39"/>
          <file name="tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java">
              <method name="testPr129163_3" returnType="void" parameters=""/>
          </file>
          <file name="weaver/src/org/aspectj/weaver/Lint.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="135068" opendate="2006-4-5 12:15:00" fixdate="2006-5-16 9:45:00">
    <buginformation>
      <summary>VerifyError with LTW and @AJ style aspects</summary>
      <description>I get "VerifyError: Incompatible object argument for function call" error when using LTW with @Aspect stype aspects. Interestingly enough, LTW works as expected with equivalent .aj style aspect. Compile time weaving works with both aspect styles. Tested on Linux with AspectJ 1.5.0, 1.5.1 and DEVELOPMENT-20060404163823 and SUN 1.5.0_06 and IBM 1.5.0SR1 JVMs. I will attach example project shortly.</description>
      <comments>
		<comment id="1" date="2006-04-05 12:23:29 EDT" author="Igor Fedorenko">Created attachment 37768 [details]
sample project that demonstrates the problem

Make sure your JAVA_HOME points to Java5 installation and run "ant -f test:ltw" from ajtestjava directory to reproduce the problem.</comment>
		<comment id="2" date="2006-05-10 12:41:44 EDT" author="Wes Isberg">Raising priority of verify error, though I haven't validated the test case.</comment>
		<comment id="3" date="2006-05-15 11:47:09 EDT" author="Andrew Clement">I've recreated the problem using the supplied testcase.  Currently debugging through it.

On running the class C, which is woven with the around advice, I get:

Exception in thread "main" java.lang.VerifyError: (class: t/C, method: test signature: ()V) Incompatible object argument for function call

LTW isn't required, you can recreate this just compiling source code:

ajc -1.5 -XnoInline -d output t/C.java t/Ajava.java

XnoInline - which causes closure generation, is what leads to the problem.</comment>
		<comment id="4" date="2006-05-16 03:47:58 EDT" author="Andrew Clement">the problem here is that the advice in the @AJ case is declared static.  We let that through and then generate code that fails verification at runtime.  If you tried to make code style advice static you would get:

"illegal modifier on advice, only strictfp is allowed"

I've just committed changes to also police this for @AJ aspects - and added a few testcases.

If you make your around advice non-static, everything works fine.</comment>
		<comment id="5" date="2006-05-16 09:45:26 EDT" author="Andrew Clement">fix available in latest dev build to police this.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="9ffc63b51aa49fa3bb67a4a1c40dd7d1fe4c97ae" author="aclement" date="2006-05-16 04:38:53"/>
          <file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/ValidateAtAspectJAnnotationsVisitor.java">
              <method name="validateAdvice" returnType="void" parameters="MethodDeclaration"/>
          </file>
          <file name="tests/bugs152/pr135068/A.java">
          </file>
          <file name="tests/bugs152/pr135068/Ajava.java">
          </file>
          <file name="tests/bugs152/pr135068/Ajava2.java">
          </file>
          <file name="tests/bugs152/pr135068/C.java">
          </file>
          <file name="tests/bugs152/pr135068/C2.java">
          </file>
          <file name="tests/bugs152/pr135068/t/Ajava.java">
          </file>
          <file name="tests/bugs152/pr135068/t/Ajava2.java">
          </file>
          <file name="tests/bugs152/pr135068/t/C.java">
          </file>
          <file name="tests/bugs152/pr135068/t/C2.java">
          </file>
          <file name="tests/src/org/aspectj/systemtest/ajc152/Ajc152Tests.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/bcel/AtAjAttributes.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="82570" opendate="2005-1-11 11:17:00" fixdate="2006-05-16 09:46:34">
    <buginformation>
      <summary>Weaved code does not include debug lines</summary>
      <description>I am attempting to use AspectJ and output all classes in debug mode (required by
our code coverage instrumentor). However any code introduced by our aspects to
production classes does not include debug line information.

Our ant script uses the iajc task as follows:

 &lt;iajc ... debug="true" .. /&gt;

We have an aspect that introduces a public, no-arguments constructor into
various classes. If I enable this aspect, then do a clean build, I get the
following error from our code coverage tool:

 [jblanket] java.lang.UnsupportedOperationException: No line numbers detected in
 com.abmuk.oms.core.model.core.XMLObject.&lt;init&gt;. Either remove the 'oneLineFile'
 tag or turn debug on when compiling.

If I remove that aspect, we get no errors about debug line information.

I've tried debug="true" or debugLevel="lines,vars,source", with no success.

This issue is preventing our Unit Test suite from executing.

If you require any further information, please don't hesitate to email me.

Cheers,

  Chris Nappin.</description>
      <comments>
		<comment id="1" date="2005-01-11 17:47:06 EST" author="Andrew Clement">We don't currently create line number information for members created in a
target type to support ITDs.  The reason is that the methods/ctors added to the
target type are simply forwarding methods that delegate to the aspect to execute
the intended behavior.  Here is a decompiled class that had a method and ctor
ITD'd upon it:

public A();
  Code:
   Stack=1, Locals=2, Args_size=1
   0:   invokestatic    #30; //Method
X.ajc$preInterConstructor$X$A:()[Ljava/lang/Object;
   3:   astore_1
   4:   aload_0
   5:   invokespecial   #11; //Method java/lang/Object."&lt;init&gt;":()V
   8:   aload_0
   9:   invokestatic    #33; //Method X.ajc$postInterConstructor$X$A:(LA;)V
   12:  return

public void sayhi();
  Code:
   Stack=1, Locals=1, Args_size=1
   0:   aload_0
   1:   invokestatic    #25; //Method X.ajc$interMethod$X$A$sayhi:(LA;)V
   4:   return

You can see in each case the body of the member in the class simply forwards the
request to an ajc$XXX method in the aspect (called X in this case).

So, any line number information we did add to the members added to a class for
ITDs would be 'fake' - as it wouldn't refer to anything that really existed in
the source file for the class.  However, we can do this - there is a precedent
in that we already do create fake line number tables for methods to support
inlined around advice.  I'm just not sure that I want to create too much 'fake'
information in everything the weaver creates just to support this use case - I
think we'd get a lot of push back about unnecessary code bloat.

But I'm keen to help you if we can - I'm currently right in the midst of our
debug support so you raised this bug at the right time :)  Is there no way the
tool can be tailored to be a little less strict on what should have debug info
attached? After all, coverage information for these delegator methods would
simply be measuring coverage of AspectJ 'generated' code - coverage of the
actual body of the ctor would count when the delegated ctor (in the aspect) was
executed.

Andy.</comment>
		<comment id="2" date="2005-01-12 04:42:28 EST" author="Chris Nappin">Thanks for looking into this so quickly! I'm not sure about your comment on 
code bloat, if compiling classes in debug mode then I'd certainly expect to 
get larger class files?

I will try to see if I can get the coverage tool we're using (JBlanket) to 
side-step these constructors as a special case. I couldn't get it to ignore 
methods previously, although it should be able to, and I'm not sure it 
supports ignoring constructors. It may be that we have to move to a different 
coverage tool, but I believe a lot of them instrument code in a very similar 
way, using classes built in debug mode, and the CGLIB or bcel libraries.

Chris.</comment>
		<comment id="3" date="2005-01-12 09:32:10 EST" author="Chris Nappin">Hi,

  I've had a play with JBlanket's exclusion mechanism and unfortunately it 
seems to work by filtering the results, rather than reducing which blocks of 
code it adds instrumentation to. I imagine that other tools work in a similar 
way. Is there any possibility that AspectJ can be updated to honour 
the "debug" flag for introduced code?

Chris. </comment>
		<comment id="4" date="2005-01-12 11:39:38 EST" author="Andrew Clement">I've just tried a comparable case that occurs in pure java - to see what happens
for generated code like this.  Here is a simple program:

public class Test {
  private int i;
  private  class Inner {
    public void aMethod() {
     System.err.println(i);
    }
  }
}

So that 'Inner' can see 'i', an accessor method for it is generated when you
compile this program, on javap -verbose I see this:

public Test();
  Code:
   Stack=1, Locals=1, Args_size=1
   0:   aload_0
   1:   invokespecial   #2; //Method java/lang/Object."&lt;init&gt;":()V
   4:   return
  LineNumberTable:
   line 1: 0
   line 6: 4

static int access$000(Test);
  Code:
   Stack=1, Locals=1, Args_size=1
   0:   aload_0
   1:   getfield        #1; //Field i:I
   4:   ireturn
  LineNumberTable:
   line 1: 0
  Synthetic: true

}

So, there is a line number table with just one entry in for the generated method
(and it is marked synthetic) - I guess we should do the same for AspectJ
generated methods !</comment>
		<comment id="5" date="2005-01-19 05:26:11 EST" author="Andrew Clement">Fix checked in - we add a single line number table entry if one does not exist
for the generated methods.  This adds 12bytes per method that previously didn't
have a table.  Creation of it could be made conditional on the value of the -g:
flag - but after some minimal testing we don't seem to respect -g:none correctly
so I'm leaving someone else to fix that in a separate bug.

I've not added extra logic to add extra synthetic markers here and there - it
doesn't seem necessary to ensure the tests pass, but I hope debuggers don't
start having problems with these unusual tables around.

Waiting for build ...</comment>
		<comment id="6" date="2005-01-19 11:12:38 EST" author="Andrew Clement">BUILD COMPLETE -  build.439
Date of build: 01/19/2005 11:53:40
Time to build: 112 minutes 16 seconds
Last changed: 01/19/2005 09:36:48
Last log entry: Fix for Bug 82570: Weaved code does not include debug lines
Latest good AspectJ jar available at:
download.eclipse.org/technology/ajdt/dev/aspectj-DEVELOPMENT.jar</comment>
		<comment id="7" date="2006-03-07 09:51:55 EST" author="Chris Nappin">Hi, I'm now trying again to introduce AspectJ into our project, but am hitting against this same issue again. 

I'm now using AspectJ 1.5.0, JDK 1.4.2 and Windows XP.

This time I have one simple Aspect that has a single "around" advice added to various classes in our project. I'm compiling using iajc with debug set to "true", but I get the following error from JBlanket:

 [jblanket] java.lang.UnsupportedOperationException: No line numbers detected in
 com.abmuk.oms.core.common.logging.Timer.ajc$around$com_abmuk_oms_core_common_lo
gging_Timer$1$e548cc5bproceed. Either remove the 'oneLineFile' tag or turn debug
 on when compiling.
 [jblanket]     at csdl.jblanket.modifier.MethodModifier.processMethod(MethodMod
ifier.java:121)
 [jblanket]     at csdl.jblanket.modifier.ClassModifier.modifyMethods(ClassModif
ier.java:123)
 [jblanket]     at csdl.jblanket.modifier.Modifier.processIncludeClasses(Modifie
r.java:282)
 [jblanket]     at csdl.jblanket.modifier.Modifier.modify(Modifier.java:520)
 [jblanket]     at csdl.jblanket.modifier.Modifier.main(Modifier.java:662)
 [jblanket]     at csdl.jblanket.ant.JBlanketModifierTask.execute(JBlanketModifi
erTask.java:366)</comment>
		<comment id="8" date="2006-03-07 12:04:42 EST" author="Andrew Clement">you could try compiling with -XnoInline to see if that helps...</comment>
		<comment id="9" date="2006-03-08 06:18:45 EST" author="Chris Nappin">Thanks for the suggestion. Unfortunately this has no affect, I still get the same error about missing line numbers:

 [jblanket] java.lang.UnsupportedOperationException: No line numbers detected in
 com.abmuk.oms.core.common.logging.Timer.ajc$around$com_abmuk_oms_core_common_lo
gging_Timer$1$e548cc5bproceed. Either remove the 'oneLineFile' tag or turn debug
 on when compiling.
 [jblanket]     at csdl.jblanket.modifier.MethodModifier.processMethod(MethodMod
ifier.java:121)
 ...

To clarify, the ant entry I'm using is as follows:

&lt;iajc sourceroots="${core.java}" destdir="${build.classes}"
 deprecation="true" debug="true" xlintwarnings="true"
 classpathref="build.path" source="1.4" target="1.4" x="noInline"/&gt;</comment>
		<comment id="10" date="2006-05-09 09:50:36 EDT" author="Chris Nappin">Hi,

  I've just re-tested with AspectJ 1.5.1a and unfortunately the fault is still present. Is there any chance the priority of this issue can be increased?

At the moment it means that none of the code executed in a Unit test environment can include any AOP code.

  Thanks,

Chris.</comment>
		<comment id="11" date="2006-05-09 12:36:38 EDT" author="Andrew Clement">let me give it some kind of priority for 1.5.2 ... not sure what I'll do for it yet tho:

- adding line number info for generated code is a bogus as the code never existed in source....
- adding synthetic attribute to the code may be something we have to look into again, or ... maybe the bridge flag makes sense actually for some of these ...
- asking jblanket to respect the ajsynthetic attribute in addition to the synthetic attribute would be another option...</comment>
		<comment id="12" date="2006-05-11 05:21:01 EDT" author="Chris Nappin">Hi, thanks for considering to resolve this issue.

&gt; - adding line number info for generated code is a bogus as the code 
&gt; never existed in source....

I thought the result of your investigation on the Sun javac compiler (comment #4 below) was that it generates "bogus" line numbers if in debug mode, and aspectj should merely do the same?

&gt; - asking jblanket to respect the ajsynthetic attribute in addition to the
&gt; synthetic attribute would be another option...

I have tried out a few other Code Coverage tools and they also suffer from the same problem. Rather than changing every code coverage tool on the market it might be easier to change aspectj?

If you require any further info to help you out, please just let me know.

Thanks,

  Chris Nappin.</comment>
		<comment id="13" date="2006-05-16 07:45:40 EDT" author="Andrew Clement">I just committed a change to add blank line number tables for the XXXproceed() method you are hitting and aspectOf/hasAspect methods - we should investigate proper use of synthetic but this is a suitable temporary workaround as we dont have the time to do that investigation right now.  When the dev build is available I will close this bug report.</comment>
		<comment id="14" date="2006-05-16 09:46:34 EDT" author="Andrew Clement">dev build is available with the proposed changes in.  There may be other methods that exhibit this problem .. please reopen this if you come across them.</comment>
		<comment id="15" date="2006-05-16 10:17:23 EDT" author="Chris Nappin">Thanks, downloading the latest development build that seems to have resolved all our use of Aspects so far.

Do you know when the 1.5.2 release is expected to be available?</comment>
		<comment id="16" date="2006-05-16 10:38:34 EDT" author="Andrew Clement">from our plans page :

http://www.eclipse.org/aspectj/plans.php

we are looking at end of June 2006 for 1.5.2</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="71966e3348a05cb99b88885b8e6b751cc61a638e" author="aclement" date="2005-01-19 06:36:46"/>
          <file name="tests/bugs150/PR82570_1.java">
          </file>
          <file name="tests/src/org/aspectj/systemtest/ajc150/Ajc150TestsNoHarness.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java">
              <method name="packBody" returnType="void" parameters="MethodGen"/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="142165" opendate="2006-5-17 4:37:00" fixdate="2006-5-17 6:02:00">
    <buginformation>
      <summary>rewriting XML concretized pointcuts doesnt work for AND construct</summary>
      <description>the scheme used to rewrite pointcuts defined in XML that use AND doesnt work, they get mangled.</description>
      <comments>
		<comment id="1" date="2006-05-17 05:35:01 EDT" author="Andrew Clement">Here are two examples:

xml pointcut:

"within(SomeType) AND execution(* foo(..))"

transformed to:

"within(SomeType)within(SomeType)execution(* foo(..))"

parsed (yes, parsed!) as:

"within(SomeType)"

the weaver will proceed having discarded the execution part of the pointcut (!)


Example 2:

original="within(*) AND call(* foo(..))"
transformed="within(C)within(C)call(* foo(..))"
parsedAs="within(C)"

matching rather more joinpoints than you'd hope...</comment>
		<comment id="2" date="2006-05-17 06:02:05 EDT" author="Andrew Clement">fix committed and tests added.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="7d9a7287ee1aef66ba2edf55ef2fec2bf95b0dc3" author="aclement" date="2006-05-17 07:04:47"/>
          <file name="tests/src/org/aspectj/systemtest/ajc152/Ajc152Tests.java">
          </file>
          <file name="util/src/org/aspectj/util/LangUtil.java">
              <method name="replace" returnType="String" parameters="String String String"/>
          </file>
          <file name="weaver/src/org/aspectj/weaver/bcel/AtAjAttributes.java">
              <method name="parsePointcut" returnType="Pointcut" parameters="String AjAttributeStruct boolean"/>
          </file>
          <file name="weaver/src/org/aspectj/weaver/patterns/PatternParser.java">
              <method name="peek" returnType="boolean" parameters="String"/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="141956" opendate="2006-5-16 5:12:00" fixdate="2006-5-18 6:41:00">
    <buginformation>
      <summary>Null Pointer Exception when trying to skip Parent Mungers.</summary>
      <description>I don't know much about the internal workings of aspectJ but this bug keeps popping up so I went through the trouble of checking of trying to debug it so that I could hopefully provide enough information to get it fixed.

This happens while using eclipse AJDT. It never happens if I fully do a clean before rebuild. It only seems to happen when doing incrmental builds (using  the project-&gt;build automatically setting). 

The error happens in the iterator that recursively builds a list of methods
to return for matching. The error is triggered here:


    // we need to know if it is an interface from Parent kind munger
            // as those are used for @AJ ITD and we precisely want to skip those
            boolean shouldSkip = false;
            for (int j = 0; j &lt; rtx.interTypeMungers.size(); j++) {
                ConcreteTypeMunger munger = (ConcreteTypeMunger) rtx.interTypeMungers.get(j);
                if (munger.getMunger().getKind() == ResolvedTypeMunger.Parent) {
                    shouldSkip = true;
                    break;
                }
            }

munger.getMunger() returns null because the munger instance is a BcelPerClauseAspectAdder. My naive fix would be to check munger.getMunger() == null or check munger.getKind(). I'm assuming that BcelPerClausAspectAdder is one that should be skipped since it is related to @AJ ??? 

Again, I don't know very much about the internal architecture of the weaver magic so I hope this is enough information. 

I would appreciate it if someone who knows more of the internals could speculate as to why this bug would never pop up on a clean build but only on incremental builds? Also it's not on all incremental builds and I haven't been able to isolate what kind of changes or compiles it triggers this, although it seems that  once I got the exception once, I keep getting it on every build until I do a clean. 

java.lang.NullPointerException
at org.aspectj.weaver.ResolvedType.addAndRecurse(ResolvedType.java:288)
at org.aspectj.weaver.ResolvedType.getMethodsWithoutIterator(ResolvedType.java:257)
at org.aspectj.weaver.ResolvedType.lookupResolvedMember(ResolvedType.java:378)
at org.aspectj.weaver.JoinPointSignatureIterator.findSignaturesFromSupertypes(JoinPointSignatureIterator.java:178)
at org.aspectj.weaver.JoinPointSignatureIterator.hasNext(JoinPointSignatureIterator.java:69)
at org.aspectj.weaver.patterns.SignaturePattern.matches(SignaturePattern.java:287)
at org.aspectj.weaver.patterns.KindedPointcut.matchInternal(KindedPointcut.java:103)
at org.aspectj.weaver.patterns.Pointcut.match(Pointcut.java:144)
at org.aspectj.weaver.patterns.AndPointcut.matchInternal(AndPointcut.java:51)
at org.aspectj.weaver.patterns.Pointcut.match(Pointcut.java:144)
at org.aspectj.weaver.ShadowMunger.match(ShadowMunger.java:64)
at org.aspectj.weaver.Advice.match(Advice.java:109)
at org.aspectj.weaver.bcel.BcelAdvice.match(BcelAdvice.java:104)
at org.aspectj.weaver.bcel.BcelClassWeaver.match(BcelClassWeaver.java:2210)
at org.aspectj.weaver.bcel.BcelClassWeaver.match(BcelClassWeaver.java:1752)
at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:479)
at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:109)
at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1574)
at org.aspectj.weaver.bcel.BcelWeaver.weaveWithoutDump(BcelWeaver.java:1525)
at org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify(BcelWeaver.java:1305)
at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1127)
at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave(AjCompilerAdapter.java:321)
at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling(AjCompilerAdapter.java:192)
at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$afterReturning$org_aspectj_ajdt_internal_compiler_CompilerAdapter$2$f9cc9ca0(CompilerAdapter.aj:70)
at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:367)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:862)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:269)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.incrementalBuild(AjBuildManager.java:168)
at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:117)
at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)</description>
      <comments>
		<comment id="1" date="2006-05-16 08:17:37 EDT" author="Andrew Clement">There are certainly situations where errors only occur on incremental compilation - we record state during the full build to optimize subsequent incremental builds.  
I don't fully understand what is going wrong in this scenario though - from the description I might expect it to happen on a full build, so there is possibly something more serious lurking.  It needs the combination of a perclause of some kind and using @AJ syntax, is your aspect particularly complicated?

To just help you progress I am tempted to put in your simple null check extension to that test if we can't work out a simplistic scenario in which this happens reliably.

You could try running with the AJDT event trace open - it will tell us exactly what is getting recompiled/rewoven on an incremental build and that may give us a clue as to what is happening.  (You might have to press some magic switch to get the event trace to produce all its diagnostics info, either on the view window itself or in the AspectJ project/workbench properties).</comment>
		<comment id="2" date="2006-05-16 11:37:26 EDT" author="Daniel Tabuenca">The aspect is fairly simple: 

@Aspect
public class ExpirableToucher {

 @Before("within(com.residencycentral.app.Expirable+) &amp;&amp; execution(public * *(..)) &amp;&amp; !execution(* touch()) &amp;&amp; target(target)")
 public void touchBeforeExecute(Expirable target) {
  target.touch();
 }
}


I will try my best to figure out the circumstances that reproduce this bug.</comment>
		<comment id="3" date="2006-05-16 12:22:26 EDT" author="Daniel Tabuenca">Is this the trace?

trouble in: 
public abstract class com.residencycentral.tapestry.pages.residency.html.SurveyReport extends com.residencycentral.tapestry.pages.residency.html.ModuleBasedPage:
  private static final String SURVEY_REPORT_MODULE_NAME = "SurveyReportModule"
  public void &lt;init&gt;():
                    ALOAD_0     // Lcom/residencycentral/tapestry/pages/residency/html/SurveyReport; this   (line 11)
                    INVOKESPECIAL com.residencycentral.tapestry.pages.residency.html.ModuleBasedPage.&lt;init&gt; ()V
    constructor-execution(void com.residencycentral.tapestry.pages.residency.html.SurveyReport.&lt;init&gt;())
    |               RETURN
    constructor-execution(void com.residencycentral.tapestry.pages.residency.html.SurveyReport.&lt;init&gt;())
  end public void &lt;init&gt;()

  public abstract org.apache.tapestry.IAsset getStyleSheet()    org.aspectj.weaver.MethodDeclarationLineNumber: 17:584
;

  protected void attachNewModule()    org.aspectj.weaver.MethodDeclarationLineNumber: 20:633
:
                    ALOAD_0     // Lcom/residencycentral/tapestry/pages/residency/html/SurveyReport; this   (line 21)
                    LDC "SurveyReportModule"
                    INVOKEVIRTUAL com.residencycentral.tapestry.pages.residency.html.SurveyReport.attachNewModule (Ljava/lang/String;)V
                    RETURN   (line 22)
  end protected void attachNewModule()

  private com.residencycentral.survey.modules.SurveyReportModule getSurveyReportModule()    org.aspectj.weaver.MethodDeclarationLineNumber: 24:740
:
                    ALOAD_0     // Lcom/residencycentral/tapestry/pages/residency/html/SurveyReport; this   (line 25)
                    INVOKEVIRTUAL com.residencycentral.tapestry.pages.residency.html.SurveyReport.getModule ()Lcom/residencycentral/app/ApplicationModule;
                    CHECKCAST com.residencycentral.survey.modules.SurveyReportModule
                    ARETURN
  end private com.residencycentral.survey.modules.SurveyReportModule getSurveyReportModule()

  public java.util.List getReportEntries()    org.aspectj.weaver.MethodDeclarationLineNumber: 28:849
:
                    ALOAD_0     // Lcom/residencycentral/tapestry/pages/residency/html/SurveyReport; this   (line 29)
                    INVOKESPECIAL com.residencycentral.tapestry.pages.residency.html.SurveyReport.getSurveyReportModule ()Lcom/residencycentral/survey/modules/SurveyReportModule;
                    INVOKEINTERFACE com.residencycentral.survey.modules.SurveyReportModule.getReportEntries ()Ljava/util/List;
                    ARETURN
  end public java.util.List getReportEntries()

  public String getColumnsExpression()    org.aspectj.weaver.MethodDeclarationLineNumber: 34:952
:
                    LDC "procedure:Procedure:procedure.description"   (line 36)
                    ASTORE_1
                    ALOAD_0     // Lcom/residencycentral/tapestry/pages/residency/html/SurveyReport; this   (line 37)
                    INVOKESPECIAL com.residencycentral.tapestry.pages.residency.html.SurveyReport.getSurveyReportModule ()Lcom/residencycentral/survey/modules/SurveyReportModule;
                    INVOKEINTERFACE com.residencycentral.survey.modules.SurveyReportModule.getSurveyOptions ()Ljava/util/List;
                    INVOKEINTERFACE java.util.List.iterator ()Ljava/util/Iterator;
                    ASTORE_3
                    GOTO L1
                L0: ALOAD_3
                    INVOKEINTERFACE java.util.Iterator.next ()Ljava/lang/Object;
                    CHECKCAST com.residencycentral.survey.SurveyOption
                    ASTORE_2
                    NEW java.lang.StringBuilder   (line 38)
                    DUP
                    ALOAD_1     // Ljava/lang/String; expression
                    INVOKESTATIC java.lang.String.valueOf (Ljava/lang/Object;)Ljava/lang/String;
                    INVOKESPECIAL java.lang.StringBuilder.&lt;init&gt; (Ljava/lang/String;)V
                    LDC ","
                    INVOKEVIRTUAL java.lang.StringBuilder.append (Ljava/lang/String;)Ljava/lang/StringBuilder;
                    ALOAD_2     // Lcom/residencycentral/survey/SurveyOption; option
                    INVOKEINTERFACE com.residencycentral.survey.SurveyOption.getId ()Ljava/lang/Long;
                    INVOKEVIRTUAL java.lang.StringBuilder.append (Ljava/lang/Object;)Ljava/lang/StringBuilder;
                    LDC ":"
                    INVOKEVIRTUAL java.lang.StringBuilder.append (Ljava/lang/String;)Ljava/lang/StringBuilder;
                    ALOAD_2     // Lcom/residencycentral/survey/SurveyOption; option
                    INVOKEINTERFACE com.residencycentral.survey.SurveyOption.getLabel ()Ljava/lang/String;
                    INVOKEVIRTUAL java.lang.StringBuilder.append (Ljava/lang/String;)Ljava/lang/StringBuilder;
                    LDC ":getCountForAnswer("   (line 39)
                    INVOKEVIRTUAL java.lang.StringBuilder.append (Ljava/lang/String;)Ljava/lang/StringBuilder;
                    ALOAD_2     // Lcom/residencycentral/survey/SurveyOption; option
                    INVOKEINTERFACE com.residencycentral.survey.SurveyOption.getId ()Ljava/lang/Long;
                    INVOKEVIRTUAL java.lang.StringBuilder.append (Ljava/lang/Object;)Ljava/lang/StringBuilder;
                    LDC ")"
                    INVOKEVIRTUAL java.lang.StringBuilder.append (Ljava/lang/String;)Ljava/lang/StringBuilder;
                    INVOKEVIRTUAL java.lang.StringBuilder.toString ()Ljava/lang/String;   (line 38)
                    ASTORE_1     // Ljava/lang/String; expression
                L1: ALOAD_3   (line 37)
                    INVOKEINTERFACE java.util.Iterator.hasNext ()Z
                    IFNE L0
                    ALOAD_1     // Ljava/lang/String; expression   (line 41)
                    ARETURN
  end public String getColumnsExpression()

end public abstract class com.residencycentral.tapestry.pages.residency.html.SurveyReport

when weaving type com.residencycentral.tapestry.pages.residency.html.SurveyReport
when weaving classes 
when weaving 
when incrementally building BuildConfig[H:\programming\workspace\.metadata\.plugins\org.eclipse.ajdt.core\residency.generated.lst] #Files=367</comment>
		<comment id="4" date="2006-05-16 18:00:07 EDT" author="Daniel Tabuenca">Ok I have debugged some more and I think I'm closer to the source of the bug.

When I do a clean and compile, in BcelWeaver.prepareForWeave() it sets the typeMunger list on line 464:
    typeMungerList = xcutSet.getTypeMungers();
    lateTypeMungerList = xcutSet.getLateTypeMungers();
    declareParentsList = xcutSet.getDeclareParents();

when going from a clean compile xcutSet.getTypeMungers() returns a bunch of mungers but not the BcelPerClauseAspectAdder munger that is the source of 
the segfault later on. 

the BcelPerClauseApectAdder is returned by the second call to xcutSet.getLateTypeMungers(), but this is fine because this list is not checked in the code that caused the segfault.

When doing the incremental compile,  the xcutSet.getTypeMungers() gets modified by org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.finishTypeMungers():

// XXX by Andy: why do we mix up the mungers here? it means later we know about 
// two sets and the late ones are a subset of the complete set? (see pr114436)
        baseTypeMungers.addAll(getWorld().getCrosscuttingMembersSet().getLateTypeMungers());

I'm not sure why this is done or what it does as I don't really understand all the inner workings of AspectJ. But what happens is now those LateTypeMungers (which include the BcelPerClauseAspectAdder mungers that cause the problem) now get added to the list returned by xcutSet.getTypeMungers();.

In fact, it seems this is not intended, because if I edit the code and recompile 
several times, it keeps appending those BcelPerClauseAspectAdder to the end of the list so after a while I have 5-6 mungers followed by 40+ BcelPerClauseAspectAdder mungers. 

I'd appreciate any further clarification of what this code does and how it could be fixed. I don't fully understand  what the BcelPerClauseAspectAdder does or what a LateTypeMunger is or why it is merged... etc... but I hope the debugging information I'm providing can get this solved soon.</comment>
		<comment id="5" date="2006-05-17 07:51:09 EDT" author="Andrew Clement">More good work Daniel ;)

based on what you have said, I've created a testcase that shows us leaking the typemungers on incremental compiles.

Late type mungers are 'special' ones that can only perform their job after the pointcuts have been matched and the advice applied.  (Normal type mungers are applied before the pointcuts are matched and advice is applied - here 'normal' means things like ITDs).

The BcelPerClauseAspectAdder creates the methods aspectOf() and hasAspect() - for each kind of aspect these vary depending on the per clause in use.  Specifying no perclause means you get the default of 'persingleton'.  In the old days before annotation style development came along, the compiler generated aspectOf() and hasAspect().  Nowadays with annotation style it is possible the aspect is built using regular javac - which won't create these aspectof()/hasAspect() methods.  So the BcelPerClauseAdder was created which adds these methods at weave time for @AJ aspects.

As you have discovered, I put a comment in the code against something another developer did:

// XXX by Andy: why do we mix up the mungers here? it means later we know about 
// two sets and the late ones are a subset of the complete set? (see pr114436)
       
baseTypeMungers.addAll(getWorld().getCrosscuttingMembersSet().getLateTypeMungers());

which I wanted to revisit at some point when I had time to investigate. Now based on my testcase and your observation about the collection constantly growing on compiles, I've removed that line of code.  All our tests continue to execute fine.  I have also put in the guard for a null munger that was described in the initial comment in this bug report.  So the code should be much more reliable now.

the fixes will be in a dev build shortly, then in an AJDT build a little after that.
thanks for the investigation work!</comment>
		<comment id="6" date="2006-05-17 11:18:07 EDT" author="Andrew Clement">fix available in latest AJ dev build.</comment>
		<comment id="7" date="2006-05-18 06:41:37 EDT" author="Andrew Clement">fixed.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="5f6a6b12c560f80dd720a943c4c63cf8dc182cc3" author="aclement" date="2006-05-17 08:38:39"/>
          <file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java">
          </file>
          <file name="tests/multiIncremental/PR141956/base/A.java">
          </file>
          <file name="tests/multiIncremental/PR141956/base/C.java">
          </file>
          <file name="tests/multiIncremental/PR141956/inc1/C.java">
          </file>
          <file name="tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/ResolvedType.java">
              <method name="addAndRecurse" returnType="void" parameters="Set List ResolvedType boolean boolean"/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="138171" opendate="2006-4-24 0:19:00" fixdate="2006-5-18 6:49:00">
    <buginformation>
      <summary>Internal compilation error while copying resources</summary>
      <description>This is with 1.5.1a.

I am developing a web application and I ran into this compiler crash.
The resource to be copied (Thumbs.db) was in use and therefore could
not be copied. However, AJC ended up producing an internal error instead
of a warning or a normal error.

java.io.FileNotFoundException
at java.io.FileOutputStream.open(Native Method)
at java.io.FileOutputStream.&lt;init&gt;(FileOutputStream.java:179)
at java.io.FileOutputStream.&lt;init&gt;(FileOutputStream.java:131)
at org.aspectj.util.FileUtil.makeOutputStream(FileUtil.java:1258)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.writeResource(AjBuildManager.java:504)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.copyResourcesFromFile(AjBuildManager.java:482)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.copyResourcesToDestination(AjBuildManager.java:424)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:320)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:161)
at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:122)
at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)

FileNotFoundException thrown: C:\work\workspace\MyCompany\class\images\Thumbs.db (Access is denied)</description>
      <comments>
		<comment id="1" date="2006-05-10 13:33:42 EDT" author="Wes Isberg">The problem is not that the compiler fails, but the message isn't nice.  But errors I think are restricted to compile-time errors - not unexpected exceptions stemming from configuration errors.

I don't see a clean way around the verbosity, but I agree with the sentiment.  It would be nice if for every stack trace stemming from a user or environment error we could guess  what the error was a provide instructions on how to fix - or at least note for IOExceptions the affected file in an error message.  Here I think the message (at the bottom) is clear enough, but printing the stack might be unnecessary.  But I don't think we can know for all these whether to print the stack; we might know it in FileUtil.makeOutputStream(..) or in all the callers thereof, but we can't really call it a compiler error so it ends up being an abort, handled like all the others.

Reopen if you disagree, but I don't see a clean fix for this class of problems, and a point fix for this case introduces a new kind of error.  It might be that we create a new message kind, AbortWarning, which stops processing but by convention only emits a message and not a trace.  that crosscutting smell.</comment>
		<comment id="2" date="2006-05-10 19:35:42 EDT" author="Ramnivas Laddad">Any stack trace produced by a compiler is very unnerving to user--new or old.
It reduces confidence in the tool due to a dobut that there may be more 
problems not yet known. I don't remember, for example, Javac ever producing 
a stack trace.

Here I can see a nice message produced by the compiler:
Error copying resources: C:\work\workspace\MyCompany\class\images\Thumbs.db (Access is denied)

Here is an advice that would do the job (not that I am suggesting this as necessarily a good way of implementing, but only as a possible way):
Object around() : execution(* FileUtil.makeOutputStream(..))
      &amp;&amp; cflow(execution(* AjBuildManager.copyResourcesToDestination(..))) {
    try {
         return proceed();
    } catch (IOException ex) { // or perhaps even Exception
         printError("Error copying resources: " + ex.getMessage());
    }
}</comment>
		<comment id="3" date="2006-05-18 02:51:05 EDT" author="Andrew Clement">*** Bug 142383 has been marked as a duplicate of this bug. ***</comment>
		<comment id="4" date="2006-05-18 04:18:51 EDT" author="Andrew Clement">I've fixed this - now a proper error is produced for this case rather than a stack trace.  My fix is a *bit* like Ramnivas' aspect hand coded ;)

fix will be in next dev build.</comment>
		<comment id="5" date="2006-05-18 06:49:07 EDT" author="Andrew Clement">fix available.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="21720a06321ea83f9969e8be58c520480fca4b09" author="aclement" date="2006-05-18 05:04:07"/>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="125480" opendate="2006-1-27 9:48:00" fixdate="2006-5-18 7:44:00">
    <buginformation>
      <summary>[ltw] aop.xml aspect generator treats abstract methods as pointcuts</summary>
      <description>An aop.xml aspect cannot inherit an abstract method but it should inherit one that has already been made concrete in a super-aspect. At the moment an abstract method "test()" causes the follow error during LTW:

info AspectJ Weaver Version DEVELOPMENT built on 
info register classloader org.aspectj.weaver.loadtime.WeavingURLClassLoader
info using /C:/temp/ajcSandbox/ajcTest6462.tmp/META-INF/aop.xml
error Abstract pointcut 'test' not configured: &lt;concrete-aspect name='TraceHelloWorld' extends='ConcreteMethods'/&gt; in aop.xml
warning register definition failed -- (AbortException) Abstract pointcut 'test' not configured: &lt;concrete-aspect name='TraceHelloWorld' extends='ConcreteMethods'/&gt; in aop.xml
Abstract pointcut 'test' not configured: &lt;concrete-aspect name='TraceHelloWorld' extends='ConcreteMethods'/&gt; in aop.xml
Message: error Abstract pointcut 'test' not configured: &lt;concrete-aspect name='TraceHelloWorld' extends='ConcreteMethods'/&gt; in aop.xml
org.aspectj.bridge.AbortException: Abstract pointcut 'test' not configured: &lt;concrete-aspect name='TraceHelloWorld' extends='ConcreteMethods'/&gt; in aop.xml</description>
      <comments>
		<comment id="1" date="2006-01-27 09:53:49 EST" author="Matthew Webster">Created attachment 33704 [details]
Testcase (combined with 125875)</comment>
		<comment id="2" date="2006-05-18 07:44:10 EDT" author="Andrew Clement">hmmm - shame matthews test doesn't actually fail when it doesnt work !  I just glanced at this bug and went to find it in ajc151tests - it already exists and is committed, it should be failing as I see an AbortException as mentioned in the abstract, but it doesnt.  I suspect it got committed with the patch for 125475 since the patches in each of these bugs included tests for both bugs.

I fixed the test so it now fails properly - I also created a second variant where the super aspect is annotation style.

The code looking at concretizing pointcuts in XML makes no allowance for whether the abstract method is a pointcut or not.  I modified it to actually check for @Pointcut (seems reasonable!) before barfing.

I moved the tests into ajc152

it also revealed a new bug - we have no logic that verifies there aren't abstract methods leftover in the hierarchy of an aspect we are trying to concretize in XML.  We simply ignore them, go ahead and create the concrete aspect and then crash with an abstract method error at runtime.  I'll raise a new bug for this...

tests/fixes committed</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="2b5329c2a672ff32f8c941f0c56e475ea58ce5f3" author="aclement" date="2006-01-30 07:22:10"/>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="132349" opendate="2006-3-17 10:54:00" fixdate="2006-5-23 10:04:00">
    <buginformation>
      <summary>Inter-Type Declaration on nested class in generic type: IllegalStateException</summary>
      <description>Using the 1.5 compiler from the 20th of December or Eclipse with the AJDT plugin 1.5.0.20051220093604 to compile the following code:

public class TopLevelType&lt;E&gt; {
	public static class NestedType {}
}

aspect SomeAspect {
	public void TopLevelType.NestedType.someMethod() {
	}
}

results in: 

C:\Dokumente und Einstellungen\Michi\Eigene Dateien\Temp\tmp\TopLevelType.java [error] Internal compiler error
java.lang.IllegalStateException: Use generic type, not parameterized type
	at org.aspectj.weaver.ResolvedTypeMunger.&lt;init&gt;(ResolvedTypeMunger.java:69)
	at org.aspectj.weaver.NewMethodTypeMunger.&lt;init&gt;(NewMethodTypeMunger.java:28)
	at org.aspectj.ajdt.internal.compiler.ast.InterTypeMethodDeclaration.build(InterTypeMethodDeclaration.java:197)
	at org.aspectj.ajdt.internal.compiler.ast.AspectDeclaration.buildInterTypeAndPerClause(AspectDeclaration.java:1066)
	at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.buildInterTypeAndPerClause(AjLookupEnvironment.java:442)
	at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.collectAllITDsAndDeclares(AjLookupEnvironment.java:326)
	at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.completeTypeBindings(AjLookupEnvironment.java:168)
	at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.beginToCompile(Compiler.java:301)
	at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:315)
	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:811)
	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:230)
	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:156)
	at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:112)
	at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:60)
	at org.aspectj.tools.ajc.Main.run(Main.java:326)
	at org.aspectj.tools.ajc.Main.runMain(Main.java:240)
	at org.aspectj.tools.ajc.Main.main(Main.java:83)

(no source information available)
ABORT
	
Exception thrown from AspectJ 1.5.0

This might be logged as a bug already -- find current bugs at
  http://bugs.eclipse.org/bugs/buglist.cgi?product=AspectJ&amp;component=Compiler

Bugs for exceptions thrown have titles File:line from the top stack, 
e.g., "SomeFile.java:243"

If you don't find the exception below in a bug, please add a new bug
at http://bugs.eclipse.org/bugs/enter_bug.cgi?product=AspectJ
To make the bug a priority, please include a test program
that can reproduce this exception.
Use generic type, not parameterized type

when collecting itds and declares SomeAspect
when completing type bindings 
when batch building with classpath: C:\Programme\Java\jre1.5.0_06\lib\ext\dnsns.jar;C:\Programme\Java\jre1.5.0_06\lib\ext\localedata.jar;C:\Programme\Java\jre1.5.0_06\lib\ext\sunjce_provider.jar;C:\Programme\Java\jre1.5.0_06\lib\ext\sunpkcs11.jar;C:\Programme\Java\aspectj1.5\lib\aspectjrt.jar;
Use generic type, not parameterized type
java.lang.IllegalStateException: Use generic type, not parameterized type
	at org.aspectj.weaver.ResolvedTypeMunger.&lt;init&gt;(ResolvedTypeMunger.java:69)
	at org.aspectj.weaver.NewMethodTypeMunger.&lt;init&gt;(NewMethodTypeMunger.java:28)
	at org.aspectj.ajdt.internal.compiler.ast.InterTypeMethodDeclaration.build(InterTypeMethodDeclaration.java:197)
	at org.aspectj.ajdt.internal.compiler.ast.AspectDeclaration.buildInterTypeAndPerClause(AspectDeclaration.java:1066)
	at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.buildInterTypeAndPerClause(AjLookupEnvironment.java:442)
	at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.collectAllITDsAndDeclares(AjLookupEnvironment.java:326)
	at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.completeTypeBindings(AjLookupEnvironment.java:168)
	at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.beginToCompile(Compiler.java:301)
	at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:315)
	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:811)
	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:230)
	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:156)
	at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:112)
	at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:60)
	at org.aspectj.tools.ajc.Main.run(Main.java:326)
	at org.aspectj.tools.ajc.Main.runMain(Main.java:240)
	at org.aspectj.tools.ajc.Main.main(Main.java:83)


1 fail|abort, 1 error</description>
      <comments>
		<comment id="1" date="2006-03-17 12:22:29 EST" author="Andrew Clement">also fails with the latest HEAD copy of the compiler.  Problem is incorrectly parsing the target type for the ITD.</comment>
		<comment id="2" date="2006-03-28 04:35:37 EST" author="Andrew Clement">testcase committed</comment>
		<comment id="3" date="2006-05-22 06:25:16 EDT" author="Andrew Clement">fix committed - waiting on build</comment>
		<comment id="4" date="2006-05-23 10:04:28 EDT" author="Andrew Clement">fix available.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="4cbd5456f8d8886579970939d58992d32a1746bd" author="aclement" date="2006-03-28 06:34:35"/>
          <file name="tests/bugs151/pr126560/pkg1/A.java">
          </file>
          <file name="tests/bugs151/pr126560/pkg1/C.java">
          </file>
          <file name="tests/bugs151/pr126560/pkg2/InOneFile.java">
          </file>
          <file name="tests/bugs151/pr132349/TopLevelType.java">
          </file>
          <file name="tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/bcel/AtAjAttributes.java">
              <method name="makeSourceLocation" returnType="ISourceLocation" parameters="IHasPosition"/>
          </file>
          <file name="weaver/src/org/aspectj/weaver/patterns/SimpleScope.java">
              <method name="lookupType" returnType="UnresolvedType" parameters="String IHasPosition"/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="72528" opendate="2004-8-24 14:21:00" fixdate="2006-5-30 8:49:00">
    <buginformation>
      <summary>around advice throws java.lang.VerifyError at runtime</summary>
      <description>I have an aspect that captures around() a pcd and returns an Object[], though
the actual methods being instrumented might return any valid POJO array, i
understand that AspectJ will take care of casting at assignment.

I expected the following code to work properly, but at runtime i get a
java.lang.VerifyError as shown below:

F:\wd\Hello&gt;ajbrowser HelloWorld.lst
java.lang.VerifyError: (class: de/rohith/PrinterWorld, method: returnArrayWithCl
oning signature: ()[Ljava/lang/Integer;) Incompatible argument to function
        at de.rohith.HelloWorld.main(HelloWorld.java:18)
Exception in thread "main"

I suspect the compiler fails to notice the return types of the methods being
caught at compile time.

I have tested this code with both ajbrowser as well as AJDT, both result in the
same error output.

-----------HelloWorldAspect.java---------------
package de.rohith;

import java.lang.Object;

public aspect HelloWorldAspect {
    
	private int callDepth = -1;

    public HelloWorldAspect() {
    }
    
    pointcut hello(): !within(HelloWorldAspect);
    
    pointcut method(): execution(public (*[]) de..*(..));
    
    pointcut cloning(): call(* java.lang.Object.clone());

    declare warning: method() &amp;&amp; hello(): "*[] returning method called" ;
    
    Object[] around(): cflow(method()) &amp;&amp; cloning() &amp;&amp; hello() {
    	print("", thisEnclosingJoinPointStaticPart);
    	Object[] ret = proceed(); 
    	return (Object[])ret.clone();
    }

    private void print(String prefix, Object message) {
        for (int i = 0, spaces = callDepth * 2; i &lt; spaces; i++) {
            System.out.print(" ");
        }
        System.out.println(prefix + message);
    }

}


-----------PrinterWorld.java------------
package de.rohith;
public class PrinterWorld {
	private Integer[] intArray = new Integer[2];
	public PrinterWorld() {
		
	}
    public void print() {
        System.out.println("Hello World!"); 
    }
    
    public Integer returnInt() {
    	return new Integer(3);
    }
    
    public Integer[] returnArrayWithCloning() {
    	for (int i = 0; i &lt; intArray.length; i++) {
			intArray[i] = new Integer(i++);
		}
    	return (Integer[])intArray.clone();
    }
    
    public Integer[] returnArrayWithoutCloning() {
    	return intArray;
    }
}

-----------HelloWorld.java------------
package de.rohith;

public class HelloWorld {

    public static void main(String[] args) {
        PrinterWorld p = new PrinterWorld();
        p.print(); 
        Integer i = p.returnInt();
        Integer[] intArray = p.returnArrayWithCloning();
        Integer[] array2 = p.returnArrayWithoutCloning();
    }
}</description>
      <comments>
		<comment id="1" date="2004-08-24 14:29:09 EDT" author="Rohith Ajjampur">Created attachment 14155 [details]
Contains all the classes to reproduce this bug</comment>
		<comment id="2" date="2004-08-24 15:49:57 EDT" author="Adrian Colyer">This is almost certainly related to the bug in the handling of [] in type 
patterns, as reported in bug 72531. Any verify error is serious and we will fix 
this in the 1.2.1 release. I'll post to this bug report as soon as a fix is 
available for download from the AspectJ download page.</comment>
		<comment id="3" date="2004-08-25 13:15:16 EDT" author="Adrian Colyer">This turns out to be a really interesting bug. The problem is that in 
'marshalling' the parameters to call the around body, ajc gets confused and 
thinks that the target of the call (the intArray) is a Foo, and generates a line 
of code of the form:

Foo foo = intArray;

this is what causes the verify error.

This is all wrapped up in the special treatment of array types and of the clone 
method. Note that clone() is redefined for an array type, to be public (you 
can't just call clone on an arbitrary Object), and to return a shallow copy of 
the array. But where does this special redefinition of the clone() method happen 
(in which type??). It's this unique combination of factors - a redefined method 
on a 'special' type that is causing the confusion. I'm off to spend some time 
reading in the JVM and JLS specs to see what they have to say on the topic 
before deciding on the right fix.... </comment>
		<comment id="4" date="2004-08-25 13:22:44 EDT" author="Adrian Colyer">JSL 10.7.....</comment>
		<comment id="5" date="2004-08-25 13:28:50 EDT" author="Erik Hilsdale">this is not the first time those magical JLS 10.7 array members cause trouble.
We're already special casing the length field somewhere (actually, it's 
more special since it is represented in bytecode by the ARRAYLENGTH bytecode
and not by a field at all).  </comment>
		<comment id="6" date="2004-08-25 13:34:25 EDT" author="Erik Hilsdale">related to Bug 67665 </comment>
		<comment id="7" date="2004-08-26 06:06:22 EDT" author="Rohith Ajjampur">I understand from JLS 10.7 that it is unclear what type represents an array type
at runtime, but if this bug is related to Bug 67665 then i think the basic
assumption that AspectJ supports all the Java types fails. According to JLS
10.1, an array is a Java type. Another reason i would assume that arrays are
supported as types is in "AspectJ 1.1 quick refernce" among TypePat it clearly
mentions that it accepts an array type.</comment>
		<comment id="8" date="2004-08-26 10:24:02 EDT" author="Erik Hilsdale">when I said it was related to Bug 67665, I meant that I raised
_implementation_ issues of treatment of 
.length and .clone() there, and that there are some cleanup issues with
array syntax there as well.  

I don't think 10.7 is at all unclear about what types represent at runtime.
Array types are types.  They have some methods and one field.  We need to 
capture calls to those methods (and accesses and assignments to that field)
as join points.  Nobody is talking about language changes here.  We're
talking about fixing a bug, and I noted that array treatment in general
is a place where we've had bugs before.</comment>
		<comment id="9" date="2004-09-03 09:51:14 EDT" author="Andrew Clement">Ok - fix checked in.  What I've done is what we thought we'd have to do.  When
we grab the target for a method-call shadow and we recognize it as being one of
these nasty clone calls on Object, I have a quick look before the shadow to see
what the 'thing' is on the stack.  There are a number of possibilities (that I
have captured in the testcase), basically we might encounter:

- a load instruction, in which case we ask the instruction what type it is
working with (querying the local variable tag) and this helps us work out that
it is an array.

- a field access instruction, in which case we ask the field what type it is.

- a anewarray instruction, in which case we *know* its an array (although why
anyone would write '(Integer[])new Integer[5].clone()' I dont know!)

- a multianewarray instruction, in which case *know* its an array.

I've put a lot of guards in so that we don't do this extra processing unless it
meets the criteria of being this nasty case.  It will also blow up if it
encounters an instruction other than those expected when trying to determine the
real type of the target - if we didn't blow up then we would fail later at
verify time.

its a bit messy but I think it is quite a robust solution.</comment>
		<comment id="10" date="2004-09-03 11:41:46 EDT" author="Erik Hilsdale">I can't look at the code right now, but two reactions to the solution description:

* the localVariable tag won't work at all if someone has stripped off debugging
information.  Whatever solution we have should perhaps work better if we have
debugging info, but better not generate a bad classfile if we don't.

* even if we're lucky enough to have debugging information, ?: can surprise you

  ((testA ? exp0 : exp1) (testB ? exp2 : exp3) (testC ? exp4 : exp5)).clone()</comment>
		<comment id="11" date="2004-09-03 12:24:57 EDT" author="Andrew Clement">Hi Erik.  
Yes, I hadn't thought about them stripping that debug info off.  
I just couldn't think of a nicer solution to this problem (unless we say
compiler restriction).  I believe that at least now we will fail at compile time
rather than runtime.  Did you have a nicer fix in mind for this?  My first go
was to try and generate the code that looked like this:

public static final Object clone_aroundBody0(X x, Object y) {
  if (y instanceof Object[]) {
    return ((Object[])y).clone();
  } else {
    return y.clone();
  }
}

but that still fails verification because 'return y.clone()' exists in the bytecode.

I then thought well - is the only time we will ever try and create a method like
this:

public static final Object clone_aroundBody0(Object y) {
  return y.clone();
}

when the clone was originally on an array type.  If its true then in this case
we could always produce:

public static final Object[] clone_aroundBody0(Object[] y) {
  return (Object[])y.clone();
}

but I wasnt sure if that was one assumption too far?</comment>
		<comment id="12" date="2004-09-09 11:26:45 EDT" author="Erik Hilsdale">Yeah, I see your point.  The proposed solution we had was worse, too, since

  ((Object) new int[3]) instanceof Object[]

is false.  I'm still worried about the fragility of this solution without
debugging info, but there it is.

This is exactly the case where a separate set of people working on the AspectJ
semantics might come up with a better solution that we could then steal if the
current one turns out to be too fragile in practice *grin*.

We should probably close this as fixed.</comment>
		<comment id="13" date="2004-09-09 12:31:02 EDT" author="Andrew Clement">I'm going on holiday at the weekend for two weeks and want to write down my last
minute thoughts on this bug so I don't forget them whilst I'm in the Maldives. 
I may not get to finishing this bug off before I go.

The oxford guys didn't seem to think a 1.4 compiler should still be producing
the 'Object.clone()' bytecode, they seemed to think the one they are using is
producing the right '&lt;arraytype&gt;.clone()' bytecode.  I need to check if this is
really the case.  It could be a bug in the Eclipse compiler so I need to check
it on SUN and IBM 1.4 compilers. (And check the polyglot compiler they use?)

I do think my current solution will fail at compile time if we can't determine
the actual type on which clone() is called - but if there is no debug
information I don't think it will fail in a nice way - it will fail with an NPE
as I'm assuming the local variable tag is found.  It should gracefully fail if
the tag is missing.</comment>
		<comment id="14" date="2006-02-15 03:52:10 EST" author="Andrew Clement">not useful targetting 1.2.1</comment>
		<comment id="15" date="2006-05-30 08:49:20 EDT" author="Andrew Clement">not planning to do any more with this for now... basic verifyerror was fixed long ago.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="27d204cf9f57a0cc06f4d7c5800c93eb55edc02a" author="aclement" date="2004-09-03 10:45:46"/>
          <file name="tests/bugs/ArrayCloning.java">
          </file>
          <file name="tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java">
              <method name="test055_cnfe" returnType="void" parameters=""/>
          </file>
          <file name="weaver/src/org/aspectj/weaver/ResolvedTypeX.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/bcel/BcelShadow.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="120739" opendate="2005-12-13 16:10:00" fixdate="2006-6-2 11:08:00">
    <buginformation>
      <summary>LTW Optimization: Disable World if it has No Aspects</summary>
      <description>This optimization disables weaving for a ClassLoader where there are no aspects defined. This is actually useful if you have aspect exclusions that exclude all the aspects defined in a parent class loader. It is also helpful in the trivial/rare case where there is an aop.xml definition with no aspect definitions.</description>
      <comments>
		<comment id="1" date="2005-12-13 16:11:42 EST" author="Ron Bodkin">Created attachment 31686 [details]
Disable weaving if no aspects are defined.</comment>
		<comment id="2" date="2006-02-15 06:10:48 EST" author="Andrew Clement">check status for 1.5.1</comment>
		<comment id="3" date="2006-04-04 14:20:56 EDT" author="Andrew Clement">why haven't we put this in?</comment>
		<comment id="4" date="2006-06-01 09:49:36 EDT" author="Matthew Webster">This is a good optimization. I have added a message, similar to that issued when no aop.xml is found, and a 1.5.2 testcase. In the long run it might be better to more aggressively parse the XML into a Configuration object (paving the way for a programmatic API) so that we donât create then throw away the Weaver and World.</comment>
		<comment id="5" date="2006-06-01 12:20:30 EDT" author="Matthew Webster">4 tests failed: testLTWDump/BeforeAndAfter/Proxy and testCompileTimeAspectsDeclaredToLTWWeaver because they don't have an aspect and hence no weaving took place or the new message caused problems. I amended the expected messages and added EmptyAspect.aj/EmptyAtAspect.java to the compile step and relevant aop.xml files.</comment>
		<comment id="6" date="2006-06-02 03:51:47 EDT" author="Matthew Webster">Fix available</comment>
		<comment id="7" date="2006-06-02 11:08:08 EDT" author="Ron Bodkin">I agree that parsing into an options file would be better. This would also be a step towards reusing the parsing when aop.xml files are shared by multiple ClassLoaders (based on the same URL). That in turn would allow sharing initial weaver state (using a test to make sure that there isn't a different class definition between the different ClassLoaders, e.g., by nondelegation)</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="4513e921c89fb3b8f037418a901e49906724e7bd" author="mwebster" date="2006-06-02 01:30:21"/>
          <file name="loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java">
              <method name="initialize" returnType="void" parameters="ClassLoader IWeavingContext"/>
          </file>
          <file name="tests/java5/ataspectj/ataspectj/ltwreweavable/EmptyAtAspect.java">
          </file>
          <file name="tests/src/org/aspectj/systemtest/ajc152/Ajc152Tests.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="145086" opendate="2006-6-2 11:35:00" fixdate="2006-6-3 4:24:00">
    <buginformation>
      <summary>NPE when weak reference set in signature</summary>
      <description>Simon ran into the same problem in setting the values. I will attach a patch to fix this, with test cases to properly verify it works in both cases.

java.lang.NullPointerException
	at org.aspectj.runtime.reflect.SignatureImpl$CacheImpl.set(SignatureImpl.java:224)
	at org.aspectj.runtime.reflect.SignatureImpl.toString(SignatureImpl.java:57)
	at org.aspectj.runtime.reflect.SignatureImpl.toString(SignatureImpl.java:62)</description>
      <comments>
		<comment id="1" date="2006-06-02 11:36:29 EDT" author="Ron Bodkin">Created attachment 43360 [details]
Test and fix of NPE on set of weak reference (ugh)</comment>
		<comment id="2" date="2006-06-03 04:24:11 EDT" author="Andrew Clement">fix committed</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="4842f1826c3905c2789bc99a2dc841c733092339" author="aclement" date="2006-05-17 06:43:15"/>
          <file name="tests/bugs152/pr135865/A.java">
          </file>
          <file name="tests/bugs152/pr135865/B.java">
          </file>
          <file name="tests/bugs152/pr135865/One.java">
          </file>
          <file name="tests/bugs152/pr142165/A.java">
          </file>
          <file name="tests/bugs152/pr142165/C.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="145950" opendate="2006-6-8 3:57:00" fixdate="2006-6-8 4:27:00">
    <buginformation>
      <summary>-XaddSerialVersionUID doesn't work if there is an indirect route to Serializable in the hierarchy</summary>
      <description>-XaddSerialVersionUID fails to add a serialversionuid field to a type if Serializable isn't a direct parent.  this case fails:

class X implements I { } // X will not get the field if woven
interface I implements Serializable {}

this works:

class X implements Serializable {} // X will get the field if woven

there is a mistake in the code that checks for the serializable interface</description>
      <comments>
		<comment id="1" date="2006-06-08 04:27:45 EDT" author="Andrew Clement">test and fix committed.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="afe41a56ebf6c0dcbe69285a263f0e5739d58028" author="aclement" date="2006-06-08 05:27:34"/>
          <file name="tests/bugs152/pr145950/Indirect.java">
          </file>
          <file name="tests/src/org/aspectj/systemtest/ajc152/Ajc152Tests.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="146546" opendate="2006-6-12 7:59:00" fixdate="2006-6-12 9:57:00">
    <buginformation>
      <summary>"Remove hard coded dependency on ""|"" in getFileName(..) methods"</summary>
      <description>As part of bug 141730 we need to remove the hard coded dependency on "|" in methods which use handles to get the filename. These methods are:

AsmManager.getFileName(String)
AspectJElementHierarchy.getFileName(String)</description>
      <comments>
		<comment id="1" date="2006-06-12 08:36:01 EDT" author="Helen Beeken">Created attachment 44132 [details]
proposed fix

Apply this patch to the asm project.

The proposed fix is to delegate to the IElementHandleProvider to get the filename for the given handle.</comment>
		<comment id="2" date="2006-06-12 09:57:15 EDT" author="Andrew Clement">committed.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="38cc0dd2f77eaea1778ede835e7da0aa9d871de7" author="aclement" date="2006-06-12 11:00:02"/>
          <file name="asm/src/org/aspectj/asm/AsmManager.java">
          </file>
          <file name="asm/src/org/aspectj/asm/internal/AspectJElementHierarchy.java">
              <method name="updateHandleMap" returnType="void" parameters="Set"/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="122580" opendate="2006-1-3 20:19:00" fixdate="2006-6-12 10:18:00">
    <buginformation>
      <summary>Fix &amp; Bug: Circularity Failure for Verbose Loading on JRockit 1.4.2_08 Agent</summary>
      <description>Here is a stack trace I am getting when I try to use AspectJ 1.5.0 final release's load-time weaving with JRockIt 1.4.2_08 using -Xmanagement:class=org.aspectj.weaver.loadtime.JRockitAgent to load Weblogic Server 8.1 SP2. I debugged the code in Eclipse and discovered that the weaver was being initialized while loading IMessage$Kind, so the JRockIt VM simply hasn't run staticinitialization yet, making IMessage.INFO null.

I was able to fix this stack trace by hoisting the check for loading AspectJ code up BEFORE initializing a weaving adaptor i.e., changing line 55 of Aj.java to be
        if (loader == null || className == null || className.startsWith("org/aspectj/")) {

I then commented out line 251 of WeavingAdaptor to avoid a duplicate check:
	private boolean shouldWeaveName (String name) {
		return !((/*(name.startsWith("org.apache.bcel.")||//FIXME AV why ? bcel is wrapped in org.aspectj.
                name.startsWith("org.aspectj.")||*/ // now checked earlier, to avoid circularity issues in initialization 
                name.startsWith("java.")
                || name.startsWith("javax."))
                //|| name.startsWith("$Proxy")//JDK proxies//FIXME AV is that 1.3 proxy ? fe. ataspect.$Proxy0 is a java5 proxy...
                || name.startsWith("sun.reflect."));//JDK reflect
	}

Note that this bug does NOT occur when using a JRockIt 1.5.0 VM, even with the -Xmanagement command line argument.

Stack Trace:
java.lang.IllegalArgumentException: null kind
	at org.aspectj.bridge.Message.&lt;init&gt;(Ljava/lang/String;Ljava/lang/String;Lorg/aspectj/bridge/IMessage$Kind;Lorg/aspectj/bridge/ISourceLocation;Ljava/lang/Throwable;[Lorg/aspectj/bridge/ISourceLocation;ZIII)V(Message.java:89)
	at org.aspectj.bridge.Message.&lt;init&gt;(Ljava/lang/String;Ljava/lang/String;Lorg/aspectj/bridge/IMessage$Kind;Lorg/aspectj/bridge/ISourceLocation;Ljava/lang/Throwable;[Lorg/aspectj/bridge/ISourceLocation;)V(Message.java:67)
	at org.aspectj.bridge.Message.&lt;init&gt;(Ljava/lang/String;Lorg/aspectj/bridge/IMessage$Kind;Ljava/lang/Throwable;Lorg/aspectj/bridge/ISourceLocation;)V(Message.java:110)
	at org.aspectj.bridge.MessageUtil.info(Ljava/lang/String;)Lorg/aspectj/bridge/IMessage;(MessageUtil.java:211)
	at org.aspectj.bridge.MessageUtil.info(Lorg/aspectj/bridge/IMessageHandler;Ljava/lang/String;)Z(MessageUtil.java:98)
	at org.aspectj.weaver.tools.WeavingAdaptor.info(Ljava/lang/String;)Z(WeavingAdaptor.java:343)
	at org.aspectj.weaver.tools.WeavingAdaptor.createMessageHandler()V(WeavingAdaptor.java:168)
	at org.aspectj.weaver.tools.WeavingAdaptor.&lt;init&gt;()V(WeavingAdaptor.java:80)
	at org.aspectj.weaver.loadtime.ClassLoaderWeavingAdaptor.&lt;init&gt;(Ljava/lang/ClassLoader;Lorg/aspectj/weaver/loadtime/IWeavingContext;)V(ClassLoaderWeavingAdaptor.java:70)
	at org.aspectj.weaver.loadtime.Aj$WeaverContainer.getWeaver(Ljava/lang/ClassLoader;Lorg/aspectj/weaver/loadtime/IWeavingContext;)Lorg/aspectj/weaver/tools/WeavingAdaptor;(Aj.java:94)
	at org.aspectj.weaver.loadtime.Aj.preProcess(Ljava/lang/String;[BLjava/lang/ClassLoader;)[B(Aj.java:61)
	at org.aspectj.weaver.loadtime.JRockitAgent.preProcess(Ljava/lang/ClassLoader;Ljava/lang/String;[B)[B(JRockitAgent.java:74)
	at jrockit.vm.ClassPreProcessorManager.notifyClassPreProcessor(ILjava/lang/String;[B)[B(Unknown Source)
	at jrockit.vm.Classes.defineClass0(ILjava/lang/String;[BII)I(Unknown Source)
	at jrockit.vm.Classes.defineClass(Ljava/lang/ClassLoader;Ljava/lang/String;[BII)Ljava/lang/Class;(Unknown Source)
	at java.lang.ClassLoader.defineClass(Ljava/lang/String;[BIILjava/security/ProtectionDomain;)Ljava/lang/Class;(Unknown Source)
	at java.security.SecureClassLoader.defineClass(Ljava/lang/String;[BIILjava/security/CodeSource;)Ljava/lang/Class;(SecureClassLoader.java:123)
	at java.net.URLClassLoader.defineClass(Ljava/lang/String;Lsun/misc/Resource;)Ljava/lang/Class;(URLClassLoader.java:251)
	at java.net.URLClassLoader.access$100(Ljava/net/URLClassLoader;Ljava/lang/String;Lsun/misc/Resource;)Ljava/lang/Class;(URLClassLoader.java:55)
	at java.net.URLClassLoader$1.run()Ljava/lang/Object;(URLClassLoader.java:194)
	at jrockit.vm.AccessController.do_privileged_exc(Ljava/security/PrivilegedExceptionAction;Ljava/security/AccessControlContext;I)Ljava/lang/Object;(Unknown Source)
	at jrockit.vm.AccessController.doPrivileged(Ljava/security/PrivilegedExceptionAction;Ljava/security/AccessControlContext;)Ljava/lang/Object;(Unknown Source)
	at java.net.URLClassLoader.findClass(Ljava/lang/String;)Ljava/lang/Class;(URLClassLoader.java:187)
	at java.lang.ClassLoader.loadClass(Ljava/lang/String;Z)Ljava/lang/Class;(Unknown Source)
	at sun.misc.Launcher$AppClassLoader.loadClass(Ljava/lang/String;Z)Ljava/lang/Class;(Launcher.java:274)
	at java.lang.ClassLoader.loadClass(Ljava/lang/String;)Ljava/lang/Class;(Unknown Source)
	at java.lang.ClassLoader.loadClassFromNative(II)Ljava/lang/Class;(Unknown Source)
	at jrockit.vm.RNI.getRunnableCode(I)I(Unknown Source)
	at jrockit.vm.RNI.trampoline()V(Unknown Source)
	at org.aspectj.bridge.MessageUtil.info(Ljava/lang/String;)Lorg/aspectj/bridge/IMessage;(MessageUtil.java:???)
	at org.aspectj.bridge.MessageUtil.info(Lorg/aspectj/bridge/IMessageHandler;Ljava/lang/String;)Z(MessageUtil.java:98)
	at org.aspectj.weaver.tools.WeavingAdaptor.info(Ljava/lang/String;)Z(WeavingAdaptor.java:343)
java.lang.IllegalArgumentException: null kind
	at org.aspectj.bridge.Message.&lt;init&gt;(Ljava/lang/String;Ljava/lang/String;Lorg/aspectj/bridge/IMessage$Kind;Lorg/aspectj/bridge/ISourceLocation;Ljava/lang/Throwable;[Lorg/aspectj/bridge/ISourceLocation;ZIII)V(Message.java:89)
	at org.aspectj.bridge.Message.&lt;init&gt;(Ljava/lang/String;Ljava/lang/String;Lorg/aspectj/bridge/IMessage$Kind;Lorg/aspectj/bridge/ISourceLocation;Ljava/lang/Throwable;[Lorg/aspectj/bridge/ISourceLocation;)V(Message.java:67)
	at org.aspectj.bridge.Message.&lt;init&gt;(Ljava/lang/String;Lorg/aspectj/bridge/IMessage$Kind;Ljava/lang/Throwable;Lorg/aspectj/bridge/ISourceLocation;)V(Message.java:110)
	at org.aspectj.bridge.MessageUtil.info(Ljava/lang/String;)Lorg/aspectj/bridge/IMessage;(MessageUtil.java:211)
	at org.aspectj.bridge.MessageUtil.info(Lorg/aspectj/bridge/IMessageHandler;Ljava/lang/String;)Z(MessageUtil.java:98)
	at org.aspectj.weaver.tools.WeavingAdaptor.info(Ljava/lang/String;)Z(WeavingAdaptor.java:343)
	at org.aspectj.weaver.tools.WeavingAdaptor.createMessageHandler()V(WeavingAdaptor.java:168)
	at org.aspectj.weaver.tools.WeavingAdaptor.&lt;init&gt;()V(WeavingAdaptor.java:80)
	at org.aspectj.weaver.loadtime.ClassLoaderWeavingAdaptor.&lt;init&gt;(Ljava/lang/ClassLoader;Lorg/aspectj/weaver/loadtime/IWeavingContext;)V(ClassLoaderWeavingAdaptor.java:70)
	at org.aspectj.weaver.loadtime.Aj$WeaverContainer.getWeaver(Ljava/lang/ClassLoader;Lorg/aspectj/weaver/loadtime/IWeavingContext;)Lorg/aspectj/weaver/tools/WeavingAdaptor;(Aj.java:94)
	at org.aspectj.weaver.loadtime.Aj.preProcess(Ljava/lang/String;[BLjava/lang/ClassLoader;)[B(Aj.java:61)
	at org.aspectj.weaver.loadtime.JRockitAgent.preProcess(Ljava/lang/ClassLoader;Ljava/lang/String;[B)[B(JRockitAgent.java:74)
	at jrockit.vm.ClassPreProcessorManager.notifyClassPreProcessor(ILjava/lang/String;[B)[B(Unknown Source)
	at jrockit.vm.Classes.defineClass0(ILjava/lang/String;[BII)I(Unknown Source)
	at jrockit.vm.Classes.defineClass(Ljava/lang/ClassLoader;Ljava/lang/String;[BII)Ljava/lang/Class;(Unknown Source)
	at java.lang.ClassLoader.defineClass(Ljava/lang/String;[BIILjava/security/ProtectionDomain;)Ljava/lang/Class;(Unknown Source)
	at java.security.SecureClassLoader.defineClass(Ljava/lang/String;[BIILjava/security/CodeSource;)Ljava/lang/Class;(SecureClassLoader.java:123)
	at java.net.URLClassLoader.defineClass(Ljava/lang/String;Lsun/misc/Resource;)Ljava/lang/Class;(URLClassLoader.java:251)
	at java.net.URLClassLoader.access$100(Ljava/net/URLClassLoader;Ljava/lang/String;Lsun/misc/Resource;)Ljava/lang/Class;(URLClassLoader.java:55)
	at java.net.URLClassLoader$1.run()Ljava/lang/Object;(URLClassLoader.java:194)
	at jrockit.vm.AccessController.do_privileged_exc(Ljava/security/PrivilegedExceptionAction;Ljava/security/AccessControlContext;I)Ljava/lang/Object;(Unknown Source)
	at jrockit.vm.AccessController.doPrivileged(Ljava/security/PrivilegedExceptionAction;Ljava/security/AccessControlContext;)Ljava/lang/Object;(Unknown Source)
	at java.net.URLClassLoader.findClass(Ljava/lang/String;)Ljava/lang/Class;(URLClassLoader.java:187)
	at java.lang.ClassLoader.loadClass(Ljava/lang/String;Z)Ljava/lang/Class;(Unknown Source)
	at sun.misc.Launcher$AppClassLoader.loadClass(Ljava/lang/String;Z)Ljava/lang/Class;(Launcher.java:274)
	at java.lang.ClassLoader.loadClass(Ljava/lang/String;)Ljava/lang/Class;(Unknown Source)
	at java.lang.ClassLoader.loadClassFromNative(II)Ljava/lang/Class;(Unknown Source)
	at jrockit.vm.RNI.getRunnableCode(I)I(Unknown Source)
	at jrockit.vm.RNI.trampoline()V(Unknown Source)
	at org.aspectj.bridge.MessageUtil.info(Lorg/aspectj/bridge/IMessageHandler;Ljava/lang/String;)Z(MessageUtil.java:???)
	at org.aspectj.weaver.tools.WeavingAdaptor.info(Ljava/lang/String;)Z(WeavingAdaptor.java:343)
	at org.aspectj.weaver.tools.WeavingAdaptor.createMessageHandler()V(WeavingAdaptor.java:168)</description>
      <comments>
		<comment id="1" date="2006-01-03 21:48:34 EST" author="Ron Bodkin">By the way, this error occurs with *no* aop.xml file even defined. Just enabling the AspectJ JRockIt agent and starting Weblogic causes it...</comment>
		<comment id="2" date="2006-01-04 02:48:41 EST" author="Ron Bodkin">Ok this appears to be symptomatic of a deeper problem. The older BEA VM's are choking because the classloader agent is part of the classpath and we are weaving everything on the system classpath. The Java 5 agents are on the bootstrap classpath and so are never woven and I think that Java is it may also be  My first fix allows not weaving, but I needed to add some additional logic to prevent trying to weave before the ClassLoaderWeavingAdaptor has been fully initialized.

With the attached patch, I can start up and weave classes into Weblogic running on a JRockIt 1.4.2_08 VM.</comment>
		<comment id="3" date="2006-01-04 02:53:39 EST" author="Ron Bodkin">Created attachment 32450 [details]
Patch to loadtime module to fix problems weaving on older JRockIt VM</comment>
		<comment id="4" date="2006-01-04 02:59:08 EST" author="Ron Bodkin">Created attachment 32451 [details]
Patch to weaver module to fix problems weaving on older JRockIt VM</comment>
		<comment id="5" date="2006-06-05 11:42:32 EDT" author="Matthew Webster">The problem here is that we are trying to weave the contents of aspectjweaver.jar which should be avoided altogether. The classloader used is entirely at the discretion of the user rather than being dependent on the JVM e.g. the aj5.bat launcher uses âjavaagent and aspectjweaver.jar is loaded from CLASSPATH. I suspect the difference between Sun and JRockit lies with how/when the agent is initialized: either a startup or on first reference. We must avoid weaving _any_ AspectJ classes because of potiential ClassCircularityErrors but clearly the existing mechanism in WeavingAdaptor.shouldWeave() comes too late. There are several approaches:
1. Use a classloader that performs no weaving i.e. the bootstrap loader but modifying bootclasspath is either frowned upon or prohibited.
2. Use CodeSource (obtained from ProtectionDomain) passed on a modified preProcess() method  to identify those classes loaded from the same URL as Aj. Unfortunately the com.bea.jvm.ClassPreProcessor does not supply this information.
3. Perform no weaving on the classloader used to define Aj/JRockitAgent/ClassPreProcessorAgentAdapter. This would require a change to aj5.
4. Simply exclude classes whose names begin âorg.aspectj.â but much earlier. This only works if we rename any classes we ship.

Patch 32450 uses option #4. Why did you find it necessary to add the addional logic?</comment>
		<comment id="6" date="2006-06-06 01:04:43 EDT" author="Ron Bodkin">I think you're right here Matthew: it's enough to just exclude weaving into org/aspectj types earlier in the cycle. However, Patch 32451 has most of the logic to actually exclude weaving earlier in the process whereas 32450 just comments out the test when it's too late. I probably started off with the logic to handle weaving while being initialized and then fell back on adding the earlier check in Aj.

I tested using -Xmanagement on JRockIt 1.4.2 with just the logic to exclude AspectJ classes in Aj instead of the WeavingAdaptor, i.e., without the logic to detect "am I initializing" and it worked for a version of GlassboxInspector on Tomcat 4.1.x.

Let's leave bug 140709 to track any possible need of handling self-weaving while initializing and apply the rest of these patches so that the JRockIt agent works properly.</comment>
		<comment id="7" date="2006-06-06 04:10:55 EDT" author="Matthew Webster">Reference to BEA JRockit JMAPI: http://edocs.bea.com/jrockit/docs142/jmapi/javadoc/Management%20API/index.html</comment>
		<comment id="8" date="2006-06-06 09:34:53 EDT" author="Matthew Webster">I am convinced that JVMTI has built-in recursion detection, something that JRockit JMAPI seems to lacks. If I trace calls to ClassPreProcessorAgentAdapter.transform() when using the agent to weave HelloWorld the first class I see (from CLASSPATH) is HelloWorld. Some AspectJ classes are loaded before HelloWorld e.g. org.aspectj.weaver.loadtime.ClassLoaderWeavingAdaptor but those that are the cause of this bug e.g. org.aspectj.bridge.IMessage$Kind are loaded later but never passed to the agent. Subsequently classes like org.aspectj.runtime.reflect.Factory _are_ passed to the agent but filtered by the existing mechanism. 

[Opened C:\jdk1.5.0_05\jre\lib\rt.jar]
[Opened C:\jdk1.5.0_05\jre\lib\jsse.jar]
[Opened C:\jdk1.5.0_05\jre\lib\jce.jar]
[Opened C:\jdk1.5.0_05\jre\lib\charsets.jar]
[Loaded java.lang.Object from C:\jdk1.5.0_05\jre\lib\rt.jar]
...
[Loaded org.aspectj.weaver.loadtime.Agent from file:/C:/workspaces/org.aspectj-Ron_LTW/loadtime5/bin/]
[Loaded java.lang.UnsupportedOperationException from C:\jdk1.5.0_05\jre\lib\rt.jar]
[Loaded sun.reflect.NativeMethodAccessorImpl from C:\jdk1.5.0_05\jre\lib\rt.jar]
[Loaded sun.reflect.DelegatingMethodAccessorImpl from C:\jdk1.5.0_05\jre\lib\rt.jar]
[Loaded org.aspectj.weaver.loadtime.ClassPreProcessorAgentAdapter from file:/C:/workspaces/org.aspectj-Ron_LTW/loadtime5/bin/]
[Loaded org.aspectj.weaver.loadtime.ClassPreProcessor from file:/C:/workspaces/org.aspectj-Ron_LTW/loadtime/bin/]
[Loaded java.lang.ExceptionInInitializerError from C:\jdk1.5.0_05\jre\lib\rt.jar]
[Loaded org.aspectj.bridge.context.CompilationAndWeavingContext from file:/C:/workspaces/org.aspectj-Ron_LTW/bridge/bin/]
...
? ClassPreProcessorAgentAdapter.transform() loader=sun.misc.Launcher$AppClassLoader@92e78c, className=hello/HelloWorld
...
[Loaded org.aspectj.bridge.IMessage from file:/C:/workspaces/org.aspectj-Ron_LTW/bridge/bin/]
[Loaded org.aspectj.bridge.IMessageHandler from file:/C:/workspaces/org.aspectj-Ron_LTW/bridge/bin/]
[Loaded org.aspectj.weaver.tools.GeneratedClassHandler from file:/C:/workspaces/org.aspectj-Ron_LTW/weaver/bin/]
[Loaded org.aspectj.weaver.ReferenceTypeDelegate from file:/C:/workspaces/org.aspectj-Ron_LTW/weaver/bin/]
[Loaded org.aspectj.weaver.AbstractReferenceTypeDelegate from file:/C:/workspaces/org.aspectj-Ron_LTW/weaver/bin/]
[Loaded org.aspectj.weaver.bcel.BcelObjectType from file:/C:/workspaces/org.aspectj-Ron_LTW/weaver/bin/]
[Loaded org.aspectj.weaver.AnnotatedElement from file:/C:/workspaces/org.aspectj-Ron_LTW/weaver/bin/]
[Loaded org.aspectj.weaver.TypeVariableDeclaringElement from file:/C:/workspaces/org.aspectj-Ron_LTW/weaver/bin/]
[Loaded org.aspectj.weaver.UnresolvedType from file:/C:/workspaces/org.aspectj-Ron_LTW/weaver/bin/]
[Loaded org.aspectj.weaver.ResolvedType from file:/C:/workspaces/org.aspectj-Ron_LTW/weaver/bin/]
[Loaded org.aspectj.weaver.ReferenceType from file:/C:/workspaces/org.aspectj-Ron_LTW/weaver/bin/]
[Loaded org.aspectj.weaver.loadtime.IWeavingContext from file:/C:/workspaces/org.aspectj-Ron_LTW/loadtime/bin/]
[Loaded org.aspectj.weaver.ICrossReferenceHandler from file:/C:/workspaces/org.aspectj-Ron_LTW/weaver/bin/]
[Loaded org.aspectj.weaver.reflect.IReflectionWorld from file:/C:/workspaces/org.aspectj-Ron_LTW/weaver/bin/]
[Loaded org.aspectj.weaver.ltw.LTWWorld from file:/C:/workspaces/org.aspectj-Ron_LTW/weaver/bin/]
[Loaded java.lang.reflect.InvocationTargetException from C:\jdk1.5.0_05\jre\lib\rt.jar]
[Loaded org.aspectj.bridge.MessageWriter from file:/C:/workspaces/org.aspectj-Ron_LTW/bridge/bin/]
[Loaded org.aspectj.weaver.tools.WeavingAdaptor$WeavingAdaptorMessageHandler from file:/C:/workspaces/org.aspectj-Ron_LTW/weaver/bin/]
[Loaded org.aspectj.bridge.AbortException from file:/C:/workspaces/org.aspectj-Ron_LTW/bridge/bin/]
[Loaded java.io.PrintWriter from C:\jdk1.5.0_05\jre\lib\rt.jar]
[Loaded org.aspectj.bridge.IMessage$Kind from file:/C:/workspaces/org.aspectj-Ron_LTW/bridge/bin/]
[Loaded org.aspectj.bridge.IMessage$1 from file:/C:/workspaces/org.aspectj-Ron_LTW/bridge/bin/]
...
? ClassPreProcessorAgentAdapter.transform() loader=sun.misc.Launcher$AppClassLoader@92e78c, className=org/aspectj/runtime/reflect/Factory
...

I think the solution is to add recursion protection to JRockitAgent, something that I have already done for WeavingURLClassLoader which is used both in the harness and AJDT LTW support (for both JDK 1.4 and 1.5).</comment>
		<comment id="9" date="2006-06-06 10:25:20 EDT" author="Ron Bodkin">That sounds like a good approach to me. Thanks!</comment>
		<comment id="10" date="2006-06-07 06:22:19 EDT" author="Matthew Webster">An article on writing a JRockit ClassPreProcessor with a nice sample implementation : http://dev2dev.bea.com/pub/a/2004/01/class_preprocessing.html</comment>
		<comment id="11" date="2006-06-07 10:07:45 EDT" author="Matthew Webster">1. Re-implemented JRockitAgent using recursion protection
2. Removed âloadtimeâ dependency on managementapi-jrockit81.jar and implemented to the necessary JRockit classes to aid testing
3. Added JRockitAgentTest with from-scratch class loader to test recursion protection
4. Relaxed "catch (Throwble)" to "catch (Exception)" in Aj.preProcess() to protect agent users against weaver problems but allow reporting of unrecoverable errors.

My only concern with the recursion protection relates to around closure generation. When these are defined dependencies that have not yet been loaded may be passed to the weaver. This causes recursion in the agent/adaptor (although not in the weaver itself) which with the new agent may result in certain closures not being woven.

Awaiting JRockit testing.</comment>
		<comment id="12" date="2006-06-07 10:15:07 EDT" author="Ron Bodkin">That sounds great. Should I sync to head and build a copy to test it?</comment>
		<comment id="13" date="2006-06-07 10:19:02 EDT" author="Matthew Webster">1. Re-implemented JRockitAgent using recursion protection
2. Removed âloadtimeâ dependency on managementapi-jrockit81.jar and implemented to the necessary JRockit classes to aid testing
3. Added JRockitAgentTest with from-scratch class loader to test recursion protection
4. Relaxed "catch (Throwble)" to "catch (Exception)" in Aj.preProcess() to protect agent users against weaver problems but allow reporting of unrecoverable errors.

My only concern with the recursion protection relates to around closure generation. When these are defined dependencies that have not yet been loaded may be passed to the weaver. This causes recursion in the agent/adaptor (although not in the weaver itself) which with the new agent may result in certain closures not being woven.

Awaiting JRockit testing.</comment>
		<comment id="14" date="2006-06-09 06:48:58 EDT" author="Matthew Webster">Ron: 

Good news: I just installed it in Tomcat running against JRockit 1.4.2 and it was able to start up and weave aspects as required. I will do more testing, but the first smoke test worked well (and fails with 1.5.1a or recent dev builds).</comment>
		<comment id="15" date="2006-06-09 06:49:30 EDT" author="Matthew Webster">Great
Are we sure the thread local stack approach in there has no side effect when classloading gets into this recursive behavior ? Seems like if there is recursion, we won't weave the class at all since we 'll return bytecode from this thread local stack - which is fine if we assume the weaver only is the root cause of the recursion. 
Noone came across this in AspectWerkz - so I guess that 's because we had a slightly different weaver initialisation behavior

Alex</comment>
		<comment id="16" date="2006-06-09 08:22:06 EDT" author="Matthew Webster">The only reason for recursion is class loading while weaving using the class loader that actually defines the weaver. This can happen at any point, not just during initialization. It cannot and should not happen while resolving types necessary to weave a class: until now these have been loaded using getResourceAsStream() and with LTWWorld Class.forName is used only for bootstrap classes and these are exluded from weaving in Aj.preProcess(). I do not believe that the weaver is re-entrant.

One issue previously noted concerns generated closures and will only be potential a problem for non-inlined around advice applied to classes loaded by the same loader used by the weaver. My advice is donât weave classes on the same classpath as AspectJ!</comment>
		<comment id="17" date="2006-06-09 08:23:25 EDT" author="Matthew Webster">Awaiting build.</comment>
		<comment id="18" date="2006-06-12 10:18:08 EDT" author="Matthew Webster">Fix available</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="75afb31e38f75e61de5c15058d3332f3dac0df15" author="mwebster" date="2006-06-09 07:56:50"/>
          <file name="loadtime/src/org/aspectj/weaver/loadtime/Aj.java">
              <method name="preProcess" returnType="byte[]" parameters="String byte[] ClassLoader"/>
          </file>
          <file name="loadtime/src/org/aspectj/weaver/loadtime/JRockitAgent.java">
          </file>
          <file name="loadtime/testsrc/LoadtimeModuleTests.java">
          </file>
          <file name="loadtime/testsrc/org/aspectj/bea/jvm/ClassLibraryImpl.java">
          </file>
          <file name="loadtime/testsrc/org/aspectj/bea/jvm/JVMImpl.java">
          </file>
          <file name="loadtime/testsrc/org/aspectj/weaver/loadtime/JRockitAgentTest.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="132591" opendate="2006-3-20 15:51:00" fixdate="2006-6-13 10:13:00">
    <buginformation>
      <summary>Duplicate exception with aop.xml file on aspectpath</summary>
      <description>See also bug #57666 which is related (but has to do with manifests):

I have a META-INF/aop.xml file in my aspectpath and another one in the source path. That shouldn't even be a duplicate, because the aspectpath resource should NOT be copied to output at all.

In AspectJ build:  1.5.1.20060309143651

I am now getting:

java.util.zip.ZipException
at java.util.zip.ZipOutputStream.putNextEntry(ZipOutputStream.java:163)
at java.util.jar.JarOutputStream.putNextEntry(JarOutputStream.java:90)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.writeOutxmlFile(AjBuildManager.java:549)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:320)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:163)
at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:122)
at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)

ZipException thrown: duplicate entry: META-INF/aop.xml</description>
      <comments>
		<comment id="1" date="2006-06-01 12:46:09 EDT" author="Matthew Webster">I the problem is occuring because you are using either -outxml or -outxmlfile. Could you post the commandline or Ant options you are using? This option will generate an aop.xml file for those aspects visible to the weaver which is probably clashing with the one in the source path. We don't copy resources from aspectpath.

Now of cause we shouldn't throw an exception so I propose the first come first served approach we used for manifests. Therefore in you case we will ignore the -outxml/outfile option. But should we issue and error/warning?</comment>
		<comment id="2" date="2006-06-02 08:13:28 EDT" author="Matthew Webster">1. Added test for existing aop.xml to OutXmlTest
2. Modified NullIdeProperties to allow testProjectPath to be overriden by sourceRoots
3. Issue warning message inAjBuildManager.writeResource() to say -outxml ignored</comment>
		<comment id="3" date="2006-06-02 10:11:22 EDT" author="Ron Bodkin">You are right - there was both a META-INF/aop.xml file in the sources and an -outxml file option. The project was having this error in AJDT. Removing the -outxml option fixes the problem. Thanks and as you say this is a good condition to detect and warn about, with then not generating a file.</comment>
		<comment id="4" date="2006-06-13 10:13:15 EDT" author="Matthew Webster">Fix available</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="319a0d15703c098b74335ecb9672f58166bf3c5b" author="mwebster" date="2006-06-02 09:47:08"/>
          <file name="ajde/testsrc/org/aspectj/ajde/NullIdeProperties.java">
          </file>
          <file name="ajde/testsrc/org/aspectj/ajde/OutxmlTest.java">
          </file>
          <file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="136707" opendate="2006-4-13 14:23:00" fixdate="2006-6-13 15:46:00">
    <buginformation>
      <summary>iajc should print summary like javac</summary>
      <description>The iajc ant task should produce a summary of what it is doing, like the javac task does:

[javac] Compiling 189 source files to C:\project\classes</description>
      <comments>
		<comment id="1" date="2006-05-10 13:23:35 EDT" author="Wes Isberg">Thanks for the bug.  iajc will print the full ajc command line when in verbose mode.  The problem with trying to calculate a summary is that the iajc task does not enumerate files the way javac does - there could be any number of arg files, source roots, source files, etc. Reopen this if verbose isn't working for you or you have a proposal for useful info-level output (I thought perhaps when forking...).</comment>
		<comment id="2" date="2006-05-10 13:39:08 EDT" author="Ron Bodkin">How about just printing a count of the number of top level input items (directories, inpath entries, source roots, etc.)? Verbose output is good for debugging, but it's helpful to see some summary of how much is being compiled in a batch build without so much information.</comment>
		<comment id="3" date="2006-06-13 15:46:49 EDT" author="Wes Isberg">Fixed in AjcTask.java:1.55 with new logCommand option that emits the entire command to INFO (verbose mode does the same, but also adds all other verbose messages).  No summary is correct in the presence of command editors, so the actual command is the best option absent heinous code to parse and summarize the command as edited.  I also left the command elements in [array, mode] to make parsing easier if need be.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="008efca98bdfe5cda6c32ec75575facf7da2c687" author="wisberg" date="2006-06-14 04:45:44"/>
          <file name="taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java">
          </file>
          <file name="taskdefs/testsrc/org/aspectj/tools/ant/taskdefs/AjcTaskTest.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="147701" opendate="2006-6-19 5:48:00" fixdate="2006-6-20 6:57:00">
    <buginformation>
      <summary>"@DeclareParents does not use FQNs for exceptions declared in throws-clauses, leading to NoClassDefFoundError"</summary>
      <description>This is my code:

@Aspect
public class TestBeanAdvice {

    public static class ApplicationContextAwareImpl implements ApplicationContextAware {
        public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {

        }
    }

    @DeclareParents(value="org.springframework.beans.TestBean", defaultImpl=TestBeanAdvice.ApplicationContextAwareImpl.class)
    private ApplicationContextAware implementationInterface;
}

If I use this advice with the load-time weaver I get this exception:

org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'testBean' defined in class path resource [org/springframework/context/support/testbean-context.xml]: Instantiation of bean failed; nested exception is java.lang.NoClassDefFoundError: BeansException
Caused by: java.lang.NoClassDefFoundError: BeansException
	at java.lang.Class.getDeclaredMethods0(Native Method)
	at java.lang.Class.privateGetDeclaredMethods(Class.java:2365)
	at java.lang.Class.getDeclaredMethods(Class.java:1763)
	at java.beans.Introspector$1.run(Introspector.java:1265)
	at java.security.AccessController.doPrivileged(Native Method)
	at java.beans.Introspector.getPublicDeclaredMethods(Introspector.java:1263)
	at java.beans.Introspector.getTargetMethodInfo(Introspector.java:1129)
	at java.beans.Introspector.getBeanInfo(Introspector.java:387)
	at java.beans.Introspector.getBeanInfo(Introspector.java:159)
	at org.springframework.beans.CachedIntrospectionResults.&lt;init&gt;(CachedIntrospectionResults.java:142)
	at org.springframework.beans.CachedIntrospectionResults.forClass(CachedIntrospectionResults.java:83)
	at org.springframework.beans.BeanWrapperImpl.setIntrospectionClass(BeanWrapperImpl.java:238)
	at org.springframework.beans.BeanWrapperImpl.setWrappedInstance(BeanWrapperImpl.java:196)
	at org.springframework.beans.BeanWrapperImpl.setWrappedInstance(BeanWrapperImpl.java:179)
	at org.springframework.beans.BeanWrapperImpl.&lt;init&gt;(BeanWrapperImpl.java:132)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.instantiateBean(AbstractAutowireCapableBeanFactory.java:502)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:356)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:256)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:167)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:253)
	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:332)
	at org.springframework.context.support.AspectJClassLoaderWithGenericApplicationContextTests.testCreateApplicationContextWithBeanFactoryAndAspectJClassLoader(AspectJClassLoaderWithGenericApplicationContextTests.java:63)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at com.intellij.rt.execution.junit2.JUnitStarter.main(JUnitStarter.java:32)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at com.intellij.rt.execution.application.AppMain.main(AppMain.java:90)

(wrapped in a Spring exception, I'm using the container)

After doing some debugging I found the exception appears when loading the dependencies of the TestBean class, so I guess there's a problem with the way the parent is declared in the bytecode of TestBean.

You can find the TestBean class here:

http://fisheye1.cenqua.com/browse/~raw,r=1.28/springframework/spring/test/org/springframework/beans/TestBean.java

Steven</description>
      <comments>
		<comment id="1" date="2006-06-20 03:48:43 EDT" author="Andrew Clement">Problem was someone calling getClassName() rather than getName() - the latter includes the package name in what it returns, the former does not.  I also fixed a bug that occurs if you fail to declare that the Impl class implements the interface - it was failing at runtime with an IncompatibleClassChangeError, it now gives an error at compile time.

Fix committed - waiting on build.</comment>
		<comment id="2" date="2006-06-20 06:57:43 EDT" author="Andrew Clement">fix available in latest dev build.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="8cab27018dc4dc96ad5eba90df86dfe232ecb967" author="aclement" date="2006-06-20 04:18:02"/>
          <file name="tests/bugs152/pr147701/TestBean.java">
          </file>
          <file name="tests/bugs152/pr147701/TestBean2.java">
          </file>
          <file name="tests/bugs152/pr147701/TestBean3.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="147801" opendate="2006-6-19 18:07:00" fixdate="2006-6-22 4:16:00">
    <buginformation>
      <summary>java.lang.ClassFormatError: Repetitive method name/signature</summary>
      <description>I get a ClassFormatError trying to perform runtime-weaving on a DB2 class.
The class being woven is COM.ibm.db2.jdbc.app.DB2PreparedStatement.  
The full message exception is: java.lang.ClassFormatError: Repetitive method name/signature in class file COM/ibm/db2/jdbc/app/DB2PreparedStatement.

In examining the post-weave class file, it looks as if Aspectj is defining
a duplicate method within the class called getParameterMetaData().  

Here are the messages from the weaver:
04:21:13,640 INFO  [STDOUT] info weaving 'COM.ibm.db2.jdbc.app.DB2CallableStatement'
04:21:13,640 INFO  [STDOUT] info weaver operating in reweavable mode.  Need to verify any required types exist.
04:21:13,671 INFO  [STDOUT] info weaving 'COM.ibm.db2.jdbc.app.DB2PreparedStatement'
04:21:13,671 INFO  [STDOUT] info weaver operating in reweavable mode.  Need to verify any required types exist.
04:21:13,703 INFO  [STDOUT] weaveinfo Join point 'method-execution(java.sql.ResultSet COM.ibm.db2.jdbc.app.DB2PreparedStatement.executeQuery())' in Type 'COM.ibm.db2.jdbc.app.DB2PreparedStatement' (DB2PreparedStatement.java:1679) advised by before advice from 'com.ibm.tivoli.itcam.toolkit.ai.aspectj.captureJDBC.CaptureSQLStatement' (CaptureSQLStatement.aj:747) [with runtime test]
04:21:13,703 INFO  [STDOUT] weaveinfo Join point 'method-execution(java.sql.ResultSet COM.ibm.db2.jdbc.app.DB2PreparedStatement.executeQuery())' in Type 'COM.ibm.db2.jdbc.app.DB2PreparedStatement' (DB2PreparedStatement.java:1679) advised by afterReturning advice from 'com.ibm.tivoli.itcam.toolkit.ai.aspectj.captureJDBC.CaptureSQLStatement' (CaptureSQLStatement.aj:946) [with runtime test]
04:21:13,718 INFO  [STDOUT] weaveinfo Join point 'method-execution(java.sql.ResultSet COM.ibm.db2.jdbc.app.DB2PreparedStatement.executeQuery())' in Type 'COM.ibm.db2.jdbc.app.DB2PreparedStatement' (DB2PreparedStatement.java:1679) advised by afterThrowing advice from 'com.ibm.tivoli.itcam.toolkit.ai.aspectj.captureJDBC.CaptureSQLStatement' (CaptureSQLStatement.aj:971) [with runtime test]
04:21:13,718 INFO  [STDOUT] weaveinfo Join point 'method-execution(boolean COM.ibm.db2.jdbc.app.DB2PreparedStatement.execute())' in Type 'COM.ibm.db2.jdbc.app.DB2PreparedStatement' (DB2PreparedStatement.java:3971) advised by before advice from 'com.ibm.tivoli.itcam.toolkit.ai.aspectj.captureJDBC.CaptureSQLStatement' (CaptureSQLStatement.aj:833) [with runtime test]
04:21:13,718 INFO  [STDOUT] weaveinfo Join point 'method-execution(boolean COM.ibm.db2.jdbc.app.DB2PreparedStatement.execute())' in Type 'COM.ibm.db2.jdbc.app.DB2PreparedStatement' (DB2PreparedStatement.java:3971) advised by afterReturning advice from 'com.ibm.tivoli.itcam.toolkit.ai.aspectj.captureJDBC.CaptureSQLStatement' (CaptureSQLStatement.aj:946) [with runtime test]</description>
      <comments>
		<comment id="1" date="2006-06-20 03:49:48 EDT" author="Andrew Clement">i've been sent the classes privately - it looks like multiple bridge methods are being created.  I need to work out why there should be any first, and if there should be any then why there is more than one.</comment>
		<comment id="2" date="2006-06-20 04:29:51 EDT" author="Andrew Clement">Ok, in the unwoven class we have a method:

public COM.ibm.db2.jdbc.app.DB2ParameterMetaData getParameterMetaData() 
       throws java.sql.SQLException;

In the woven class we end up with:

public COM.ibm.db2.jdbc.app.DB2ParameterMetaData getParameterMetaData() 
       throws java.sql.SQLException;
public java.sql.ParameterMetaData getParameterMetaData()       
       throws java.sql.SQLException;
public java.sql.ParameterMetaData getParameterMetaData()       
       throws java.sql.SQLException;

the extra two methods look like this:

public java.sql.ParameterMetaData getParameterMetaData()
       throws java.sql.SQLException;
  Code:
   Stack=1, Locals=1, Args_size=1
   0:   aload_0
   1:   invokevirtual   #1902; //Method getParameterMetaData:()LCOM/ibm/db2/jdbc/app/DB2ParameterMetaData;
   4:   areturn
  LineNumberTable:
   line 1: 0
  Exceptions:
   throws java.sql.SQLException

They look like bridge methods, but I've not checked the access flags to verify that.  The class file version before and after weaving is 45.3 (Java 1.1).

So, I need to:
- confirm if they are bridge methods
- if so, determine why they are getting created, since the method takes no parameters it looks like the compiler believes covariance  is occurring or generic types are involved and so it needs to put them in - thats not right.


The class declaration is:

public class COM.ibm.db2.jdbc.app.DB2PreparedStatement 
     extends COM.ibm.db2.jdbc.app.DB2Statement 
  implements java.sql.PreparedStatement,com.ibm.db2.jcc.SQLJPreparedStatement

So, I need to see the class in the hierarchy that declares getParameterMetaData, which could be DB2Statement/PreparedStatement or SQLJPreparedStatement.

And why on earth are there two of them?</comment>
		<comment id="3" date="2006-06-21 08:19:53 EDT" author="Andrew Clement">I've put in a 'fix' for this.  I have recreated a situation where an incorrect bridge method is created, but I've not been able to recreate a situation where two are created as in this case.  Having obtained more of the types involved in this situation, it is very peculiar.

The compiler is assuming covariance is occurring and generating a bridge method.


It thinks this method in DB2PreparedStatement:

public COM.ibm.db2.jdbc.app.DB2ParameterMetaData getParameterMetaData() 
       throws java.sql.SQLException;


is implementing this method in PreparedStatement because DB2PreparedStatement implements PreparedStatement

public java.sql.ParameterMetaData getParameterMetaData()       
       throws java.sql.SQLException;


It makes the assumption that if you have two methods like that in a hierarchy then one is the implementation....

But in this case it looks like DB2PreparedStatement was compiled against an old version of PreparedStatement that didnt have a getParameterMetaData() method.  This *has* to be the case because DB2ParameterMetaData type returned by the implementation extends Object... it is not covariance.

Then it just so happens that when the application is run, it finds the more up to date version of PreparedStatement that does include this getParameterMetaData() method.  Whether this code actually behaves, I don't know - I'm a little surprised there is no verify problem.

Anyway, to cover this case i now verify absolutely that there is some kind of relationship between the return type of the submethod and the return type of the super method - if there isn't then it's not covariance.

I've also exposed bridge method debugging via the option:

-Xset:debugBridging=true

With that option, here is an example of the output for the testcase:
Bridging: Determining if we have to bridge to Foo.getParameterMetaData()LSub;
Bridging: Checking supertype java.lang.Object
  Bridging:checking for override of getParameterMetaData in java.lang.Object
Bridging:checking superinterface PreparedStatement
  Bridging:checking for override of getParameterMetaData in PreparedStatement
  Bridging:seriously considering this might be getting overridden 'ParameterMetaData PreparedStatement.getParameterMetaData()'
  Bridging:checking for override of getParameterMetaData in java.lang.Object
Bridging:checking superinterface java.io.Serializable
  Bridging:checking for override of getParameterMetaData in java.io.Serializable
  Bridging:checking for override of getParameterMetaData in java.lang.Object</comment>
		<comment id="4" date="2006-06-22 04:16:24 EDT" author="Andrew Clement">fix has been tested and confirmed to work...</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="13dde4efd453d32bb4f25781a8fa7aafc2cef850" author="aclement" date="2006-06-21 08:33:21"/>
          <file name="tests/bugs152/pr147801/Foo.java">
          </file>
          <file name="tests/bugs152/pr147801/PreparedStatement.java">
          </file>
          <file name="tests/src/org/aspectj/systemtest/ajc152/Ajc152Tests.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/World.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java">
              <method name="createBridgeMethod" returnType="void" parameters="BcelWorld LazyMethodGen LazyClassGen ResolvedMember"/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="148545" opendate="2006-6-24 18:27:00" fixdate="2006-6-26 4:20:00">
    <buginformation>
      <summary>NoSuchMethodError calling generic method of privileged aspect from advice</summary>
      <description>MyEnum.java
===========
public enum MyEnum {
	ONE, TWO, THREE, FOUR, FIVE
}

---

MyAnnotation.java
=================
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;

@Retention(RetentionPolicy.RUNTIME)
public @interface MyAnnotation {
	MyEnum[] value();
}

---

MyClass.java
============
public class MyClass {

	public MyEnum getValue() {
		return MyEnum.ONE;
	}

	@MyAnnotation({ MyEnum.ONE, MyEnum.TWO })
	public void test() {
	}

	public static void main(String[] args) {
		new MyClass().test();
	}
}

---

MyAspect.aj
===========
import java.util.Arrays;

privileged public aspect MyAspect {

	Object around(MyClass o, MyAnnotation a) :
			execution(@MyAnnotation * *(..)) &amp;&amp;
			target(o) &amp;&amp;
			@annotation(a) {
		if (!isOneOf(o.getValue(), a.value()))
			throw new IllegalStateException(
					o.getValue() +
					" is not one of " +
					Arrays.toString(a.value()));
		return proceed(o, a);
	}

	private static final &lt;T&gt; boolean isOneOf(T obj, T[] arr) {
		for (T el : arr) if (obj == el) return true;
		return false;
	}
}

---

Executing the main method of MyClass produces:

Exception in thread "main" java.lang.NoSuchMethodError: MyAspect.isOneOf(LMyEnum;[LMyEnum;)Z
	at MyAspect.ajc$privMethod$MyAspect$MyAspect$isOneOf(MyAspect.aj:1)
	at MyClass.test_aroundBody1$advice(MyClass.java:109)
	at MyClass.test(MyClass.java:1)
	at MyClass.main(MyClass.java:12)

---

What's interesting is that if you remove the "privileged" modifier from the aspect definition, then it works fine.</description>
      <comments>
		<comment id="1" date="2006-06-26 03:31:33 EDT" author="Andrew Clement">fix committed - will be in next dev build.  the privilege accessor generation code wasnt aware of generic methods.</comment>
		<comment id="2" date="2006-06-26 04:20:45 EDT" author="Andrew Clement">fix available in latest AJ dev build.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="75a17318a97a8528c2604ada7ce159b3e46f12a6" author="aclement" date="2006-06-26 03:50:54"/>
          <file name="tests/bugs152/pr148545/MyAnnotation.java">
          </file>
          <file name="tests/bugs152/pr148545/MyAspect.java">
          </file>
          <file name="tests/bugs152/pr148545/MyClass.java">
          </file>
          <file name="tests/bugs152/pr148545/MyEnum.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="148536" opendate="2006-6-24 13:21:00" fixdate="2006-6-26 4:21:00">
    <buginformation>
      <summary>NullPointerException when declaring inter-type annotation</summary>
      <description>public aspect Bug {
	declare @type : Object+ : @SomeAnnotation;
}

If SomeAnnotation cannot be found, this aspect produces an internal compiler error:

java.lang.NullPointerException
at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.doDeclareAnnotations(AjLookupEnvironment.java:806)
at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.weaveInterTypeDeclarations(AjLookupEnvironment.java:592)
at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.weaveIntertypes(AjLookupEnvironment.java:363)
at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.completeTypeBindings(AjLookupEnvironment.java:214)
at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.beginToCompile(Compiler.java:301)
at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:315)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:862)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:242)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:161)
at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:122)
at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)

NullPointerException thrown: null</description>
      <comments>
		<comment id="1" date="2006-06-26 03:32:33 EDT" author="Andrew Clement">Fix committed.  If we cope with the NPE correctly then the rest of the infrastructure puts out the correct message about the missing type.</comment>
		<comment id="2" date="2006-06-26 04:21:23 EDT" author="Andrew Clement">fix available in latest AJ dev build.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="045e82d5cebc9c9674ac71cffa3fefc34eeb042f" author="aclement" date="2006-06-26 02:59:34"/>
          <file name="tests/bugs152/pr148536/Bug.java">
          </file>
          <file name="tests/bugs152/pr148537/MyAspect.java">
          </file>
          <file name="tests/bugs152/pr148537/MyClass.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="148786" opendate="2006-6-27 5:42:00" fixdate="2006-6-27 7:31:00">
    <buginformation>
      <summary>new array construction join point can fail for freaky array constructors</summary>
      <description>Took me a while to discover how to recreate this problem, but this class:

public class A {
  public static void main(String []argv) {
    byte[][] bytes = new byte[][]{{0},{1}};
  }
}

causes this bytecode:

0:   iconst_2
1:   anewarray       #18; //class "[B"

and this causes the newarray joinpoint code to go bang.
(eg. before(): call(*[].new(..)) {})

java.lang.NullPointerException
        at org.aspectj.weaver.bcel.BcelWorld.fromBcel(BcelWorld.java:236)
        at org.aspectj.weaver.bcel.BcelWorld.makeJoinPointSignatureForArrayConstruction(BcelWorld.java:483)
        at org.aspectj.weaver.bcel.BcelShadow.makeArrayConstructorCall(BcelShadow.java:801)
        at org.aspectj.weaver.bcel.BcelClassWeaver.match(BcelClassWeaver.java:2510)
        at org.aspectj.weaver.bcel.BcelClassWeaver.match(BcelClassWeaver.java:2325)
        at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:490)
        at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:115)
        at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1574)
        at org.aspectj.weaver.bcel.BcelWeaver.weaveWithoutDump(BcelWeaver.java:1525)
        at org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify(BcelWeaver.java:1305)
        at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1127)</description>
      <comments>
		<comment id="1" date="2006-06-27 07:31:30 EDT" author="Andrew Clement">tiny localized fix committed (only changes anything when -Xjoinpoints:arrayconstruction active)</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="792d1dfd50e8b9ca5df70ea84c0b35de9cfba0f3" author="aclement" date="2006-06-27 08:34:41"/>
          <file name="tests/bugs152/pr148786/A.java">
          </file>
          <file name="tests/src/org/aspectj/systemtest/ajc152/Ajc152Tests.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/bcel/BcelWorld.java">
              <method name="makeJoinPointSignatureForArrayConstruction" returnType="Member" parameters="LazyClassGen InstructionHandle"/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="148388" opendate="2006-6-23 9:55:00" fixdate="2006-6-28 3:50:00">
    <buginformation>
      <summary>LTW weaver produces a debug message at the begining</summary>
      <description>Using the code in bug #148381 (with any of the working options), LT weaver 
produces what seems a debug message:
"? WeavingClassFileProvider.acceptResult() test.Main-&gt;test.Main$AjcClosure1"

&gt; java -javaagent:%ASPECTJ_LIB_HOME%\aspectjweaver.jar test.Main
? WeavingClassFileProvider.acceptResult() test.Main-&gt;test.Main$AjcClosure1
Method Main.foo() took longer than expected
        Max expected = 1000, actual = 65371</description>
      <comments>
		<comment id="1" date="2006-06-27 08:37:59 EDT" author="Matthew Webster">That was me, some debug info left over from fixing Bug 139936.</comment>
		<comment id="2" date="2006-06-27 10:44:26 EDT" author="Andrew Clement">going to close out for final 1.5.2 if we just need to remove a line?</comment>
		<comment id="3" date="2006-06-27 14:25:26 EDT" author="Matthew Webster">Fix committed</comment>
		<comment id="4" date="2006-06-28 03:50:46 EDT" author="Matthew Webster">Fix available</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="99d1c184fdbaafc772ae290d7af3b3430e33d33b" author="mwebster" date="2006-06-28 03:28:17"/>
          <file name="weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java">
              <method name="getRequestor" returnType="IWeaveRequestor" parameters=""/>
              <method name="acceptResult" returnType="void" parameters="UnwovenClassFile"/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="148727" opendate="2006-6-26 16:46:00" fixdate="2006-6-28 7:32:00">
    <buginformation>
      <summary>Can't call synthetic aspectOf method on aspect in library jar</summary>
      <description>Separate compilation of the following program breaks on 1.5.2rc1 because of the recent change to marking aspect methods as synthetic:

public aspect Asp {
}

public class Client {
    public static void main(String argz[]) {
        System.out.println("Can call aspectOf? "+Asp.aspectOf());
    }
}

C:\devel\scratch\synthetic&gt;ajc -classpath asp.jar;%CLASSPATH% Client.java
C:\devel\scratch\synthetic\Client.java:3 [error] The method aspectOf() is undefi
ned for the type Asp
System.out.println("Can call aspectOf? "+Asp.aspectOf());


1 error

C:\devel\scratch\synthetic&gt;javac -classpath asp.jar;%CLASSPATH% Client.java
Client.java:3: cannot find symbol
symbol  : method aspectOf()
location: class Asp
        System.out.println("Can call aspectOf? "+Asp.aspectOf());
                                                    ^
1 error

Clearly it's vital that external users of a library be able to call API methods like aspectOf on library aspects.

This works:

C:\devel\scratch\synthetic&gt;ajc *.aj Client.java

C:\devel\scratch\synthetic&gt;java Client
Can call aspectOf? Asp@b89838

Patch with test integrated into CVS tree to follow...</description>
      <comments>
		<comment id="1" date="2006-06-26 17:08:17 EDT" author="Ron Bodkin">I think the best fix for this problem would be to enhance the iajc compiler to allow calls to the synthetic aspectOf and hasAspect methods. It's reasonable to require the use of an AspectJ-aware compiler to call these methods. For users who only use javac, they should already be using @AspectJ (i.e., it seems appropriate to fix this with the AspectJ compiler and not require the methods to be visible to javac).</comment>
		<comment id="2" date="2006-06-26 17:40:25 EDT" author="Ron Bodkin">Created attachment 45335 [details]
2 added test cases: integrated compilation works, separate compilation breaks.</comment>
		<comment id="3" date="2006-06-27 10:25:55 EDT" author="Andrew Clement">thanks for the test programs.

Enabling ajc to allow calls to synthetic methods isn't trivial, it requires compiler changes and the changes may have unexpected side effects.  Currently the compiler deliberately filters out synthetic methods (and &lt;clinit&gt;s) from types it loads, meaning they are not available when resolving program statements (ofc they still exist in the bytecode).  And if we do choose to expose any synthetic methods at all, I'm not sure what impact that has on the rest of the JDT compiler.

options appear to be:
- go back to the old days of these two methods being AjSynthetic and not 'really' synthetic but ensuring they have a dummy line number table to keep other tools happy 
     (straightforward)
- expose all synthetic methods in the compiler as callable 
     (no!)
- expose just hasAspect/aspectOf in the compiler as callable 
     (doable, but not something I'd prefer to do in an RC, I'm not sure we can tell that we're loading an aspect at that point either, so may have to make these available for all types - not that they are likely to occur in classes of course.  And requires a careful extension to the compiler rather than hacking 'aspectOf/hasAspect' directly into JDT)</comment>
		<comment id="4" date="2006-06-27 11:45:59 EDT" author="Adrian Colyer">Doh. It's obvious in hindsight that this would happen. 

I think the best solution for 1.5.2 is:

  "- go back to the old days of these two methods being AjSynthetic and not
  'really' synthetic but ensuring they have a dummy line number table to keep
  other tools happy 
       (straightforward)"

it's only two methods, and they are part of the programming model so I guess in this case it's ok to have them not be fully synthetic. We could possibly look at making them truly synthetic and allowing calls to them from in the compiler, but that's a further out thing (and possibly doesn't add much value over the approach above).

Note that generating the line number table will be needed if we make them non-synthetic otherwise Emma et al. will break again (but JAXB and ORM tools will be happy).</comment>
		<comment id="5" date="2006-06-28 05:14:00 EDT" author="Andrew Clement">I've just committed the code to go back to the old way for aspectOf()/hasAspect() - had to modify the existing testcode and I've committed Rons test program too.

I've manually inspected that the (fake) line number table was there for the two methods but haven't written a test for it.</comment>
		<comment id="6" date="2006-06-28 05:46:29 EDT" author="Adrian Colyer">fix looks good, thanks Andy. Enjoyed the droids ;)</comment>
		<comment id="7" date="2006-06-28 07:32:47 EDT" author="Andrew Clement">fix available.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="21e06a69892469bab688d2315e7e034047431082" author="aclement" date="2006-06-28 06:16:01"/>
          <file name="tests/bugs152/pr148727/Client.java">
          </file>
          <file name="tests/src/org/aspectj/systemtest/ajc152/Ajc152Tests.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/NameMangler.java">
              <method name="isSyntheticMethod" returnType="boolean" parameters="String boolean"/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="148693" opendate="2006-6-26 13:29:00" fixdate="2006-7-5 4:22:00">
    <buginformation>
      <summary>woven class does not pass org.apache.bcel.verifier.statics.Pass2Verifier</summary>
      <description>'Number of LocalVariableTable attributes of Code attribute '&lt;CODE&gt;' (method 'public static mypackage.MyAspect aspectOf() [(Unknown attribute org.aspectj.weaver.AjSynthetic)]') exceeds number of local variable slots '0' ('There may be no more than one LocalVariableTable attribute per local variable in the Code attribute.').'.

=================================================
package mypackage; 

public aspect MyAspect { 

    pointcut executeMethod(): within(TestClass) &amp;&amp; execution(* *(..)); 

    before(): executeMethod() { 
     System.out.println("Enter "+thisJoinPointStaticPart); 
    } 
    after(): executeMethod() { 
     System.out.println("Leave "+thisJoinPointStaticPart); 
    } 
} 

class TestClass { 

public static void main(String[] args) { 
} 

} 

================================================
JustIce by Enver Haase, (C) 2001-2002. 
&lt;http://bcel.sourceforge.net&gt; 
&lt;http://jakarta.apache.org/bcel&gt; 

Now verifying: mypackage.TestClass 

Pass 1: 
VERIFIED_OK 
Passed verification. 

Pass 2: 
VERIFIED_OK 
Passed verification. 

Pass 3a, method number 0 ['public void &lt;init&gt;()']: 
VERIFIED_OK 
Passed verification. 

Pass 3b, method number 0 ['public void &lt;init&gt;()']: 
VERIFIED_OK 
Passed verification. 

Pass 3a, method number 1 ['public static void main(String[] args) [(Unknown 
attribute org.aspectj.weaver.MethodDeclarationLineNumber: 
00 00 00 05 00 00 00 46)]']: 
VERIFIED_REJECTED 
Instruction invokestatic[184](3) 28 constraint violated: Return type 
class/interface could not be verified successfully: 'Number of 
LocalVariableTable attributes of Code attribute '&lt;CODE&gt;' (method 'public 
static mypackage.MyAspect aspectOf() [(Unknown attribute 
org.aspectj.weaver.AjSynthetic)]') exceeds number of local variable slots 
'0' ('There may be no more than one LocalVariableTable attribute per local 
variable in the Code attribute.').'. 

Pass 3b, method number 1 ['public static void main(String[] args) [(Unknown 
attribute org.aspectj.weaver.MethodDeclarationLineNumber: 
00 00 00 05 00 00 00 46)]']: 
VERIFIED_NOTYET 
Not yet verified. 

Pass 3a, method number 2 ['static void &lt;clinit&gt;()']: 
VERIFIED_OK 
Passed verification. 

Pass 3b, method number 2 ['static void &lt;clinit&gt;()']: 
VERIFIED_OK 
Passed verification. 

Warnings: 
Pass 2: Attribute '(Unknown attribute 
org.aspectj.weaver.WeaverVersion: 00 03 00 00 00 00 00 00 
00 00... (truncated))' as an attribute of the ClassFile structure 'public 
class mypackage.TestClass extends java.lang.Object 
filename  mypackage.TestClass 
compiled from  TestClass.java 
compiler version 46.0 
access flags  33 
constant pool  69 entries 
ACC_SUPER flag  true 

Attribute(s): 
SourceFile(TestClass.java) 
(Unknown attribute org.aspectj.weaver.WeaverVersion: 00 03 
00 00 00 00 00 00 00 00... (truncated)) 
(Unknown attribute org.aspectj.weaver.WeaverState: 53 00 00 00 01 00 12 6d 
79 70... (truncated)) 

1 fields: 
private static final org.aspectj.lang.JoinPoint$StaticPart 
ajc$tjp_0 

3 methods: 
public void &lt;init&gt;() 
public static void main(String[] args) [(Unknown attribute 
org.aspectj.weaver.MethodDeclarationLineNumber: 00 00 00 05 
00 00 00 46)] 
static void &lt;clinit&gt;() 
' is unknown and will therefore be ignored. 
Pass 2: Attribute '(Unknown attribute org.aspectj.weaver.WeaverState: 53 00 
00 00 01 00 12 6d 79 70... (truncated))' as an attribute of the ClassFile 
structure 'public class mypackage.TestClass extends java.lang.Object 
filename  mypackage.TestClass 
compiled from  TestClass.java 
compiler version 46.0 
access flags  33 
constant pool  69 entries 
ACC_SUPER flag  true 

Attribute(s): 
SourceFile(TestClass.java) 
(Unknown attribute org.aspectj.weaver.WeaverVersion: 00 03 
00 00 00 00 00 00 00 00... (truncated)) 
(Unknown attribute org.aspectj.weaver.WeaverState: 53 00 00 00 01 00 12 6d 
79 70... (truncated)) 

1 fields: 
private static final org.aspectj.lang.JoinPoint$StaticPart 
ajc$tjp_0 

3 methods: 
public void &lt;init&gt;() 
public static void main(String[] args) [(Unknown attribute 
org.aspectj.weaver.MethodDeclarationLineNumber: 00 00 00 05 
00 00 00 46)] 
static void &lt;clinit&gt;() 
' is unknown and will therefore be ignored. 
Pass 2: Attribute '&lt;LocalVariableTable: LocalVariable(start_pc = 0, length = 
5, index = 0:mypackage.TestClass this)&gt;' as an attribute of Code attribute 
'&lt;CODE&gt;' (method 'public void &lt;init&gt;()') will effectively be ignored and is 
only useful for debuggers and such. 
Pass 2: Attribute '&lt;LineNumberTable: LineNumber(0, 3)&gt;' as an attribute of 
Code attribute '&lt;CODE&gt;' (method 'public void &lt;init&gt;()') will effectively be 
ignored and is only useful for debuggers and such. 
Pass 2: Attribute '(Unknown attribute 
org.aspectj.weaver.MethodDeclarationLineNumber: 00 00 00 05 
00 00 00 46)' as an attribute of Method 'public static void main(String[] 
args) [(Unknown attribute 
org.aspectj.weaver.MethodDeclarationLineNumber: 00 00 00 05 
00 00 00 46)]' is unknown and will therefore be ignored. 
Pass 2: Attribute '(Unknown attribute 
org.aspectj.weaver.MethodDeclarationLineNumber: 00 00 00 05 
00 00 00 46)' as an attribute of Method 'public static void main(String[] 
args) [(Unknown attribute 
org.aspectj.weaver.MethodDeclarationLineNumber: 00 00 00 05 
00 00 00 46)]' is neither Code nor Exceptions and is therefore only of use 
for debuggers and such. 
Pass 2: Unknown attribute '(Unknown attribute 
org.aspectj.weaver.MethodDeclarationLineNumber: 00 00 00 05 
00 00 00 46)'. This attribute is not known in any context! 
Pass 2: Attribute '&lt;LocalVariableTable: LocalVariable(start_pc = 9, length = 
0, index = 0:String[] args)&gt;' as an attribute of Code attribute '&lt;CODE&gt;' 
(method 'public static void main(String[] args) [(Unknown attribute 
org.aspectj.weaver.MethodDeclarationLineNumber: 00 00 00 05 
00 00 00 46)]') will effectively be ignored and is only useful for debuggers 
and such. 
Pass 2: Attribute '&lt;LineNumberTable: LineNumber(9, 6)&gt;' as an attribute of 
Code attribute '&lt;CODE&gt;' (method 'public static void main(String[] args) 
[(Unknown attribute 
org.aspectj.weaver.MethodDeclarationLineNumber: 00 00 00 05 
00 00 00 46)]') will effectively be ignored and is only useful for debuggers 
and such. 
Pass 2: Class or interface initialization method 'static void &lt;clinit&gt;()' 
has superfluous access modifier(s) set: everything but ACC_STRICT is 
ignored. 
Pass 2: Attribute '&lt;LineNumberTable: LineNumber(0, 1)&gt;' as an attribute of 
Code attribute '&lt;CODE&gt;' (method 'static void &lt;clinit&gt;()') will effectively 
be ignored and is only useful for debuggers and such. 
Pass 2: Unknown attribute '(Unknown attribute 
org.aspectj.weaver.WeaverVersion: 00 03 00 00 00 00 00 00 
00 00... (truncated))'. This attribute is not known in any context! 
Pass 2: Unknown attribute '(Unknown attribute 
org.aspectj.weaver.WeaverState: 53 00 00 00 01 00 12 6d 79 70... 
(truncated))'. This attribute is not known in any context!</description>
      <comments>
		<comment id="1" date="2006-07-04 06:24:32 EDT" author="Andrew Clement">Can I ask which bcel verifier you are using, the one in AspectJ or the one from the standard bcel project?

Is this class actually causing you a problem when you run it or are you just raising the issue because you happened to try it through a verifier?

The verifier is complaining because there are no local variables for the aspectOf() method and yet there is a LocalVariableTable attribute.  Now the LocalVariableTable attribute is empty but because there is one and 'one' is greater than the number of localvariables for the method then it fails verification.  I think the verifier should have checked how many variables got defined in that local variable table entry...  However, it is an optimization to skip the attribute creation when there are none, so I'm seeing what impact that has on the AspectJ test suite.  I'm nervous about preventing its creation entirely as some funky coverage tools or debugging tools may like to see it...</comment>
		<comment id="2" date="2006-07-04 22:29:14 EDT" author="Dake Gu">I'm using the one in BCEL 5.1 and 5.2</comment>
		<comment id="3" date="2006-07-04 22:30:30 EDT" author="Dake Gu">The class is OK at runtime, but I just happened to try bcel Verifier</comment>
		<comment id="4" date="2006-07-05 04:22:17 EDT" author="Andrew Clement">Although I cannot find anywhere in the JVM spec that specifies an empty local variable table is invalid, I think this optimization is OK.  Hopefully the coverage/debugger tools out there won't barf when they can't find it - I mean they shouldn't be looking, there are no local variables...  we'll have to keep an eye out...and deactivate this optimization if anything unusual happens in the wild.

I've created a utility method called verifyClass() that will run the bcel verifier over a class from the sandbox - we may use this more in the future, see it being used in Ajc153Tests.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="82f217fa97084beaa1c4c88ec2e96e4cf83e8aad" author="aclement" date="2006-07-05 05:22:55"/>
          <file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectDeclaration.java">
              <method name="generateMethod" returnType="void" parameters="ClassFile MethodBinding List BodyGenerator"/>
          </file>
          <file name="tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java">
          </file>
          <file name="tests/src/org/aspectj/testing/Utils.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="148537" opendate="2006-6-24 13:30:00" fixdate="2006-7-5 5:41:00">
    <buginformation>
      <summary>ClassCastException on private nested annotation with @Retention meta-annotation given an array-type value</summary>
      <description>MyClass.java
============
public class MyClass {

	@Retention({RententionPolicy.RUNTIME})
	private @interface MyAnnotation {
	}
}

---

MyAspect.aj
===========
privileged public aspect MyAspect {

	declare @type : MyClass+ : @MyClass.MyAnnotation;

}

---

Internal Compiler Error:

java.lang.ClassCastException
at org.aspectj.org.eclipse.jdt.internal.compiler.ast.Annotation.detectStandardAnnotation(Annotation.java:99)
at org.aspectj.org.eclipse.jdt.internal.compiler.ast.Annotation.resolveType(Annotation.java:280)
at org.aspectj.org.eclipse.jdt.internal.compiler.ast.ASTNode.resolveAnnotations(ASTNode.java:436)
at org.aspectj.org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.getAnnotationTagBits(SourceTypeBinding.java:743)
at org.aspectj.org.eclipse.jdt.internal.compiler.ast.Annotation.resolveType(Annotation.java:331)
at org.aspectj.org.eclipse.jdt.internal.compiler.ast.ASTNode.resolveAnnotations(ASTNode.java:436)
at org.aspectj.org.eclipse.jdt.internal.compiler.lookup.MethodBinding.getAnnotationTagBits(MethodBinding.java:450)
at org.aspectj.org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.resolveTypesFor(SourceTypeBinding.java:1268)
at org.aspectj.org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.methods(SourceTypeBinding.java:1081)
at org.aspectj.ajdt.internal.compiler.ast.AspectDeclaration.checkSpec(AspectDeclaration.java:131)
at org.aspectj.ajdt.internal.compiler.ast.AspectDeclaration.buildInterTypeAndPerClause(AspectDeclaration.java:1070)
at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.buildInterTypeAndPerClause(AjLookupEnvironment.java:463)
at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.collectAllITDsAndDeclares(AjLookupEnvironment.java:332)
at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.completeTypeBindings(AjLookupEnvironment.java:173)
at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.beginToCompile(Compiler.java:301)
at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:315)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:862)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:242)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:161)
at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:122)
at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)

ClassCastException thrown: org.aspectj.org.eclipse.jdt.internal.compiler.ast.ArrayInitializer</description>
      <comments>
		<comment id="1" date="2006-06-24 13:37:56 EDT" author="Matt Whitlock">Actually, it turns out the aspect isn't even needed.

This is enough to trigger the Internal Compiler Error:

Bug.java
========
public class Bug {

 @Retention({RetentionPolicy.RUNTIME})
 public @interface MyAnnotation {
 }
}

---

I just realized that the @Retention meta-annotation isn't supposed to take an array-type value.  The problem goes away when I change it to the proper:

@Retention(RetentionPolicy.RUNTIME)

Therefore, this is a trivial bug.

It looks like the regular Java compiler also throws an Internal Compiler Error on the incorrect construct, so it's probably not specifically an AspectJ problem.</comment>
		<comment id="2" date="2006-07-05 05:41:00 EDT" author="Andrew Clement">Fix committed. May already be fixed in the Eclipse 3.2 compiler - we should look out when we move to it.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="045e82d5cebc9c9674ac71cffa3fefc34eeb042f" author="aclement" date="2006-06-26 02:59:34"/>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="148972" opendate="2006-6-28 7:24:00" fixdate="2006-7-5 5:44:00">
    <buginformation>
      <summary>problems with binary weaving declare parents in mixed environment.</summary>
      <description>These have been reported to me on a large system doing some intricate weaving where some classes are 1.2, some 1.4, some 1.5 and the VM is 1.5.  Binary weaving declare parents sometimes refuses to allow the modification of the hierarchy because it sees a clash between two methods when there is none.  The two cases I'm fixing are:
  1. sometimes the signatures of the return types differ with the '.' or '/' problem (fix == be consistent)
  2. sometimes the syntheticness of the methods in the relationship isn't determined correctly</description>
      <comments>
		<comment id="1" date="2006-07-05 05:44:26 EDT" author="Andrew Clement">'fix' committed. see BcelTypeMunger.mungeNewParent()</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="2f2f5683643a0f1e0856ac43fa590c4b39f1be26" author="aclement" date="2006-06-28 08:44:10"/>
          <file name="tests/src/org/aspectj/systemtest/ajc152/Ajc152Tests.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java">
              <method name="mungeNewParent" returnType="boolean" parameters="BcelClassWeaver NewParentTypeMunger"/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="148737" opendate="2006-6-26 20:09:00" fixdate="2006-7-5 5:48:00">
    <buginformation>
      <summary>IllegalStateException for non-generic type</summary>
      <description>I believe this is similar to 112880.  The message and stack trace I am getting are

 -- (IllegalStateException) Can't ask to parameterize a member of non-generic type: com...object  kind(raw)
Can't ask to parameterize a member of non-generic type: com...object  kind(raw)
java.lang.IllegalStateException: Can't ask to parameterize a member of non-generic type: com....object  kind(raw)
	at org.aspectj.weaver.ResolvedMemberImpl.parameterizedWith(ResolvedMemberImpl.java:612)
	at org.aspectj.weaver.ResolvedMemberImpl.parameterizedWith(ResolvedMemberImpl.java:597)
	at org.aspectj.weaver.ReferenceType.getDeclaredMethods(ReferenceType.java:508)
	at org.aspectj.weaver.ResolvedType$4.get(ResolvedType.java:225)
	at org.aspectj.weaver.Iterators$3$1.hasNext(Iterators.java:118)
	at org.aspectj.weaver.Iterators$5.hasNext(Iterators.java:171)
	at org.aspectj.weaver.Iterators$3.hasNext(Iterators.java:128)
	at org.aspectj.weaver.ResolvedType.lookupMember(ResolvedType.java:345)
	at org.aspectj.weaver.ResolvedType.lookupMethod(ResolvedType.java:326)
.
.
.

The same code was able to be weaved under 1.5.0.  The reason why this is a major issue is 1.5.0 suffers from a StackOverflowException.</description>
      <comments>
		<comment id="1" date="2006-06-26 22:40:25 EDT" author="Brian Keyser">The stackoverflow bug was 125101.</comment>
		<comment id="2" date="2006-06-27 03:10:40 EDT" author="Andrew Clement">Does comment #1 about 125101 apply to this bug?  since the exception included in the initial text is an IllegalStateException?

I've seen this IllegalState occur for a few reasons.  Can I ask if you are doing a regular command line compile or are you in AJDT or are you doing loadtime weaving?

Did the code compile/weave ok under AspectJ 1.5.1a or did it also fail there?  

I'm very confused by the text of the message as it says the declaring type is 'com...object' ??!  Do you have a package called that?  Is there any way you can summarize your type hierarchy (the part that includes generic signatures) so that I can investigate further?</comment>
		<comment id="3" date="2006-06-30 03:59:34 EDT" author="Andrew Clement">have you managed to try this on 1.5.1a yet?</comment>
		<comment id="4" date="2006-06-30 12:11:36 EDT" author="Brian Keyser">Created attachment 45597 [details]
Simple class with non-utilized generic</comment>
		<comment id="5" date="2006-06-30 12:12:30 EDT" author="Brian Keyser">Created attachment 45598 [details]
Class that extends B</comment>
		<comment id="6" date="2006-06-30 12:13:33 EDT" author="Brian Keyser">Created attachment 45599 [details]
Class that obtains an aspect.</comment>
		<comment id="7" date="2006-06-30 12:14:10 EDT" author="Brian Keyser">Created attachment 45601 [details]
"Controlling method" used in the aspect</comment>
		<comment id="8" date="2006-06-30 12:15:17 EDT" author="Brian Keyser">Created attachment 45602 [details]
aspect that causes the parameterization error</comment>
		<comment id="9" date="2006-06-30 12:21:02 EDT" author="Brian Keyser">Hi Andy,

I was able to create a small test reproducible test case.  You will have to forgive the obfuscation, but it was the best I could do.  I have attached the following files:  A.java, B.java, C.java, D.java, and TestAspect.aj.  The command I used to compile the files is

% ajc -source 5 -target 5 -inpath C:\Software\hibernate.org\hibernate-3.1\hibernate3.jar A.java B.java C.java D.java TestAspect.aj

Obviously, you will need the hibernate3.jar for the compilation.

The bug 148738 is related to this bug as you will see from the output.

The same problem happens with 1.5.1a.

If you have any questions, please let me know.</comment>
		<comment id="10" date="2006-07-03 09:44:20 EDT" author="Andrew Clement">I've made a shorter test program that demonstrates the failure (didn't need hibernate):

=========8&lt;============
public abstract class A&lt;E&gt; { 
    public A() { }
    public void setUniqueID(Object o) {}
}

class B extends A {
    public B() {}    
}

class D {
    public void method() {
        B b = new B();
        b.setUniqueID(null);
    }
}

aspect TestAspect {
 before(): call(public void *.*()) { }    
}

=========8&lt;============

ajc -source 5 -target 5 A.java

It turns out the actual problem is that you are supplying "-source 5" rather than "-source 1.5".  Although the compiler sees these as equivalent, the weaver only understands "1.5".  Typically we invoke the compiler with this shorthand:

ajc -1.5 A.java

So - I've made the weaver understand "5".

Just to confirm this is what you are seeing, can you try supplying the option as "1.5".  My fix should be in a dev build shortly (this is probably the fix for the other bug too...)</comment>
		<comment id="11" date="2006-07-04 09:00:15 EDT" author="Andrew Clement">fix to also support "5" is in the latest AJ dev build.</comment>
		<comment id="12" date="2006-07-05 05:48:27 EDT" author="Andrew Clement">fix is available - please reopen if you continue to have problems.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="f6834c7692082a20e94f7d88841e6c7c3f96c26a" author="aclement" date="2006-07-03 10:49:07"/>
          <file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java">
              <method name="parseOption" returnType="void" parameters="String LinkedList"/>
          </file>
          <file name="tests/bugs153/pr148737/A.java">
          </file>
          <file name="tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="148409" opendate="2006-6-23 12:29:00" fixdate="2006-7-19 9:47:00">
    <buginformation>
      <summary>[generics] ClassCastException in UnresolvedType.java:348</summary>
      <description>I am using AspectJ load time weaving with Spring 2.0 RC1 to inject my entities, and I am getting the following exception:

java.lang.ClassCastException: org.aspectj.apache.bcel.classfile.Signature$TypeVariableSignature
	at org.aspectj.weaver.UnresolvedType.forGenericTypeSignature(UnresolvedType.java:348)
	at org.aspectj.weaver.bcel.BcelWorld.addSourceObjectType(BcelWorld.java:385)
	at org.aspectj.weaver.loadtime.ClassLoaderWeavingAdaptor.accept(ClassLoaderWeavingAdaptor.java:492)
	at org.aspectj.weaver.tools.WeavingAdaptor.shouldWeave(WeavingAdaptor.java:230)
	at org.aspectj.weaver.tools.WeavingAdaptor.weaveClass(WeavingAdaptor.java:210)
	at org.aspectj.weaver.loadtime.Aj.preProcess(Aj.java:65)
	at org.aspectj.weaver.loadtime.ClassPreProcessorAgentAdapter.transform(ClassPreProcessorAgentAdapter.java:55)
	at sun.instrument.TransformerManager.transform(TransformerManager.java:122)
	at sun.instrument.InstrumentationImpl.transform(InstrumentationImpl.java:155)
	at java.lang.ClassLoader.defineClass1(Native Method)

.
.
.

Having examined the call stack under the debugger, this seems to happening when the weaver is attempting to determine whether a particular class should be weaved. The exception is thrown in the following method, at the cast highlighted below.


    public static UnresolvedType forGenericTypeSignature(String sig,String declaredGenericSig) {
    	UnresolvedType ret = UnresolvedType.forSignature(sig);
    	ret.typeKind=TypeKind.GENERIC;
    	
    	ClassSignature csig = new GenericSignatureParser().parseAsClassSignature(declaredGenericSig);
    	
    	Signature.FormalTypeParameter[] ftps = csig.formalTypeParameters;
    	ret.typeVariables = new TypeVariable[ftps.length];
    	for (int i = 0; i &lt; ftps.length; i++) {
			Signature.FormalTypeParameter parameter = ftps[i];
			Signature.ClassTypeSignature cts = (Signature.ClassTypeSignature)parameter.classBound; // EXCEPTION HERE!
			ret.typeVariables[i]=new TypeVariable(ftps[i].identifier,UnresolvedType.forSignature(cts.outerType.identifier+";"));
		}
    	ret.signatureErasure = sig;
    	ret.signature = ret.signatureErasure;
    	return ret;
    }


The class in question (which is not one that requires weaving), has the following signature:

public class HibernateEntityDAO&lt;interfaceT extends SecurityEntity, concreteT extends interfaceT&gt; extends HibernateDaoSupport
        implements EntityDAO&lt;interfaceT&gt;
 
The exception is happening because the parameter.classBound member is not of type Signature.ClassTypeSignature, but an instance of Signature.TypeVariableSignature.

The loop variable i is 1, and parameter.identifier is "concreteT", so it looks like it's the signature of the second type parameter (concreteT) that is tripping up the weaver.</description>
      <comments>
		<comment id="1" date="2006-06-23 12:34:46 EDT" author="Rob David">Created attachment 45187 [details]
Debugger Screenshot</comment>
		<comment id="2" date="2006-07-06 08:09:41 EDT" author="Andrew Clement">thanks for the clear bug report - I've recreated it, added a testcase and committed the fix into CVS.  waiting on build...</comment>
		<comment id="3" date="2006-07-19 09:47:31 EDT" author="Andrew Clement">fix available in latest AspectJ dev builds.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="369de870280d4ae4f1e984a7bd8a76affb4ed0a2" author="aclement" date="2006-07-06 09:12:07"/>
          <file name="tests/bugs153/pr148409/Blurgh.java">
          </file>
          <file name="tests/bugs153/pr148409/X.java">
          </file>
          <file name="tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/UnresolvedType.java">
              <method name="forGenericTypeSignature" returnType="UnresolvedType" parameters="String String"/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="149305" opendate="2006-6-30 10:25:00" fixdate="2006-7-19 9:48:00">
    <buginformation>
      <summary>[@AspectJ] Source file ordering dependency in @AspectJ aspects inheritance</summary>
      <description>Compiling following code placed in different packages causes unexpected error.
======================================================
package com.codesrc.ozonator;

import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Pointcut;
import com.codesrc.ozonator.identity.User;

@Aspect
public abstract class AbstractOzonator
{

  @Pointcut("")
  protected abstract void readMethodExecution();

  @Pointcut("readMethodExecution() &amp;&amp; this(ozonated)")
  private void ozonatedReadExecution(Object ozonated){};

  @Around("ozonatedReadExecution(ozonated)")
  public Object aroundGetterCallNoRecurse( ProceedingJoinPoint thisJoinPoint,
      Object ozonated) throws Throwable
  {
    System.out.println("thisJoinPoint="+thisJoinPoint+", ozonated="+ozonated);
      return thisJoinPoint.proceed();
  }

}
-------------------------------------------------------------
package com.codesrc.ozonator.identity;

import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Pointcut;

import com.codesrc.ozonator.AbstractOzonator;

@Aspect
public class IdentityOzonator extends AbstractOzonator 
{
    @Pointcut("execution(public *  com.codesrc.ozonator.identity.User+.get*(..)) ")
	protected void readMethodExecution() {}
}
========================================================================

/home/kei/tmp/0/t3/src/com/codesrc/ozonator/identity/IdentityOzonator.java:1 [error] the parameter thisJoinPoint is not bound in [all branches of] pointcut
(no source information available)

If I place all code into one package, then the code is being compiled successfuly.

This bag looks like Bug 125699, but I use aspectj-1.5.2.rc1.</description>
      <comments>
		<comment id="1" date="2006-06-30 10:33:32 EDT" author="Eugene Kireyev">Created attachment 45589 [details]
Two cases of aspect inheritance

This file contains two test cases of same aspects. One case with all files placed into one package (ajtest2) and other with concrete aspect placed in subpackage of abstract aspect.</comment>
		<comment id="2" date="2006-07-03 11:52:28 EDT" author="Andrew Clement">Can I ask how you are compiling the files? they all work for me.

I am on windows which might make a difference...

I un-gzip'd your tar and expanded the directories, I can then compile either using sourceroots:
=====8&lt;=======
F:\case2&gt;ajc -1.5 -showWeaveInfo -sourceroots .

Join point 'method-execution(java.lang.String com.codesrc.ozonator.identity.User.getName())' in Type 'com.codesrc.ozonator.identity.User' (User.java:7) advised by around advice from 'com.codesrc.ozonator.identity.IdentityOzonator' (AbstractOzonator.java:20)
=====8&lt;=======

or all the files separately:
=====8&lt;=======
F:\case2&gt;ajc -1.5 com\codesrc\ozonator\AbstractOzonator.java com\codesrc\ozonato
r\identity\IdentityOzonator.java com\codesrc\ozonator\identity\User.java -showWeaveInfo

Join point 'method-execution(java.lang.String com.codesrc.ozonator.identity.User.getName())' in Type 'com.codesrc.ozonator.identity.User' (User.java:7) advised by around advice from 'com.codesrc.ozonator.identity.IdentityOzonator' (AbstractOzonator.java:20)

=====8&lt;=======</comment>
		<comment id="3" date="2006-07-03 12:28:21 EDT" author="Eugene Kireyev">(In reply to comment #2)
&gt; Can I ask how you are compiling the files? they all work for me.
&gt; 
&gt; I am on windows which might make a difference...

I am on Linux (Fedora Core 5 )
I un-gzip'd this tar.gz file into t4 directory and run compiler with "-1.5 -showWeaveInfo -sourceroots src" options:
========================================================================
[kei@xenophobe t4]$ /opt/Java/jdk1.5.0_07/bin/java -cp /opt/Java/aspectj1.5.2rc1/lib/aspectjweaver.jar:/opt/Java/aspectj1.5.2rc1/lib/aspectjtools.jar:/opt/Java/aspectj1.5.2rc1/lib/aspectjrt.jar:/opt/Java/aspectj1.5.2rc1/lib/aspectjlib.jar: -Xmx256M org.aspectj.tools.ajc.Main -cp /opt/Java/aspectj1.5.2rc1/lib/aspectjweaver.jar:/opt/Java/aspectj1.5.2rc1/lib/aspectjtools.jar:/opt/Java/aspectj1.5.2rc1/lib/aspectjrt.jar:/opt/Java/aspectj1.5.2rc1/lib/aspectjlib.jar: -1.5 -showWeaveInfo -sourceroots src
Join point 'method-execution(java.lang.String com.codesrc.ozonator.identity.User.getName())' in Type 'com.codesrc.ozonator.identity.User' (User.java:7) advised by around advice from 'com.codesrc.ozonator.identity.IdentityOzonator' (AbstractOzonator.java:20)

/home/kei/tmp/0/t4/src/com/codesrc/ozonator/identity/IdentityOzonator.java:1 [error] the parameter thisJoinPoint is not bound in [all branches of] pointcut
(no source information available)
Join point 'method-execution(java.lang.String ajtest2.User.getName())' in Type 'ajtest2.User' (User.java:7) advised by around advice from 'ajtest2.IdentityOzonator' (AbstractOzonator.java:19)
======================================================================

I think what this error depends on real file order on hard disk (without any sorting). At first time I get this type of error when I moved source code from one compuer to another one. On my first machine I have not any error, on second machine I got alot of errors.
After what I made two directories with source tree of my real project, one from this directories compiles without any errors, and another one give me 24 errors.
The "diff" utility results no differnece between this two source tree. But results of "find" utility (real file order on disk) are different.</comment>
		<comment id="4" date="2006-07-04 03:55:04 EDT" author="Andrew Clement">you are correct about it being ordering, I've recreated it.</comment>
		<comment id="5" date="2006-07-04 09:11:57 EDT" author="Andrew Clement">the problem is here is if the sub-aspect is defined first.  If this happens then when the super-aspect is defined then we go through the 'addOrReplaceDescendants' processing in CrosscuttingMembersSet.  This gets us into trouble as we forget the set of advice arguments we can ignore when looking at whether the pointcut is binding them all.</comment>
		<comment id="6" date="2006-07-04 13:02:51 EDT" author="Andrew Clement">fix committed - waiting on build.</comment>
		<comment id="7" date="2006-07-19 09:48:48 EDT" author="Andrew Clement">fix available in latest AspectJ dev build.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="4a8b8532694b79c106efd1eb70070e71174b6f1a" author="aclement" date="2006-07-05 01:53:37"/>
          <file name="tests/bugs153/pr148693/MyAspect.java">
          </file>
          <file name="tests/bugs153/pr149305/case1/AbstractOzonator.java">
          </file>
          <file name="tests/bugs153/pr149305/case1/IdentityOzonator.java">
          </file>
          <file name="tests/bugs153/pr149305/case1/User.java">
          </file>
          <file name="tests/bugs153/pr149305/case2/com/codesrc/ozonator/AbstractOzonator.java">
          </file>
          <file name="tests/bugs153/pr149305/case2/com/codesrc/ozonator/identity/IdentityOzonator.java">
          </file>
          <file name="tests/bugs153/pr149305/case2/com/codesrc/ozonator/identity/User.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="150671" opendate="2006-7-14 12:19:00" fixdate="2006-7-27 3:35:00">
    <buginformation>
      <summary>declare error on set of volatile field does not work</summary>
      <description>When an aspect has a declare error statement involving a pointcut that captures the setting of a volatile field, a compilation error is not produced.  

This bug can be reproduced as follows.  Consider the following class:

class A {
   private volatile int state;

   public void foo() {
      state = 0;
   }
}

Now consider this aspect:

aspect FSM {
   declare error: set(* A.state): "Changing state";
}

The setting of the state field in method foo() does not result in a compilation error as expected.  

I originally noticed this bug when using AJDT 1.4 with Eclipse 3.2.  However this has been reproduced and confirmed with the aspectj 1.5.2 compiler.</description>
      <comments>
		<comment id="1" date="2006-07-24 10:35:54 EDT" author="Helen Beeken">Created attachment 46703 [details]
failing testcase

Apply this patch to the tests project.

Failing testcase that fits into the AJ test suite using the example code provided by Arjun.</comment>
		<comment id="2" date="2006-07-24 10:37:24 EDT" author="Helen Beeken">Note: this bug is not specific to deow statements. Advice is also not applied if the variable 'state' is declared volatile.

The reason this bug is happening is that in the case of the volatile variable we enter the following if statement (SignaturePattern line 307):

  if (aMember.isBridgeMethod() &amp;&amp; !allowBridgeMethods) {
    return FuzzyBoolean.MAYBE;
  }

When 'volatile' is removed we bypass this if statement because aMember.isBridgeMethod() returns false. The reason for the difference is in ResolvedMemberImpl.isBridgeMethod() whose implementation is:

   public boolean isBridgeMethod() {
     return (modifiers &amp; Constants.ACC_BRIDGE)!=0;
    }

where Constants.ACC_BRIDGE = 0x0040. The field with the 'volatile' keyword has modifers = 66 which is why this returns true.</comment>
		<comment id="3" date="2006-07-24 10:41:00 EDT" author="Andrew Clement">I thought it might be something like this.  Modifier flags sometimes 'share' bit values (presumably to keep more available for future use).  You can't have a volatile method and you can't have a bridge field - so they are safely mutually exclusive.  the problem is with our code not saying the first condition of being a bridge method is that you *are a method* ... if we also checked it was a method then the isBridgeMethod() wont return true for fields...</comment>
		<comment id="4" date="2006-07-24 11:27:51 EDT" author="Helen Beeken">Created attachment 46711 [details]
patch containing fix

Apply this patch to the weaver project.

This patch contains a proposed fix to only return true in ResolvedMemberImpl.isBridgeMethod() if &amp;'ing the modifiers and bridge constants returns non zero and if the ResolvedMemberImpl has kind Member.METHOD.</comment>
		<comment id="5" date="2006-07-25 03:42:54 EDT" author="Andrew Clement">patches committed.</comment>
		<comment id="6" date="2006-07-27 03:35:30 EDT" author="Helen Beeken">fixes available in the latest dev build</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="357bbe9eeb34748f7c8c2ff85049230db2adbbf2" author="aclement" date="2006-07-25 04:46:13"/>
          <file name="tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/ResolvedMemberImpl.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="151673" opendate="2006-7-25 5:45:00" fixdate="2006-7-31 3:31:00">
    <buginformation>
      <summary>Incorrect weaving of after returning when 'input' bytecode is of a strange form</summary>
      <description>We have had a user report a problem where after advice being woven into a particular method is producing code that does not verify.  The problem occurs if the bytecode being input to the weaving process includes a subroutine that contains the return from the method.

Here is the problematic snippet produced by some unknown compiler:
   200:	invokespecial	#17; //Method com/MyException."&lt;init&gt;":(Ljava/lang/String;)V
   203:	athrow
   204:	aload_3
   205:	astore	6
   207:	jsr	234
   210:	aload	6
   212:	areturn
   213:	astore	4
   215:	aload	4
   217:	invokevirtual	#79; //Method java/lang/Throwable.printStackTrace:()V
   220:	jsr	234
   223:	goto	238
   226:	astore	7
   228:	jsr	234
   231:	aload	7
   233:	athrow
   234:	astore	8
   236:	aload_3
   237:	areturn
   238:	return
  Exception table:
   from   to  target type
     2   213   213   Class javax/ejb/FinderException

     2   226   226   any

see the jsr's jump to 234, but before the subroutine return at 238 there is an areturn out of the method (this method returns a String).

After weaving we get something like this:

   200:	invokespecial	#17; //Method com/MyException."&lt;init&gt;":(Ljava/lang/String;)V
   203:	athrow
   204:	aload_3
   205:	astore	6
   207:	jsr	238
   210:	aload	6
   212:	astore	9
   214:	goto	248
   217:	astore	4
   219:	aload	4
   221:	invokevirtual	#79; //Method java/lang/Throwable.printStackTrace:()V
   224:	jsr	238
   227:	goto	246
   230:	astore	7
   232:	jsr	238
   235:	aload	7
   237:	athrow
   238:	astore	8
   240:	aload_3
   241:	astore	9
   243:	goto	248
   246:	astore	9
   248:	invokestatic	#299; //Method After.aspectOf:()LAfter;
   251:	invokevirtual	#302; //Method After.ajc$afterReturning$After$1$26d6d4a7:()V
   254:	aload	9
   256:	return

see how the areturn has been lost - this code will blow up with a verify error (the string is on the stack, we just ignore it and 'return' normally)</description>
      <comments>
		<comment id="1" date="2006-07-27 03:32:19 EDT" author="Andrew Clement">the neatest fix here is that when we collect up the returns for a method, if this is a method with a non-void return type we don't try and use 'RETURN' - which is what happens at the moment in BcelShadow.

Whilst working on this I discovered a bug where duplicate RETURNs (second is harmless) are inserted in woven code for methods woven with a VOID return value.  also fixing that.</comment>
		<comment id="2" date="2006-07-27 06:13:01 EDT" author="Andrew Clement">fixes committed.</comment>
		<comment id="3" date="2006-07-31 03:31:34 EDT" author="Andrew Clement">fix available.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="e4ab0ae5762be7d9869e0eee350677ac79749150" author="aclement" date="2006-07-27 06:57:26"/>
          <file name="weaver/src/org/aspectj/weaver/bcel/BcelShadow.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="151845" opendate="2006-7-26 9:44:00" fixdate="2006-7-31 3:32:00">
    <buginformation>
      <summary>NPE while building</summary>
      <description>Building of a large project fails while weaving. 
NPE in EclipseSourceContext.removeUnnecessaryProblems(..)

The project was just migrated to Eclipse 3.2
Eclipse newly installed with Eclipse SDK and via Update manager with
AJDT, CDT, Web/J2EE tools, SubClipse, SpringIDE.

Same Project workes in Eclipse 3.1.
Simple Test AspectJ-Project workes OK
Building with Ant/AspectJ compiler (as external Tools Launch in Eclipse)
works.

I tried the following, but got the error anyway:
 - Checked out as a new AspectJ Project
 - upgraded to the developement Version of AJDT</description>
      <comments>
		<comment id="1" date="2006-07-26 09:47:56 EDT" author="Hermann VoÃeler">Version: 1.4.1
Build id: 20060726064959
AspectJ version: 1.5.3.20060726092219


Stacktrace/Error Output:
java.lang.NullPointerException
at org.aspectj.ajdt.internal.core.builder.EclipseSourceContext.removeUnnecessaryProblems(EclipseSourceContext.java:82)
at org.aspectj.weaver.bcel.BcelAdvice.removeUnnecessaryProblems(BcelAdvice.java:297)
at org.aspectj.weaver.bcel.BcelAdvice.implementOn(BcelAdvice.java:214)
at org.aspectj.weaver.Shadow.implementMungers(Shadow.java:684)
at org.aspectj.weaver.Shadow.implement(Shadow.java:471)
at org.aspectj.weaver.bcel.BcelClassWeaver.implement(BcelClassWeaver.java:2825)
at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:502)
at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:115)
at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1591)
at org.aspectj.weaver.bcel.BcelWeaver.weaveWithoutDump(BcelWeaver.java:1542)
at org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify(BcelWeaver.java:1322)
at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1143)
at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave(AjCompilerAdapter.java:321)
at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling(AjCompilerAdapter.java:192)
at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$afterReturning$org_aspectj_ajdt_internal_compiler_CompilerAdapter$2$f9cc9ca0(CompilerAdapter.aj:70)
at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:367)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:890)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:245)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:164)
at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:122)
at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)

trouble in: 
public abstract class baag.boa.esn.client.ESNEnumDao extends java.lang.Object implements baag.boa.mvc.element.enums.EnumFilter:
  protected baag.boa.common.interfaces.ESN esn
  private String filterDaoID
  private baag.boa.esn.server.workflowfw.dao.ClientDataDao filterDAO
  private static final org.aspectj.lang.JoinPoint$StaticPart ajc$tjp_0 [Synthetic]
  public void &lt;init&gt;():
                    ALOAD_0     // Lbaag/boa/esn/client/ESNEnumDao; this   (line 37)
                    INVOKESPECIAL java.lang.Object.&lt;init&gt; ()V
    constructor-execution(void baag.boa.esn.client.ESNEnumDao.&lt;init&gt;())
    |               ALOAD_0     // Lbaag/boa/esn/client/ESNEnumDao; this   (line 47)
    |               ACONST_NULL
    |               PUTFIELD baag.boa.esn.client.ESNEnumDao.filterDaoID Ljava/lang/String;
    |               ALOAD_0     // Lbaag/boa/esn/client/ESNEnumDao; this   (line 59)
    |               ACONST_NULL
    |               PUTFIELD baag.boa.esn.client.ESNEnumDao.filterDAO Lbaag/boa/esn/server/workflowfw/dao/ClientDataDao;
    |               RETURN   (line 37)
    constructor-execution(void baag.boa.esn.client.ESNEnumDao.&lt;init&gt;())
  end public void &lt;init&gt;()

  public void setEsn(baag.boa.common.interfaces.ESN)    org.aspectj.weaver.MethodDeclarationLineNumber: 42:1596
:
    method-execution(void baag.boa.esn.client.ESNEnumDao.setEsn(baag.boa.common.interfaces.ESN))
    |               ALOAD_0     // Lbaag/boa/esn/client/ESNEnumDao; this   (line 42)
    |               ALOAD_1     // Lbaag/boa/common/interfaces/ESN; esn
    |               PUTFIELD baag.boa.esn.client.ESNEnumDao.esn Lbaag/boa/common/interfaces/ESN;
    |               RETURN
    method-execution(void baag.boa.esn.client.ESNEnumDao.setEsn(baag.boa.common.interfaces.ESN))
  end public void setEsn(baag.boa.common.interfaces.ESN)

  public void setFilterDaoID(String)    org.aspectj.weaver.MethodDeclarationLineNumber: 46:1754
:
    method-execution(void baag.boa.esn.client.ESNEnumDao.setFilterDaoID(java.lang.String))
    |               ALOAD_0     // Lbaag/boa/esn/client/ESNEnumDao; this   (line 46)
    |               ALOAD_1     // Ljava/lang/String; fidID
    |               PUTFIELD baag.boa.esn.client.ESNEnumDao.filterDaoID Ljava/lang/String;
    |               RETURN
    method-execution(void baag.boa.esn.client.ESNEnumDao.setFilterDaoID(java.lang.String))
  end public void setFilterDaoID(String)

  protected baag.boa.esn.server.workflowfw.dao.ClientDataDao getFilter() throws baag.boa.exception.BOAException    org.aspectj.weaver.MethodDeclarationLineNumber: 51:1946
:
    method-execution(baag.boa.esn.server.workflowfw.dao.ClientDataDao baag.boa.esn.client.ESNEnumDao.getFilter())
    |               ALOAD_0     // Lbaag/boa/esn/client/ESNEnumDao; this   (line 52)
    | field-get(baag.boa.esn.server.workflowfw.dao.ClientDataDao baag.boa.esn.client.ESNEnumDao.filterDAO)
    | |             GETFIELD baag.boa.esn.client.ESNEnumDao.filterDAO Lbaag/boa/esn/server/workflowfw/dao/ClientDataDao;
    | field-get(baag.boa.esn.server.workflowfw.dao.ClientDataDao baag.boa.esn.client.ESNEnumDao.filterDAO)
    |               IFNONNULL L1
    |               ALOAD_0     // Lbaag/boa/esn/client/ESNEnumDao; this   (line 53)
    | field-get(java.lang.String baag.boa.esn.client.ESNEnumDao.filterDaoID)
    | |             GETFIELD baag.boa.esn.client.ESNEnumDao.filterDaoID Ljava/lang/String;
    | field-get(java.lang.String baag.boa.esn.client.ESNEnumDao.filterDaoID)
    |               IFNONNULL L0
    |               NEW baag.boa.exception.BOARuntimeException   (line 54)
    |               DUP
    |               LDC "Fehlkonfig: ID fÃ¼r Filter-DAO nicht definiert."
    | constructor-call(void baag.boa.exception.BOARuntimeException.&lt;init&gt;(java.lang.String))
    | |             INVOKESPECIAL baag.boa.exception.BOARuntimeException.&lt;init&gt; (Ljava/lang/String;)V
    | constructor-call(void baag.boa.exception.BOARuntimeException.&lt;init&gt;(java.lang.String))
    |               ATHROW
    |           L0: ALOAD_0     // Lbaag/boa/esn/client/ESNEnumDao; this   (line 55)
    |               ALOAD_0     // Lbaag/boa/esn/client/ESNEnumDao; this
    | field-get(baag.boa.common.interfaces.ESN baag.boa.esn.client.ESNEnumDao.esn)
    | |             GETFIELD baag.boa.esn.client.ESNEnumDao.esn Lbaag/boa/common/interfaces/ESN;
    | field-get(baag.boa.common.interfaces.ESN baag.boa.esn.client.ESNEnumDao.esn)
    |               ALOAD_0     // Lbaag/boa/esn/client/ESNEnumDao; this
    | field-get(java.lang.String baag.boa.esn.client.ESNEnumDao.filterDaoID)
    | |             GETFIELD baag.boa.esn.client.ESNEnumDao.filterDaoID Ljava/lang/String;
    | field-get(java.lang.String baag.boa.esn.client.ESNEnumDao.filterDaoID)
    |               ASTORE_1
    |               ASTORE_2
    | method-call(baag.boa.esn.server.workflowfw.dao.ClientDataDao baag.boa.common.interfaces.ESN.filterData(java.lang.String))
    | |             INVOKESTATIC baag.boa.common.connect.ServerFasadenDefinition.aspectOf ()Lbaag/boa/common/connect/ServerFasadenDefinition;
    | |             ALOAD_2
    | |             BIPUSH 3
    | |             ANEWARRAY java.lang.Object
    | |             ASTORE_3
    | |             ALOAD_3
    | |             BIPUSH 0
    | |             ALOAD_0
    | |             AASTORE
    | |             ALOAD_3
    | |             BIPUSH 1
    | |             ALOAD_2
    | |             AASTORE
    | |             ALOAD_3
    | |             BIPUSH 2
    | |             ALOAD_1
    | |             AASTORE
    | |             NEW baag.boa.esn.client.ESNEnumDao$AjcClosure1
    | |             DUP
    | |             ALOAD_3
    | |             INVOKESPECIAL baag.boa.esn.client.ESNEnumDao$AjcClosure1.&lt;init&gt; ([Ljava/lang/Object;)V
    | |             GETSTATIC baag.boa.esn.client.ESNEnumDao.ajc$tjp_0 Lorg/aspectj/lang/JoinPoint$StaticPart;
    | |             INVOKEVIRTUAL baag.boa.common.connect.RufServer.ajc$around$baag_boa_common_connect_RufServer$1$19b2b7d5 (Ljava/lang/Object;Lorg/aspectj/runtime/internal/AroundClosure;Lorg/aspectj/lang/JoinPoint$StaticPart;)Ljava/lang/Object;
    | |             CHECKCAST baag.boa.esn.server.workflowfw.dao.ClientDataDao
    | method-call(baag.boa.esn.server.workflowfw.dao.ClientDataDao baag.boa.common.interfaces.ESN.filterData(java.lang.String))
    |               PUTFIELD baag.boa.esn.client.ESNEnumDao.filterDAO Lbaag/boa/esn/server/workflowfw/dao/ClientDataDao;
    |           L1: ALOAD_0     // Lbaag/boa/esn/client/ESNEnumDao; this   (line 57)
    | field-get(baag.boa.esn.server.workflowfw.dao.ClientDataDao baag.boa.esn.client.ESNEnumDao.filterDAO)
    | |             GETFIELD baag.boa.esn.client.ESNEnumDao.filterDAO Lbaag/boa/esn/server/workflowfw/dao/ClientDataDao;
    | field-get(baag.boa.esn.server.workflowfw.dao.ClientDataDao baag.boa.esn.client.ESNEnumDao.filterDAO)
    |               ARETURN
    method-execution(baag.boa.esn.server.workflowfw.dao.ClientDataDao baag.boa.esn.client.ESNEnumDao.getFilter())
  end protected baag.boa.esn.server.workflowfw.dao.ClientDataDao getFilter() throws baag.boa.exception.BOAException

  public java.util.List select() throws baag.boa.exception.BOAException    org.aspectj.weaver.MethodDeclarationLineNumber: 70:2497
:
    method-execution(java.util.List baag.boa.esn.client.ESNEnumDao.select())
    |               ALOAD_0     // Lbaag/boa/esn/client/ESNEnumDao; this   (line 71)
    | method-call(baag.boa.esn.server.workflowfw.dao.ClientDataDao baag.boa.esn.client.ESNEnumDao.getFilter())
    | |             INVOKEVIRTUAL baag.boa.esn.client.ESNEnumDao.getFilter ()Lbaag/boa/esn/server/workflowfw/dao/ClientDataDao;
    | method-call(baag.boa.esn.server.workflowfw.dao.ClientDataDao baag.boa.esn.client.ESNEnumDao.getFilter())
    |               ASTORE_1
    |               ALOAD_1     // Lbaag/boa/esn/server/workflowfw/dao/ClientDataDao; dau   (line 72)
    |               ICONST_0
    | method-call(void baag.boa.esn.server.workflowfw.dao.ClientDataDao.setBisElement(int))
    | |             INVOKEINTERFACE baag.boa.esn.server.workflowfw.dao.ClientDataDao.setBisElement (I)V
    | method-call(void baag.boa.esn.server.workflowfw.dao.ClientDataDao.setBisElement(int))
    |               ALOAD_0     // Lbaag/boa/esn/client/ESNEnumDao; this   (line 73)
    |               ALOAD_0     // Lbaag/boa/esn/client/ESNEnumDao; this
    | field-get(baag.boa.common.interfaces.ESN baag.boa.esn.client.ESNEnumDao.esn)
    | |             GETFIELD baag.boa.esn.client.ESNEnumDao.esn Lbaag/boa/common/interfaces/ESN;
    | field-get(baag.boa.common.interfaces.ESN baag.boa.esn.client.ESNEnumDao.esn)
    |               ALOAD_1     // Lbaag/boa/esn/server/workflowfw/dao/ClientDataDao; dau
    | method-call(java.util.List baag.boa.common.interfaces.ESN.getPresentationList(baag.boa.esn.server.workflowfw.dao.ClientDataDao))
    | |             INVOKEINTERFACE baag.boa.common.interfaces.ESN.getPresentationList (Lbaag/boa/esn/server/workflowfw/dao/ClientDataDao;)Ljava/util/List;
    | method-call(java.util.List baag.boa.common.interfaces.ESN.getPresentationList(baag.boa.esn.server.workflowfw.dao.ClientDataDao))
    | method-call(java.util.List baag.boa.esn.client.ESNEnumDao.adaptiere(java.util.List))
    | |             INVOKEVIRTUAL baag.boa.esn.client.ESNEnumDao.adaptiere (Ljava/util/List;)Ljava/util/List;
    | method-call(java.util.List baag.boa.esn.client.ESNEnumDao.adaptiere(java.util.List))
    |               ARETURN
    method-execution(java.util.List baag.boa.esn.client.ESNEnumDao.select())
  end public java.util.List select() throws baag.boa.exception.BOAException

  protected abstract java.util.List adaptiere(java.util.List)    org.aspectj.weaver.MethodDeclarationLineNumber: 79:2853
;

  static final baag.boa.esn.server.workflowfw.dao.ClientDataDao filterData_aroundBody0(baag.boa.esn.client.ESNEnumDao, baag.boa.common.interfaces.ESN, String):
                    ALOAD_1
                    ALOAD_2
                    INVOKEINTERFACE baag.boa.common.interfaces.ESN.filterData (Ljava/lang/String;)Lbaag/boa/esn/server/workflowfw/dao/ClientDataDao;   (line 55)
                    ARETURN
  end static final baag.boa.esn.server.workflowfw.dao.ClientDataDao filterData_aroundBody0(baag.boa.esn.client.ESNEnumDao, baag.boa.common.interfaces.ESN, String)
end public abstract class baag.boa.esn.client.ESNEnumDao

public class baag.boa.esn.client.ESNEnumDao$AjcClosure1 extends org.aspectj.runtime.internal.AroundClosure:
  public void &lt;init&gt;(Object[]):
                    ALOAD_0
                    ALOAD_1
                    INVOKESPECIAL org.aspectj.runtime.internal.AroundClosure.&lt;init&gt; ([Ljava/lang/Object;)V
                    RETURN
  end public void &lt;init&gt;(Object[])

  public Object run(Object[]):
                    ALOAD_0
                    GETFIELD org.aspectj.runtime.internal.AroundClosure.state [Ljava/lang/Object;
                    ASTORE_2
                    ALOAD_2
                    BIPUSH 0
                    AALOAD
                    CHECKCAST baag.boa.esn.client.ESNEnumDao
                    ALOAD_1
                    BIPUSH 0
                    AALOAD
                    CHECKCAST baag.boa.common.interfaces.ESN
                    ALOAD_2
                    BIPUSH 2
                    AALOAD
                    CHECKCAST java.lang.String
                    INVOKESTATIC baag.boa.esn.client.ESNEnumDao.filterData_aroundBody0 (Lbaag/boa/esn/client/ESNEnumDao;Lbaag/boa/common/interfaces/ESN;Ljava/lang/String;)Lbaag/boa/esn/server/workflowfw/dao/ClientDataDao;
                    ARETURN
  end public Object run(Object[])
end public class baag.boa.esn.client.ESNEnumDao$AjcClosure1

when implementing on shadow method-call(baag.boa.esn.server.workflowfw.dao.ClientDataDao baag.boa.common.interfaces.ESN.filterData(java.lang.String))
when weaving type baag.boa.esn.client.ESNEnumDao
when weaving classes 
when weaving 
when batch building BuildConfig[/home/hiv/devel/Arbeit/.metadata/.plugins/org.eclipse.ajdt.core/BOA3.generated.lst] #Files=658</comment>
		<comment id="2" date="2006-07-27 04:42:50 EDT" author="Matt Chapman">Passing over to compiler</comment>
		<comment id="3" date="2006-07-27 05:24:49 EDT" author="Andrew Clement">fix committed.  NPE guard.</comment>
		<comment id="4" date="2006-07-27 18:58:12 EDT" author="Matt Chapman">*** Bug 152024 has been marked as a duplicate of this bug. ***</comment>
		<comment id="5" date="2006-07-31 03:32:07 EDT" author="Andrew Clement">fix available in AJ dev builds.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="54f7bb4f25792e717eadf21421c81ae1dc8e0718" author="aclement" date="2006-07-27 06:27:55"/>
          <file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/EclipseSourceContext.java">
              <method name="removeUnnecessaryProblems" returnType="void" parameters="Member int"/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="152257" opendate="2006-7-29 14:18:00" fixdate="2006-8-1 8:43:00">
    <buginformation>
      <summary>Incremental compiler doesn't handle exception declaration correctly</summary>
      <description>Incrementally compiling code with advice throwing an excpetion gives errors 
stating that the exception can't be thrown. Full compilation compiles the code 
successfully.

AJDT Version: 1.4.1
Build id: 20060727081607
AspectJ version: 1.5.3.20060726092219

Here is the minimum code the reproduce the behavior.
// Main.java
package test;

import java.io.IOException;

public class Main {
	public void testMethod() throws IOException {
		methodThatThrows();
	}

	public static void methodThatThrows() throws IOException {
		System.out.println("Inside method that may throw an IOException");
	}
}

// IOExceptionInjector.aj
package test;

import java.io.IOException;

public aspect IOExceptionInjector {
	pointcut faultInjection() : call(void methodThatThrows() throws IOException);

	void around() throws IOException : faultInjection() {
		throw new IOException("Exception injected by aspect."); 
	}
}

1. Modify something in Main.java (add and delete a space, for example). 
2. Save to compile incremetally.

An error is issued for the call to methodThatThrows() stating
"Severity and Description	Path	Resource	Location	Creation Time	Id
can't throw checked exception 'java.io.IOException' at this join point 'method-call(void test.Main.methodThatThrows())'	IncrementalCompilerHandlingException/src/test	Main.java	line 7	1154196826350	7956
"

Do a full rebuild and the error goes away.</description>
      <comments>
		<comment id="1" date="2006-07-31 05:50:23 EDT" author="Matt Chapman">Thanks for the simple testcase. Reproduced with latest AJDT. Any change causing an incremental build seems to show the problem.</comment>
		<comment id="2" date="2006-07-31 11:01:44 EDT" author="Andrew Clement">between the first and second compiles we flush/clear the 'expendablemap' of types in the type map.  We shouldn't do that.  expendablemap is a weakhashmap and as soon as noone is using the values in the map in some way, they are free for GC.  flushing/clearing the expendable map by forces mean removing something that someone may still be using.  In this case the first compilation resolved IOException and got a referencetype back.  When the map is flushed, we re-resolve IOException on the second compile and get a different referencetype - these are not == and so we fail.  We do not use 'equals()' comparisons, because that's a whole world of pain.

Basically, expendableMap is a 'workingset' of types currently in use, it should be free to manage its own contents as a weakhashmap - anyone forcably managing the contents can cause this kind of problem.

Committed the testcase (thanks for the clear test program) and fix.</comment>
		<comment id="3" date="2006-08-01 08:43:53 EDT" author="Andrew Clement">fix available in AJ dev builds.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="f1f468907e99cf8fcc0ec9a3dedd467a4f78e1f3" author="aclement" date="2006-07-31 11:03:17"/>
          <file name="tests/multiIncremental/PR152257/base/Main.java">
          </file>
          <file name="tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java">
              <method name="testPr123612" returnType="void" parameters=""/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="151938" opendate="2006-7-26 19:33:00" fixdate="2006-8-2 8:48:00">
    <buginformation>
      <summary>Handle Duplicate -javaagent entries more gracefully</summary>
      <description>If you start a java 5 VM with AspectJ's load-time weaver specified more than once using the -javaagent flag, if there is an aop.xml file defined, it chokes badly: it tries to reweave the woven AspectJ code and emits massive amounts of bytecode. It would be better if AspectJ detected that it was specified more than once and gave a warning then disabled all but one of the agents. Failing that, it would be better to fail and give an error message than emit the bytecode.

This issue came up for our automated installer, which adds a -javaagent flag to VM startup commands. If the script is wrapped twice, it can generate a duplicate. We are making our scripts more intelligent to avoid this issue, but we are probably not the only people who will hit this issue (e.g., if someone manually edits both setclasspath.bat and catalina.bat to add the flag for a Tomcat instance...)</description>
      <comments>
		<comment id="1" date="2006-07-31 04:39:46 EDT" author="Matthew Webster">This is probably a good piece of self defence. We can simply test in Agent.preMain() whether we have already been call, put a simple message to stderr and return immdiately. I'm just trying to write a failing testcase.</comment>
		<comment id="2" date="2006-08-02 08:48:20 EDT" author="Matthew Webster">Fix available.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="bebb3640698bf2c465b64d9565123ec699dac45d" author="mwebster" date="2006-08-02 05:41:52"/>
          <file name="loadtime5/java5-src/org/aspectj/weaver/loadtime/Agent.java">
              <method name="premain" returnType="void" parameters="String Instrumentation"/>
          </file>
          <file name="tests/java5/ataspectj/HelloWorld.java">
          </file>
          <file name="tests/java5/ataspectj/MessageHandler.java">
          </file>
          <file name="tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="152388" opendate="2006-7-31 18:31:00" fixdate="2006-8-8 9:47:00">
    <buginformation>
      <summary>NPE in MessageUtil.addExtraSourceLocations</summary>
      <description>I get this message from an error in a recent dev build of AspectJ with load-time weaving. I don't know how there is a null source location associated with this message, but either it shouldn't be there or MessageUtil line 806 should use this patch:

Index: src/org/aspectj/bridge/MessageUtil.java
===================================================================
RCS file: /home/technology/org.aspectj/modules/bridge/src/org/aspectj/bridge/MessageUtil.java,v
retrieving revision 1.11
diff -u -r1.11 MessageUtil.java
--- src/org/aspectj/bridge/MessageUtil.java	1 Jun 2006 09:36:37 -0000	1.11
+++ src/org/aspectj/bridge/MessageUtil.java	31 Jul 2006 22:32:16 -0000
@@ -803,7 +803,7 @@
 		writer.println(baseMessage);
 		for (Iterator iter = message.getExtraSourceLocations().iterator(); iter.hasNext();) {
 		    ISourceLocation element = (ISourceLocation) iter.next();
-		    writer.print("\tsee also: " + element.toString());
+		    writer.print("\tsee also: " + element);
 		    if (iter.hasNext()) {
 		        writer.println();
 		    }

NPE follows:

java.lang.NullPointerException
	at org.aspectj.bridge.MessageUtil.addExtraSourceLocations(MessageUtil.java:806)
	at org.aspectj.bridge.MessageUtil.renderMessage(MessageUtil.java:793)
	at org.aspectj.bridge.Message.toString(Message.java:177)
	at org.aspectj.bridge.MessageWriter.render(MessageWriter.java:73)
	at org.aspectj.weaver.tools.WeavingAdaptor$WeavingAdaptorMessageHandler.render(WeavingAdaptor.java:471)
	at org.aspectj.bridge.MessageWriter.handleMessage(MessageWriter.java:41)
	at org.aspectj.weaver.tools.WeavingAdaptor$WeavingAdaptorMessageHandler.handleMessage(WeavingAdaptor.java:425)
	at org.aspectj.weaver.bcel.BcelTypeMunger.error(BcelTypeMunger.java:378)
	at org.aspectj.weaver.bcel.BcelTypeMunger.enforceDecpRule1_abstractMethodsImplemented(BcelTypeMunger.java:273)
	at org.aspectj.weaver.bcel.BcelTypeMunger.mungeNewParent(BcelTypeMunger.java:194)
	at org.aspectj.weaver.bcel.BcelTypeMunger.munge(BcelTypeMunger.java:106)
	at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:450)
	at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:115)
	at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1613)
	at org.aspectj.weaver.bcel.BcelWeaver.weaveWithoutDump(BcelWeaver.java:1564)
	at org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify(BcelWeaver.java:1341)
	at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1163)
	at org.aspectj.weaver.tools.WeavingAdaptor.getWovenBytes(WeavingAdaptor.java:288)
	at org.aspectj.weaver.tools.WeavingAdaptor.weaveClass(WeavingAdaptor.java:214)
	at org.aspectj.weaver.loadtime.Aj.preProcess(Aj.java:76)
	at org.aspectj.ext.ltw13.ClassPreProcessorAdapter.preProcess(ClassPreProcessorAdapter.java:65)
	at org.codehaus.aspectwerkz.hook.impl.ClassPreProcessorHelper.defineClass0Pre(ClassPreProcessorHelper.java:107)
	at java.lang.ClassLoader.defineClass(ClassLoader.java:539)
...

NOTE: I'm using Alex Vasseur's adaptor to invoke AspectJ LTW from a 1.4 VM, but with recursion protection added. I don't think that should change the expected behavior of Aj.</description>
      <comments>
		<comment id="1" date="2006-08-01 03:25:42 EDT" author="Andrew Clement">Hmmm ... I'd rather see a testcase for the problem that leads to this...</comment>
		<comment id="2" date="2006-08-01 04:04:33 EDT" author="Ron Bodkin">It was triggered by the current problems in LTW with ITD's. The system gets confused because of loading order for an ITD and it produces invalid bytecode so it dumps the bytecode in an abort. This bug meant that while producing the message output it hit an NPE, thereby obscuring the real error. With the patch I submitted I saw the real error message instead. 

Creating a test for this means forcing the weaver to crash, which shouldn't be possible, of course. With the ITD bug in place it's surely possible but it is dependent on order of loading in a large system (simple attempts fail)

I have temporarily fixed the original crash by working around the bug by using maps instead of ITD's. With that change the woven bytecode is valid and the bug doesn't happen.</comment>
		<comment id="3" date="2006-08-08 09:47:59 EDT" author="Andrew Clement">reworked suggestion integrated. you have caught me in a good mood today.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="a38edd39a8e998a22b41a0cf1928493aa0755e65" author="aclement" date="2006-08-08 10:48:32"/>
          <file name="bridge/src/org/aspectj/bridge/MessageUtil.java">
              <method name="addExtraSourceLocations" returnType="String" parameters="IMessage String"/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="152631" opendate="2006-8-2 13:26:00" fixdate="2006-8-9 2:53:00">
    <buginformation>
      <summary>Problem with decp on an aspect using cflow</summary>
      <description>This occurs in the AspectJ build in AJDT from August 1 but not from July 31:

java.lang.NullPointerException
at org.aspectj.weaver.bcel.BcelTypeMunger.enforceDecpRule1_abstractMethodsImplemented(BcelTypeMunger.java:250)
at org.aspectj.weaver.bcel.BcelTypeMunger.mungeNewParent(BcelTypeMunger.java:194)
at org.aspectj.weaver.bcel.BcelTypeMunger.munge(BcelTypeMunger.java:106)
at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:454)
at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:119)
at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1597)
at org.aspectj.weaver.bcel.BcelWeaver.weaveWithoutDump(BcelWeaver.java:1548)
at org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify(BcelWeaver.java:1328)
at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1124)
at org.aspectj.ajdt.internal.compiler.AjPipeliningCompilerAdapter.weaveQueuedEntries(AjPipeliningCompilerAdapter.java:451)
at org.aspectj.ajdt.internal.compiler.AjPipeliningCompilerAdapter.queueForWeaving(AjPipeliningCompilerAdapter.java:389)
at org.aspectj.ajdt.internal.compiler.AjPipeliningCompilerAdapter.afterProcessing(AjPipeliningCompilerAdapter.java:377)
at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$after$org_aspectj_ajdt_internal_compiler_CompilerAdapter$5$6b855184(CompilerAdapter.aj:98)
at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:533)
at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:329)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:891)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:246)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:165)
at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:122)
at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)

trouble in:public class glassbox.agent.ErrorContainmentTest$ErrorMockAspect extends java.lang.Object implements glassbox.agent.api.NotSerializable:
private static Throwable ajc$initFailureCause [Synthetic]
public static final glassbox.agent.ErrorContainmentTest$ErrorMockAspect ajc$perSingletonInstance [Synthetic]
static void &lt;clinit&gt;():
catch java.lang.Throwable -&gt; E0
|               INVOKESTATIC glassbox.agent.ErrorContainmentTest$ErrorMockAspect.ajc$postClinit ()V   (line 60)
catch java.lang.Throwable -&gt; E0
GOTO L0
E0: ASTORE_0
ALOAD_0
PUTSTATIC glassbox.agent.ErrorContainmentTest$ErrorMockAspect.ajc$initFailureCause Ljava/lang/Throwable;
L0: RETURN
end static void &lt;clinit&gt;()
void &lt;init&gt;():
ALOAD_0     // Lglassbox/agent/ErrorContainmentTest$ErrorMockAspect; this   (line 60)
INVOKESPECIAL java.lang.Object.&lt;init&gt; ()V
RETURN
end void &lt;init&gt;()
public void ajc$before$glassbox_agent_ErrorContainmentTest$ErrorMockAspect$1$9589fc()    AdviceAttribute(before, (scope() &amp;&amp; call(* hook1())), 0, 1670)
:
NEW java.lang.RuntimeException   (line 64)
DUP
LDC "rte"
INVOKESPECIAL java.lang.RuntimeException.&lt;init&gt; (Ljava/lang/String;)V
ATHROW
end public void ajc$before$glassbox_agent_ErrorContainmentTest$ErrorMockAspect$1$9589fc()
public void ajc$before$glassbox_agent_ErrorContainmentTest$ErrorMockAspect$2$f75db3e2()    AdviceAttribute(before, execution(* glassbox.agent.ErrorContainmentTest.hook5()), 0, 1764)
:
NEW java.lang.RuntimeException   (line 67)
DUP
LDC "rte"
INVOKESPECIAL java.lang.RuntimeException.&lt;init&gt; (Ljava/lang/String;)V
ATHROW
end public void ajc$before$glassbox_agent_ErrorContainmentTest$ErrorMockAspect$2$f75db3e2()
public void ajc$around$glassbox_agent_ErrorContainmentTest$ErrorMockAspect$3$a3a17d(org.aspectj.runtime.internal.AroundClosure)    AdviceAttribute(around, (scope() &amp;&amp; call(* hook2())), 1, 1913)
:
NEW java.lang.Error   (line 71)
DUP
LDC "foo"
INVOKESPECIAL java.lang.Error.&lt;init&gt; (Ljava/lang/String;)V
ATHROW
end public void ajc$around$glassbox_agent_ErrorContainmentTest$ErrorMockAspect$3$a3a17d(org.aspectj.runtime.internal.AroundClosure)
static void ajc$around$glassbox_agent_ErrorContainmentTest$ErrorMockAspect$3$a3a17dproceed(org.aspectj.runtime.internal.AroundClosure) throws java.lang.Throwable    org.aspectj.weaver.AjAttribute$AjSynthetic@19a01f9
:
ALOAD_0     // Lglassbox/agent/ErrorContainmentTest$ErrorMockAspect; this   (line 1)
ICONST_0
ANEWARRAY java.lang.Object
INVOKEVIRTUAL org.aspectj.runtime.internal.AroundClosure.run ([Ljava/lang/Object;)Ljava/lang/Object;
INVOKESTATIC org.aspectj.runtime.internal.Conversions.voidValue (Ljava/lang/Object;)Ljava/lang/Object;
RETURN
end static void ajc$around$glassbox_agent_ErrorContainmentTest$ErrorMockAspect$3$a3a17dproceed(org.aspectj.runtime.internal.AroundClosure) throws java.lang.Throwable
public void ajc$after$glassbox_agent_ErrorContainmentTest$ErrorMockAspect$4$bfd07f()    AdviceAttribute(after, (scope() &amp;&amp; call(* hook4())), 0, 1991)
:
NEW org.aspectj.lang.SoftException   (line 74)
DUP
ACONST_NULL
INVOKESPECIAL org.aspectj.lang.SoftException.&lt;init&gt; (Ljava/lang/Throwable;)V
ATHROW
end public void ajc$after$glassbox_agent_ErrorContainmentTest$ErrorMockAspect$4$bfd07f()
public void ajc$before$glassbox_agent_ErrorContainmentTest$ErrorMockAspect$5$e5bddfdc()    AdviceAttribute(before, logErrorInTest(), 0, 2446)
:
GETSTATIC glassbox.agent.ErrorContainmentTest.logCount I   (line 84)
ICONST_1
IADD
PUTSTATIC glassbox.agent.ErrorContainmentTest.logCount I
RETURN   (line 85)
end public void ajc$before$glassbox_agent_ErrorContainmentTest$ErrorMockAspect$5$e5bddfdc()
public void ajc$before$glassbox_agent_ErrorContainmentTest$ErrorMockAspect$6$16ecfe62()    AdviceAttribute(before, (adviceexecution(* *) &amp;&amp; (within(glassbox.util.logging.api.LogManagement) &amp;&amp; (cflow(logError()) &amp;&amp; cflow((execution(* testLoggingError(..)) &amp;&amp; within(glassbox.agent.ErrorContainmentTest)))))), 0, 2506)
:
GETSTATIC java.lang.System.err Ljava/io/PrintStream;   (line 87)
LDC "match"
INVOKEVIRTUAL java.io.PrintStream.println (Ljava/lang/String;)V
RETURN   (line 88)
end public void ajc$before$glassbox_agent_ErrorContainmentTest$ErrorMockAspect$6$16ecfe62()
public void ajc$before$glassbox_agent_ErrorContainmentTest$ErrorMockAspect$7$e9ae8482()    AdviceAttribute(before, (adviceexecution(* *) &amp;&amp; (within(glassbox.util.logging.api.LogManagement) &amp;&amp; cflow((execution(* testLoggingError(..)) &amp;&amp; within(glassbox.agent.ErrorContainmentTest))))), 0, 2721)
:
GETSTATIC java.lang.System.err Ljava/io/PrintStream;   (line 90)
LDC "match in test"
INVOKEVIRTUAL java.io.PrintStream.println (Ljava/lang/String;)V
RETURN   (line 91)
end public void ajc$before$glassbox_agent_ErrorContainmentTest$ErrorMockAspect$7$e9ae8482()
public void ajc$before$glassbox_agent_ErrorContainmentTest$ErrorMockAspect$8$c6ac5351()    AdviceAttribute(before, (adviceexecution(* *) &amp;&amp; (within(glassbox.util.logging.api.LogManagement) &amp;&amp; cflow(logError()))), 0, 2923)
:
GETSTATIC java.lang.System.err Ljava/io/PrintStream;   (line 93)
LDC "match in log"
INVOKEVIRTUAL java.io.PrintStream.println (Ljava/lang/String;)V
RETURN   (line 94)
end public void ajc$before$glassbox_agent_ErrorContainmentTest$ErrorMockAspect$8$c6ac5351()
public void ajc$before$glassbox_agent_ErrorContainmentTest$ErrorMockAspect$9$16ecfe62()    AdviceAttribute(before, (adviceexecution(* *) &amp;&amp; (within(glassbox.util.logging.api.LogManagement) &amp;&amp; (cflow(logError()) &amp;&amp; cflow((execution(* testLoggingError(..)) &amp;&amp; within(glassbox.agent.ErrorContainmentTest)))))), 0, 3069)
:
GETSTATIC glassbox.agent.ErrorContainmentTest.recursiveThrows I   (line 96)
ICONST_1
IADD
PUTSTATIC glassbox.agent.ErrorContainmentTest.recursiveThrows I
GETSTATIC glassbox.agent.ErrorContainmentTest.recursiveThrows I   (line 97)
ICONST_2
IF_ICMPGE L0
NEW java.lang.RuntimeException   (line 98)
DUP
LDC "recursive logging failure"
INVOKESPECIAL java.lang.RuntimeException.&lt;init&gt; (Ljava/lang/String;)V
ATHROW
L0: RETURN   (line 100)
end public void ajc$before$glassbox_agent_ErrorContainmentTest$ErrorMockAspect$9$16ecfe62()
public static glassbox.agent.ErrorContainmentTest$ErrorMockAspect aspectOf()    org.aspectj.weaver.AjAttribute$AjSynthetic@3cd8fe
:
GETSTATIC glassbox.agent.ErrorContainmentTest$ErrorMockAspect.ajc$perSingletonInstance Lglassbox/agent/ErrorContainmentTest$ErrorMockAspect;   (line 1)
IFNONNULL L0
NEW org.aspectj.lang.NoAspectBoundException
DUP
LDC "glassbox_agent_ErrorContainmentTest$ErrorMockAspect"
GETSTATIC glassbox.agent.ErrorContainmentTest$ErrorMockAspect.ajc$initFailureCause Ljava/lang/Throwable;
INVOKESPECIAL org.aspectj.lang.NoAspectBoundException.&lt;init&gt; (Ljava/lang/String;Ljava/lang/Throwable;)V
ATHROW
L0: GETSTATIC glassbox.agent.ErrorContainmentTest$ErrorMockAspect.ajc$perSingletonInstance Lglassbox/agent/ErrorContainmentTest$ErrorMockAspect;
ARETURN
end public static glassbox.agent.ErrorContainmentTest$ErrorMockAspect aspectOf()
public static boolean hasAspect()    org.aspectj.weaver.AjAttribute$AjSynthetic@1bd4f6
:
GETSTATIC glassbox.agent.ErrorContainmentTest$ErrorMockAspect.ajc$perSingletonInstance Lglassbox/agent/ErrorContainmentTest$ErrorMockAspect;   (line 1)
IFNULL L0
ICONST_1
IRETURN
L0: ICONST_0
IRETURN
end public static boolean hasAspect()
private static void ajc$postClinit()    org.aspectj.weaver.AjAttribute$AjSynthetic@1febf91
:
NEW glassbox.agent.ErrorContainmentTest$ErrorMockAspect   (line 1)
DUP
INVOKESPECIAL glassbox.agent.ErrorContainmentTest$ErrorMockAspect.&lt;init&gt; ()V
PUTSTATIC glassbox.agent.ErrorContainmentTest$ErrorMockAspect.ajc$perSingletonInstance Lglassbox/agent/ErrorContainmentTest$ErrorMockAspect;
RETURN
end private static void ajc$postClinit()
end public class glassbox.agent.ErrorContainmentTest$ErrorMockAspect
when type munging with (BcelTypeMunger ResolvedTypeMunger(Parent, null))
when weaving aspects
when weaving
when batch building BuildConfig[C:\devel\glassbox\.metadata\.plugins\org.eclipse.ajdt.core\glassboxMonitor.generated.lst] #Files=107

The source is:

public class ErrorContainmentTest extends TestCase {
...
	static aspect ErrorMockAspect implements NotSerializable {
...

I will try to narrow this down if the problem isn't obvious.</description>
      <comments>
		<comment id="1" date="2006-08-02 14:06:07 EDT" author="Ron Bodkin">Created attachment 47247 [details]
Self-contained AJDT project that reproduces the problem

This uses an already-built version of Glassbox built by a recent but earlier dev build. The failure depends on the effects of at least one other aspect.</comment>
		<comment id="2" date="2006-08-02 14:07:45 EDT" author="Ron Bodkin">By the way, the previous dev build that works is actually from July 28.</comment>
		<comment id="3" date="2006-08-02 14:14:24 EDT" author="Andrew Clement">i think i know what it'll be.</comment>
		<comment id="4" date="2006-08-03 10:52:03 EDT" author="Andrew Clement">...but I would like to recreate it first.  Is that project really standalone?  I get all kinds of errors if I try and build it:

eg. "can't determine whether missing type javax.servlet.ServletContext is an instance of"

So I used the 5meg of jars we have had before from you and stuffed them on the classpath, now it fails with:

"can't determine whether missing type glassbox.bootstrap.log.BootstrapLog is an instance of glassbox.util.logging.api.LogOwner"

are you running with cant find type switched off?  Are you getting this on a full build or an incremental build?</comment>
		<comment id="5" date="2006-08-03 12:21:09 EDT" author="Ron Bodkin">Hi Andy,

I think I didn't see the missing classpath entries because I ran into this error before I got that far. But I commented out the erroring out part and you are right: if you compile with -Xlint:ignore or turn off cantFindType switched off (although it looks like AJDT no longer lets you configure this) it should work unless you add the extra advice. 

I am uploading the glassboxBootstrap.jar that resolves some missing type references. The other jar that you will is the commons http client which I'll attach too. This is interesting because it isn't even on the build path of the project when compiling the jar but resolving this pointcut at weave time with the jar on the aspect path seems to require it:
    args(org.apache.commons.httpclient.HostConfiguration, httpMethod, ..)

This error happens with both full and incremental builds. </comment>
		<comment id="6" date="2006-08-03 12:23:14 EDT" author="Ron Bodkin">Created attachment 47339 [details]
Jar for classpath</comment>
		<comment id="7" date="2006-08-03 12:25:09 EDT" author="Ron Bodkin">Created attachment 47341 [details]
Commons httpclient jar for classpath</comment>
		<comment id="8" date="2006-08-04 06:25:34 EDT" author="Andrew Clement">A simple standalone testcase for the problem:

====
public aspect EMA {
    before() : cflow(execution(* *(..))) {}
}

aspect Goo {
  declare parents: EMA extends C;
  public void EMA.m() {}
}

abstract class C {
  abstract void m();
}
====

this occurs because of the declare parents targeting the aspect and the aspect has a cflow pointcut in it.  this fix is as expected, coping with null - but it was nice to verify that it is completely safe.  (Fails on 1.5.1a/1.5.2/HEAD)

testcase and fix committed ... and nothing to do with pipelining ;)</comment>
		<comment id="9" date="2006-08-09 02:53:40 EDT" author="Andrew Clement">fix available.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="ff2377a7f3b3d2148d107a7c411cf8308d254136" author="aclement" date="2006-08-04 07:29:04"/>
          <file name="tests/bugs153/pr152631/EMA.java">
          </file>
          <file name="tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java">
              <method name="enforceDecpRule1_abstractMethodsImplemented" returnType="boolean" parameters="BcelClassWeaver ISourceLocation LazyClassGen ResolvedType"/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="152871" opendate="2006-8-4 15:15:00" fixdate="2006-8-9 2:54:00">
    <buginformation>
      <summary>Parse bytecode at most once when weaving: 10% CPU time reduction</summary>
      <description>I'm analyzing a profile of cpu times spent weaving into Weblogic 9.2 with LTW. Of a total of 22 seconds of CPU, 2.6 seconds are spent in ClassParser.parse() with the exact same amount spent underneath WeavingAdaptor.shouldWeave and WeavingAdaptor.shouldWeaveAnnotationStyleAspect

WeavingAdaptor.shouldWeave is calling CLWA.accept which calls Utility.makeJavaClass which calls ClassParser.parse. Then the exact same expensive operation is getting called again in shouldWeaveAnnotationStyleAspect via BcelWorld.isAnnotationStyleAspect. 

Proposed Simple fix: allow shouldWeave to also return a BcelObjectType by setting a field in the adapter (which would be cleared to be null on start). The in shouldWeaveAnnotationStyleAspect, check the field. I'd be glad to write and test a patch to do this if the committers agree with the proposal.

We wouldn't want to always parse the bytecode, because it would we should be aiming to avoid that expense as often as possible. In our case, we're using exclusion type patterns that currently require accept to make a Java class. In cases where that's not necessary, it also seems odd that shouldWeaveAnnotationStyleAspect runs at all: I will post a separate enhancement request for limiting the cases where it runs.</description>
      <comments>
		<comment id="1" date="2006-08-04 15:31:35 EDT" author="Ron Bodkin">In addition, as Alex's comments in ClassLoaderWeavingAdaptor.accept indicate, if the class is accepted, then the bytecode will get parsed a third time in the constructor for WeavingClassFileProvider. So this too should use the already parsed Java class, if any.</comment>
		<comment id="2" date="2006-08-04 15:43:35 EDT" author="Ron Bodkin">... and then again in BcelWeaver.weave where classFile.getClassName() also parses it. In the test configuration I described before another 300 ms is spent parsing again in WeavingClassFileProvider and another 400 ms is spent parsing in UnwovenClassFile.getJavaClass. That brings the total CPU time overhead from redundant parsing to over 10% in this configuration.</comment>
		<comment id="3" date="2006-08-07 06:55:51 EDT" author="Matthew Webster">This bug is related to Bug 152873. However we should be able to determine more efficiently, perhaps by looking at the set of registered aspects, whether a particular class is in fact an @AspectJ aspect thereby eliminating one of the duplicate parses.</comment>
		<comment id="4" date="2006-08-07 09:14:20 EDT" author="Andrew Clement">some fixes are in - as Ron says it does need a combination of
excludes/typepatterns etc to trigger the worst case number of parses, hopefully
I managed to exercise that config in my test program.</comment>
		<comment id="5" date="2006-08-09 02:54:33 EDT" author="Andrew Clement">all the cases here covered... and fixes are available.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="73368931c7c7b346b062321c83a55c86ecd41ffd" author="aclement" date="2006-08-07 09:58:51"/>
          <file name="tests/bugs153/pr152871/MyAspect.java">
          </file>
          <file name="tests/bugs153/pr152871/MyClass.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="152873" opendate="2006-8-4 15:21:00" fixdate="2006-8-9 2:55:00">
    <buginformation>
      <summary>Optimize shouldWeaveAnnotationStyleAspect with Patch</summary>
      <description>The current implementation of shouldWeaveAnnotationStyleAspect is surprising because it weaves annotation aspects without regard as to whether they are registered in an aop.xml file. If an annotation-style aspect is loaded, it is always woven, even if it doesn't match the for what classes should be woven in the aop.xml file, and even if not registered therein. This is both unexpected and it imposes significant overhead on configurations where they aren't used and simple fast match exclusions prevent weaving (see bug #152871).

Is there really a need to weave annotation style aspects like this? Why can't it be done by using the aop.xml configuration mechanism that all other aspects use? In a large system, the CPU overhead of parsing and creating BCEL objects for all loaded classes should be avoided where possible.</description>
      <comments>
		<comment id="1" date="2006-08-07 06:14:40 EDT" author="Andrew Clement">not my code ... but I believe they have to be included in the weaving because they may be half finished (have no aspectOf/hasAspect).  Hence they are not subject to the same rules as regular code styles aspects that are always already finished.

You might well exclude them at some level but if they are included at a different level and *do* apply then that code will be woven with calls to aspectOf() that will go bang unless the @AJ aspect was finished off by getting woven when first discovered.</comment>
		<comment id="2" date="2006-08-07 06:52:51 EDT" author="Matthew Webster">It is possible, through the use of a custom IWeavingContext for example, to include an aspect for a weaver that was excluded by another visible aop.xml file. In which case the locally defined classes will be woven with an âunfinishedâ aspect and get NoSuchMethodError for aspectOf(). We therefore cannot exclude @AspectJ aspects and should issue a warning message if the user attempts to do so either by using either include or exclude in the weaver section.</comment>
		<comment id="3" date="2006-08-07 20:33:47 EDT" author="Ron Bodkin">It looks like avoiding this check altogether would be hard. However, the main objective here is to reduce the time spent testing for annotation-style aspects. Eugene Kuleshov wrote a simple ASM visitor that I adapted and plugged in, and I also avoided testing for annotation aspects in classes like javax..* that can't be woven. This patch should also be a bit faster when AspectJ uses ASM 3.0, so it could add flags to skip parsing methods and fields too (I tested short-circuitng those tests by throwing a runtime exception but that was actually slower).

The attached patch contains tests that validate this logic works both for excluded @Aspect annotations and that it doesn't match for other annotations.

I have measured that this patch reduces cpu time used in shouldWeaveAnnotationStyleAspect when starting WebLogic from over 1000 ms to 200 ms (an 80% reduction in overhead and a 10% reduction in total weaving time).

Longer term, I think it should be a requirement that an annotation-style aspect should always be listed with an aspect element in an aop.xml configuration visible to its loader. That seems much better than having to parse the bytecode of all loaded types to see if they are, in fact, an annotation-style aspects. 

If such a rule were agreed upon then it would be important to not allow including aspects that aren't woven to avoid a NoSuchMethodError from unfinished aspects. Unfortunately, it seems like doing this would require weaver context support so you could determine if the aspect class is loaded by this loader or not. In the former case, simply requiring the aspect to not be excluded (as Matthew noted) and if there's a non-empty inclusion list requiring the aspect to be in that would work. If we could determine the aspect is provided by an external loader, then we could instantiate a reflection delegate for it and test that it had the required woven methods. Maybe when #133770 is fixed we can revisit this. In the meanwhile, this patch dramatically reduces the overhead for annotation-style aspects.</comment>
		<comment id="4" date="2006-08-07 20:35:43 EDT" author="Ron Bodkin">Created attachment 47497 [details]
testing module patch: need to add asm-aj.jar to test classpath</comment>
		<comment id="5" date="2006-08-07 20:37:12 EDT" author="Ron Bodkin">Created attachment 47498 [details]
Tests module patch: tests that verify the ASM visitor corrects identifies whether classes with annotations are @Aspect aspects</comment>
		<comment id="6" date="2006-08-07 20:39:24 EDT" author="Ron Bodkin">Created attachment 47499 [details]
Weaver module patch: use ASM to test for @AspectJ aspects if no delegate and don't even test for classes excluded from weaving by package (e.g., org.aspectj..*)</comment>
		<comment id="7" date="2006-08-07 22:43:52 EDT" author="Ron Bodkin">Created attachment 47500 [details]
Weaver module patch: use ASM to test for @AspectJ aspects if no delegate and don't even test for classes excluded from weaving by package (e.g., org.aspectj..*)

Includes copyright in module header and a few minor cleanups.</comment>
		<comment id="8" date="2006-08-08 04:03:29 EDT" author="Andrew Clement">AspectJ doesn't currently have a hard dependency on asm - if asm isn't there, it continues to work fine.  Some products that reship AJ don't currently have permission to include asm.  I've made this use of asm conditional also (I think).

I will look at including asm 3.0 when it goes final.

I'm not a fan of tests that pass regardless of whether the patch to the mainline code is applied or not...

applied.</comment>
		<comment id="9" date="2006-08-09 02:55:15 EDT" author="Andrew Clement">available.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="f239f2a2ac6a887fd46e6d95e8fb4ec93e2e159d" author="aclement" date="2006-08-08 04:59:54"/>
          <file name="testing/newsrc/org/aspectj/testing/AntSpec.java">
          </file>
          <file name="tests/java5/ataspectj/ataspectj/bugs/NotAspect.java">
          </file>
          <file name="tests/src/org/aspectj/systemtest/ajc150/ataspectj/AtAjLTWTests.java">
              <method name="testAspectOfWhenAspectNotInInclude" returnType="void" parameters=""/>
          </file>
          <file name="weaver/src/org/aspectj/weaver/World.java">
              <method name="setSynchronizationPointcutsInUse" returnType="void" parameters=""/>
          </file>
          <file name="weaver/src/org/aspectj/weaver/tools/IsAtAspectAnnotationVisitor.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="152589" opendate="2006-8-2 9:33:00" fixdate="2006-8-9 11:19:00">
    <buginformation>
      <summary>[pipeline] adding a whitespace results in adviceDidNotMatch warning</summary>
      <description>Given the following
------------------------------------------------------------
public aspect A {
    after () throwing (Throwable th) :  execution(* *(..)) {
		System.err.println(thisEnclosingJoinPointStaticPart);
	}
}

class C1 {
	public void anotherMethod() {
		
	}
}
--------------------------------------------------

adding a whitespace before the aspect declaration results in an adviceDidNotMatch warning even though weaving took place and the advice clearly matches. Output from the AJDT event trace shows:

14:38:23 ===========================================================================================
14:38:23 Build kind = AUTOBUILD
14:38:23 Project=bug92895, kind of build requested=Incremental AspectJ compilation
14:38:23 build: Examined delta - source file changes in required project bug92895
14:38:23 Classpath=/home/hawkinsh/eclipse/workspace32/runtime-New_configuration/bug92895/bin:/home/hawkinsh/javas/jdk1.5.0_05/jre/lib/rt.jar:/home/hawkinsh/javas/jdk1.5.0_05/jre/lib/jsse.jar:/home/hawkinsh/javas/jdk1.5.0_05/jre/lib/jce.jar:/home/hawkinsh/javas/jdk1.5.0_05/jre/lib/charsets.jar:/home/hawkinsh/javas/jdk1.5.0_05/jre/lib/ext/sunjce_provider.jar:/home/hawkinsh/javas/jdk1.5.0_05/jre/lib/ext/sunpkcs11.jar:/home/hawkinsh/javas/jdk1.5.0_05/jre/lib/ext/dnsns.jar:/home/hawkinsh/javas/jdk1.5.0_05/jre/lib/ext/localedata.jar:/home/hawkinsh/eclipse/eclipse32/plugins/org.aspectj.runtime_1.5.3.20060801095103/aspectjrt.jar:
14:38:23 Preparing for build: planning to be an incremental build
14:38:23 Starting incremental compilation loop 1 of possibly 5
14:38:23 AJC: compiling source files
14:38:23 Timer event: 215ms: Time to first compiled message
14:38:23 AJC: compiled: /home/hawkinsh/eclipse/workspace32/runtime-New_configuration/bug92895/src/pack/A.aj
14:38:23 addSourcelineTask message=advice defined in pack.A has not been applied [Xlint:adviceDidNotMatch] file=/home/hawkinsh/eclipse/workspace32/runtime-New_configuration/bug92895/src/pack/A.aj line=4
14:38:23  Dropping back to full build
14:38:23 Preparing for build: not going to be incremental because no successful previous full build
14:38:23 AJC: compiling source files
14:38:23 AJC: compiled: /home/hawkinsh/eclipse/workspace32/runtime-New_configuration/bug92895/src/pack/A.aj
14:38:23 AJC: processing reweavable state
14:38:23 AJC: adding type mungers
14:38:23 Timer event: 452ms: Time to first woven message
14:38:23 AJC: woven aspect pack.A (from /home/hawkinsh/eclipse/workspace32/runtime-New_configuration/bug92895/src/pack/A.aj)
14:38:23 AJC: woven class pack.C1 (from /home/hawkinsh/eclipse/workspace32/runtime-New_configuration/bug92895/src/pack/A.aj)
14:38:23 AspectJ reports build successful, build was: FULL
14:38:23 AJDE Callback: finish. Was full build: true
14:38:23 Timer event: 517ms: Total time spent in AJDE
14:38:23 Timer event: 6ms: Create element map (2 rels in project: bug92895)
14:38:23 Types affected during build = 1
14:38:23 Timer event: 3ms: Add markers (2 markers)
14:38:24 Timer event: 1274ms: Total time spent in AJBuilder.build()


namely, the adviceDidNotMatch warning was added and then we fell back to a full build and the warning wasn't cleared. Performing a "clean" build fixes the problem. This is since the pipelining changes.</description>
      <comments>
		<comment id="1" date="2006-08-02 09:39:51 EDT" author="Helen Beeken">Created attachment 47216 [details]
failing testcase

Apply this patch to the tests project.

Failing testcase which reproduces the problem.</comment>
		<comment id="2" date="2006-08-03 03:21:40 EDT" author="Andrew Clement">the whole mechanism for producing adviceDidNotMatch changed in pipeling (almost had to be removed entirely).  The fix for this bug is to recognize when we are dropping back to a full build and dont attempt to produce the messages in that case.

test and fix committed.</comment>
		<comment id="3" date="2006-08-09 11:19:06 EDT" author="Andrew Clement">fix available.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="9664058bcdaeb4934a01969f4e5f651bc6e8cd71" author="aclement" date="2006-08-03 04:23:55"/>
          <file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/AjPipeliningCompilerAdapter.java">
          </file>
          <file name="tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java">
              <method name="testPr134471_IncrementallyRecompilingTheClassAffectedByDeclare" returnType="void" parameters=""/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="130300" opendate="2006-3-3 6:27:00" fixdate="2006-03-18 10:24:19">
    <buginformation>
      <summary>"Remove, hide or obfuscate -XnoWeave"</summary>
      <description>This option is redundant apart from use in AspectJ development and maintenance. It is confusing to users and is a source new problems for LTW.</description>
      <comments>
		<comment id="1" date="2006-03-03 07:56:53 EST" author="Andrew Clement">I've got this all done in a workspace at home, I'll check it in over the weekend.  You won't get a message with -XnoWeave (or -noweave which also works), it will just FAIL FAIL FAIL FAIL FAIL.</comment>
		<comment id="2" date="2006-03-05 12:03:40 EST" author="Andrew Clement">its gone.</comment>
		<comment id="3" date="2006-03-18 10:24:19 EST" author="Andrew Clement">'fix' available :)</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="b2259116b8731725743d255a85c894d6f998afb1" author="aclement" date="2006-03-06 02:00:04"/>
          <file name="ajde/testsrc/org/aspectj/ajde/BuildConfigurationTests.java">
          </file>
          <file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java">
              <method name="parseOption" returnType="void" parameters="String LinkedList"/>
          </file>
          <file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/core/AspectJCore.java">
          </file>
          <file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/AjCompilerAdapter.java">
          </file>
          <file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.java">
              <method name="installGlobals" returnType="void" parameters="AjBuildConfig"/>
          </file>
          <file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java">
              <method name="getAdapter" returnType="ICompilerAdapter" parameters="org.aspectj.org.eclipse.jdt.internal.compiler.Compiler"/>
          </file>
          <file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjCompilerOptions.java">
          </file>
          <file name="org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/BcweaverJarMaker.java">
              <method name="makeJar1a" returnType="void" parameters=""/>
          </file>
          <file name="org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/core/builder/AjCompilerOptionsTest.java">
          </file>
          <file name="taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java">
          </file>
          <file name="taskdefs/testsrc/org/aspectj/tools/ant/taskdefs/AjcTaskTest.java">
              <method name="testDefaultFileComplete" returnType="void" parameters=""/>
          </file>
          <file name="testing/src/org/aspectj/testing/harness/bridge/CompilerRun.java">
              <method name="CRSOptions" returnType="null" parameters=""/>
          </file>
          <file name="tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java">
              <method name="testIllegalAccessErrorWithAroundAdviceNotSelf_pr119657" returnType="void" parameters=""/>
          </file>
          <file name="tests/src/org/aspectj/systemtest/ajc150/ataspectj/AtAjLTWTests.java">
              <method name="testRunThemAllWithJavacCompiledAndLTW" returnType="void" parameters=""/>
          </file>
          <file name="tests/src/org/aspectj/systemtest/inpath/InPathTests.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="154332" opendate="2006-8-18 3:49:00" fixdate="2006-8-18 4:18:00">
    <buginformation>
      <summary>[annotations] Incorrect handling of java.lang annotations when matching</summary>
      <description>As raised by Mr Bodkin on the list:
Can anyone tell me why this compiling this program produces warnings for marker but not for deprecated (in a recent dev build of AJDT)? Is this just a bug? Both have runtime retention, so I would expect equivalent behavior.

 

@Deprecated @Marker

public aspect Annot {

 

    pointcut test() : within(@Marker *);// *);

   

    declare warning: staticinitialization(@Deprecated *): "deprecated";   

    declare warning: staticinitialization(@Marker *): "marker";   

   

    public static void main(String argz[]) {

        new Baz().foo();

    }

}

 

@Deprecated @Marker

class Baz {

    public void foo() {}

}

 

@Retention(RetentionPolicy.RUNTIME)

public @interface Marker {

 

}</description>
      <comments>
		<comment id="1" date="2006-08-18 04:18:18 EDT" author="Andrew Clement">test and fix committed - some silly code that chopped java.lang off the front and left us with something that wouldn't resolve (doh!) - who writes this rubbish...</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="59123b0efba484e81625d403ca36768e149bd451" author="aclement" date="2006-08-18 05:21:58"/>
          <file name="tests/bugs153/pr154332/Annot.java">
          </file>
          <file name="tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/bcel/BcelObjectType.java">
              <method name="ensureAnnotationsUnpacked" returnType="void" parameters=""/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="153535" opendate="2006-8-11 3:34:00" fixdate="2006-8-23 10:52:00">
    <buginformation>
      <summary>Bug in reflection delegate signature for array of object type</summary>
      <description>The following problem is interesting because the advice weaves correctly with Java 1.5 LTW and also using Java 1.4 with build-time weaving. However, the following call pointcut isn't matching the expected call site in Java 1.4 load-time weaving (*).

Pointcut:
    private pointcut inExecQuery() : 
        (within(uk.ltd.getahead.dwr.impl.ExecuteQuery) || within(uk.ltd.getahead.dwr.ExecuteQuery));
    
    public pointcut dwrQuery(Method method, Object receiver, Object[] params) : 
        inExecQuery() &amp;&amp; withincode(* execute(..)) &amp;&amp; 
        call(* Method.invoke(..)) &amp;&amp; args(receiver, params) &amp;&amp; target(method);

    protected pointcut monitorEnd() : dwrQuery(*, *, *);

Matching call site:
                Object reply = method.invoke(object, params);

I've tracked it down to failing to find the method in ResolvedType.matches. On line 405:

"m1.getSignature()"= "(Ljava/lang/Object;[Ljava.lang.Object;)Ljava/lang/Object;"	
"m2.getSignature()"= "(Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;"	

Note the difference between . and /            ^    ^

It looks to me like the signature for array types in the reflection delegate is erroneously using . instead of /. I have attached a patch to the ReflectionBasedReferenceTypeDelegateTest that isolates this unexpected signature return. Hopefully you agree that this is not correct. If not, some more information follows.

Here's the stack trace where the match fails:

ResolvedType.matches(Member, Member) line: 405	
ReferenceType(ResolvedType).lookupMember(Member, Iterator) line: 347	
ReferenceType(ResolvedType).lookupMethod(Member) line: 326	
LTWWorld(World).resolve(Member) line: 504	
MemberImpl.resolve(World) line: 93	
JoinPointSignatureIterator.addSignaturesUpToFirstDefiningMember() line: 109	
JoinPointSignatureIterator.&lt;init&gt;(Member, World) line: 51	
MemberImpl.getJoinPointSignatures(World) line: 943	
SignaturePattern.matches(Member, World, boolean) line: 286	
KindedPointcut.matchInternal(Shadow) line: 106	
KindedPointcut(Pointcut).match(Shadow) line: 146	
AndPointcut.matchInternal(Shadow) line: 53	
AndPointcut(Pointcut).match(Shadow) line: 146	
AndPointcut.matchInternal(Shadow) line: 51	
AndPointcut(Pointcut).match(Shadow) line: 146	
AndPointcut.matchInternal(Shadow) line: 51	
AndPointcut(Pointcut).match(Shadow) line: 146	
AndPointcut.matchInternal(Shadow) line: 51	
AndPointcut(Pointcut).match(Shadow) line: 146	
OrPointcut.matchInternal(Shadow) line: 50	
OrPointcut(Pointcut).match(Shadow) line: 146	
BcelAdvice(ShadowMunger).match(Shadow, World) line: 71	
BcelAdvice(Advice).match(Shadow, World) line: 112	
BcelAdvice.match(Shadow, World) line: 107	
BcelClassWeaver.match(BcelShadow, List) line: 2806	
BcelClassWeaver.matchInvokeInstruction(LazyMethodGen, InstructionHandle, InvokeInstruction, BcelShadow, List) line: 2768	
BcelClassWeaver.match(LazyMethodGen, InstructionHandle, BcelShadow, List) line: 2506	
BcelClassWeaver.match(LazyMethodGen) line: 2332	
BcelClassWeaver.weave() line: 494	
BcelClassWeaver.weave(BcelWorld, LazyClassGen, List, List, List) line: 119	
BcelWeaver.weave(UnwovenClassFile, BcelObjectType, boolean) line: 1613	
BcelWeaver.weaveWithoutDump(UnwovenClassFile, BcelObjectType) line: 1564	
BcelWeaver.weaveAndNotify(UnwovenClassFile, BcelObjectType, IWeaveRequestor) line: 1341	
BcelWeaver.weave(IClassFileProvider) line: 1163	
ClassLoaderWeavingAdaptor(WeavingAdaptor).getWovenBytes(String, byte[]) line: 319	
ClassLoaderWeavingAdaptor(WeavingAdaptor).weaveClass(String, byte[]) line: 225	
Aj.preProcess(String, byte[], ClassLoader) line: 77	
ClassPreProcessorAdapter.preProcess(String, byte[], ClassLoader) line: 67	
ClassPreProcessorHelper.defineClass0Pre(ClassLoader, String, byte[], int, int, ProtectionDomain) line: 107	
WebappClassLoader(ClassLoader).defineClass(String, byte[], int, int, ProtectionDomain) line: 539	
WebappClassLoader(SecureClassLoader).defineClass(String, byte[], int, int, CodeSource) line: 123	
WebappClassLoader.findClassInternal(String) line: 1786	
WebappClassLoader.findClass(String) line: 1048	
WebappClassLoader.loadClass(String, boolean) line: 1506	
WebappClassLoader.loadClass(String) line: 1385	
WebappClassLoader(ClassLoader).loadClassInternal(String) line: 302	
Class.forName0(String, boolean, ClassLoader) line: not available [native method]	
Class.forName(String) line: 141	
InitializeLog.setWarnLogging(String) line: 121	
InitializeLog.initializeLogging() line: 96	
ContextLoaderServlet.init() line: 13	
ContextLoaderServlet(GenericServlet).init(ServletConfig) line: 212	
StandardWrapper.loadServlet() line: 879	
StandardWrapper.load() line: 767	
StandardContext.loadOnStartup(Container[]) line: 3483	
StandardContext.start() line: 3709	
StandardHost(ContainerBase).addChildInternal(Container) line: 776	
StandardHost(ContainerBase).addChild(Container) line: 759	
StandardHost.addChild(Container) line: 537	
StandardHostDeployer.install(String, URL) line: 260	
StandardHost.install(String, URL) line: 730	
HostConfig.deployWARs(File, String[]) line: 558	
HostConfig.deployApps() line: 373	
HostConfig.start() line: 784	
HostConfig.lifecycleEvent(LifecycleEvent) line: 330	
LifecycleSupport.fireLifecycleEvent(String, Object) line: 119	
StandardHost(ContainerBase).start() line: 1155	
StandardHost.start() line: 696	
StandardEngine(ContainerBase).start() line: 1147	
StandardEngine.start() line: 310	
StandardService.start() line: 449	
StandardServer.start() line: 2212	
Catalina.start() line: 458	
Catalina.execute() line: 345	
Catalina.process(String[]) line: 129	
NativeMethodAccessorImpl.invoke0(Method, Object, Object[]) line: not available [native method]	
NativeMethodAccessorImpl.invoke(Object, Object[]) line: 39	
DelegatingMethodAccessorImpl.invoke(Object, Object[]) line: 25	
Method.invoke(Object, Object[]) line: 324	
Bootstrap.main(String[]) line: 150	

I'm using a modified version of Alex Vasseur's LTW plugin for a Java 1.4 VM although I haven't tested on the JRockIt plugin for a 1.4 VM: my guess is that this would fail there too.</description>
      <comments>
		<comment id="1" date="2006-08-11 03:44:28 EDT" author="Ron Bodkin">Created attachment 47752 [details]
Patch to weaver module showing unexpected signature in reflection delegate</comment>
		<comment id="2" date="2006-08-11 03:57:06 EDT" author="Adrian Colyer">Yep, this definitely looks wrong. We should never see dots in a signature string.</comment>
		<comment id="3" date="2006-08-15 07:48:18 EDT" author="Andrew Clement">I've seen this before - it is a java spec thing that arrays get the different signatures for their component types.  I did try and find the bug that involved this problem previously so I could refer to it here, but I can't find it.

testcase and fix committed.</comment>
		<comment id="4" date="2006-08-17 17:49:47 EDT" author="Ron Bodkin">The fix is also working as expected in the original case where calls were not matching correctly with LTW on a 1.4 VM.

Please feel free to mark as FIXED whenever you have released it (it's probably already in a dev build?)</comment>
		<comment id="5" date="2006-08-23 10:52:30 EDT" author="Andrew Clement">fix available.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="82e3e13c66720ed17399821d478c31151b2d2234" author="aclement" date="2006-08-15 08:51:21"/>
          <file name="weaver/src/org/aspectj/weaver/reflect/ReflectionWorld.java">
              <method name="resolve" returnType="ResolvedType" parameters="World Class"/>
          </file>
          <file name="weaver/testsrc/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateTest.java">
          </file>
          <file name="weaver5/java5-testsrc/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateTest.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="129525" opendate="2006-2-27 3:18:00" fixdate="2006-8-25 4:30:00">
    <buginformation>
      <summary>Don't Dump Bytecodes to Syserr in LTW</summary>
      <description>The load-time weaving system can produce truly massive quantities of output when there's a weaving error, since the system dumps the bytecode to syserr. It would be much better to produce an ajcore file and just point to it, or use some other log.</description>
      <comments>
		<comment id="1" date="2006-03-10 08:20:47 EST" author="Matthew Webster">I agree we should make better use of ajcore files. However they will be times when, due to a SecurityManager, the weaver does not have access to the disk and all data will still need to be sent to stderr.

What other log do you suggest?</comment>
		<comment id="2" date="2006-03-10 10:07:43 EST" author="Ron Bodkin">I would suggest:
1) try to write an ajcore file
2) failing that, try to use java.util.logging to log the information at an error level
3) failing that, writing to System.error</comment>
		<comment id="3" date="2006-08-24 12:56:03 EDT" author="Matthew Webster">I have changed the LTW message handler so that it no longer causes an AbortException when an error is issued. My original intention was to fail the loading of the class concerned but this doesn't happen because the exception is caught somewhere else in weaver/loadtime and it may not be desirable anyway. This should result in fewer "trouble in: ..." type messages where there is actually no problem with weaving.

I have opened Bug 155033 "Use ajcore for LTW problems" to look at a more appropriate method of information capture.</comment>
		<comment id="4" date="2006-08-24 19:17:29 EDT" author="Ron Bodkin">I ran into a case where the new code still dumps a spectacular amount of data to the console by dumping bytecode for each class, this with a very recent dev build. I reran with stdout and stderr redirected and have 2 megs of output from startup. This is the kind of scenario that would be greatly improved with ajcore files!

In this case, it was a circularity error from some test advice (which was obscured badly by the obscure message and the volumes of bytecode dumped):
[PolicyClassLoader@13631582] error at glassbox\monitor\AbstractMonitor.aj:115::0
 can't determine precedence between two or more pieces of advice that apply to t
he same join point: method-execution...
[PolicyClassLoader@13631582] abort trouble in:
...</comment>
		<comment id="5" date="2006-08-25 04:30:39 EDT" author="Matthew Webster">Fix available in aspectj-DEVELOPMENT-20060824191234.jar.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="04fa1dcce12934cc5cfe1e5e8b66523c10e93672" author="mwebster" date="2006-08-25 02:32:00"/>
          <file name="loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java">
              <method name="registerAspects" returnType="void" parameters="BcelWeaver ClassLoader List"/>
          </file>
          <file name="loadtime/src/org/aspectj/weaver/loadtime/WeavingURLClassLoader.java">
          </file>
          <file name="tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="155148" opendate="2006-8-24 20:59:00" fixdate="2006-8-30 3:56:00">
    <buginformation>
      <summary>jdk14 trace deadlock in oc4j</summary>
      <description>I turned on tracing for the Aj class inside of Oracle's OC4J server. In one test (not always) it deadlocked. It looks like the threads are each trying to lock each other's loader. Notice that one of the threads is in the toString method of the Oracle ClassLoader (perhaps another reason to prefer tracing argument class names and system identity hashcodes).

Here's a thread dump from Ctrl+BREAK:

Found one Java-level deadlock:
=============================
"WorkExecutorWorkerThread-1":
  waiting to lock monitor 0x003384ec (object 0x05239e48, a oracle.classloader.Po
licyClassLoader),
  which is held by "OC4J Launcher"
"OC4J Launcher":
  waiting to lock monitor 0x0033848c (object 0x0554f0e8, a oracle.classloader.Po
licyClassLoader),
  which is held by "WorkExecutorWorkerThread-1"

Java stack information for the threads listed above:
===================================================
"WorkExecutorWorkerThread-1":
        at oracle.classloader.SearchPolicy.loadClass(SearchPolicy.java:641)
        - waiting to lock &lt;0x05239e48&gt; (a oracle.classloader.PolicyClassLoader)
        at oracle.classloader.PolicyClassLoader.askParentForClass(PolicyClassLoader.java:1284)
        at oracle.classloader.SearchPolicy$AskParent.getClass(SearchPolicy.java:69)
        at oracle.classloader.SearchSequence.getClass(SearchSequence.java:119)
        at oracle.classloader.SearchPolicy.loadClass(SearchPolicy.java:642)
        - locked &lt;0x0554f0e8&gt; (a oracle.classloader.PolicyClassLoader)
        at oracle.classloader.PolicyClassLoader.askParentForClass(PolicyClassLoader.java:1284)
        at oracle.classloader.SearchPolicy$AskParent.getClass(SearchPolicy.java:69)
        at oracle.classloader.SearchSequence.getClass(SearchSequence.java:119)
        at oracle.classloader.PolicyClassLoader.internalLoadClass(PolicyClassLoader.java:1660)
        - locked &lt;0x056a9ed0&gt; (a oracle.classloader.PolicyClassLoader)
        at oracle.classloader.PolicyClassLoader.loadClass(PolicyClassLoader.java:1621)
        at oracle.classloader.PolicyClassLoader.loadClass(PolicyClassLoader.java:1606)
        at java.lang.ClassLoader.loadClassInternal(ClassLoader.java:319)
        - locked &lt;0x056a9ed0&gt; (a oracle.classloader.PolicyClassLoader)
        at oracle.j2ee.ra.jms.generic.WorkConsumer.doReceive(WorkConsumer.java:987)
        at oracle.j2ee.ra.jms.generic.WorkConsumer.run(WorkConsumer.java:215)
        - locked &lt;0x05de2718&gt; (a oracle.j2ee.ra.jms.generic.WorkConsumer)
        at oracle.j2ee.connector.work.WorkWrapper.runTargetWork(WorkWrapper.java:242)
        at oracle.j2ee.connector.work.WorkWrapper.doWork(WorkWrapper.java:215)
        at oracle.j2ee.connector.work.WorkWrapper.run(WorkWrapper.java:190)
        at EDU.oswego.cs.dl.util.concurrent.PooledExecutor$Worker.run(PooledExecutor.java:814)
        at java.lang.Thread.run(Thread.java:595)
"OC4J Launcher":
        at oracle.classloader.PolicyClassLoader.toString(PolicyClassLoader.java:1846)
        - waiting to lock &lt;0x0554f0e8&gt; (a oracle.classloader.PolicyClassLoader)
        at java.text.MessageFormat.subformat(MessageFormat.java:1237)
        at java.text.MessageFormat.format(MessageFormat.java:828)
        at java.text.Format.format(Format.java:133)
        at java.text.MessageFormat.format(MessageFormat.java:804)
        at java.util.logging.Formatter.formatMessage(Formatter.java:130)
        - locked &lt;0x0514e920&gt; (a java.util.logging.SimpleFormatter)
        at java.util.logging.SimpleFormatter.format(SimpleFormatter.java:63)
        - locked &lt;0x0514e920&gt; (a java.util.logging.SimpleFormatter)
        at java.util.logging.StreamHandler.publish(StreamHandler.java:179)
        - locked &lt;0x0514a0a8&gt; (a java.util.logging.FileHandler)
        at java.util.logging.FileHandler.publish(FileHandler.java:555)
        - locked &lt;0x0514a0a8&gt; (a java.util.logging.FileHandler)
        at java.util.logging.Logger.log(Logger.java:428)
        at java.util.logging.Logger.doLog(Logger.java:450)
        at java.util.logging.Logger.logp(Logger.java:619)
        at java.util.logging.Logger.entering(Logger.java:870)
        at org.aspectj.weaver.tools.Jdk14Trace.enter(Jdk14Trace.java:32)
        at org.aspectj.weaver.loadtime.Aj.preProcess(Aj.java:67)
        at org.aspectj.weaver.loadtime.ClassPreProcessorAgentAdapter.transform(ClassPreProcessorAgentAdapter.java:55)
        at sun.instrument.TransformerManager.transform(TransformerManager.java:122)
        at sun.instrument.InstrumentationImpl.transform(InstrumentationImpl.java:155)
        at java.lang.ClassLoader.defineClass1(Native Method)
        at java.lang.ClassLoader.defineClass(ClassLoader.java:620)
        at oracle.classloader.PolicyClassLoader.defineClass(PolicyClassLoader.java:2224)
        at oracle.classloader.PolicyClassLoader.findLocalClass(PolicyClassLoader.java:1457)
        at oracle.classloader.SearchPolicy$FindLocal.getClass(SearchPolicy.java:167)
        at oracle.classloader.SearchSequence.getClass(SearchSequence.java:119)
        at oracle.classloader.PolicyClassLoader.internalLoadClass(PolicyClassLoader.java:1660)
        - locked &lt;0x05239e48&gt; (a oracle.classloader.PolicyClassLoader)
        at oracle.classloader.PolicyClassLoader.loadClass(PolicyClassLoader.java:1621)
        at oracle.classloader.PolicyClassLoader.loadClass(PolicyClassLoader.java:1606)
        at java.lang.ClassLoader.loadClassInternal(ClassLoader.java:319)
        - locked &lt;0x05239e48&gt; (a oracle.classloader.PolicyClassLoader)
        at com.evermind.server.http.HttpRequestHandler.&lt;init&gt;(HttpRequestHandler.java:97)
        at com.evermind.server.http.HttpConnectionListener$HttpNIOAcceptHandler.getReadHandler(HttpConnectionListener.java:116)
        at oracle.oc4j.network.ReadHandlerPool.getContextFromBackend(ReadHandlerPool.java:63)
        at com.evermind.util.BBPool.startPool(BBPool.java:42)
        at oracle.oc4j.network.ReadHandlerPool.register(ReadHandlerPool.java:25)
        - locked &lt;0x05ec9290&gt; (a java.util.ArrayList)
        at oracle.oc4j.network.ServerSocketAcceptHandler.setPoolOptions(ServerSocketAcceptHandler.java:140)
        at com.evermind.server.http.HttpConnectionListener.setRequestHandlerPool(HttpConnectionListener.java:232)
        at com.evermind.server.http.HttpConnectionListener.initHandlers(HttpConnectionListener.java:226)
        at com.evermind.server.http.HttpConnectionListener.&lt;init&gt;(HttpConnectionListener.java:174)
        at com.evermind.server.http.HttpServer.getListener(HttpServer.java:481)
        - locked &lt;0x05ec4f88&gt; (a com.evermind.server.http.HttpServer)
        at com.evermind.server.http.HttpServer.setSites(HttpServer.java:267)
        - locked &lt;0x05ec4f88&gt; (a com.evermind.server.http.HttpServer)
        at com.evermind.server.http.HttpServer.setConfig(HttpServer.java:180)
        at com.evermind.server.ApplicationServer.initializeHttp(ApplicationServer.java:2296)
        at com.evermind.server.ApplicationServer.setConfig(ApplicationServer.java:944)
        at com.evermind.server.ApplicationServerLauncher.run(ApplicationServerLauncher.java:113)
        - locked &lt;0x0530eb20&gt; (a java.lang.Object)
        at java.lang.Thread.run(Thread.java:595)

Found 1 deadlock.</description>
      <comments>
		<comment id="1" date="2006-08-24 21:05:56 EDT" author="Ron Bodkin">Here's another deadlock from a second run, in this case one thread wants to lock a FileHandler (to log) and the other thread wants to lock another loader. In this case, both threads are weaving...

Found one Java-level deadlock:
=============================
"ApplicationServerThread-0":
  waiting to lock monitor 0x0033864c (object 0x05149eb8, a java.util.logging.Fil
eHandler),
  which is held by "Thread-14"
"Thread-14":
  waiting to lock monitor 0x0033852c (object 0x05c0c0e8, a oracle.classloader.Po
licyClassLoader),
  which is held by "ApplicationServerThread-0"

Java stack information for the threads listed above:
===================================================
"ApplicationServerThread-0":
        at java.util.logging.FileHandler.publish(FileHandler.java:552)
        - waiting to lock &lt;0x05149eb8&gt; (a java.util.logging.FileHandler)
        at java.util.logging.Logger.log(Logger.java:428)
        at java.util.logging.Logger.doLog(Logger.java:450)
        at java.util.logging.Logger.logp(Logger.java:619)
        at java.util.logging.Logger.entering(Logger.java:842)
        at org.aspectj.weaver.tools.Jdk14Trace.enter(Jdk14Trace.java:30)
        at org.aspectj.weaver.loadtime.Aj.preProcess(Aj.java:67)
        at org.aspectj.weaver.loadtime.ClassPreProcessorAgentAdapter.transform(ClassPreProcessorAgentAdapter.java:55)
        at sun.instrument.TransformerManager.transform(TransformerManager.java:122)
        at sun.instrument.InstrumentationImpl.transform(InstrumentationImpl.java:155)
        at java.lang.ClassLoader.defineClass1(Native Method)
        at java.lang.ClassLoader.defineClass(ClassLoader.java:620)
        at oracle.classloader.PolicyClassLoader.defineClass(PolicyClassLoader.java:2224)
        at oracle.classloader.PolicyClassLoader.findLocalClass(PolicyClassLoader.java:1457)
        at oracle.classloader.SearchPolicy$FindLocal.getClass(SearchPolicy.java:167)
        at oracle.classloader.SearchSequence.getClass(SearchSequence.java:119)
        at oracle.classloader.PolicyClassLoader.internalLoadClass(PolicyClassLoader.java:1660)
        - locked &lt;0x05c0c0e8&gt; (a oracle.classloader.PolicyClassLoader)
        at oracle.classloader.PolicyClassLoader.loadClass(PolicyClassLoader.java:1621)
        at oracle.classloader.PolicyClassLoader.loadClass(PolicyClassLoader.java:1606)
        at java.lang.ClassLoader.loadClassInternal(ClassLoader.java:319)
        - locked &lt;0x05c0c0e8&gt; (a oracle.classloader.PolicyClassLoader)
        at org.springframework.web.servlet.view.ResourceBundleViewResolver.initFactory(ResourceBundleViewResolver.java:190)
        - locked &lt;0x063d7690&gt; (a org.springframework.web.servlet.view.ResourceBundleViewResolver)
        at org.springframework.web.servlet.view.ResourceBundleViewResolver.loadView(ResourceBundleViewResolver.java:148)
        at org.springframework.web.servlet.view.AbstractCachingViewResolver.createView(AbstractCachingViewResolver.java:141)
        at org.springframework.web.servlet.view.AbstractCachingViewResolver.resolveViewName(AbstractCachingViewResolver.java:79)
        at org.springframework.web.servlet.DispatcherServlet.resolveViewName(DispatcherServlet.java:983)
        at org.springframework.web.servlet.DispatcherServlet.render(DispatcherServlet.java:942)
        at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:738)
        at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:658)
        at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:392)
        at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:347)
        at javax.servlet.http.HttpServlet.service(HttpServlet.java:743)
        at javax.servlet.http.HttpServlet.service(HttpServlet.java:856)
        at com.evermind.server.http.ServletRequestDispatcher.invoke(ServletRequestDispatcher.java:719)
        at com.evermind.server.http.ServletRequestDispatcher.forwardInternal(ServletRequestDispatcher.java:376)
        at com.evermind.server.http.HttpRequestHandler.doProcessRequest(HttpRequestHandler.java:870)
        at com.evermind.server.http.HttpRequestHandler.processRequest(HttpRequestHandler.java:451)
        at com.evermind.server.http.HttpRequestHandler.serveOneRequest(HttpRequestHandler.java:218)
        at com.evermind.server.http.HttpRequestHandler.run(HttpRequestHandler.java:119)
        at com.evermind.server.http.HttpRequestHandler.run(HttpRequestHandler.java:112)
        at oracle.oc4j.network.ServerSocketReadHandler$SafeRunnable.run(ServerSocketReadHandler.java:260)
        at oracle.oc4j.network.ServerSocketAcceptHandler.procClientSocket(ServerSocketAcceptHandler.java:230)
        at oracle.oc4j.network.ServerSocketAcceptHandler.access$800(ServerSocketAcceptHandler.java:33)
        at oracle.oc4j.network.ServerSocketAcceptHandler$AcceptHandlerHorse.run(ServerSocketAcceptHandler.java:831)
        at com.evermind.util.ReleasableResourcePooledExecutor$MyWorker.run(ReleasableResourcePooledExecutor.java:298)
        at java.lang.Thread.run(Thread.java:595)
"Thread-14":
        at oracle.classloader.PolicyClassLoader.toString(PolicyClassLoader.java:
1846)
        - waiting to lock &lt;0x05c0c0e8&gt; (a oracle.classloader.PolicyClassLoader)
        at java.text.MessageFormat.subformat(MessageFormat.java:1237)
        at java.text.MessageFormat.format(MessageFormat.java:828)
        at java.text.Format.format(Format.java:133)
        at java.text.MessageFormat.format(MessageFormat.java:804)
        at java.util.logging.Formatter.formatMessage(Formatter.java:130)
        - locked &lt;0x0514e718&gt; (a java.util.logging.SimpleFormatter)
        at java.util.logging.SimpleFormatter.format(SimpleFormatter.java:63)
        - locked &lt;0x0514e718&gt; (a java.util.logging.SimpleFormatter)
        at java.util.logging.StreamHandler.publish(StreamHandler.java:179)
        - locked &lt;0x05149eb8&gt; (a java.util.logging.FileHandler)
        at java.util.logging.FileHandler.publish(FileHandler.java:555)
        - locked &lt;0x05149eb8&gt; (a java.util.logging.FileHandler)
        at java.util.logging.Logger.log(Logger.java:428)
        at java.util.logging.Logger.doLog(Logger.java:450)
        at java.util.logging.Logger.logp(Logger.java:619)
        at java.util.logging.Logger.entering(Logger.java:870)
        at org.aspectj.weaver.tools.Jdk14Trace.enter(Jdk14Trace.java:32)
        at org.aspectj.weaver.loadtime.Aj.preProcess(Aj.java:67)
        at org.aspectj.weaver.loadtime.ClassPreProcessorAgentAdapter.transform(ClassPreProcessorAgentAdapter.java:55)
        at sun.instrument.TransformerManager.transform(TransformerManager.java:122)
        at sun.instrument.InstrumentationImpl.transform(InstrumentationImpl.java:155)
        at sun.misc.Unsafe.defineClass(Native Method)
        at sun.reflect.ClassDefiner.defineClass(ClassDefiner.java:45)
        at sun.reflect.MethodAccessorGenerator$1.run(MethodAccessorGenerator.java:381)
        at java.security.AccessController.doPrivileged(Native Method)
        at sun.reflect.MethodAccessorGenerator.generate(MethodAccessorGenerator.java:377)
        at sun.reflect.MethodAccessorGenerator.generateSerializationConstructor(MethodAccessorGenerator.java:95)
        at sun.reflect.ReflectionFactory.newConstructorForSerialization(ReflectionFactory.java:313)
        at java.io.ObjectStreamClass.getSerializableConstructor(ObjectStreamClass.java:1272)
        at java.io.ObjectStreamClass.access$1400(ObjectStreamClass.java:47)
        at java.io.ObjectStreamClass$2.run(ObjectStreamClass.java:393)
        at java.security.AccessController.doPrivileged(Native Method)
        at java.io.ObjectStreamClass.&lt;init&gt;(ObjectStreamClass.java:373)
        at java.io.ObjectStreamClass.lookup(ObjectStreamClass.java:268)
        at java.io.ObjectOutputStream.writeObject0(ObjectOutputStream.java:1029)

        at java.io.ObjectOutputStream.writeObject(ObjectOutputStream.java:291)
        at sun.rmi.server.UnicastRef.marshalValue(UnicastRef.java:258)
        at sun.rmi.server.UnicastRef.invoke(UnicastRef.java:117)
        at com.sun.jmx.remote.internal.PRef.invoke(Unknown Source)
        at javax.management.remote.rmi.RMIConnectionImpl_Stub.invoke(Unknown Source)
        at javax.management.remote.rmi.RMIConnector$RemoteMBeanServerConnection.invoke(RMIConnector.java:969)
        at javax.management.MBeanServerInvocationHandler.invoke(MBeanServerInvoc
ationHandler.java:201)
        at $Proxy5.listOperations(Unknown Source)
        at glassbox.client.remote.AbstractAgentClientProvider$2.doCommand(AbstractAgentClientProvider.java:111)
        at glassbox.client.remote.AbstractAgentClientProvider$RemoteCommand.execute(AbstractAgentClientProvider.java:64)
        at glassbox.client.remote.AbstractAgentClientProvider.doRemoteCommand(AbstractAgentClientProvider.java:171)
        at glassbox.client.remote.AbstractAgentClientProvider.selectOperations(AbstractAgentClientProvider.java:109)
        at glassbox.client.helper.OperationHelper.updateListOfOperations(OperationHelper.java:152)
        at glassbox.client.helper.OperationHelper.updateListOfOperations(OperationHelper.java:146)
        - locked &lt;0x05e95e08&gt; (a glassbox.client.helper.OperationHelper)
        at glassbox.client.helper.OperationHelper$OperationBuilder.run(OperationHelper.java:118)

Found 1 deadlock.</comment>
		<comment id="2" date="2006-08-24 21:16:57 EDT" author="Ron Bodkin">Created attachment 48664 [details]
This patch to loadtime isn't a complete solution to the problem, but it fixed it in my case.

In general, I think the weaver tracing shouldn't call methods like toString that might trigger class loading and result in deadlock.</comment>
		<comment id="3" date="2006-08-25 08:35:14 EDT" author="Matthew Webster">&gt;In general, I think the weaver tracing shouldn't call methods like toString
&gt;that might trigger class loading and result in deadlock.
If you look carefully at the stack trace you will see that it doesn't. This is _actually_ a problem with the JUL formatter which is using toString(). If you used a different formatter or logging implementation this wouldn't happen. The internal weaver DefaultTrace implementation always uses object identity unless it's a well know simple type.

I am inclined to view this as a JDK problem but see the merit of your patch. However I think I will change the implementation of Jdk14Trace to pre-format classes like ClassLoader.</comment>
		<comment id="4" date="2006-08-25 08:36:43 EDT" author="Matthew Webster">*** Bug 155146 has been marked as a duplicate of this bug. ***</comment>
		<comment id="5" date="2006-08-25 10:38:38 EDT" author="Matthew Webster">I have decided not to trust anyone! All arguments, apart from a few JDK classes like Integer, will be pre-formatted as String before being passed to a logging implementation. In the case of this bug it means you will _always_ get oracle.classloader.PolicyClassLoader@12345678.

We will continue to expand the set of AspectJ classes that implement Traceable, will add trusted JDK classes on request and may offer a TraceFormatter interface to be used at the user's own risk!</comment>
		<comment id="6" date="2006-08-25 11:21:02 EDT" author="Ron Bodkin">That sounds like an excellent strategy.</comment>
		<comment id="7" date="2006-08-30 03:56:11 EDT" author="Matthew Webster">Fix available in aspectj-DEVELOPMENT-20060825175312.jar.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="6be70973a704548a42e396e996c9d49915b92a64" author="mwebster" date="2006-08-25 11:37:34"/>
          <file name="loadtime/src/org/aspectj/weaver/loadtime/DefaultWeavingContext.java">
              <method name="getClassLoaderName" returnType="String" parameters=""/>
          </file>
          <file name="weaver/src/org/aspectj/weaver/tools/AbstractTrace.java">
              <method name="formatObj" returnType="Object" parameters="Object"/>
          </file>
          <file name="weaver/testsrc/org/aspectj/weaver/AbstractTraceTest.java">
              <method name="testEnterWithThisAndArray" returnType="void" parameters=""/>
          </file>
          <file name="weaver5/java5-src/org/aspectj/weaver/tools/Jdk14Trace.java">
              <method name="enter" returnType="void" parameters="String Object Object[]"/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="155238" opendate="2006-8-25 11:46:00" fixdate="2006-9-5 3:55:00">
    <buginformation>
      <summary>"Trace should use System.identityHashCode, not hashCode"</summary>
      <description>The tracing module uses obj.hashCode() to identify untrusted objects when formatting. I think it would be a little safer and more accurate to use
System.identityHashCode(obj). This way the tracing code wouldn't call any application-defined code, and would give a value that can't change if the loader state changes.</description>
      <comments>
		<comment id="1" date="2006-08-30 05:44:42 EDT" author="Matthew Webster">Good idea. I have changed DefaultWeavingContext too. Changes committed.</comment>
		<comment id="2" date="2006-09-05 03:55:28 EDT" author="Matthew Webster">aspectj-DEVELOPMENT-20060904170118.jar</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="14e8b7d8f0c94d316665036c3968821f8874678e" author="mwebster" date="2006-08-30 06:46:37"/>
          <file name="loadtime/src/org/aspectj/weaver/loadtime/DefaultWeavingContext.java">
              <method name="getClassLoaderName" returnType="String" parameters=""/>
          </file>
          <file name="weaver/src/org/aspectj/weaver/tools/AbstractTrace.java">
              <method name="formatObj" returnType="Object" parameters="Object"/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="155972" opendate="2006-9-1 8:45:00" fixdate="2006-9-5 3:55:00">
    <buginformation>
      <summary>NullPointerException in ConstructorSignature.getConstructor()</summary>
      <description>AspectJ version: 1.5.3.200608290814

When advising a constructor, we can do the following to obtain the constructor as a java.lang.reflect.Member:

		Member cons = ((ConstructorSignature) thisJoinPointStaticPart
				.getSignature()).getConstructor();

however that sometimes fails, and returns null.</description>
      <comments>
		<comment id="1" date="2006-09-01 08:53:01 EDT" author="Matt Chapman">Created attachment 49252


Run MyClass.java and get:

main
member: null
done

Note that the project has a 1.4 Java compliance setting (bug doesn't occur with 5.0)

Also, if you uncomment this line in the aspect:
   thisJoinPointStaticPart.getSignature().getDeclaringType();
it starts working as expected:

main
member: public bar.MyClass()
done</comment>
		<comment id="2" date="2006-09-01 09:06:32 EDT" author="Matt Chapman">Created attachment 49253 [details]
testcase

oops, previous attachment was the full testcase, this one is the cut down version</comment>
		<comment id="3" date="2006-09-01 09:09:35 EDT" author="Matt Chapman">Created attachment 49254 [details]
fix

The NPE comes from this line in ConstructorSignatureImpl.getConstructor():

constructor = declaringType.getDeclaredConstructor(getParameterTypes());

because declaringType hasn't been initialised yet.

A fix is to use getDeclaringType() instead. There may be other cases of this to consider.</comment>
		<comment id="4" date="2006-09-01 13:50:21 EDT" author="Ron Bodkin">I ran into a similar bug #94167 a long time ago ... it would be good to test that none of the join point methods are implicitly relying on some other method to initialize internal variables.</comment>
		<comment id="5" date="2006-09-04 06:55:11 EDT" author="Matthew Webster">In an instructive, although not scientific, experiment I wrote the following aspect to first find fields in the Signature hierarchy that are initialized lazily then individual declare error statements to find if thy were ever accessed directly where they shouldn't.

public aspect LazyInitialization {

 /* Find fields that are initialized lazily */
 declare warning : set(* org.aspectj.lang.Signature+.*) &amp;&amp; withincode(* *.get*(..)) &amp;&amp; within(org.aspectj..*) :
  "initialize";
 
 /* Find direct access to those fields */
 declare error : get(* org.aspectj.lang.Signature+.*Type) &amp;&amp; !(withincode(* *.create*(..)) || withincode(* *.get*Type(..)) || withincode(*.new(..))) &amp;&amp; within(org.aspectj..*) :
  "reference";

 declare error : get(* org.aspectj.lang.Signature+.*Types) &amp;&amp; !(withincode(* *.create*(..)) || withincode(* *.get*Types(..)) || withincode(*.new(..))) &amp;&amp; within(org.aspectj..*) :
  "reference";

 declare error : get(* org.aspectj.lang.Signature+.*TypeName) &amp;&amp; !(withincode(* *.create*(..)) || withincode(* *.get*TypeName(..)) || withincode(*.new(..))) &amp;&amp; within(org.aspectj..*) :
  "reference";

 declare error : get(* org.aspectj.lang.Signature+.*ClassLoader) &amp;&amp; !(withincode(* *.create*(..)) || withincode(* *.get*ClassLoader(..)) || withincode(*.new(..))) &amp;&amp; within(org.aspectj..*) :
  "reference";
}

It found two addition cases in FieldSignatureIMpl.getField() and InitializerSignatureImpl.getInitializer(). However a better solution might be to declare fields private that are initialized lazily.</comment>
		<comment id="6" date="2006-09-04 10:22:04 EDT" author="Matthew Webster">Fix applied and tests added along with those for FieldSignatureImpl and InitializerSignatureImpl.</comment>
		<comment id="7" date="2006-09-05 03:55:09 EDT" author="Matthew Webster">Fix available in aspectj-DEVELOPMENT-20060904170118.jar</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="090de7e4c5c9618f965259f93de6d490050543da" author="mwebster" date="2006-09-04 11:24:51"/>
          <file name="runtime/src/org/aspectj/runtime/reflect/ConstructorSignatureImpl.java">
              <method name="getConstructor" returnType="Constructor" parameters=""/>
          </file>
          <file name="runtime/src/org/aspectj/runtime/reflect/FieldSignatureImpl.java">
              <method name="getField" returnType="Field" parameters=""/>
          </file>
          <file name="runtime/src/org/aspectj/runtime/reflect/InitializerSignatureImpl.java">
              <method name="getInitializer" returnType="Constructor" parameters=""/>
          </file>
          <file name="tests/bugs153/pr155972/ConstructorTest.java">
          </file>
          <file name="tests/bugs153/pr155972/FieldTest.java">
          </file>
          <file name="tests/bugs153/pr155972/InitializerTest.java">
          </file>
          <file name="tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java">
              <method name="testReweavableAspectNotRegistered_pr129525" returnType="void" parameters=""/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="151182" opendate="2006-7-20 2:50:00" fixdate="2006-9-5 3:57:00">
    <buginformation>
      <summary>NPE in BcelWeaver using LTW</summary>
      <description>Hi,

I created a logging aspect for our application some time ago using 1.5.0 of AspectJ. I enabled this from time to time using Load Time Weaving.

I have recently recompiled the aspect using 1.5.2 and tried to run it also using the 1.5.2 weaver jar, but it fails with a NullPointerException.

This is part of one of the many stacktraces:

20 jul 2006 07:42:49,046 - java.lang.NullPointerException
20 jul 2006 07:42:49,062 - 	at org.aspectj.weaver.bcel.BcelWeaver.weaveParentTypeMungers(BcelWeaver.java:1367)
20 jul 2006 07:42:49,062 - 	at org.aspectj.weaver.bcel.BcelWeaver.weaveParentsFor(BcelWeaver.java:1237)
20 jul 2006 07:42:49,062 - 	at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1072)
20 jul 2006 07:42:49,062 - 	at org.aspectj.weaver.tools.WeavingAdaptor.getWovenBytes(WeavingAdaptor.java:284)
20 jul 2006 07:42:49,062 - 	at org.aspectj.weaver.tools.WeavingAdaptor.weaveClass(WeavingAdaptor.java:212)
20 jul 2006 07:42:49,062 - 	at org.aspectj.weaver.loadtime.Aj.preProcess(Aj.java:65)
20 jul 2006 07:42:49,062 - 	at org.aspectj.weaver.loadtime.ClassPreProcessorAgentAdapter.transform(ClassPreProcessorAgentAdapter.java:55)
20 jul 2006 07:42:49,062 - 	at sun.instrument.TransformerManager.transform(Unknown Source)
20 jul 2006 07:42:49,062 - 	at sun.instrument.InstrumentationImpl.transform(Unknown Source)
20 jul 2006 07:42:49,062 - 	at java.lang.ClassLoader.defineClass1(Native Method)
20 jul 2006 07:42:49,062 - 	at java.lang.ClassLoader.defineClass(Unknown Source)

I then tried with the 1.5.0 weaver jar (although the aspect was compiled using 1.5.2) and this ran without problems.</description>
      <comments>
		<comment id="1" date="2006-07-20 02:53:53 EDT" author="Wim Deblauwe">Created attachment 46562 [details]
Aspect source code and compiled class file</comment>
		<comment id="2" date="2006-07-20 09:10:23 EDT" author="Matthew Webster">Created attachment 46573 [details]
JDK 1.4 Logging Configuration

We think this is a threading problem: two different threads are trying to load, weave and define a class using the same class loader. There is a race where one initializes the weaver while the other uses it before the process is complete hence the NPE. We assume, possibly incorrectly, that this situation cannot occur because the class loader lock prevents it.

Can you give some more information:
- Are you using AspectJ 1.5.2 Final from 30th June?
- Which JDK are you using (âjava âversionâ) e.g. Sun 1.5.0_05
- Are you using a dual processor or dual core machine (where threading issues are more likely)?

Recent development builds have a new tracing infrastructure that may help us track down the problem. Could you try the âLast Known Good developer buildâ? If the problem still occurs could you please use the attached logging.properties file, either by replacing the one in &lt;JAVA_HOME&gt;/jre/lib or by specifying it using â-Djava.util.logging.config.file=logging.propertiesâ, and send us the resulting â/Documents and Settings/&lt;USER&gt;/java0.logâ.</comment>
		<comment id="3" date="2006-07-20 10:56:52 EDT" author="Wim Deblauwe">I *think* I'm using the final version. The manifest file shows this:
Manifest-Version: 1.0
Name: org/aspectj/weaver/
Specification-Title: AspectJ Weaver Classes
Specification-Version: 1.5.2
Specification-Vendor: aspectj.org
Implementation-Title: org.aspectj.weaver
Implementation-Version: 1.5.2
Implementation-Vendor: aspectj.org
Premain-Class: org.aspectj.weaver.loadtime.Agent
Can-Redefine-Classes: true

and it's dated 29/06/2006 16:31. Most of the class files are also from that date, although some are from 8/05/2006 6:47.

JDK VERSION:
java version "1.5.0_06"
Java(TM) 2 Runtime Environment, Standard Edition (build 1.5.0_06-b05)
Java HotSpot(TM) Client VM (build 1.5.0_06-b05, mixed mode)

I'm not on a multi-core pc. I'm using a Dell OPTIPLEX GX260 Pentium 4 2.4 GHz and 1 GB RAM.

I won't be able to test it with the logging today and I'm out of the office for the next three weeks. I will test this when I get back.</comment>
		<comment id="4" date="2006-07-20 15:35:17 EDT" author="Ron Bodkin">See also bug #140709 with a patch I developed to deal with race conditions like this. As noted in that bug, it had been a while since I'd seen one, so I wasn't sure it was possible without another extension I was trying out to share state among weavers...</comment>
		<comment id="5" date="2006-07-24 12:14:39 EDT" author="Matthew Webster">It seems to me that the root cause of these problems is the implementation of Unsafe (what an appropriate name) on the Sun JVM.

- Bug 99861 âDeadlock in Java5 Load Time Weaving on Sun VMâ
- Bug 109344 âAnother LTW Deadlock on Sun VMsâ
- Bug 140709 â[ltw] Patch: Handle weaving while initializing properlyâ
- Bug 151182 âNPE in BcelWeaver using LTWâ

The implementation of Aj assumes that the classloader lock is held before it is invoked, either directly or through JVMTI. If it isnât there are 3 potential consequences:
1. ClassLoader and HashMap locks taken in different orders
2. A race condition with ClassLoaderWeavingAdaptor.initialize() 
3. Multi-threaded invocation of ClassLoaderWeavingAdaptor.weaveClass()

The Weaver must be initialized just once before weaving byte-code. The Weaver is not thread safe so must be protected. The obvious solution is to use the ClassLoader lock which under normal conditions will have been taken. This can be used to protect both initialize() and weaveClass(). I therefore propose the following in Aj.preprocess():

    try {
        synchronized (loader) {
            WeavingAdaptor weavingAdaptor = WeaverContainer.getWeaver(loader, weavingContext);
            if (weavingAdaptor == null) {
                return bytes;
            }
            return weavingAdaptor.weaveClass(className, bytes);
 }
    } catch (Exception t) {
    â¦

If we already have the lock then taking it again should not be expensive on modern JVMs. The code could be moved to ClassPreProcessorAgentAdapter so that JRockit and direct invokers are not penalized. I will wait until we have some more information, in particular a full stack trace to see if Unsafe is indeed implicated.</comment>
		<comment id="6" date="2006-07-25 07:32:13 EDT" author="Matthew Webster">If Unsafe is the problem then it may not be caused by reflection delegates. These use a special class loader that since bug 120473 (incorrectly shown as 120743 in the History for Aj) for whicn we no longer create WeavingAdaptor instance. This bug occurs when creating and initializing an adaptor.</comment>
		<comment id="7" date="2006-08-02 03:47:40 EDT" author="Matthew Webster">Fix available. Awaiting verfication.</comment>
		<comment id="8" date="2006-08-24 05:17:17 EDT" author="Matthew Webster">See http://dev.eclipse.org/mhonarc/lists/aspectj-users/msg06584.html.</comment>
		<comment id="9" date="2006-09-05 03:57:54 EDT" author="Matthew Webster">Changing to FIXED after a month on inactivity and anecdotal evidence that the solution works.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="397a19d441eaf7fdc67e841232b410358b48ba11" author="mwebster" date="2006-07-27 06:25:50"/>
          <file name="loadtime/src/org/aspectj/weaver/loadtime/Aj.java">
              <method name="preProcess" returnType="byte[]" parameters="String byte[] ClassLoader"/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="156962" opendate="2006-9-11 23:16:00" fixdate="2006-9-12 6:21:00">
    <buginformation>
      <summary>[annotations] Problems with @Deprecated in member signatures</summary>
      <description>The latest dev builds still have cases where they don't match properly on @Deprecated. See attached for two failing test cases for execution and hasMethod.</description>
      <comments>
		<comment id="1" date="2006-09-11 23:20:38 EDT" author="Ron Bodkin">Created attachment 49894 [details]
Patch to tests module</comment>
		<comment id="2" date="2006-09-12 06:00:21 EDT" author="Andrew Clement">the case I fixed was for types - this case is for methods (and there is a related case for fields).  I've fixed all these.  I also had to modify some of the has member matching because of the way we store the declared annotation (we stick it on a special member in the aspect) - without my change it considered some parts of the aspect to be annotated and so LiftDeprecation made the aspect deprecated too !</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="df98dedb103d8b85aca337aac9436b8c88064680" author="aclement" date="2006-09-12 05:46:16"/>
          <file name="tests/bugs153/pr156962/Sample.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="153845" opendate="2006-8-14 21:28:00" fixdate="2006-09-14 09:26:12">
    <buginformation>
      <summary>[generics] Problem with signature for generic type</summary>
      <description>public aspect OuterAspect {

  private pointcut isSetter() : execution(void set*(..));

  public static aspect InnerAspect pertarget(isSetter()) {

  }

}


java.lang.IllegalStateException
at org.aspectj.apache.bcel.classfile.GenericSignatureParser.parseFieldTypeSignature(GenericSignatureParser.java:163)
at org.aspectj.apache.bcel.classfile.GenericSignatureParser.parseTypeArgument(GenericSignatureParser.java:253)
at org.aspectj.apache.bcel.classfile.GenericSignatureParser.maybeParseTypeArguments(GenericSignatureParser.java:261)
at org.aspectj.apache.bcel.classfile.GenericSignatureParser.parseClassTypeSignature(GenericSignatureParser.java:208)
at org.aspectj.apache.bcel.classfile.GenericSignatureParser.parseAsClassSignature(GenericSignatureParser.java:56)
at org.aspectj.apache.bcel.classfile.Signature.asClassSignature(Signature.java:315)
at org.aspectj.apache.bcel.classfile.JavaClass.getGenericClassTypeSignature(JavaClass.java:973)
at org.aspectj.weaver.bcel.BcelObjectType.initializeFromJavaclass(BcelObjectType.java:164)
at org.aspectj.weaver.bcel.BcelObjectType.&lt;init&gt;(BcelObjectType.java:131)
at org.aspectj.weaver.bcel.BcelWorld.buildBcelDelegate(BcelWorld.java:337)
at org.aspectj.weaver.bcel.BcelWorld.addSourceObjectType(BcelWorld.java:395)
at org.aspectj.weaver.bcel.BcelWeaver.addIfAspect(BcelWeaver.java:263)
at org.aspectj.weaver.bcel.BcelWeaver.addAspectsFromDirectory(BcelWeaver.java:255)
at org.aspectj.weaver.bcel.BcelWeaver.addLibraryJarFile(BcelWeaver.java:205)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.initBcelWorld(AjBuildManager.java:698)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:223)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:199)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.incrementalBuild(AjBuildManager.java:170)
at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:117)
at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)

IllegalStateException thrown: Expecting [,L, or T, but found Pjava while unpacking Ljava/util/AbstractSet&lt;Pjava/util/Map$Entry&lt;TK;TV;&gt;;&gt;;</description>
      <comments>
		<comment id="1" date="2006-08-15 03:08:43 EDT" author="Andrew Clement">Are you on 1.5.2 or a dev build of 1.5.3?

I tried just compiling the aspect you included, worked fine.  Given that the signature it has trouble with is 

"Ljava/util/AbstractSet&lt;Pjava/util/Map$Entry&lt;TK;TV;&gt;;&gt;;"

something else must be involved - since your aspect doesn't use collection classes.  How are you compiling that aspect? Are you weaving rt.jar?</comment>
		<comment id="2" date="2006-08-15 03:17:20 EDT" author="Matt Whitlock">I can't reproduce it anymore.  I'm using AspectJ 1.5.2 with AJDT 1.4 on Eclipse 3.2.  I was not trying to weave into rt.jar.  I'll reopen this bug if I come across it again and can make a reproducible test case for you.</comment>
		<comment id="3" date="2006-09-11 13:37:26 EDT" author="John D. Heintz">Created attachment 49854 [details]
Testcase: Ant driven

This small project demonstrate the BCEL exception for this bug. The project assumes a lib directory with the AspectJ jars (I used aspectj-DEVELOPMENT-20060907092616.jar for this).</comment>
		<comment id="4" date="2006-09-11 13:40:10 EDT" author="John D. Heintz">I've added a test case that demonstrates this bug.</comment>
		<comment id="5" date="2006-09-13 12:41:33 EDT" author="Andrew Clement">thanks for the testcase - I've been able to work out how the rogue signature is getting into the class output during the first compilation.</comment>
		<comment id="6" date="2006-09-14 06:40:33 EDT" author="Andrew Clement">I stripped down the testcase to the bare minimum.

Basically you need to have some type that implements/extends a generic type, eg.

Foo extends List&lt;Set&lt;String&gt;&gt;

(and the generic reference has to be nested, can't be List&lt;String&gt; - needs to be more complex).

That type must be affected by a declare parents to cause the signature to change, this will result in a broken signature on disk (so assume declare parents: Foo implements Serializable):

Ljava/util/List&lt;Pjava/util/Set&lt;Ljava/lang/String;&gt;;&gt;;

(see the rogue P)

then that has to be used in a subsequent weave and the weaver will blow up when unpacking it.  The fix is trivial ;)

Test and fix checked in - the fix is likely to address any/all related bugs that  suffer this same illegal state exception.</comment>
		<comment id="7" date="2006-09-14 09:26:12 EDT" author="Andrew Clement">fix available in AJ dev builds.</comment>
		<comment id="8" date="2006-09-20 19:12:19 EDT" author="John D. Heintz">Still getting this problem, but only from AJDT - it seems to work perfectly well in Ant/AspectJ.

I'll attach a Team Project Set file with two projects that generate this failure. Sorry for the moderate download size. (Depends on Subclipse for Subversion access).

The stack trace is a little different from Eclipse as well, here is a copy:
java.lang.IllegalStateException
at org.aspectj.apache.bcel.classfile.GenericSignatureParser.parseFieldTypeSignature(GenericSignatureParser.java:163)
at org.aspectj.apache.bcel.classfile.GenericSignatureParser.parseTypeArgument(GenericSignatureParser.java:253)
at org.aspectj.apache.bcel.classfile.GenericSignatureParser.maybeParseTypeArguments(GenericSignatureParser.java:261)
at org.aspectj.apache.bcel.classfile.GenericSignatureParser.pars ... teException thrown: Expecting [,L, or T, but found Pjava while unpacking Ljava/lang/ThreadLocal&lt;Pjava/util/Set&lt;Ldash/obtain/provider/ObtainLookup;&gt;;&gt;;</comment>
		<comment id="9" date="2006-09-20 19:14:44 EDT" author="John D. Heintz">Created attachment 50611 [details]
Team Project Set file for failing case

This Team Project Set file points to two Eclipse projects that demonstrate the failure in AJDT.</comment>
		<comment id="10" date="2006-09-21 03:15:15 EDT" author="Andrew Clement">i dont believe AJDT has been upgraded with the most recent AspectJ build... hence it is still failing...</comment>
		<comment id="11" date="2006-09-21 11:02:02 EDT" author="Helen Beeken">The latest 1.4 and 1.5 AJDT dev builds now contain this fix.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="70ae0f8df6ec8b77ea2940b222e11d6d411ec5d2" author="aclement" date="2006-09-14 07:38:50"/>
          <file name="tests/bugs153/pr153845/Aspect.java">
          </file>
          <file name="tests/bugs153/pr153845/Aspect2.java">
          </file>
          <file name="tests/bugs153/pr153845/GenericType.java">
          </file>
          <file name="tests/bugs153/pr153845/Interface.java">
          </file>
          <file name="tests/bugs153/pr153845/Nothing.java">
          </file>
          <file name="tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/ReferenceType.java">
              <method name="makeDeclaredSignature" returnType="String" parameters="ResolvedType UnresolvedType[]"/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="153490" opendate="2006-8-10 16:39:00" fixdate="2006-9-25 9:50:41">
    <buginformation>
      <summary>IllegalStateException thrown: How come we're in AsmObjectType resolving an inner type of something that is NOT a AsmObjectType??</summary>
      <description>I try out Contract4J 0.5 with AspectJ 1.5.2 (Build 20060629124300) and Eclipse 3.2 (Build M20060629-1905) under Windows XP SP2 and Java 1.5.0_06. So I became following exception. (You will find my testcode below the exception.) I am not sure if this bug related to Contract4J or to AspectJ!?

==== The Exception ====

java.lang.IllegalStateException
at org.aspectj.weaver.asm.AsmDelegate.getFormalTypeParametersFromOuterClass(AsmDelegate.java:465)
at org.aspectj.weaver.asm.AsmDelegate.ensureSignatureUnpacked(AsmDelegate.java:395)
at org.aspectj.weaver.asm.AsmDelegate.getDeclaredInterfaces(AsmDelegate.java:538)
at org.aspectj.weaver.ReferenceType.getDeclaredInterfaces(ReferenceType.java:426)
at org.aspectj.weaver.ResolvedType.getDirectSupertypes(ResolvedType.java:64)
at org.aspectj.weaver.ResolvedType.collectInterTypeMungers(ResolvedType.java:1155)
at org.aspectj.weaver.ResolvedType.getInterTypeMungersIncludingSupers(ResolvedType.java:1134)
at org.aspectj.weaver.ResolvedType.checkInterTypeMungers(ResolvedType.java:1201)
at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.weaveInterTypeDeclarations(AjLookupEnvironment.java:643)
at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.weaveInterTypeDeclarations(AjLookupEnvironment.java:519)
at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.createBinaryTypeFrom(AjLookupEnvironment.java:1058)
at org.aspectj.org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.createBinaryTypeFrom(LookupEnvironment.java:480)
at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.accept(Compiler.java:190)
at org.aspectj.org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.askForType(LookupEnvironment.java:111)
at org.aspectj.org.eclipse.jdt.internal.compiler.lookup.UnresolvedReferenceBinding.resolve(UnresolvedReferenceBinding.java:43)
at org.aspectj.org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.resolveType(BinaryTypeBinding.java:53)
at org.aspectj.org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.getMemberType(BinaryTypeBinding.java:618)
at org.aspectj.org.eclipse.jdt.internal.compiler.lookup.Scope.findMemberType(Scope.java:928)
at org.aspectj.org.eclipse.jdt.internal.compiler.lookup.BlockScope.getBinding(BlockScope.java:449)
at org.aspectj.org.eclipse.jdt.internal.compiler.ast.QualifiedNameReference.resolveType(QualifiedNameReference.java:903)
at org.aspectj.org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:326)
at org.aspectj.org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:829)
at org.aspectj.org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:422)
at org.aspectj.org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:178)
at org.aspectj.org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:400)
at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1088)
at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1137)
at org.aspectj.org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:305)
at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:519)
at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:329)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:887)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:271)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.incrementalBuild(AjBuildManager.java:170)
at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:117)
at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)

IllegalStateException thrown: How come we're in AsmObjectType resolving an inner type of something that is NOT a AsmObjectType??

==== My TestCode ====

import org.contract4j5.Contract;
import org.contract4j5.Post;
import org.contract4j5.Pre;

import org.contract4j5.aspects.Contract4J;

// this is a dummy code!!

@Contract
public class Foo {

  private String fooField = null;
  
  @Pre("nr != null")
  public void setFooField(String f) {
    fooField = f; 
  }
  
  @Post("$return != null")
  public String getFooField() {
    return fooField;
  }
  
  public static void main(String[] args) {
    
    Contract4J.setEnabled(Contract4J.TestType.Pre,   true); //1
    Contract4J.setEnabled(Contract4J.TestType.Post,  true); //2 
    Contract4J.setEnabled(Contract4J.TestType.Invar, true); //3
    
    Foo foo = new Foo();
    foo.setFooField(null);
    System.out.println(foo.getFooField());
    
  }
  
}</description>
      <comments>
		<comment id="1" date="2006-08-10 17:50:05 EDT" author="Dean Wampler">Created attachment 47732 [details]
Bug reporter's example reworked as a unit test.</comment>
		<comment id="2" date="2006-08-10 17:53:53 EDT" author="Dean Wampler">I've attached a slightly-reworked version of your example as a unit test. No real difference.
I tried with the same AspectJ, Eclipse, and AJDT versions and had no problems (except that one test expression "nr != null" will always fail since "nr" is undefined..). However, there are a few possible differences:
(i) I am using a slightly newer development version of C4J that will released as V0.6 hopefully this weekend. It mostly adds structural improvements that shouldn't be involved in this problem (famous last words...).
(ii) I have occasionally seen similar, but not repeatable compiler errors. Usually a clean rebuild of everything makes it go away.
So, I suspect AspectJ ;) I will try to reproduce it on the actual V0.5 Contract4J release.</comment>
		<comment id="3" date="2006-08-10 18:13:00 EDT" author="Thomas Zuberbuehler">Hello

Perhaps, I've found some solution in Bug 140375 (Comment 5, from Heiko Seeberger). With -Xset:activateLightweightDelegates=false no exception will be thrown anymore.

My program don't run without some output, but this is definitely no bug.. Only my greenness with Contract4J I think.. ;)

Thank you.</comment>
		<comment id="4" date="2006-08-10 18:16:43 EDT" author="Thomas Zuberbuehler">sorry. of course ' ... don't run with ... ' ;)

what is the work of -Xset:activateLightweightDelegates=false? could it be that I receive therefore no output in my program? </comment>
		<comment id="5" date="2006-08-11 03:53:44 EDT" author="Adrian Colyer">AspectJ keeps a 'world' in which it retains information about the types used in your program (so that it can answer questions about pointcut matching for example). We have several different ways that information about types can be obtained - these are captured by different "delegate" classes that we use like a strategy pattern. We used to only use BCEL for delegates backed by .class files, but for types that we are not going to weave into we now have the option (used by default) of using ASM for 'types not exposed to the weaver'. The flag you are setting turns off this use of ASM for "lighter weight" delegates and falls back on the BCEL strategy. It should make no difference to the output of your program, only the amount of memory used (slightly more with BCEL). This bug is clearly to do with mixing up ASM and BCEL delegates in a way we weren't anticipating - hence why disabling the ASM support makes it go away...</comment>
		<comment id="6" date="2006-08-14 08:43:25 EDT" author="Thomas Zuberbuehler">Thank you!</comment>
		<comment id="7" date="2006-08-29 10:53:25 EDT" author="Helen Beeken">I've managed to recreate this bug with the AJ version in HEAD and the following simple testcase:

---------------------------------------------------
public aspect A {
 public enum TestType {Pre};
}

public class Foo {

 public static void main(String[] args) {
  A.TestType pre = A.TestType.Pre;
    }

}
----------------------------------------------------

The requirement for recreating this bug is that the aspect is compiled into a jar file which is then placed on the classpath when compiling Foo.</comment>
		<comment id="8" date="2006-08-29 10:56:51 EDT" author="Helen Beeken">Created attachment 48965 [details]
failing testcase

Apply to the tests project.

This patch is the test program in the above comment written to fit in with the aj test harness.</comment>
		<comment id="9" date="2006-08-29 11:41:38 EDT" author="Helen Beeken">In answer to the exception message "How come we're in AsmObjectType resolving an inner type of something that is NOT a AsmObjectType??", the reason is that the enum is an inner type of an aspect and due to the fix for bug 135001 we "fallbackToLoadingBcelDelegatesForAspects" in BcelWorld line 302 and so create a BcelObjecType for A instead. When we come to resolve the Enum we're not an aspect and so return the AsmDelegate. Consequently the AsmDelegate is an inner type of the BcelObjectType.</comment>
		<comment id="10" date="2006-08-30 08:11:44 EDT" author="Helen Beeken">Two possible solutions are:

1. because the aspect is a BcelObjectType then all inner types should consequently be BcelObjectTypes

2. cope with the case when the inner type is an AsmDelegate whose enclosing type is an aspect which is a BcelObjectType</comment>
		<comment id="11" date="2006-08-31 04:12:32 EDT" author="Helen Beeken">Created attachment 49142 [details]
zip containing improved tests

This zip contains the following:

* pr153490-tests.txt: apply to the tests project
* jarForFoo.jar, jarForGoo.jar, jarForBar.jar: place in the tests\bugs153\pr153490 directory

These tests replace the previously attached ones as they include more cases:

1. enum is an inner type of an aspect
2. enum is an inner type of a class which is an inner type of an aspect
3. enum is an inner type of an aspect which is an inner type of a class</comment>
		<comment id="12" date="2006-09-13 03:43:19 EDT" author="Andrew Clement">I don't think there is a need to force the delegates of inner types to be Bcel ones - the second option in comment #10 is the way to go.  As with other illegal state exceptions, it was in the code to police something we were concerned about - something that might happen in the wild and yet we hadn't been able to cover with tests.  When it arises in the wild, we look at what is happening and decide whether the behaviour is reasonable - if it is then we remove the restriction (effectively considering the 'illegalstate' to be a 'legal state').  So - I've fixed this by allowing the mixing of delegates - the code was a mess to deal with this stuff so I've moved quite a bit of it around, I hope it hasn't introduced new problems but you never know.  if it has then they are likely to be in the use of generic/parmeterized types.

testcases and fixes all in.</comment>
		<comment id="13" date="2006-09-25 09:50:41 EDT" author="Andrew Clement">fixes available in dev build.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="43638daf5d222e4dd9af8788d575b721f84d1210" author="aclement" date="2006-09-13 12:19:54"/>
          <file name="tests/bugs153/pr153490/Bar.java">
          </file>
          <file name="tests/bugs153/pr153490/C.java">
          </file>
          <file name="tests/bugs153/pr153490/Foo.java">
          </file>
          <file name="tests/bugs153/pr153490/Goo.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="152848" opendate="2006-8-4 11:15:00" fixdate="2006-9-25 9:53:12">
    <buginformation>
      <summary>IllegalStateException thrown: Expecting raw type</summary>
      <description>I get the exception below when I enable AspectJ on my Java project:

java.lang.IllegalStateException
at org.aspectj.weaver.TypeFactory.createParameterizedType(TypeFactory.java:42)
at org.aspectj.weaver.bcel.BcelGenericSignatureToTypeXConverter.classTypeSignature2TypeX(BcelGenericSignatureToTypeXConverter.java:82)
at org.aspectj.weaver.bcel.BcelGenericSignatureToTypeXConverter.classTypeSignature2TypeX(BcelGenericSignatureToTypeXConverter.java:42)
at org.aspectj.weaver.asm.AsmDelegate.ensureSignatureUnpacked(AsmDelegate.java:410)
at org.aspectj.weaver.asm.AsmDelegate.getDeclaredInterfaces(AsmDelegate.java:538)
at org.aspectj.weaver.ReferenceType.getDeclaredInterfaces(ReferenceType.java:426)
at org.aspectj.weaver.ResolvedType.getDirectSupertypes(ResolvedType.java:64)
at org.aspectj.weaver.ResolvedType.collectInterTypeMungers(ResolvedType.java:1155)
at org.aspectj.weaver.ResolvedType.getInterTypeMungersIncludingSupers(ResolvedType.java:1134)
at org.aspectj.weaver.ResolvedType.checkInterTypeMungers(ResolvedType.java:1201)
at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.weaveInterTypeDeclarations(AjLookupEnvironment.java:643)
at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.weaveInterTypeDeclarations(AjLookupEnvironment.java:519)
at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.createBinaryTypeFrom(AjLookupEnvironment.java:1058)
at org.aspectj.org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.createBinaryTypeFrom(LookupEnvironment.java:480)
at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.accept(Compiler.java:190)
at org.aspectj.org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.askForType(LookupEnvironment.java:111)
at org.aspectj.org.eclipse.jdt.internal.compiler.lookup.UnresolvedReferenceBinding.resolve(UnresolvedReferenceBinding.java:43)
at org.aspectj.org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.resolveType(BinaryTypeBinding.java:53)
at org.aspectj.org.eclipse.jdt.internal.compiler.lookup.PackageBinding.getTypeOrPackage(PackageBinding.java:167)
at org.aspectj.org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope.findImport(CompilationUnitScope.java:413)
at org.aspectj.org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope.findSingleImport(CompilationUnitScope.java:466)
at org.aspectj.org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope.faultInImports(CompilationUnitScope.java:331)
at org.aspectj.org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope.faultInTypes(CompilationUnitScope.java:400)
at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:512)
at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:329)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:887)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:244)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:163)
at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:122)
at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)

IllegalStateException thrown: Expecting raw type</description>
      <comments>
		<comment id="1" date="2006-08-04 11:44:35 EDT" author="Felix Mayer">Once this problem has occurred, all *.aj files are opened with the Java editor instead of the AspectJ editor.</comment>
		<comment id="2" date="2006-08-23 10:50:31 EDT" author="Andrew Clement">we've fixed a few cases of this ... guess this is another one....</comment>
		<comment id="3" date="2006-08-25 05:41:03 EDT" author="Andrew Clement">I've reproduced this failure - not sure if its via the route the raiser is using but I'm going to fix the case I've found.

I have a Java5 type with a member:

Pair&lt;String,String&gt; foo;

Where Pair is:

class Pair&lt;A,B&gt; {}

All fine....  the problem I see is because after initial compilation, in an LTW environment, we reuse the type containing the member 'foo' in an situation where Pair is not-generic (ie. probably a back level of the library containing Pair).

The code that unpacks the signature for the member is expecting Pair to be in its 'raw' form (ie. it is actually a generic type underneath) - when we discover it isnt, we go bang.

In these situations where we cannot parameterize the non-generic type, we'll continue with the simple type that has been found.  I can't immediately think of a situation where this will get us into trouble.  I am adding trace entries for this situation so that it is logged in future and we can more easily diagnose what is going wrong.</comment>
		<comment id="4" date="2006-09-25 09:53:12 EDT" author="Andrew Clement">i think this has now been resolved - we allow the type that was discovered to be non-generic and continue with the simple type.  please reopen if it still happens for you.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="04c679e8e06ab8295a9d6916960cdcfc1c0025af" author="aclement" date="2006-08-25 06:59:11"/>
          <file name="tests/bugs153/pr152848/AnAspect.java">
          </file>
          <file name="tests/bugs153/pr152848/BaseType.java">
          </file>
          <file name="tests/bugs153/pr152848/PairGeneric.java">
          </file>
          <file name="tests/bugs153/pr152848/PairNormal.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="158573" opendate="2006-9-25 11:09:00" fixdate="2006-10-3 6:54:12">
    <buginformation>
      <summary>changing value of variable in aspect results in adviceDidNotMatch warning</summary>
      <description>Given the following:

public aspect A {
	public static int i = 0;
	before() : execution(* *.*(..)) {}
}

public class C {
	public void m() {}
}

Changing the value of i to be something else and then saving results in an incremental build and an "adviceDidNotMatch" warning. A full build clears the warning.

This is since the JDTLikeHandleProvider (bug 141730) was made the default in AJDT and is down to the call on line 90 of CrosscuttingMembersSet which is the fix for bug 134541). The reason we now hit this is that the JDTLikeHandleProvider doesn't depend on location.</description>
      <comments>
		<comment id="1" date="2006-09-25 11:12:36 EDT" author="Helen Beeken">Created attachment 50831 [details]
failing testcase

Apply this patch to the tests project.</comment>
		<comment id="2" date="2006-09-25 11:19:30 EDT" author="Helen Beeken">The problem is that the new shadowMunger has the field "hasMatchedAtLeastOnce" set to false, as it would do since it was created on this incremental compile. The shadowmunger it's replacing has "hasMatchedAtLeastOnce" set to true because on the full compile we went through BcelAdvice.implementOn(). Currently in CrosscuttingMembersSet.replaceWith() we do a blanket replace of the shadowmungers to ensure we've picked up the latest changes. I guess we could be more specific here and ensure that we don't loose this type of information...... </comment>
		<comment id="3" date="2006-09-25 11:48:49 EDT" author="Andrew Clement">it's ugly but we could do that ... i've put in similarly ugly fixes before ;)</comment>
		<comment id="4" date="2006-09-25 11:59:48 EDT" author="Helen Beeken">Created attachment 50839 [details]
patch containing proposed fix

Apply this patch to the weaver project.

This patch contains the fix proposed in the above comment.</comment>
		<comment id="5" date="2006-09-29 10:18:11 EDT" author="Andrew Clement">test and 'fix' in ;)

iplog</comment>
		<comment id="6" date="2006-10-03 06:54:12 EDT" author="Andrew Clement">fix available in aj dev builds.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="cd9fd1147b63c7a0df0c93307feae4dce7b19d4d" author="aclement" date="2006-09-29 11:21:57"/>
          <file name="tests/multiIncremental/PR158573/base/C.java">
          </file>
          <file name="tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java">
              <method name="testShouldFullBuildOnExceptionChange_pr154054" returnType="void" parameters=""/>
          </file>
          <file name="weaver/src/org/aspectj/weaver/CrosscuttingMembers.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java">
              <method name="hasMatchedSomething" returnType="boolean" parameters=""/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="156904" opendate="2006-9-11 13:39:00" fixdate="2006-10-4 3:05:17">
    <buginformation>
      <summary>Incorrect warning when advising a private method of a private inner class</summary>
      <description>The Eclipse AJDT give an incorrect warning when you want to advise a private method of a private inner class.


When I want to advise a private method in a private inner class, like this

public class Outer
{
   private class Inner
   {
      private void myMethod()
   }
}

Using the following poincut:

poincut innerpointcut():execution( * Outer.Inner.myMethod() );

and advice:

before():innerpointcut()
{
   System.out.println( "executing!" );
}

I get a warning "invalidAbsoluteTypeName" next to my pointcut, but next to the advice, there is a marker that points to the private method.</description>
      <comments>
		<comment id="1" date="2006-09-25 09:17:35 EDT" author="Andrew Clement">take a look for 1.5.3</comment>
		<comment id="2" date="2006-09-27 09:58:16 EDT" author="Helen Beeken">This problem is occurring because Outer is in a package. Changing the pointcut expression to include the package ie. pkg.Outer.Inner.myMethod() or moving Outer to the default package does not produce the invalidAbsoluteTypeName warning. 

Also, note that the test programs for bug 67591 and bug 65925 which have previously been fixed also produce the invalidAbsoluteTypeName warning if the classes are in packages.

The reason we're producing the warning is that at this time we're looking at Outer.Inner which we can't find, whereas when we come to match this has become pkg.Outer.Inner which we can find (and is why the marker is there indicating its been advised).</comment>
		<comment id="3" date="2006-10-02 09:34:12 EDT" author="Helen Beeken">The reason we're getting the invalidAbsoluteTypeName is the same as we were getting the warning in bug 67591. That is, due to the visibility checking in org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding.canBeSeenBy(). We find Outer.Inner, however, since this is a private class we check for the privileged modififier on the aspect. This isn't there so we return a ProblemReferenceBinding which ultimately results in the warning being reported. 

The fix for bug 67591 was to check if the type can be found in the world if there's a problem finding it from the current scope. This currently doesn't work in the case of this bug because, as previously mentioned, the class is in a package. When we come to see if the type Outer$Inner is in the world we ask the world's typemap for LOuter$Inner. However, the typemap contains Lpkg/Outer$Inner which doesn't match so we return that we can't find it in the world. A MissingResolvedTypeWithKnownSignature is created and the invalidAbsoluteTypeName warning is the result.</comment>
		<comment id="4" date="2006-10-02 09:37:49 EDT" author="Helen Beeken">The problem is though that when we're resolving the pointcut, the pointcut expression contains "Outer.Inner.myMethod()" which makes no reference to the package...</comment>
		<comment id="5" date="2006-10-03 08:57:44 EDT" author="Helen Beeken">The reason we know about the package when we come to match is that after reporting the warning we record scope.getImportedPrefixes(). In the case of the supplied testcase this includes pkg$A, pkg., java.lang.Object$ and java.lang. The fix is to update lookupTypeInWorld to include a search for the typename prepended with these prefixes.</comment>
		<comment id="6" date="2006-10-03 09:04:39 EDT" author="Helen Beeken">Created attachment 51328 [details]
failing testcases

Apply this patch to the tests project.

This patch contains four scenarios:

1. There is one file containing public aspect and a class. The class contains a private inner class which contains a private method. There should be no warning from the pointcut about not being able to find the type corresponding to the inner class.

2. The class and aspect are in different packages. The class has default visibility and contains a private method. The aspect imports the package containing the class. There should be no warning from the pointcut about not being able to find the class type.

2. The class and aspect are in different packages. The class has default visibility and contains a private method. The aspect does not import the package containing the class. There should be a warning from the pointcut about not being able to find the class type.

4. The class and aspect are are in the same package but different files. The class has default visibility and contains a private method. There should be no warnings saying cant find the class type.</comment>
		<comment id="7" date="2006-10-03 09:06:04 EDT" author="Helen Beeken">Created attachment 51329 [details]
proposed fix

Apply this patch to the weaver project.

This patch contains the proposed fix as described in comment #5.</comment>
		<comment id="8" date="2006-10-03 10:56:46 EDT" author="Andrew Clement">patches in

iplog</comment>
		<comment id="9" date="2006-10-04 03:05:17 EDT" author="Andrew Clement">fixed in latest aj dev builds.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="782ade25e6d68caf361f51a1e040edbd6855842b" author="aclement" date="2006-10-04 12:00:34"/>
          <file name="tests/bugs153/pr156904/inDiffPkgAndImport/Outer.java">
          </file>
          <file name="tests/bugs153/pr156904/inDiffPkgWithoutImport/Outer.java">
          </file>
          <file name="tests/bugs153/pr156904/inSamePkg/Outer.java">
          </file>
          <file name="tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java">
              <method name="testNPEWithCustomAgent_pr158005" returnType="void" parameters=""/>
          </file>
          <file name="weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java">
              <method name="resolveBindingsFromFullyQualifiedTypeName" returnType="TypePattern" parameters="String IScope Bindings boolean boolean"/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="149071" opendate="2006-6-28 15:37:00" fixdate="2006-10-4 3:06:00">
    <buginformation>
      <summary>[itds] Improper visibility of ITD in nested inner type</summary>
      <description>This code fails, but should work:

public aspect AspectItd {
    //private interface Holder {}
    private int Holder.x;
    static aspect Inner {
        int doIt(Holder h) {
            return h.x++;
        }
    }
}

interface Holder{}

C:\devel\scratch\inner&gt;ajc AspectItd.java
C:\devel\scratch\inner\AspectItd.java:6 [error] The field Holder.x is not visibl
e
return h.x++;


1 error

This appears to be incorrectly applying the visibility rules based on the declared type (i.e., a private defined on Holder shouldn't be visible in Inner), whereas of course it should be using the aspect's visibility rule: the field is visible to AspectItd, hence to Inner.

If you make the interface an inner type, then it works properly (i.e., comment out interface Holder and uncomment the line above). By analogy, this Java code also works:

public class Java {
    private int x;
    static class Inner {
        int doIt(Java j) {
            return j.x++;
        }
    }
}</description>
      <comments>
		<comment id="1" date="2006-08-23 09:17:32 EDT" author="Andrew Clement">i know what to do to fix this - but want to confirm its reasonable with Adrian.</comment>
		<comment id="2" date="2006-10-03 09:00:54 EDT" author="Andrew Clement">fix committed</comment>
		<comment id="3" date="2006-10-04 03:06:00 EDT" author="Andrew Clement">fixed in latest aj dev builds.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="2c5ebb90bdac4eaf8dc7e9575ef7f0e3de30be94" author="aclement" date="2006-07-06 05:33:29"/>
          <file name="tests/bugs153/pr149071/AspectItd.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="152366" opendate="2006-7-31 14:44:00" fixdate="2006-10-04 03:05:42">
    <buginformation>
      <summary>LTW Within Patterns Should Accept AND For Consistency</summary>
      <description>The load-time weaving definition system accepts AND in addition to &amp;amp;&amp;amp; for pointcuts, but it silently accepts and then fails to work with type patterns that use AND. Such type patterns are important when creating exceptions (e.g., excluding weblogic..* &amp;amp;&amp;amp; !weblogic.jdbc..*) and using AND is also helpful here.

I've attached a patch to support this and tests to show it's working.</description>
      <comments>
		<comment id="1" date="2006-07-31 14:48:24 EDT" author="Ron Bodkin">Created attachment 47087 [details]
Patch to loadtime module</comment>
		<comment id="2" date="2006-07-31 14:54:38 EDT" author="Ron Bodkin">Created attachment 47088 [details]
Patch to tests module</comment>
		<comment id="3" date="2006-10-03 10:26:40 EDT" author="Andrew Clement">patches in.

iplog</comment>
		<comment id="4" date="2006-10-04 03:05:42 EDT" author="Andrew Clement">fixed in latest aj dev builds.</comment>
		<comment id="5" date="2006-10-06 06:54:00 EDT" author="Helen Beeken">Created attachment 51521 [details]
tests patch to ensure they work on linux

Apply this patch to the tests project.

Currently the three tests for this bug fail on linux. The attached patch fixes this.</comment>
		<comment id="6" date="2006-10-06 07:15:36 EDT" author="Andrew Clement">doh!  ron and his patches...</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="7b831ff7356725b9872a9635d1e0eeb035f2790b" author="aclement" date="2006-10-03 11:30:21"/>
          <file name="loadtime/src/org/aspectj/weaver/loadtime/definition/DocumentParser.java">
              <method name="startElement" returnType="void" parameters="String String String Attributes"/>
          </file>
          <file name="tests/src/org/aspectj/systemtest/ajc150/ltw/LTWTests.java">
              <method name="getSpecFile" returnType="File" parameters=""/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="159896" opendate="2006-10-5 11:44:00" fixdate="2006-10-12 12:37:01">
    <buginformation>
      <summary>advice from injars do not have unique handles with the JDTLikeHandleProvider</summary>
      <description>Advice of the same kind contained in the same aspect currently do not have unique handles if the aspect is on the aspectpath.</description>
      <comments>
		<comment id="1" date="2006-10-06 03:12:11 EDT" author="Helen Beeken">*** Bug 159895 has been marked as a duplicate of this bug. ***</comment>
		<comment id="2" date="2006-10-06 06:39:13 EDT" author="Helen Beeken">Created attachment 51520 [details]
zip containing testcases and proposed patch

The attached zip file contains the following:

1. pr159896-tests.txt - apply to the tests project
2. pr159896-weaver.txt - apply to the weaver project
3. declare.jar - place in tests\features153\jdtlikehandleprovider
4. advice.jar - place in tests\features153\jdtlikehandleprovider
5. jarForAspectPath.jar -  - place in tests\features153\jdtlikehandleprovider

Together these contain the tests and proposed fix for this bug.</comment>
		<comment id="3" date="2006-10-06 12:27:29 EDT" author="Andrew Clement">patches in.  iplog</comment>
		<comment id="4" date="2006-10-12 12:37:01 EDT" author="Andrew Clement">fixes available.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="d532892d89865511ea39286e4ebd34fc20b96a5d" author="aclement" date="2006-10-07 01:29:03"/>
          <file name="tests/features153/jdtlikehandleprovider/ClassForAspectpath.java">
          </file>
          <file name="tests/src/org/aspectj/systemtest/ajc153/JDTLikeHandleProviderTests.java">
              <method name="testIPEsWithSameNameHaveUniqueHandles_set" returnType="void" parameters=""/>
          </file>
          <file name="weaver/src/org/aspectj/weaver/ShadowMunger.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/patterns/DeclareErrorOrWarning.java">
              <method name="DeclareErrorOrWarning" returnType="null" parameters="boolean Pointcut String"/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="158624" opendate="2006-9-25 14:18:00" fixdate="2006-09-29 10:55:48">
    <buginformation>
      <summary>Compiler Error: generics and arrays</summary>
      <description>OK, not sure what to report here or what info you need, but here's the set up, message, and erroreous class.  I don't understand the errors from the compiler enough to parse down the erroneous file to something that contains only the bug, but I could if direction were given.

Here's my set up:
Eclipse SDK
Version: 3.2.0
Build id: M20060629-1905

With AJDT:
Eclipse AspectJ Development Tools
Version: 1.4.1.200608141223
AspectJ version: 1.5.3.200608210848

Here's the bug dump from the compiler inside Eclipse:
java.lang.UnsupportedOperationException
at org.aspectj.weaver.UnresolvedType.parameterize(UnresolvedType.java:221)
at org.aspectj.weaver.ResolvedMemberImpl.parameterize(ResolvedMemberImpl.java:680)
at org.aspectj.weaver.ResolvedMemberImpl.parameterize(ResolvedMemberImpl.java:690)
at org.aspectj.weaver.ResolvedMemberImpl.parameterizedWith(ResolvedMemberImpl.java:643)
at org.aspectj.weaver.ResolvedMemberImpl.parameterizedWith(ResolvedMemberImpl.java:597)
at org.aspectj.weaver.ReferenceType.getDeclaredMethods(ReferenceType.java:508)
at org.aspectj.weaver.ResolvedType$4.get(ResolvedType.java:226)
at org.aspectj.weaver.Iterators$3$1.hasNext(Iterators.java:118)
at org.aspectj.weaver.Iterators$5.hasNext(Iterators.java:171)
at org.aspectj.weaver.Iterators$3.hasNext(Iterators.java:128)
at org.aspectj.weaver.ResolvedType.lookupMember(ResolvedType.java:346)
at org.aspectj.weaver.ResolvedType.lookupMethod(ResolvedType.java:327)
at org.aspectj.weaver.World.resolve(World.java:523)
at org.aspectj.weaver.MemberImpl.resolve(MemberImpl.java:93)
at org.aspectj.weaver.JoinPointSignatureIterator.addSignaturesUpToFirstDefiningMember(JoinPointSignatureIterator.java:109)
at org.aspectj.weaver.JoinPointSignatureIterator.&lt;init&gt;(JoinPointSignatureIterator.java:51)
at org.aspectj.weaver.MemberImpl.getJoinPointSignatures(MemberImpl.java:943)
at org.aspectj.weaver.patterns.SignaturePattern.matches(SignaturePattern.java:286)
at org.aspectj.weaver.patterns.KindedPointcut.matchInternal(KindedPointcut.java:106)
at org.aspectj.weaver.patterns.Pointcut.match(Pointcut.java:146)
at org.aspectj.weaver.patterns.AndPointcut.matchInternal(AndPointcut.java:51)
at org.aspectj.weaver.patterns.Pointcut.match(Pointcut.java:146)
at org.aspectj.weaver.ShadowMunger.match(ShadowMunger.java:75)
at org.aspectj.weaver.Advice.match(Advice.java:112)
at org.aspectj.weaver.bcel.BcelAdvice.match(BcelAdvice.java:117)
at org.aspectj.weaver.bcel.BcelClassWeaver.match(BcelClassWeaver.java:2806)
at org.aspectj.weaver.bcel.BcelClassWeaver.matchInvokeInstruction(BcelClassWeaver.java:2768)
at org.aspectj.weaver.bcel.BcelClassWeaver.match(BcelClassWeaver.java:2506)
at org.aspectj.weaver.bcel.BcelClassWeaver.match(BcelClassWeaver.java:2332)
at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:494)
at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:119)
at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1606)
at org.aspectj.weaver.bcel.BcelWeaver.weaveWithoutDump(BcelWeaver.java:1557)
at org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify(BcelWeaver.java:1335)
at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1155)
at org.aspectj.ajdt.internal.compiler.AjPipeliningCompilerAdapter.weaveQueuedEntries(AjPipeliningCompilerAdapter.java:455)
at org.aspectj.ajdt.internal.compiler.AjPipeliningCompilerAdapter.queueForWeaving(AjPipeliningCompilerAdapter.java:392)
at org.aspectj.ajdt.internal.compiler.AjPipeliningCompilerAdapter.afterProcessing(AjPipeliningCompilerAdapter.java:380)
at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$after$org_aspectj_ajdt_internal_compiler_CompilerAdapter$5$6b855184(CompilerAdapter.aj:98)
at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:533)
at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:329)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:892)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:246)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:165)
at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:122)
at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)

trouble in: 
public class com.wec.lib.util.test.SyncValueTest extends junit.framework.TestCase:
  private com.wec.lib.util.test.SyncValueTest$SyncInteger a
  private com.wec.lib.util.test.SyncValueTest$SyncInteger b
  private com.wec.lib.util.test.SyncValueTest$SyncInteger c
  private com.wec.lib.util.test.SyncValueTest$SyncInteger d
  private com.wec.lib.util.test.SyncValueTest$SyncInteger e
  public void &lt;init&gt;():
                    ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this   (line 17)
                    INVOKESPECIAL junit.framework.TestCase.&lt;init&gt; ()V
    constructor-execution(void com.wec.lib.util.test.SyncValueTest.&lt;init&gt;())
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this   (line 27)
    |               NEW com.wec.lib.util.test.SyncValueTest$SyncInteger
    |               DUP
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this
    |               ICONST_1
    |               INVOKESPECIAL com.wec.lib.util.test.SyncValueTest$SyncInteger.&lt;init&gt; (Lcom/wec/lib/util/test/SyncValueTest;I)V
    |               PUTFIELD com.wec.lib.util.test.SyncValueTest.a Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this   (line 28)
    |               NEW com.wec.lib.util.test.SyncValueTest$SyncInteger
    |               DUP
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this
    |               ICONST_2
    |               INVOKESPECIAL com.wec.lib.util.test.SyncValueTest$SyncInteger.&lt;init&gt; (Lcom/wec/lib/util/test/SyncValueTest;I)V
    |               PUTFIELD com.wec.lib.util.test.SyncValueTest.b Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this   (line 29)
    |               NEW com.wec.lib.util.test.SyncValueTest$SyncInteger
    |               DUP
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this
    |               ICONST_3
    |               INVOKESPECIAL com.wec.lib.util.test.SyncValueTest$SyncInteger.&lt;init&gt; (Lcom/wec/lib/util/test/SyncValueTest;I)V
    |               PUTFIELD com.wec.lib.util.test.SyncValueTest.c Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this   (line 30)
    |               NEW com.wec.lib.util.test.SyncValueTest$SyncInteger
    |               DUP
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this
    |               ICONST_4
    |               INVOKESPECIAL com.wec.lib.util.test.SyncValueTest$SyncInteger.&lt;init&gt; (Lcom/wec/lib/util/test/SyncValueTest;I)V
    |               PUTFIELD com.wec.lib.util.test.SyncValueTest.d Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this   (line 31)
    |               NEW com.wec.lib.util.test.SyncValueTest$SyncInteger
    |               DUP
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this
    |               ICONST_5
    |               INVOKESPECIAL com.wec.lib.util.test.SyncValueTest$SyncInteger.&lt;init&gt; (Lcom/wec/lib/util/test/SyncValueTest;I)V
    |               PUTFIELD com.wec.lib.util.test.SyncValueTest.e Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               RETURN   (line 17)
    constructor-execution(void com.wec.lib.util.test.SyncValueTest.&lt;init&gt;())
  end public void &lt;init&gt;()

  public void testSyncValueGroup()    org.aspectj.weaver.MethodDeclarationLineNumber: 39:1035
:
    method-execution(void com.wec.lib.util.test.SyncValueTest.testSyncValueGroup())
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this   (line 42)
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.a Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               ICONST_1
    |               ANEWARRAY com.wec.lib.util.SyncValueGroup
    |               DUP
    |               ICONST_0
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.b Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               AASTORE
    | method-call(void com.wec.lib.util.test.SyncValueTest$SyncInteger.link(com.wec.lib.util.SyncValueGroup[]))
    | |             INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.link ([Lcom/wec/lib/util/SyncValueGroup;)V
    | method-call(void com.wec.lib.util.test.SyncValueTest$SyncInteger.link(com.wec.lib.util.SyncValueGroup[]))
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this   (line 43)
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.a Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object;
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.b Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object;
    |               IF_ACMPNE L0
    |               ICONST_1
    |               GOTO L1
    |           L0: ICONST_0
    |           L1: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V
    |               ICONST_1   (line 44)
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.b Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object;
    |               CHECKCAST java.lang.Integer
    |               INVOKEVIRTUAL java.lang.Integer.intValue ()I
    |               IF_ICMPNE L2
    |               ICONST_1
    |               GOTO L3
    |           L2: ICONST_0
    |           L3: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this   (line 45)
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.b Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               ICONST_2
    |               INVOKESTATIC java.lang.Integer.valueOf (I)Ljava/lang/Integer;
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.setValue (Ljava/lang/Object;)V
    |               ICONST_2   (line 46)
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.a Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object;
    |               CHECKCAST java.lang.Integer
    |               INVOKEVIRTUAL java.lang.Integer.intValue ()I
    |               IF_ICMPNE L4
    |               ICONST_1
    |               GOTO L5
    |           L4: ICONST_0
    |           L5: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this   (line 47)
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.b Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               ICONST_1
    |               ANEWARRAY com.wec.lib.util.SyncValueGroup
    |               DUP
    |               ICONST_0
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.c Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               AASTORE
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.link ([Lcom/wec/lib/util/SyncValueGroup;)V
    |               ICONST_2   (line 48)
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.c Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object;
    |               CHECKCAST java.lang.Integer
    |               INVOKEVIRTUAL java.lang.Integer.intValue ()I
    |               IF_ICMPNE L6
    |               ICONST_1
    |               GOTO L7
    |           L6: ICONST_0
    |           L7: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this   (line 49)
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.c Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               ICONST_3
    |               INVOKESTATIC java.lang.Integer.valueOf (I)Ljava/lang/Integer;
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.setValue (Ljava/lang/Object;)V
    |               ICONST_3   (line 50)
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.a Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object;
    |               CHECKCAST java.lang.Integer
    |               INVOKEVIRTUAL java.lang.Integer.intValue ()I
    |               IF_ICMPNE L8
    |               ICONST_1
    |               GOTO L9
    |           L8: ICONST_0
    |           L9: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V
    |               ICONST_3   (line 51)
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.b Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object;
    |               CHECKCAST java.lang.Integer
    |               INVOKEVIRTUAL java.lang.Integer.intValue ()I
    |               IF_ICMPNE L10
    |               ICONST_1
    |               GOTO L11
    |          L10: ICONST_0
    |          L11: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this   (line 52)
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.a Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               ICONST_4
    |               INVOKESTATIC java.lang.Integer.valueOf (I)Ljava/lang/Integer;
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.setValue (Ljava/lang/Object;)V
    |               ICONST_4   (line 53)
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.c Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object;
    |               CHECKCAST java.lang.Integer
    |               INVOKEVIRTUAL java.lang.Integer.intValue ()I
    |               IF_ICMPNE L12
    |               ICONST_1
    |               GOTO L13
    |          L12: ICONST_0
    |          L13: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V
    |               ICONST_4   (line 54)
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.b Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object;
    |               CHECKCAST java.lang.Integer
    |               INVOKEVIRTUAL java.lang.Integer.intValue ()I
    |               IF_ICMPNE L14
    |               ICONST_1
    |               GOTO L15
    |          L14: ICONST_0
    |          L15: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this   (line 55)
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.b Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               ICONST_1
    |               INVOKESTATIC java.lang.Integer.valueOf (I)Ljava/lang/Integer;
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.setValue (Ljava/lang/Object;)V
    |               ICONST_1   (line 56)
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.c Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object;
    |               CHECKCAST java.lang.Integer
    |               INVOKEVIRTUAL java.lang.Integer.intValue ()I
    |               IF_ICMPNE L16
    |               ICONST_1
    |               GOTO L17
    |          L16: ICONST_0
    |          L17: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V
    |               ICONST_1   (line 57)
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.a Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object;
    |               CHECKCAST java.lang.Integer
    |               INVOKEVIRTUAL java.lang.Integer.intValue ()I
    |               IF_ICMPNE L18
    |               ICONST_1
    |               GOTO L19
    |          L18: ICONST_0
    |          L19: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this   (line 59)
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.d Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               ICONST_1
    |               ANEWARRAY com.wec.lib.util.SyncValueGroup
    |               DUP
    |               ICONST_0
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.e Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               AASTORE
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.link ([Lcom/wec/lib/util/SyncValueGroup;)V
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this   (line 60)
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.d Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object;
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.e Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object;
    |               IF_ACMPNE L20
    |               ICONST_1
    |               GOTO L21
    |          L20: ICONST_0
    |          L21: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this   (line 63)
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.b Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               ICONST_1
    |               ANEWARRAY com.wec.lib.util.SyncValueGroup
    |               DUP
    |               ICONST_0
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.d Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               AASTORE
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.link ([Lcom/wec/lib/util/SyncValueGroup;)V
    |               ICONST_1   (line 64)
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.d Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object;
    |               CHECKCAST java.lang.Integer
    |               INVOKEVIRTUAL java.lang.Integer.intValue ()I
    |               IF_ICMPNE L22
    |               ICONST_1
    |               GOTO L23
    |          L22: ICONST_0
    |          L23: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V
    |               ICONST_1   (line 65)
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.e Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object;
    |               CHECKCAST java.lang.Integer
    |               INVOKEVIRTUAL java.lang.Integer.intValue ()I
    |               IF_ICMPNE L24
    |               ICONST_1
    |               GOTO L25
    |          L24: ICONST_0
    |          L25: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this   (line 66)
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.d Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               BIPUSH 8
    |               INVOKESTATIC java.lang.Integer.valueOf (I)Ljava/lang/Integer;
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.setValue (Ljava/lang/Object;)V
    |               BIPUSH 8   (line 67)
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.a Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object;
    |               CHECKCAST java.lang.Integer
    |               INVOKEVIRTUAL java.lang.Integer.intValue ()I
    |               IF_ICMPNE L26
    |               ICONST_1
    |               GOTO L27
    |          L26: ICONST_0
    |          L27: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V
    |               BIPUSH 8   (line 68)
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.b Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object;
    |               CHECKCAST java.lang.Integer
    |               INVOKEVIRTUAL java.lang.Integer.intValue ()I
    |               IF_ICMPNE L28
    |               ICONST_1
    |               GOTO L29
    |          L28: ICONST_0
    |          L29: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V
    |               BIPUSH 8   (line 69)
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.c Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object;
    |               CHECKCAST java.lang.Integer
    |               INVOKEVIRTUAL java.lang.Integer.intValue ()I
    |               IF_ICMPNE L30
    |               ICONST_1
    |               GOTO L31
    |          L30: ICONST_0
    |          L31: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V
    |               BIPUSH 8   (line 70)
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.d Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object;
    |               CHECKCAST java.lang.Integer
    |               INVOKEVIRTUAL java.lang.Integer.intValue ()I
    |               IF_ICMPNE L32
    |               ICONST_1
    |               GOTO L33
    |          L32: ICONST_0
    |          L33: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V
    |               BIPUSH 8   (line 71)
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.e Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object;
    |               CHECKCAST java.lang.Integer
    |               INVOKEVIRTUAL java.lang.Integer.intValue ()I
    |               IF_ICMPNE L34
    |               ICONST_1
    |               GOTO L35
    |          L34: ICONST_0
    |          L35: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this   (line 74)
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.c Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.unlink ()V
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this   (line 75)
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.c Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               ICONST_3
    |               INVOKESTATIC java.lang.Integer.valueOf (I)Ljava/lang/Integer;
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.setValue (Ljava/lang/Object;)V
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this   (line 76)
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.b Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               ICONST_2
    |               INVOKESTATIC java.lang.Integer.valueOf (I)Ljava/lang/Integer;
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.setValue (Ljava/lang/Object;)V
    |               ICONST_2   (line 77)
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.a Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object;
    |               CHECKCAST java.lang.Integer
    |               INVOKEVIRTUAL java.lang.Integer.intValue ()I
    |               IF_ICMPNE L36
    |               ICONST_1
    |               GOTO L37
    |          L36: ICONST_0
    |          L37: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V
    |               ICONST_2   (line 78)
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.b Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object;
    |               CHECKCAST java.lang.Integer
    |               INVOKEVIRTUAL java.lang.Integer.intValue ()I
    |               IF_ICMPNE L38
    |               ICONST_1
    |               GOTO L39
    |          L38: ICONST_0
    |          L39: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V
    |               ICONST_3   (line 79)
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.c Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object;
    |               CHECKCAST java.lang.Integer
    |               INVOKEVIRTUAL java.lang.Integer.intValue ()I
    |               IF_ICMPNE L40
    |               ICONST_1
    |               GOTO L41
    |          L40: ICONST_0
    |          L41: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V
    |               ICONST_2   (line 80)
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.d Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object;
    |               CHECKCAST java.lang.Integer
    |               INVOKEVIRTUAL java.lang.Integer.intValue ()I
    |               IF_ICMPNE L42
    |               ICONST_1
    |               GOTO L43
    |          L42: ICONST_0
    |          L43: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V
    |               ICONST_2   (line 81)
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.e Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object;
    |               CHECKCAST java.lang.Integer
    |               INVOKEVIRTUAL java.lang.Integer.intValue ()I
    |               IF_ICMPNE L44
    |               ICONST_1
    |               GOTO L45
    |          L44: ICONST_0
    |          L45: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this   (line 82)
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.d Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.unlink ()V
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this   (line 83)
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.c Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               ICONST_1
    |               ANEWARRAY com.wec.lib.util.SyncValueGroup
    |               DUP
    |               ICONST_0
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.d Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               AASTORE
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.link ([Lcom/wec/lib/util/SyncValueGroup;)V
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this   (line 84)
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.a Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               ICONST_1
    |               INVOKESTATIC java.lang.Integer.valueOf (I)Ljava/lang/Integer;
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.setValue (Ljava/lang/Object;)V
    |               ICONST_1   (line 85)
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.a Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object;
    |               CHECKCAST java.lang.Integer
    |               INVOKEVIRTUAL java.lang.Integer.intValue ()I
    |               IF_ICMPNE L46
    |               ICONST_1
    |               GOTO L47
    |          L46: ICONST_0
    |          L47: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V
    |               ICONST_1   (line 86)
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.b Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object;
    |               CHECKCAST java.lang.Integer
    |               INVOKEVIRTUAL java.lang.Integer.intValue ()I
    |               IF_ICMPNE L48
    |               ICONST_1
    |               GOTO L49
    |          L48: ICONST_0
    |          L49: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V
    |               ICONST_3   (line 87)
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.c Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object;
    |               CHECKCAST java.lang.Integer
    |               INVOKEVIRTUAL java.lang.Integer.intValue ()I
    |               IF_ICMPNE L50
    |               ICONST_1
    |               GOTO L51
    |          L50: ICONST_0
    |          L51: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V
    |               ICONST_3   (line 88)
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.d Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object;
    |               CHECKCAST java.lang.Integer
    |               INVOKEVIRTUAL java.lang.Integer.intValue ()I
    |               IF_ICMPNE L52
    |               ICONST_1
    |               GOTO L53
    |          L52: ICONST_0
    |          L53: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V
    |               ICONST_1   (line 89)
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.e Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object;
    |               CHECKCAST java.lang.Integer
    |               INVOKEVIRTUAL java.lang.Integer.intValue ()I
    |               IF_ICMPNE L54
    |               ICONST_1
    |               GOTO L55
    |          L54: ICONST_0
    |          L55: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V
    |               RETURN   (line 90)
    method-execution(void com.wec.lib.util.test.SyncValueTest.testSyncValueGroup())
  end public void testSyncValueGroup()

end public class com.wec.lib.util.test.SyncValueTest

when weaving classes 
when weaving 
when batch building BuildConfig[D:\workspace\.metadata\.plugins\org.eclipse.ajdt.core\ANSER2.generated.lst] #Files=365

Here's the class:
package com.wec.lib.util.test;

import static com.wec.ide.Constants.UNCHECKED;
import junit.framework.TestCase;

import org.junit.Test;

import com.wec.lib.util.SyncValueGroup;
import com.wec.scrum.Tests;

/**
 * This class tests the SyncValueGroup utility class.
 */
@Tests(classes = {
        SyncValueGroup.class })
@SuppressWarnings("nls")
public class SyncValueTest extends TestCase {

    class SyncInteger extends SyncValueGroup&lt;Integer&gt; {
        public SyncInteger(int val) {
            super(new Integer(val));
        }
        public void valueChanged() {
        }
    }
    
    private SyncInteger a = new SyncInteger(1);
    private SyncInteger b = new SyncInteger(2);
    private SyncInteger c = new SyncInteger(3);
    private SyncInteger d = new SyncInteger(4);
    private SyncInteger e = new SyncInteger(5);    
    
    /**
     * Ensures that SyncValueGroup replicates values and
     * calls valueChange.
     */
    @SuppressWarnings(UNCHECKED)
    @Test
    public void testSyncValueGroup() {
        
        //  Link tests
        a.link(b);
        assertTrue(a.getValue() == b.getValue());
        assertTrue(1 == b.getValue());
        b.setValue(2);
        assertTrue(2 == a.getValue());
        b.link(c);
        assertTrue(2 == c.getValue());
        c.setValue(3);
        assertTrue(3 == a.getValue());
        assertTrue(3 == b.getValue());
        a.setValue(4);
        assertTrue(4 == c.getValue());
        assertTrue(4 == b.getValue());
        b.setValue(1);
        assertTrue(1 == c.getValue());
        assertTrue(1 == a.getValue());
        
        d.link(e);
        assertTrue(d.getValue() == e.getValue());
        
        //  Join loops
        b.link(d);
        assertTrue(1 == d.getValue());
        assertTrue(1 == e.getValue());
        d.setValue(8);
        assertTrue(8 == a.getValue());
        assertTrue(8 == b.getValue());
        assertTrue(8 == c.getValue());
        assertTrue(8 == d.getValue());
        assertTrue(8 == e.getValue());
        
        //  Unlink tests
        c.unlink();
        c.setValue(3);
        b.setValue(2);
        assertTrue(2 == a.getValue());
        assertTrue(2 == b.getValue());
        assertTrue(3 == c.getValue());
        assertTrue(2 == d.getValue());
        assertTrue(2 == e.getValue());
        d.unlink();
        c.link(d);
        a.setValue(1);
        assertTrue(1 == a.getValue());
        assertTrue(1 == b.getValue());
        assertTrue(3 == c.getValue());
        assertTrue(3 == d.getValue());
        assertTrue(1 == e.getValue());
    }
}</description>
      <comments>
		<comment id="1" date="2006-09-28 06:00:09 EDT" author="Andrew Clement">this problem is to do with generics and arrays.

But I can't see any array signatures in the junit testcase stuff.  Can you tell me if any methods in SyncValueGroup involve arrays as a return value or parameters?</comment>
		<comment id="2" date="2006-09-28 06:01:06 EDT" author="Andrew Clement">would like to fix for 1.5.3</comment>
		<comment id="3" date="2006-09-28 08:45:41 EDT" author="Karl Schaefer">Created attachment 51080 [details]
The SyncValueGroup class that the unit test is testing.</comment>
		<comment id="4" date="2006-09-28 08:46:47 EDT" author="Karl Schaefer">Comment on attachment 51080 [details]
The SyncValueGroup class that the unit test is testing.

The method link supports varargs.</comment>
		<comment id="5" date="2006-09-28 09:32:49 EDT" author="Andrew Clement">I thought you might be on to something with that link() method but I still can't get it to fail.  I see SyncValueGroup extends ValueChange - could you possibly attach that?  (I hope that is the top of the hierarchy...)

May I ask what kinds of pointcut you are using?  I'm trying within() so that I advise everything, but I just can't trigger this failure :(</comment>
		<comment id="6" date="2006-09-28 10:13:58 EDT" author="Karl Schaefer">Created attachment 51087 [details]
The ValueChange class required by SyncValueGroup.

Here's the other file you requested.

As for pointcuts, I have an abstract Aspect that pretty much cuts everything  (except for its own package) and some concrete sub-Aspects that narrow the focus.  It's basically some tracing code.  I could add those aspects as well.

Also, I am only using the Eclipse AJDT to compile this.  Perhaps this is an AJDT issue?

Thanks for the fast response.</comment>
		<comment id="7" date="2006-09-28 10:15:35 EDT" author="Karl Schaefer">Created attachment 51088 [details]
The abstract tracing class.

Here's the abstract tracing class that defines my pointcuts.</comment>
		<comment id="8" date="2006-09-28 10:54:39 EDT" author="Andrew Clement">It is worth you upgrading to a more recent AJDT - I have made a couple of changes in the compiler that could possibly be related.  However - using what you sent me (thanks!) I have recreated a failure, just not sure at the moment that it is the same problem you are seeing (I've got some different pointcuts to you).  My stack trace is:

unable to parameterize unresolved type: PSyncValueGroup&lt;TT;&gt;;
java.lang.UnsupportedOperationException: unable to parameterize unresolved type: PSyncValueGroup&lt;TT;&gt;;
 at org.aspectj.weaver.UnresolvedType.parameterize(UnresolvedType.java:221)
 at org.aspectj.weaver.ResolvedMemberImpl.parameterize(ResolvedMemberImpl.java:681)
 at org.aspectj.weaver.ResolvedMemberImpl.parameterize(ResolvedMemberImpl.java:692)
 at org.aspectj.weaver.ResolvedMemberImpl.parameterizedWith(ResolvedMemberImpl.java:645)
 at org.aspectj.weaver.ResolvedMemberImpl.parameterizedWith(ResolvedMemberImpl.java:597)
 at org.aspectj.weaver.ReferenceType.getDeclaredMethods(ReferenceType.java:513)
 at org.aspectj.weaver.ResolvedType$4.get(ResolvedType.java:226)
 at org.aspectj.weaver.Iterators$4$1.hasNext(Iterators.java:118)
 at org.aspectj.weaver.Iterators$6.hasNext(Iterators.java:171)
 at org.aspectj.weaver.Iterators$4.hasNext(Iterators.java:128)
 at org.aspectj.weaver.ResolvedType.lookupMember(ResolvedType.java:346)
 at org.aspectj.weaver.ResolvedType.lookupMethod(ResolvedType.java:327)
 at org.aspectj.weaver.World.resolve(World.java:523)
 at org.aspectj.weaver.MemberImpl.resolve(MemberImpl.java:93)
 at org.aspectj.weaver.JoinPointSignatureIterator.addSignaturesUpToFirstDefiningMember(JoinPointSignatureIterator.java:109)
 at org.aspectj.weaver.JoinPointSignatureIterator.&lt;init&gt;(JoinPointSignatureIterator.java:51)
 at org.aspectj.weaver.MemberImpl.getJoinPointSignatures(MemberImpl.java:943)
 at org.aspectj.weaver.patterns.SignaturePattern.matches(SignaturePattern.java:286)
 at org.aspectj.weaver.patterns.KindedPointcut.matchInternal(KindedPointcut.java:106)
 at org.aspectj.weaver.patterns.Pointcut.match(Pointcut.java:146)
 at org.aspectj.weaver.patterns.AndPointcut.matchInternal(AndPointcut.java:51)
 at org.aspectj.weaver.patterns.Pointcut.match(Pointcut.java:146)
 at org.aspectj.weaver.ShadowMunger.match(ShadowMunger.java:75)
 at org.aspectj.weaver.Advice.match(Advice.java:112)
 at org.aspectj.weaver.bcel.BcelAdvice.match(BcelAdvice.java:118)
 at org.aspectj.weaver.bcel.BcelClassWeaver.match(BcelClassWeaver.java:2806)
 at org.aspectj.weaver.bcel.BcelClassWeaver.matchInvokeInstruction(BcelClassWeaver.java:2768)
 at org.aspectj.weaver.bcel.BcelClassWeaver.match(BcelClassWeaver.java:2506)
 at org.aspectj.weaver.bcel.BcelClassWeaver.match(BcelClassWeaver.java:2332)
 at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:494)
 at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:119)
 at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1611)
 at org.aspectj.weaver.bcel.BcelWeaver.weaveWithoutDump(BcelWeaver.java:1562)
 at org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify(BcelWeaver.java:1340)
 at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1160)
 at org.aspectj.ajdt.internal.compiler.AjPipeliningCompilerAdapter.weaveQueuedEntries(AjPipeliningCompilerAdapter.java:455)
 at org.aspectj.ajdt.internal.compiler.AjPipeliningCompilerAdapter.queueForWeaving(AjPipeliningCompilerAdapter.java:392)
 at org.aspectj.ajdt.internal.compiler.AjPipeliningCompilerAdapter.afterProcessing(AjPipeliningCompilerAdapter.java:380)
 at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$after$org_aspectj_ajdt_internal_compiler_CompilerAdapter$5$6b855184(CompilerAdapter.aj:98)
 at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:533)
 at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:329)
 at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:908)
 at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:260)
 at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:176)
 at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:114)
 at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:60)
 at org.aspectj.tools.ajc.Main.run(Main.java:378)
 at org.aspectj.tools.ajc.Main.runMain(Main.java:253)
 at org.aspectj.tools.ajc.Main.main(Main.java:88)</comment>
		<comment id="9" date="2006-09-28 14:48:47 EDT" author="Karl Schaefer">I have upgraded my Eclipse 3.2 instance to:
Version: 1.4.1.200608141223
AspectJ version: 1.5.3.200609271036

I receive the following error message now (it seems to provide less information than before):
java.lang.UnsupportedOperationException
at org.aspectj.weaver.UnresolvedType.parameterize(UnresolvedType.java:221)
at org.aspectj.weaver.ResolvedMemberImpl.parameterize(ResolvedMemberImpl.java:680)
at org.aspectj.weaver.ResolvedMemberImpl.parameterize(ResolvedMemberImpl.java:690)
at org.aspectj.weaver.ResolvedMemberImpl.parameterizedWith(ResolvedMemberImpl.java:643)
at org.aspectj.weaver.ResolvedMemberImpl.parameterizedWith(ResolvedMemb ... weaving classes 
when weaving 
when batch building BuildConfig[D:\workspace\.metadata\.plugins\org.eclipse.ajdt.core\ANSER2.generated.lst] #Files=401

Here's the line it's dropping in the Problems view.  It seems to have more data:
Severity and Description Path Resource Location Creation Time Id
Internal compiler error
java.lang.UnsupportedOperationException: unable to parameterize unresolved type: Pcom/wec/lib/util/SyncValueGroup&lt;TT;&gt;;
 at org.aspectj.weaver.UnresolvedType.parameterize(UnresolvedType.java:221)
 at org.aspectj.weaver.ResolvedMemberImpl.parameterize(ResolvedMemberImpl.java:680)
 at org.aspectj.weaver.ResolvedMemberImpl.parameterize(ResolvedMemberImpl.java:690)
 at org.aspectj.weaver.ResolvedMemberImpl.parameterizedWith(ResolvedMemberImpl.java:643)
 at org.aspectj.weaver.ResolvedMemberImpl.parameterizedWith(ResolvedMemberImpl.java:597)
 at org.aspectj.weaver.ReferenceType.getDeclaredMethods(ReferenceType.java:512)
 at org.aspectj.weaver.ResolvedType$4.get(ResolvedType.java:226)
 at org.aspectj.weaver.Iterators$3$1.hasNext(Iterators.java:118)
 at org.aspectj.weaver.Iterators$5.hasNext(Iterators.java:171)
 at org.aspectj.weaver.Iterators$3.hasNext(Iterators.java:128)
 at org.aspectj.weaver.ResolvedType.lookupMember(ResolvedType.java:346)
 at org.aspectj.weaver.ResolvedType.lookupMethod(ResolvedType.java:327)
 at org.aspectj.weaver.World.resolve(World.java:523)
 at org.aspectj.weaver.MemberImpl.resolve(MemberImpl.java:93)
 at org.aspectj.weaver.JoinPointSignatureIterator.addSignaturesUpToFirstDefiningMember(JoinPointSignatureIterator.java:109)
 at org.aspectj.weaver.JoinPointSignatureIterator.&lt;init&gt;(JoinPointSignatureIterator.java:51)
 at org.aspectj.weaver.MemberImpl.getJoinPointSignatures(MemberImpl.java:943)
 at org.aspectj.weaver.patterns.SignaturePattern.matches(SignaturePattern.java:286)
 at org.aspectj.weaver.patterns.KindedPointcut.matchInternal(KindedPointcut.java:106)
 at org.aspectj.weaver.patterns.Pointcut.match(Pointcut.java:146)
 at org.aspectj.weaver.patterns.AndPointcut.matchInternal(AndPointcut.java:51)
 at org.aspectj.weaver.patterns.Pointcut.match(Pointcut.java:146)
 at org.aspectj.weaver.ShadowMunger.match(ShadowMunger.java:75)
 at org.aspectj.weaver.Advice.match(Advice.java:112)
 at org.aspectj.weaver.bcel.BcelAdvice.match(BcelAdvice.java:117)
 at org.aspectj.weaver.bcel.BcelClassWeaver.match(BcelClassWeaver.java:2806)
 at org.aspectj.weaver.bcel.BcelClassWeaver.matchInvokeInstruction(BcelClassWeaver.java:2768)
 at org.aspectj.weaver.bcel.BcelClassWeaver.match(BcelClassWeaver.java:2506)
 at org.aspectj.weaver.bcel.BcelClassWeaver.match(BcelClassWeaver.java:2332)
 at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:494)
 at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:119)
 at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1611)
 at org.aspectj.weaver.bcel.BcelWeaver.weaveWithoutDump(BcelWeaver.java:1562)
 at org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify(BcelWeaver.java:1340)
 at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1160)
 at org.aspectj.ajdt.internal.compiler.AjPipeliningCompilerAdapter.weaveQueuedEntries(AjPipeliningCompilerAdapter.java:455)
 at org.aspectj.ajdt.internal.compiler.AjPipeliningCompilerAdapter.queueForWeaving(AjPipeliningCompilerAdapter.java:392)
 at org.aspectj.ajdt.internal.compiler.AjPipeliningCompilerAdapter.afterProcessing(AjPipeliningCompilerAdapter.java:380)
 at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$after$org_aspectj_ajdt_internal_compiler_CompilerAdapter$5$6b855184(CompilerAdapter.aj:98)
 at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:533)
 at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:329)
 at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:908)
 at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:260)
 at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:176)
 at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:107)
 at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)
 ANSER2/src/com/wec/lib/util/test SyncValueTest.java Unknown 1159469462177 1263176</comment>
		<comment id="10" date="2006-09-28 14:52:50 EDT" author="Karl Schaefer">It seems to me that we are now both generally receiving the same error message.</comment>
		<comment id="11" date="2006-09-29 04:34:22 EDT" author="Andrew Clement">thanks for responding to me so quickly on this problem.  Here is a minimal test program that I'm using, which fails in the same way:
abstract class ValueChange&lt;Q&gt; {
    public ValueChange(Q initValue) { }
}

abstract class SyncValueGroup&lt;T&gt; extends ValueChange&lt;T&gt; {
 public SyncValueGroup(T initValue) {
        super(initValue);
    }
    public final synchronized void link(SyncValueGroup&lt;T&gt; ... list) {    }
}

class SyncValueTest {
    class SyncInteger extends SyncValueGroup&lt;Integer&gt; {
        public SyncInteger(int val) {
            super(new Integer(val));
        }
    }
    private SyncInteger a = new SyncInteger(1);
    public void testSyncValueGroup() {
        a.link(a);
    }
}

aspect X {
  before(): call(* *(..)) {}
}


As I first suspected, it is an array signature, and it was the link() method as you thought: "link(SyncValueGroup&lt;T&gt; ... list)" - after picking the array signature apart we fail to resolved the resulting parameterized type correctly (SyncValueGroup being paramterized by the type variable T).  I've now testing the fix.</comment>
		<comment id="12" date="2006-09-29 08:16:50 EDT" author="Andrew Clement">test and fix committed - will be in a dev build shortly.</comment>
		<comment id="13" date="2006-09-29 10:55:48 EDT" author="Andrew Clement">fix is in latest AJ dev build - will probably make it into AJDT in a few days.</comment>
		<comment id="14" date="2006-10-16 08:35:35 EDT" author="Karl Schaefer">(In reply to comment #13)
&gt; fix is in latest AJ dev build - will probably make it into AJDT in a few days.

Submitter confirming fix.

I downloaded the AJDT:
Eclipse AspectJ Development Tools

Version: 1.4.1.200610100440
AspectJ version: 1.5.3.200610091525

Everything is working.  Thank you.</comment>
		<comment id="15" date="2006-10-16 08:40:47 EDT" author="Andrew Clement">thanks for confirming its fixed.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="ea4ff8adad2347557c25d6e10e114132b7491870" author="aclement" date="2006-09-29 09:20:31"/>
          <file name="tests/bugs153/pr158624/ValueChange.java">
          </file>
          <file name="tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/ResolvedMemberImpl.java">
              <method name="parameterizedWith" returnType="ResolvedMemberImpl" parameters="UnresolvedType[] ResolvedType boolean List"/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="123423" opendate="2006-1-11 9:08:00" fixdate="2006-10-18 10:42:34">
    <buginformation>
      <summary>RFE: Expose withinType for pertypewithin aspects</summary>
      <description>Per type within aspects have a generated field ajc$withinType. Almost any time I ever use one of them, I'd like to access this field. Sometimes, e.g., for deferred initialization, I have to create a duplicate field that initializes this as such:

    private Class managedClass;
    after() returning: staticinitialization(*) {
        managedClass = thisJoinPointStaticPart.getSignature().getDeclaringType();
...

It would be nice if there were a method with the signature 
Class getWithinType() defined on any pertypewithin aspect.</description>
      <comments>
		<comment id="1" date="2006-01-11 09:40:34 EST" author="Andrew Clement">the field was created for this purpose (no-one currently ever reads it) - i just never completed that bit of the impl as we were still evaluating how people use ptw.  I'll take a look at it for 1.5.1</comment>
		<comment id="2" date="2006-06-27 10:42:39 EDT" author="Andrew Clement">slippy slip</comment>
		<comment id="3" date="2006-10-17 06:24:50 EDT" author="Andrew Clement">the current field that exists in pertypewithin aspects for this purpose 'ajc$withinType' is actually a string.  I'm sure there is a good reason why I made it a string rather than a class - relating to something about initialization complexities (I *think*)  So the question is would 'String getWithinType()' be sufficient - what do most people do with the Class they might get back from 'Class getWithinType()', is it just call 'getName()' ...</comment>
		<comment id="4" date="2006-10-17 12:15:17 EDT" author="Ron Bodkin">Getting the name of the class is certainly useful for logging (I checked and that's actually what my LogManagement aspects needs). It's also possible you might want to get access to the class *efficiently*, but if you aren't getting the name of the class you would then be likely to use reflection anyhow, so calling thisJoinPointStaticPart.getSignature().getDeclaringType() probably isn't that efficient. Maybe if you expose the String name we can close this bug and let someone else reopen one in future if they have a compelling use case for exposing the class itself.</comment>
		<comment id="5" date="2006-10-18 10:42:34 EDT" author="Andrew Clement">Implemented and doc'd.

String getWithinTypeName() 

returns the full qualified name of the type "com.foo.MyClass"

It is not yet in Aspects14/Aspects - but the method is generated into an annotation style pertypewithin aspect.  I will do the Aspects work if someone needs it.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="6aa48b0e4feb48912acfb203f2c5b411514fbb87" author="aclement" date="2006-01-30 07:22:44"/>
          <file name="tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="148908" opendate="2006-6-27 18:41:00" fixdate="2006-09-26 08:12:52">
    <buginformation>
      <summary>incorrect source signature for field ipe with qualified allocation expression</summary>
      <description>Ajdoc chokes on interfaces with initializers for final fields (it doesn't preserve the initializer value). See attached AJDT project that fails when you run ajdoc with the default options on it:

&gt; Calling ajc...
&gt; Building signature files...
&gt; Calling javadoc...
Loading source file C:\eclipse\3.2\ajdocworkingdir\BadInterface.java...
1 error
&gt; Decorating html files...
&gt; Removing generated tags (this may take a while)...
&gt; Finished.
C:\eclipse\3.2\ajdocworkingdir\BadInterface.java:9: = expected
static final Comparator MY_COMPARATOR;
                                     ^</description>
      <comments>
		<comment id="1" date="2006-06-27 18:42:44 EDT" author="Ron Bodkin">Created attachment 45419 [details]
Exported jar with AJDT project and source code that chokes ajdoc</comment>
		<comment id="2" date="2006-06-28 04:11:19 EDT" author="Helen Beeken">After some initial investigation.....the actual error is coming from the step where we get hold of the javadoc main class, find the execute method and then call invoke on this method. It's not coming from the "ajdoc" side of things, but from the javadoc classes (com.sun.tools.javadoc.Main). 

The problem is that given the following source file:

-------------------------------------
public interface BadInterface {
 
 static I MY_I = new I() {};
}
-------------------------------------

the copy we make in ajdocworkingdir is:

-------------------------------------
/**__AJDECLID:2:__
 * 
 */
public interface BadInterface {
/**__AJDECLID:3:__
 * 
 */
static I MY_I;
}
-------------------------------------

Consequently we pass javadoc the wrong thing and it correctly throws an error.</comment>
		<comment id="3" date="2006-06-29 05:50:34 EDT" author="Helen Beeken">This is not an ajdoc bug. Ajdoc is calling IProgramElement.getSourceSignature() on the ipe with name MY_I and this is returning "static I MY_I;". Therefore, this is a bug within the model.

Further investigation shows that this is working as designed. The sourceSignature for an IPE is set during AsmHierarchyBuilder.visit(FieldDeclaration,MethodScope) and is generated via the genSourceSignature(FieldDeclaration) method. In particular, this method has the comment "Doesn't print qualified allocation expressions". A "QualifiedAllocationExpression" has the following javadoc:

/**
 * Variation on allocation, where can optionally be specified any of:
 * - leading enclosing instance
 * - trailing anonymous type
 * - generic type arguments for generic constructor invocation
 */

In the failing case, the initialization is a QualifiedAllocationExpression and consequently it doesn't get included and the sourcesignature is set to be "static I MY_I;".

The question is why we dont print qualified allocation expressions.........</comment>
		<comment id="4" date="2006-06-29 06:28:55 EDT" author="Helen Beeken">Created attachment 45525 [details]
failing testcase

Apply this patch to the tests project.</comment>
		<comment id="5" date="2006-06-30 10:32:21 EDT" author="Helen Beeken">A possible reason for not printing the qualified allocation expressions is that some extra manipulation needs to go in. Just treating them like other expressions and using the printExpression method results in the following being set as the source signature:

static I MY_I = new I() {
  x() {
    super();
  }
};</comment>
		<comment id="6" date="2006-07-04 10:57:55 EDT" author="Helen Beeken">Created attachment 45710 [details]
failing testcase

Apply to the tests project.

This test replaces the previously attached one as it adds itself to the 153 tests rather than 152. Also it uses Ron's original BadInterface.java which tests more than the simple case.</comment>
		<comment id="7" date="2006-07-04 11:12:48 EDT" author="Helen Beeken">Created attachment 45712 [details]
possible fix

Attached is a possible fix for this bug........

However, I'm not sure about it because it assumes that given something of the form

static I MY_I = new I() {};

in the code, that this becomes something of the form

static I MY_I = new I() {
  x() {
    super();
  }
};

In other words, that " x() {super();}" is added. Unfortunately, I can't think of a testcase where this assumption could be false (that the first thing after the first "{" isn't x(){super();}"). 

One thing to note is that all this is to do with setting the source signature of the iprogramelement. Currently the source signature is only used within ajdoc to add its extra tags to the code and copy this to the ajdocworkingdir.....this isn't a reason for having the wrong signature though :-)

Apply the patch to the org.aspectj.ajdt.core project.</comment>
		<comment id="8" date="2006-08-23 09:16:44 EDT" author="Andrew Clement">decide what to do about this for 1.5.3</comment>
		<comment id="9" date="2006-09-26 05:22:38 EDT" author="Andrew Clement">patches in - seems reasonable.</comment>
		<comment id="10" date="2006-09-26 08:12:52 EDT" author="Andrew Clement">fix avaiable.</comment>
		<comment id="11" date="2006-11-09 06:24:26 EST" author="Helen Beeken">iplog</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="fc39df195868a601e071f4fec900ab1854c43549" author="aclement" date="2006-09-26 06:26:33"/>
          <file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmHierarchyBuilder.java">
          </file>
          <file name="tests/bugs153/pr148908/BadInterface.java">
          </file>
          <file name="tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="161217" opendate="2006-10-17 8:19:00" fixdate="2006-10-24 08:40:26">
    <buginformation>
      <summary>NPE in BcelAdvice</summary>
      <description>I've been playing with some aspect deployment models and got into this error during project rebuild from AJDT:

java.lang.NullPointerException
at org.aspectj.weaver.bcel.BcelAdvice.implementOn(BcelAdvice.java:199)
at org.aspectj.weaver.Shadow.implementMungers(Shadow.java:699)
at org.aspectj.weaver.Shadow.implement(Shadow.java:471)
at org.aspectj.weaver.bcel.BcelClassWeaver.implement(BcelClassWeaver.java:2832)
at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:506)
at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeave ... lasses 
when weaving 
when batch building BuildConfig[...] #Files=6

Here is the aspect and classes it is applied to:

-----
@Aspect("percflow(execution(* InstrumentedBean.getProperty2()))")
public class GetFieldAtAspect {

  @Around("execution(* ConfigurableBean.getProperty2())")
  public Object onGet(ProceedingJoinPoint jp) throws Throwable {
    return jp.proceed();
  }
}
------
import org.springframework.beans.factory.InitializingBean;


public class InstrumentedBean implements InitializingBean, IInstrumentedBean {

  private ConfigurableBean configurableBean;

  private String value;

  private transient String transientValue = "aaa";

  
  public void afterPropertiesSet() throws Exception {
    this.configurableBean = new ConfigurableBean();
  }
  
  public String getProperty1() {
    synchronized(this) {
      return this.configurableBean.getProperty1();
    }
  }

  public String getProperty2() {
    synchronized(this) {
      return this.configurableBean.getProperty2();
    }
  }
  
  public void setValue(String value) {
    synchronized(this) {
      this.value = value;
    }
  }

  public Object getValue() {
    synchronized(this) {
      return value;
    }
  }

  public Object getTransientValue() {
    return transientValue;
  }
  
  public void setTransientValue(String transientValue) {
    this.transientValue = transientValue;
  }

}

------

import java.io.Serializable;

import org.springframework.beans.factory.annotation.Configurable;


@Configurable
public class ConfigurableBean implements Serializable {
  private static final long serialVersionUID = 1L;
  
  private String property1;
  private String property2;
  
  public ConfigurableBean() {
  }
  
  public String getProperty1() {
    return this.property1;
  }
  
  public String getProperty2() {
    return this.property2;
  }
  
  public void setProperty1(String property1) {
    this.property1 = property1;
  }
  
  public void setProperty2(String property2) {
    this.property2 = property2;
  }
  
}</description>
      <comments>
		<comment id="1" date="2006-10-17 09:06:45 EDT" author="Andrew Clement">What version of AJDT are you using? Does it work fine if it is a code style aspect?

I created a project with your 3 files in and it compiled fine for me (I had to remove the references to Configurable, InitializingBean, IInstrumentedBean as I dont have them)</comment>
		<comment id="2" date="2006-10-17 09:47:30 EDT" author="Eugene Kuleshov">I am running Eclipse 3.2 with latest AJDT from the dev update site. AJ aspect is seem compiles fine.

Strange that if with "perthis" in @Aspect, error appear on InstrumentedBean, but if I change it to @Aspect(), then error appear on GetFieldAtAspect.

Configurable and InitializingBean are from Spring framework, but it looks like error appear even if I remove them as well as IInstrumentedBean.

-----------
public aspect GetFieldAspect {
  pointcut onGetValue() : execution(* InstrumentedBean.getValue(..));
  pointcut onGetValueField() : get(* InstrumentedBean.value);

  Object around() : onGetValue() {
    System.err.println("Around getValue()");
    return "{"+proceed()+"}";
  }
  
  String around() : onGetValueField() {
    String value = proceed();
    System.err.println("Around get field value: "+ value);
    return "["+value+"]";
  }
}
-----------

Here is the more complete stack trace from the Problems view:

Internal compiler error
java.lang.NullPointerException
 at org.aspectj.weaver.bcel.BcelAdvice.implementOn(BcelAdvice.java:199)
 at org.aspectj.weaver.Shadow.implementMungers(Shadow.java:699)
 at org.aspectj.weaver.Shadow.implement(Shadow.java:471)
 at org.aspectj.weaver.bcel.BcelClassWeaver.implement(BcelClassWeaver.java:2832)
 at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:506)
 at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:119)
 at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1611)
 at org.aspectj.weaver.bcel.BcelWeaver.weaveWithoutDump(BcelWeaver.java:1562)
 at org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify(BcelWeaver.java:1340)
 at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1160)
 at org.aspectj.ajdt.internal.compiler.AjPipeliningCompilerAdapter.weaveQueuedEntries(AjPipeliningCompilerAdapter.java:455)
 at org.aspectj.ajdt.internal.compiler.AjPipeliningCompilerAdapter.queueForWeaving(AjPipeliningCompilerAdapter.java:392)
 at org.aspectj.ajdt.internal.compiler.AjPipeliningCompilerAdapter.afterProcessing(AjPipeliningCompilerAdapter.java:380)
 at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$after$org_aspectj_ajdt_internal_compiler_CompilerAdapter$5$6b855184(CompilerAdapter.aj:98)
 at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:533)
 at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:329)
 at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:906)
 at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:260)
 at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:176)
 at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:298)
 at org.aspectj.ajdt.internal.core.builder.AjBuildManager.incrementalBuild(AjBuildManager.java:183)
 at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:102)
 at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)</comment>
		<comment id="3" date="2006-10-18 10:57:40 EDT" author="Andrew Clement">Ok - you must be doing something else too - because I've downloaded spring 2.0 - put the spring.jar on the project classpath, then created the 3 files in that project which you mention in the first comment.  I removed the reference to IInstrumentedBean and it all compiles fine.

Do you have any compiler options set to something other than default?
Do you just have spring.jar on the classpath in the same way I do?

Maybe attach your .classpath/.project/(.settings if you have one) for the project so I can see what you are doing differently to me?</comment>
		<comment id="4" date="2006-10-18 13:18:14 EDT" author="Eugene Kuleshov">Created attachment 52245 [details]
project .settings

I can't attach original .classpath, but it has the following artifacts:

&lt;classpath&gt;
 &lt;classpathentry excluding="**/SCCS/**" kind="src" output="build.eclipse/tests.system.classes" path="tests.system"/&gt;
 &lt;classpathentry excluding="**/SCCS/**" kind="src" output="build.eclipse/tests.system.classes" path="tests.system.resources"/&gt;
 &lt;classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER"/&gt;
 &lt;classpathentry combineaccessrules="false" kind="src" path="/spring"/&gt;
 &lt;classpathentry kind="lib" path="lib/aspectjrt.jar"/&gt;
 &lt;classpathentry kind="output" path="build.eclipse/classes"/&gt;
&lt;/classpath&gt;

So, Spring jars are exported from /spring project, that is in the same Eclipse Workspace.

Anyways, can you say, what kind of thing is null there? Maybe we can deduct from that? Otherwise I can try to run this stuff under debugger, though not sure how to setup dev environment for AJDT.</comment>
		<comment id="5" date="2006-10-19 10:02:31 EDT" author="Andrew Clement">test and fix are committed in AspectJ cvs head.</comment>
		<comment id="6" date="2006-10-19 10:06:18 EDT" author="Eugene Kuleshov">(In reply to comment #5)
&gt; test and fix are committed in AspectJ cvs head.

Cool! What was that after all?</comment>
		<comment id="7" date="2006-10-19 10:43:44 EDT" author="Andrew Clement">Annotation style has far less test coverage than code style - some code for removing warnings on the code introduced by the compiler (that were determined to be incorrect at weaving time) never expected a collection to be null and all the tests to check this were written in code style.  It could actually be null for annotation style.</comment>
		<comment id="8" date="2006-10-19 12:54:48 EDT" author="Eugene Kuleshov">Thanks Andy. Any idea when dev AJDT build with this this change will be cut?</comment>
		<comment id="9" date="2006-10-20 09:53:03 EDT" author="Helen Beeken">The latest AJDT 1.4/1.5 dev builds contain this fix.</comment>
		<comment id="10" date="2006-10-20 11:34:04 EDT" author="Eugene Kuleshov">(In reply to comment #9)
&gt; The latest AJDT 1.4/1.5 dev builds contain this fix.

Just tried that. It works fine in AJDT. I guess I can take aspectjtools.jar from this AJDT build to mak it work from the commend line?</comment>
		<comment id="11" date="2006-10-22 15:08:51 EDT" author="Eugene Kuleshov">I am sorry to bug you again with this, but can you please point me to AspectJ build, which has aspectjtools.jar with iajc Ant task. Last dev build on AJ download page is dated Oct 16.</comment>
		<comment id="12" date="2006-10-23 03:45:19 EDT" author="Andrew Clement">check the download page this morning</comment>
		<comment id="13" date="2006-10-24 08:40:26 EDT" author="Andrew Clement">fix available (in AJ and AJDT)</comment>
		<comment id="14" date="2006-11-09 08:38:54 EST" author="Helen Beeken">iplog</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="044542c6d5996806ce29156e83e1725823f5f8fe" author="aclement" date="2006-10-19 11:05:02"/>
          <file name="tests/bugs153/pr161217/AtAspectJAspect.java">
          </file>
          <file name="tests/bugs153/pr161217/C.java">
          </file>
          <file name="tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java">
              <method name="implementOn" returnType="void" parameters="Shadow"/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="149289" opendate="2006-6-30 5:54:00" fixdate="2006-11-14 8:27:06">
    <buginformation>
      <summary>Support system and user aop.xml configuration files</summary>
      <description>Both AJDT (Bug 71066) and AspectJ (Bug 95516) support the generation of an aop.xml to declare the set of know aspects for LTW. However if the user modifies the file to add options etc then the changes can be over-written. There is a need to allow the user to provide their own configuration in a separate file.</description>
      <comments>
		<comment id="1" date="2006-07-05 09:09:25 EDT" author="Matthew Webster">So the question is: what should the files be called? There are 2 alternatives:
1. Have a new file called aop-user.xml but that requires documentation changes
2. When using -outxml (either with or without -outjar) generate a file called aop-system.xml (or something similar).

In both cases all we need to change is the definition of ClassLoaderWeavingAdaptor.AOP_XML.</comment>
		<comment id="2" date="2006-07-05 09:36:04 EDT" author="Andrew Clement">how about two more:

aop-withmungers.xml

and

aop-withoutmungers.xml

----
(on a serious note - whatever option is easier on migration for the user base we already have.  any existing system configured with just an aop.xml should continue to work unchanged, but I imagine either of your options achieve that...)</comment>
		<comment id="3" date="2006-07-05 10:53:45 EDT" author="Matthew Webster">This enhancment is related to Bug 138398. </comment>
		<comment id="4" date="2006-07-13 05:50:54 EDT" author="Matthew Webster">To help with backwards compatibility I have settled on keeping aop.xml for the user file and aop-something.xml for the generated one. However I'm not completely happy with aop-system.xml and aop-generated.xml is horrible. Any suggestions?</comment>
		<comment id="5" date="2006-07-25 10:07:41 EDT" author="Matthew Webster">Need to change ClassLoaderWeavingAdaptor.AOP_XML, RunSpec.copyLtwFile() and probably BuildArgParser.parseOption() where aop.xml is currently hard-coded.</comment>
		<comment id="6" date="2006-07-25 11:40:30 EDT" author="Ron Bodkin">There is also the question of how to handle  the -Dorg.aspectj.weaver.loadtime.configuration flag: presumably it should override the user-specified default file name, hopefully there will not also be a reason to override the system generated one.</comment>
		<comment id="7" date="2006-07-25 11:51:51 EDT" author="Matthew Webster">The system property you mention is for testing purposes only. In fact it means some tests are run differently from the way they do in the wild. I may find a way to remove it.</comment>
		<comment id="8" date="2006-07-25 12:00:27 EDT" author="Matthew Webster">Please ignore Comment #7 (it's been a long day). The "Dorg.aspectj.weaver.loadtime.configuration" System property is not currently documented and was added to support multiple configurations in Eclipse/OSGi. Currently it overrides the default META-INF/aop.xml. It might be better to change it's semantics so that it adds to the list. 

Thanks for reminding me about it.</comment>
		<comment id="9" date="2006-07-25 14:09:00 EDT" author="Ron Bodkin">I have also found this property useful for writing integration tests for projects that use load-time weaving, where I need to include additional test aspects in the configuration. Sometimes I want to include some test aspects but not others in a configuration, so it's useful to have this ability.</comment>
		<comment id="10" date="2006-07-26 03:34:27 EDT" author="Ron Bodkin">For example, we supply a number of abstract base aspects that are designed to be extended with concrete xml-defined aspects. It's important for us to write tests that validate our abstract aspects can be extended and work correctly with concrete XML-defined aspects, especially given some of the limitations in these (e.g., #149096 and #132080). This naturally gives rise to a fairly large number of different LTW configurations in a test suite.</comment>
		<comment id="11" date="2006-07-26 03:49:56 EDT" author="Matthew Webster">It currently allows you to completely overide the seach path. I think this is an important feature although in testing I prefer to let things default. So, although it may seem to complicate things, having the ability to refer to and override/compliment the default is important. Perhaps having 2 separate properties or allowing a symbolic reference to the default configuration.</comment>
		<comment id="12" date="2006-08-23 10:35:42 EDT" author="Matthew Webster">I have gone for META-INF/aop.xml and META-INF/aop-ajc.xml in that order. The âoutxml option, whether or not it is used with âoutjar, will use the new name. There are plenty of LTW tests in the suite that use a custom file and -outxml already.

The only problem is see is for those people using the latest compiler and an old version of the weaver. They have 3 choices:
1. Use âoutxmlfile to override the new name
2. Use -Dorg.aspectj.weaver.loadtime.configuration which still allows you to override the default
3. Upgrade the weaver!

I have opened Bug 154857 âChange name of aop.xml generated for LTW launcherâ to update the AJDT LTW launcher.</comment>
		<comment id="13" date="2006-08-23 11:51:13 EDT" author="Ron Bodkin">That sounds good. Those stuck targeting an old weaver could also do something to merge an outxml file with a template xml file in their build process...</comment>
		<comment id="14" date="2006-08-24 04:05:14 EDT" author="Adrian Colyer">I've been doing some work with on OSGi recently, and one of the issues that came up there is that META-INF/*.xml is a bad location for configuration files as jar signing explicitly excludes all resources directly under META-INF. I can well imagine that the aop.xml configuration is something you may want to sign and not have people tamper with. We can't drop direct use of META-INF/aop.xml, but probably also need to support META-INF/aspectj/aop.xml etc. (resources in sub-folders *are* included in the signing process)...</comment>
		<comment id="15" date="2006-08-24 04:24:48 EDT" author="Matthew Webster">Committed.</comment>
		<comment id="16" date="2006-08-24 04:27:35 EDT" author="Matthew Webster">Fix available in aspectj-DEVELOPMENT-20060823220041.jar.</comment>
		<comment id="17" date="2006-08-24 12:50:16 EDT" author="Matthew Webster">WRT Comment #14 I assume that meta-data is not signed because you may need to change it and changing it does not affect the function of the JAR. For most of what we declare in aop.xml this is true. The only exception is concrete aspects which are like proto-classes. BUT the advice has not been applied to anything yet.</comment>
		<comment id="18" date="2006-10-04 05:51:38 EDT" author="Matthew Webster">I think the simplest solution is to continue supporting aop.xml and aop-ajc.xml but add built-in support for org/aspectj/aop.xml that is already used for AOSGi. Yes this will add a tiny overhead to adaptor initialization.</comment>
		<comment id="19" date="2006-11-14 08:27:06 EST" author="Matthew Webster">Fix available.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="fa7ca52b5278bd824a43a08e3ecd5f038696bb1a" author="mwebster" date="2006-08-23 11:34:28"/>
          <file name="ajde/testsrc/org/aspectj/ajde/OutxmlTest.java">
          </file>
          <file name="bridge/src/org/aspectj/bridge/Constants.java">
          </file>
          <file name="loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java">
          </file>
          <file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java">
              <method name="parseOption" returnType="void" parameters="String LinkedList"/>
          </file>
          <file name="org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/ajc/BuildArgParserTestCase.java">
              <method name="testOutxml" returnType="void" parameters=""/>
          </file>
          <file name="taskdefs/testsrc/org/aspectj/tools/ant/taskdefs/AjcTaskTest.java">
              <method name="testOutxml" returnType="void" parameters=""/>
          </file>
          <file name="tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java">
              <method name="checkXMLAspectCount" returnType="void" parameters="String String int"/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="138219" opendate="2006-4-24 12:47:00" fixdate="2006-05-17 01:38:03">
    <buginformation>
      <summary>Can't use a FQ Reference pointcut in any pointcut expression referenced by a per-clause</summary>
      <description>A pointcut expression for a per-clause fails to resolve if it contains any reference pointcuts referring to pointcut expressions defined in other types. (Even if that is indirectly, through a local named pointcut).</description>
      <comments>
		<comment id="1" date="2006-04-24 12:52:14 EDT" author="Adrian Colyer">See test case bugs152/pr138219</comment>
		<comment id="2" date="2006-05-16 11:42:58 EDT" author="Adrian Colyer">fixed in tree, waiting on build.
See also 130722.</comment>
		<comment id="3" date="2006-05-17 01:38:03 EDT" author="Adrian Colyer">Fix now available for download in dev builds</comment>
		<comment id="4" date="2007-07-29 09:19:36 EDT" author="Eclipse Webmaster">Changing OS from Mac OS to Mac OS X as per bug 185991</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="b166a7e6163889eb951f82655f0f49bfc26a49f0" author="acolyer" date="2006-05-17 12:43:08"/>
          <file name="tests/bugs152/pr130722/test/Test.java">
          </file>
          <file name="tests/src/org/aspectj/systemtest/ajc150/GenericITDsDesign.java">
              <method name="getTypeMunger" returnType="List" parameters="String"/>
          </file>
          <file name="tests/src/org/aspectj/systemtest/ajc152/Ajc152Tests.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/CrosscuttingMembers.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/CrosscuttingMembersSet.java">
              <method name="addOrReplaceAspect" returnType="boolean" parameters="ResolvedType boolean"/>
          </file>
          <file name="weaver/src/org/aspectj/weaver/ResolvedType.java">
          </file>
          <file name="weaver/testsrc/org/aspectj/weaver/bcel/NonstaticWeaveTestCase.java">
              <method name="testBeforeCflow" returnType="void" parameters=""/>
          </file>
          <file name="weaver/testsrc/org/aspectj/weaver/bcel/PointcutResidueTestCase.java">
              <method name="checkWeave" returnType="void" parameters="String String String String[] String[]"/>
          </file>
          <file name="weaver/testsrc/org/aspectj/weaver/bcel/WeaveOrderTestCase.java">
              <method name="testDominates" returnType="void" parameters=""/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="138223" opendate="2006-4-24 13:17:00" fixdate="2006-05-17 11:47:04">
    <buginformation>
      <summary>Compiler crash on two binding @xxx pcds in one compound expression</summary>
      <description>junit.framework.AssertionFailedError: test "Double at annotation matching (no binding)" failed
test "Double at annotation matching (no binding)" failed
Unexpected warning messages:
	warning at before() : transactionalOperation() {
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/private/tmp/ajcSandbox/ajcTest18924.tmp/DoubleAnnotationMatching.aj:20:0::0 advice defined in DoubleAnnotationMatching has not been applied [Xlint:adviceDidNotMatch]
Unexpected fail messages:
	abort trouble in: 
 class Foo extends java.lang.Object:
  void &lt;init&gt;():
                    ALOAD_0     // LFoo; this   (line 26)
                    INVOKESPECIAL java.lang.Object.&lt;init&gt; ()V
    constructor-execution(void Foo.&lt;init&gt;())
    |               RETURN
    constructor-execution(void Foo.&lt;init&gt;())
  end void &lt;init&gt;()

  public void foo()    org.aspectj.weaver.MethodDeclarationLineNumber: 28:533
:
    method-execution(void Foo.foo())
    |               RETURN   (line 28)
    method-execution(void Foo.foo())
  end public void foo()

  public void bar()    org.aspectj.weaver.MethodDeclarationLineNumber: 30:563
:
    method-execution(void Foo.bar())
    |               RETURN   (line 30)
    method-execution(void Foo.bar())
  end public void bar()

end  class Foo
 -- (BCException) Impossible! annotation=[Tx]  shadow=[method-execution(void Foo.foo()) at /private/tmp/ajcSandbox/ajcTest18924.tmp/DoubleAnnotationMatching.aj:28::533]    pointcut is at [/private/tmp/ajcSandbox/ajcTest18924.tmp/DoubleAnnotationMatching.aj:15::316]
when implementing on shadow method-execution(void Foo.foo())
when weaving type Foo
when weaving classes 
when weaving 
when batch building BuildConfig[null] #Files=1

Impossible! annotation=[Tx]  shadow=[method-execution(void Foo.foo()) at /private/tmp/ajcSandbox/ajcTest18924.tmp/DoubleAnnotationMatching.aj:28::533]    pointcut is at [/private/tmp/ajcSandbox/ajcTest18924.tmp/DoubleAnnotationMatching.aj:15::316]
when implementing on shadow method-execution(void Foo.foo())
when weaving type Foo
when weaving classes 
when weaving 
when batch building BuildConfig[null] #Files=1

org.aspectj.weaver.BCException: Impossible! annotation=[Tx]  shadow=[method-execution(void Foo.foo()) at /private/tmp/ajcSandbox/ajcTest18924.tmp/DoubleAnnotationMatching.aj:28::533]    pointcut is at [/private/tmp/ajcSandbox/ajcTest18924.tmp/DoubleAnnotationMatching.aj:15::316]
when implementing on shadow method-execution(void Foo.foo())
when weaving type Foo
when weaving classes 
when weaving 
when batch building BuildConfig[null] #Files=1

	at org.aspectj.weaver.patterns.AnnotationPointcut.findResidueInternal(AnnotationPointcut.java:201)
	at org.aspectj.weaver.patterns.Pointcut.findResidue(Pointcut.java:267)
	at org.aspectj.weaver.patterns.AndPointcut.findResidueInternal(AndPointcut.java:93)
	at org.aspectj.weaver.patterns.Pointcut.findResidue(Pointcut.java:267)
	at org.aspectj.weaver.patterns.AndPointcut.findResidueInternal(AndPointcut.java:93)
	at org.aspectj.weaver.patterns.Pointcut.findResidue(Pointcut.java:267)
	at org.aspectj.weaver.patterns.IfPointcut.findResidueInternal(IfPointcut.java:173)
	at org.aspectj.weaver.patterns.Pointcut.findResidue(Pointcut.java:267)
	at org.aspectj.weaver.patterns.AndPointcut.findResidueInternal(AndPointcut.java:93)
	at org.aspectj.weaver.patterns.Pointcut.findResidue(Pointcut.java:267)
	at org.aspectj.weaver.patterns.AndPointcut.findResidueInternal(AndPointcut.java:93)
	at org.aspectj.weaver.patterns.Pointcut.findResidue(Pointcut.java:267)
	at org.aspectj.weaver.patterns.OrPointcut.findResidueInternal(OrPointcut.java:96)
	at org.aspectj.weaver.patterns.Pointcut.findResidue(Pointcut.java:267)
	at org.aspectj.weaver.bcel.BcelAdvice.specializeOn(BcelAdvice.java:132)
	at org.aspectj.weaver.bcel.BcelShadow.prepareForMungers(BcelShadow.java:325)
	at org.aspectj.weaver.Shadow.implement(Shadow.java:455)
	at org.aspectj.weaver.bcel.BcelClassWeaver.implement(BcelClassWeaver.java:2236)
	at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:491)
	at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:109)
	at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1560)
	at org.aspectj.weaver.bcel.BcelWeaver.weaveWithoutDump(BcelWeaver.java:1511)
	at org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify(BcelWeaver.java:1291)
	at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1113)
	at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave(AjCompilerAdapter.java:311)
	at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling(AjCompilerAdapter.java:183)
	at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$afterReturning$org_aspectj_ajdt_internal_compiler_CompilerAdapter$2$f9cc9ca0(CompilerAdapter.aj:70)
	at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:367)
	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:862)
	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:242)
	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:161)
	at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:114)
	at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:60)
	at org.aspectj.tools.ajc.Main.run(Main.java:367)
	at org.aspectj.tools.ajc.Main.runMain(Main.java:246)
	at org.aspectj.tools.ajc.Ajc.compile(Ajc.java:199)
	at org.aspectj.tools.ajc.Ajc.compile(Ajc.java:163)
	at org.aspectj.tools.ajc.AjcTestCase.ajc(AjcTestCase.java:510)
	at org.aspectj.testing.CompileSpec.execute(CompileSpec.java:53)
	at org.aspectj.testing.AjcTest.runTest(AjcTest.java:68)
	at org.aspectj.testing.XMLBasedAjcTestCase.runTest(XMLBasedAjcTestCase.java:111)
	at org.aspectj.systemtest.ajc152.Ajc152Tests.testDoubleAnnotationMatching_pr138221(Ajc152Tests.java:37)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:585)
	at junit.framework.TestCase.runTest(TestCase.java:154)
	at junit.framework.TestCase.runBare(TestCase.java:127)
	at junit.framework.TestResult$1.protect(TestResult.java:106)
	at junit.framework.TestResult.runProtected(TestResult.java:124)
	at junit.framework.TestResult.run(TestResult.java:109)
	at junit.framework.TestCase.run(TestCase.java:118)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:478)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:344)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196)


command was: ajc -classpath /Users/adrian/projects/aspectjdev/lib/test/aspectjrt.jar:../testing-client/bin:../runtime/bin:../aspectj5rt/bin:../lib/junit/junit.jar:../bridge/bin:../loadtime/bin:../weaver/bin:../weaver5/bin:../aj-build/jars/bridge.jar:../aj-build/jars/util.jar:../aj-build/jars/loadtime.jar:../aj-build/jars/weaver.jar:../aj-build/jars/weaver5.jar:../aj-build/jars/asm.jar:../lib/test/testing-client.jar:../lib/test/aspectjrt.jar:/tmp/ajcSandbox/ajcTest18924.tmp -1.5 /tmp/ajcSandbox/ajcTest18924.tmp/DoubleAnnotationMatching.aj -d /tmp/ajcSandbox/ajcTest18924.tmp
	at junit.framework.Assert.fail(Assert.java:47)
	at org.aspectj.tools.ajc.AjcTestCase.assertMessages(AjcTestCase.java:452)
	at org.aspectj.testing.CompileSpec.execute(CompileSpec.java:56)
	at org.aspectj.testing.AjcTest.runTest(AjcTest.java:68)
	at org.aspectj.testing.XMLBasedAjcTestCase.runTest(XMLBasedAjcTestCase.java:111)
	at org.aspectj.systemtest.ajc152.Ajc152Tests.testDoubleAnnotationMatching_pr138221(Ajc152Tests.java:37)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:585)
	at junit.framework.TestCase.runTest(TestCase.java:154)
	at junit.framework.TestCase.runBare(TestCase.java:127)
	at junit.framework.TestResult$1.protect(TestResult.java:106)
	at junit.framework.TestResult.runProtected(TestResult.java:124)
	at junit.framework.TestResult.run(TestResult.java:109)
	at junit.framework.TestCase.run(TestCase.java:118)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:478)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:344)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196)</description>
      <comments>
		<comment id="1" date="2006-04-24 13:17:31 EDT" author="Adrian Colyer">See test case in bugs152/pr138223 to reproduce.</comment>
		<comment id="2" date="2006-05-17 11:47:04 EDT" author="Andrew Clement">&lt;abracadabra&gt; this now works &lt;/abracadabra&gt;

testcase is beefed up to prove it.</comment>
		<comment id="3" date="2006-06-02 08:38:39 EDT" author="Adrian Colyer">*** Bug 145048 has been marked as a duplicate of this bug. ***</comment>
		<comment id="4" date="2007-07-29 09:19:36 EDT" author="Eclipse Webmaster">Changing OS from Mac OS to Mac OS X as per bug 185991</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="6b2d9ae90158bd4e5cda5ecea5f3787400bab5af" author="aclement" date="2006-05-18 12:48:34"/>
          <file name="tests/src/org/aspectj/systemtest/ajc152/Ajc152Tests.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/patterns/AnnotationPointcut.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="138215" opendate="2006-4-24 12:22:00" fixdate="2006-04-26 08:10:55">
    <buginformation>
      <summary>Reference pointcut fails inside @DeclareWarning</summary>
      <description>When a pointcut expression used with an @DeclareWarning construct contains a reference pointcut, the warning is correctly produced at matched join points, but the compiler also gives an error saying that the referenced pointcut cannot be found.</description>
      <comments>
		<comment id="1" date="2006-04-24 12:30:24 EDT" author="Adrian Colyer">(more details forthcoming, I just raised the issue first to get a bug number to use for the test case...)</comment>
		<comment id="2" date="2006-04-24 12:38:34 EDT" author="Adrian Colyer">Reproduceable when @DeclareWarning contains an unqualified reference to a named pointcut defined within the same @Aspect.

See bugs152/pr138215 for test case that reproduces the issue.</comment>
		<comment id="3" date="2006-04-25 08:20:24 EDT" author="Adrian Colyer">fix commited in tree...</comment>
		<comment id="4" date="2006-04-26 08:10:55 EDT" author="Andrew Clement">fix available.</comment>
		<comment id="5" date="2007-07-29 09:19:36 EDT" author="Eclipse Webmaster">Changing OS from Mac OS to Mac OS X as per bug 185991</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="6b2526fdda56e30d8a151ca0b9bd16ecb690d3d0" author="acolyer" date="2006-04-25 02:46:06"/>
          <file name="tests/src/org/aspectj/systemtest/ajc152/Ajc152Tests.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="158412" opendate="2006-9-23 5:11:00" fixdate="2006-09-26 02:54:39">
    <buginformation>
      <summary>@Pointcut in declare error results in NPE</summary>
      <description>I am trying to use an @AspectJ @Pointcut in a "normal" AspectJ declare error expression. That  results in the following exception.


java.lang.NullPointerException
at org.aspectj.weaver.patterns.ReferencePointcut.concretize1(ReferencePointcut.java:361)
at org.aspectj.weaver.patterns.Pointcut.concretize(Pointcut.java:233)
at org.aspectj.weaver.patterns.NotPointcut.concretize1(NotPointcut.java:100)
at org.aspectj.weaver.patterns.Pointcut.concretize(Pointcut.java:233)
at org.aspectj.weaver.patterns.AndPointcut.concretize1(AndPointcut.java:97)
at org.aspectj.weaver.patterns.Pointcut.concretize(Pointcut.java:233)
at org.aspectj.weaver.patterns.Pointcut.concretize(Pointcut.java:220)
at org.aspectj.weaver.Checker.concretize(Checker.java:45)
at org.aspectj.weaver.CrosscuttingMembers.addShadowMunger(CrosscuttingMembers.java:91)
at org.aspectj.weaver.CrosscuttingMembers.addDeclare(CrosscuttingMembers.java:122)
at org.aspectj.weaver.CrosscuttingMembers.addDeclares(CrosscuttingMembers.java:113)
at org.aspectj.weaver.CrosscuttingMembersSet.addAdviceLikeDeclares(CrosscuttingMembersSet.java:117)
at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.addAdviceLikeDeclares(AjLookupEnvironment.java:382)
at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.completeTypeBindings(AjLookupEnvironment.java:245)
at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.beginToCompile(Compiler.java:301)
at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:315)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:887)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:244)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:199)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.incrementalBuild(AjBuildManager.java:170)
at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:117)
at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)

NullPointerException thrown: null</description>
      <comments>
		<comment id="1" date="2006-09-23 05:12:36 EDT" author="Eberhard Wolff">Created attachment 50755 [details]
Project that shows the error</comment>
		<comment id="2" date="2006-09-25 09:22:26 EDT" author="Andrew Clement">incorrect resolution for a reference pointcut when using @AJ syntax. working on fix.</comment>
		<comment id="3" date="2006-09-25 09:48:25 EDT" author="Andrew Clement">test and fix committed.</comment>
		<comment id="4" date="2006-09-26 02:54:39 EDT" author="Andrew Clement">fix available in latest dev build.</comment>
		<comment id="5" date="2007-07-29 09:20:56 EDT" author="Eclipse Webmaster">Changing OS from Mac OS to Mac OS X as per bug 185991</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="e56a69a32149724c51daf0b52958607e5cc46eb4" author="aclement" date="2006-09-25 10:51:40"/>
          <file name="org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseSourceType.java">
          </file>
          <file name="tests/bugs153/pr158412/dao/Foo.java">
          </file>
          <file name="tests/bugs153/pr158412/layering/SystemArchitektur.java">
          </file>
          <file name="tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="173602" opendate="2007-2-9 3:19:00" fixdate="2008-3-19 19:35:00">
    <buginformation>
      <summary>InterTypeMethodDeclaration.java:90</summary>
      <description>The following exception is caused by a duplicate inter-type introduction method
declaration in an aspect. Removing the duplicate method solves the problem.

java.lang.NullPointerException
at org.aspectj.ajdt.internal.compiler.ast.InterTypeMethodDeclaration.resolve(InterTypeMethodDeclaration.java:90)
at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1088)
at org.aspectj.ajdt.internal.compiler.ast.AspectDeclaration.resolve(AspectDeclaration.java:116)
at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1137)
at org.aspectj.org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:305)
at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:519)
at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:329)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:887)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:244)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:199)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.incrementalBuild(AjBuildManager.java:170)
at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:117)
at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)

NullPointerException thrown: null
</description>
      <comments>
		<comment id="1" date="2008-03-19 01:16:57 EDT" author="Andrew Clement">Still failing in 1.6 - this code:

public aspect X {
  public void Y.foo(String s) {}
  public void Y.foo(String s) {}
}

class Y {}
 

gives

java.lang.NullPointerException
        at org.aspectj.ajdt.internal.compiler.ast.InterTypeMethodDeclaration.resolve(InterTypeMethodDeclaration.java:92)
        at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1109)
        at org.aspectj.ajdt.internal.compiler.ast.AspectDeclaration.resolve(AspectDeclaration.java:114)
        at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1188)
        at org.aspectj.org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:366)</comment>
		<comment id="2" date="2008-03-19 19:35:02 EDT" author="Andrew Clement">test and fix committed.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="a60967b92a4de61a55569f8b4828ad9575b521f9" author="aclement" date="2008-03-20 08:32:31"/>
          <file name="tests/bugs160/pr173602/X.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="145693" opendate="2006-6-7 0:35:00" fixdate="2008-12-3 13:57:56">
    <buginformation>
      <summary>Verify Error unless inpath entry also on classpath and with -Xlint ignoring cantFindType</summary>
      <description>See attached failing testCase.</description>
      <comments>
		<comment id="1" date="2006-06-07 01:02:09 EDT" author="Ron Bodkin">Created attachment 43675 [details]
Patch to tests module to add failing test case</comment>
		<comment id="2" date="2006-06-07 04:24:58 EDT" author="Andrew Clement">testcase committed.  Possibly a case of us being too lenient and should error when the type is missing rather than ignoring it.</comment>
		<comment id="3" date="2006-06-07 13:57:14 EDT" author="Ron Bodkin">Created attachment 43752 [details]
Patch with 2 more test cases that build on the already committed first patch

The most important thing to notice here is that even with the required type on the inpath the weaver still fails to resolve it. In a larger project this leads to a work-around of including the inpath entries on the classpath, which just can't be right.</comment>
		<comment id="4" date="2006-06-26 13:47:10 EDT" author="Ron Bodkin">I'd sure like to see a fix for this one in 1.5.2: it seems wrong to have to include a library entry in both classpath and inpath to allow resolving types. Surely this one should be fixed...</comment>
		<comment id="5" date="2006-07-05 06:43:24 EDT" author="Andrew Clement">of course it needs fixing ... but it's one of those bugs that's always been there.  Shame it wasn't raised as the two separate problems - one is easier than the other and may have made it into 1.5.2. but oh well.

Problems:

1. Three cant find type messages are being ignored in the first of the testcases, thats the one I'm looking at.  One of them relates to trying to calculate the pointcut residue for the match that occurs on the field set in the Sample.main() method (the residue is for the cflow).  I am currently tempted to promote this particular cantfindtype to an unconditional error - once we get into this state we have matched a pointcut and are going to apply advice, we are then having problems calculating the residue and we can't go back and change our minds about the match (no mechanism).  Other options seem to be working out at match time whether we know everything we'll need to create the residue - that sounds messy.

2. Does seem bizarre that inpath/aspectpath and available for type resolution - I have a fix for this but need to test it a little more.</comment>
		<comment id="6" date="2006-07-05 08:46:54 EDT" author="Andrew Clement">ok - i followed up on my 'alternative' solution to (1) and have implemented it.  if we cannot match because of a missing type, we give out a warning to indicate that is exactly what is happening.  This is not a cant find type message, it is a new message that indicates a match couldnt be determined at a particular join point because we didn't know about a type.  the message includes the type and the locations of the join point and the pointcut.

Unable to determine match at this join point because the type 'Event' cannot be found

By not matching, we don't fail miserably creating the residue and then blow up with a verify error.

Silently ignoring the joinpoint with no message would have you climbing the walls in frustration trying to work out why there was no match.

Note I have only fixed it for the cflow case here, there are probably other cases too.  These are all indicative of having a weaver that was never intended to run with half a type system - making cantfindtype configurable causes all sorts of unexpected things to happen in the weaver.  I would rather make cantFindType an error and resolve all cases where we are looking for too many types.</comment>
		<comment id="7" date="2006-07-06 04:32:06 EDT" author="Andrew Clement">all fixes in.  i'm nervous about the path change thing for some reason ... but all the tests are OK with it so I cant think why it will go wrong...</comment>
		<comment id="8" date="2006-07-10 16:30:45 EDT" author="Ron Bodkin">See also bug #145693 for more about removing Xlint cantFindType: allowing use of runtime tests while avoiding possible errors.</comment>
		<comment id="9" date="2006-07-10 16:44:56 EDT" author="Andrew Clement">i think you mean bug 149322 where we are looking at whats possible for more flexible residue - if it can be determined to be safe.</comment>
		<comment id="10" date="2006-07-10 16:48:53 EDT" author="Ron Bodkin">Thanks for the correction Andy: that's what I meant. I forgot I had copied this bug # after copying the referenced one. </comment>
		<comment id="11" date="2006-07-10 17:19:15 EDT" author="Andrew Clement">reopening to ensure I review this case when thinking about the new residue stuff - if I can work it out for other pcuts, we might be able to do something here, but this was a complex case (isnt cflow always...)</comment>
		<comment id="12" date="2007-10-24 10:23:30 EDT" author="Andrew Clement">worth looking at in the 1.6.0 timeframe?</comment>
		<comment id="13" date="2008-12-03 13:57:56 EST" author="Andrew Clement">mentioning this bug on the other report as something to re-read and then closing this one.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="e769745da4ba14cb68c220b33f0232a920eeafae" author="aclement" date="2006-06-07 05:19:14"/>
          <file name="tests/bugs152/pr145391/GenericType.java">
          </file>
          <file name="tests/bugs152/pr145391/GenericType2.java">
          </file>
          <file name="tests/bugs152/pr145693/Event.java">
          </file>
          <file name="tests/bugs152/pr145693/Sample.java">
          </file>
      </commit>
    </fixedCommits>
  </bug>
  <bug id="150271" opendate="2006-7-11 11:31:00" fixdate="2006-8-24 8:10:52">
    <buginformation>
      <summary>Allow multiple levels of LTW information</summary>
      <description>It would be nice if basic information about load-time weaving (what version of AspectJ is being used, what loaders are doing weaving and what configuration is being used) was available without all of the -verbose information listing of all classes woven or not woven.

It's also unfortunate that the flags for weaving level are 2 quite different ones:
-Daj.weaving.verbose -Dorg.aspectj.weaver.showWeaveInfo

Why not something like -Dorg.aspectj.weaver.level=[none|summary|info|verbose]

summary: just what configuration is used
info: list affected join points etc. (like showWeaveInfo)
verbose: all (like verbose now)</description>
      <comments>
		<comment id="1" date="2006-07-11 12:26:47 EDT" author="Matthew Webster">I assume you would always like warnings and errors to come out? In which case they need context i.e. what aspects are registered and which aop.xml files were used. Therefore I think it makes sense to put out what you call "summary" information by default. Perhaps a better approach would be -silent which (for whatever reason) allows a user to turn of all messages. The -verbose and âshowWeaveInfo options, which of cause are not peculiar to LTW, would remain the same.

The aop.xml file will remain the primary configuration mechanism because in a complex system it is easier to use than System properties (in my experience) and has none of the security implications. However we should revisit the names used as they are quite old. I suspect org.aspectj.weaver.loadtime.XXX would be a good start.</comment>
		<comment id="2" date="2006-07-12 12:04:02 EDT" author="Matthew Webster">Another option would be for many of the current info messages in LTW to be debug. We don't seem to use this level of messages at the moment so their is no support for a -debug flag but it would be consistent with other tools like Ant. So that way we would have:
default:        warning, error
-verbose:       info including AspectJ version, classloader, configuration
-showWeaveInfo: weave 
-debug:         debug including weaving, not weaving, generating, ...

We could also keep the initial configuration messages and dump them when we get the first warning or error for context.</comment>
		<comment id="3" date="2006-07-12 12:59:30 EDT" author="Ron Bodkin">I would definitely like errors to come out. I would like to be able to configure warnings to suppress known ones but otherwise they should too. I quite like the idea of dumping configuration information when an error or warning is emitted. The other case where configuration information is helpful to see is when nothing is happening (e.g., -javaagent isn't being passed in, the aop.xml file isn't present, possibly one aop.xml file turns off something in another one: that is a possible warning itself).

I would also be quite happy with some kind of log adapter so that AspectJ messages could be configured through normal logging mechanisms. I agree that configuring anything possible within the aop.xml file is the preferred place: the one place where system-wide flags make sense is for global configuration (e.g., troubleshooting if you have set up your aop configuration correctly).

-Dorg.aspectj.weaver.loadtime.XXX sounds good to me, and the levels sound right. I would suggest leaving -verbose as a deprecated alias for -debug:

default:        warning, error
-info:          info including AspectJ version, classloader, configuration
-showWeaveInfo: weave PLUS info
-debug:         debug including weaving, not weaving, generating, ... 
                PLUS showWeaveInfo
-verbose:       same as -debug with deprecated warning message (or not)

How hard would it be to allow plugging in a log message handler instead of writing to the console? It seems like this is a good area to define a Plugin API with a simple interface so people can create adapters for Log4J, RAS, JULI/jdk, commons logging, sl4j, etc. </comment>
		<comment id="4" date="2006-07-13 06:03:43 EDT" author="Matthew Webster">&gt;I would like to be able to configure warnings to suppress known ones but 
&gt;otherwise they should too.
I will ask the same question as I did for Xlint: which warnings do you feel the need to suppress? The product should work out of the box if coding guidelines are followed. The messages are there for me as well as you :-)

&gt;e.g., -javaagent isn't being passed in,
Iâm not sure how we can handle this one as we are not in the loop at all

&gt;the aop.xml file isn't present, possibly one aop.xml file turns off &gt;something in another one: that is a possible warning itself
We already list the aop.xml files that are used. Using include/exclude for aspects can cause âaspectExcludedByConfigurationâ to be issued. We already issue ânot wovenâ messages (which should probably be debug) but I could add a reason why a class is exluded

&gt;How hard would it be to allow plugging in a log message handler instead &gt;of writing to the console?
Probably not very. Andy and I have been talking about problem diagnosis for LTW. I have just opened Bug 150487 âTracing and Logging Frameworkâ.

With the growing popularity of load-time weaving it is becoming increasing difficult to diagnose complex problems given the limited diagnostic information available: stack trace, verbose output, and dumped byte-code. With compiler errors it is usually possible for the bug raiser to attach a testcase but this is not possible when the problem may concern environment or integration with middleware. I therefore propose we implement a tracing/logging mechanism that will capture low level entry/exit information as well as existing informational messages (see Ronâs comment in Bug 150271 âAllow multiple levels of LTW informationâ) and route them to one of the existing logging infrastructures such as JDK 1.4 or Jakarta Commons logging.</comment>
		<comment id="5" date="2006-07-14 12:11:35 EDT" author="Ron Bodkin">&gt;I will ask the same question as I did for Xlint: which warnings do you feel the
&gt;need to suppress? The product should work out of the box if coding guidelines
&gt;are followed. The messages are there for me as well as you :-)

Almost any of the warnings that are reasonable to suppress today have been made configurable through Xlint, which is good. As an example of something of the sort, suppose there's a runtime limitation like not being able to inline around advice because of the aspect configuration (e.g., shared library aspects from the system classpath aren't being woven). That should be a warning, but it should also be supressable. The system may well work just fine without inlined around advice and an administrator shouldn't have to see a warning about it if the developer realizes the limitation and has tested for it. This wouldn't be a weaver issue since it's really an LTW configuration warning, so I don't think it should go in Xlint.properties. But that one is hypothetical. A quick look through the loadtime module shows a few other candidates:
* warnings for missing DTD's (dumped directly to syserr in DocumentParser)
* define generated class failed (ClassLoaderWeavingAdaptor): as noted in the code, there might be situtations where this happens but it's not an error. There may also be systems that recover properly from a runtime limitation like this and don't want it emitted to the output.

Of course the current aop.xml mechanism does allow you to suppress warnings, but unfortunately it suppresses all of them. I think only a few should be suppressable, based on analysis that indicates it might be expected to run with the warning occurring, rather than it being a problem that should always be fixed.

&gt;&gt;e.g., -javaagent isn't being passed in,
&gt;Iç¥ not sure how we can handle this one as we are not in the loop at all

The best way to test for this is a simple output to indicate that the LTW system has started with the AspectJ version. I.e., without any configuration, did the system print something? I'd be glad to have that one line of information come out (e.g., at INFO level in a log) by default unless you start with a silent flag. 

&gt;...I could add a reason why a class is exluded
That sounds good for debug purposes.

Re: bug #150487, that sounds great. Thanks for creating that!</comment>
		<comment id="6" date="2006-07-17 10:44:55 EDT" author="Matthew Webster">I was hoping for a list of existing warnings that you felt the need to suppress rather that a list of new ones that if I added you would like to be able suppress. As with Bug 149322 âChange Xlint cantFindType default to warningâ I believe warnings and errors should not be suppressed as a matter of course. If there are situations when a change to your code cannot remove the warning/error but you feel the resulting application behaves correctly then we should review the message.

Letâs discuss the new ones you mentioned:
- Not being able to inline around advice: I believe warnings should be used to help people. If the compiler issues a warning which the user can do nothing about, as in this situation, apart from suppress it then the message is pointless. I have opened Bug 149802 âSupport inlining of all eligible around adviceâ to investigate whether we can apply the optimization more widely.
- warnings for missing DTD's: This should be an error, not even Xlint.
- define generated class failed: This should also be an error. I was nervous about making it one because certain message handles abort on errors. There is not a situation that I can think of where not being able to define a closure on which a class we have just woven has a hard dependency is OK. I donât agree with the comment in the code. We should either ignore the explicit case mentioned or stop the situation occurring (it might be related to Bug 119657 âIllegalAccessError with around advice on interface method callâ).</comment>
		<comment id="7" date="2006-07-17 13:54:31 EDT" author="Ron Bodkin">There aren't any other cases of warnings that I've encountered that I might like to suppress other than Xlint warnings and the two examples I listed. There might be some others that I've not encountered, but if there are they're either rare or not relevant to configurations I've used.</comment>
		<comment id="8" date="2006-07-18 04:08:11 EDT" author="Matthew Webster">&gt; ...I might like to suppress other than Xlint warnings
Which ones? I don't think we are explicit enough about the purpose of Xlint but my understanding of the process from conversations the Jim H. is that it is an experimental area rather than a generalized process for suppressing errors/warnings. When I add an Xlint error I do so because I feel I might break a user who cannot avoid it. When we understand the situation better either the message goes away or becomes a hard error.</comment>
		<comment id="9" date="2006-07-18 12:36:18 EDT" author="Ron Bodkin">Here are the Xlint properties that default to warning that I have been suppressing:

invalidAbsoluteTypeName [needed to support optional 3rd party libraries]
typeNotExposedToWeaver [needed to support optional 3rd party libraries]
unmatchedSuperTypeInCall [these are of course valid and intended to not match]
adviceDidNotMatch [ditto]
runtimeExceptionNotSoftened [I don't want to soften runtime exceptions]

Of course cantFindType/cantFindTypeAffectingJPMatch are the subject of a different bugzilla issue.</comment>
		<comment id="10" date="2006-08-23 08:02:43 EDT" author="Matthew Webster">I have gone for the approach in Comment #2 although there is not yet support for dumping configuration information by default at the first error. This should reduce the amount of output generated when just trying to obtain configuration information.

&gt;Why not something like -Dorg.aspectj.weaver.level=[none|summary|info|verbose]
Unfortunately we don't yet have the concept of "levels": weaveInfo is completely separate although you coud imagine: default(warning &amp; error), -verbose(info), -debug(debug) -showWeaveInfo(weaveInfo) with one automatically including those above. Of course this only applies to the default WeavingAdaptorMessageWriter and you are free to supply you own.</comment>
		<comment id="11" date="2006-08-23 08:18:32 EDT" author="Matthew Webster">&gt;... A quick look
&gt;through the loadtime module shows a few other candidates:
&gt;* warnings for missing DTD's (dumped directly to syserr in DocumentParser)

Are you referring to DocumentParser. resolveEntity() in which case do you have a situation where this arised so that I can write a test. Or are you referring to this type of Exception which is thrown for badly formed aop.xml and for which we issue a warning (not error) but the stack trace is dumped by default:

[AppClassLoader@9627532] warning parse definitions failed -- (SAXParseException) The element type "concrete-aspect" must be terminated by the matching end-tag "&lt;/concrete-aspect&gt;".
The element type "concrete-aspect" must be terminated by the matching end-tag "&lt;/concrete-aspect&gt;".
org.xml.sax.SAXParseException: The element type "concrete-aspect" must be terminated by the matching end-tag "&lt;/concrete-aspect&gt;".
  at com.sun.org.apache.xerces.internal.util.ErrorHandlerWrapper.createSAXParseException(ErrorHandlerWrapper.java:236)
  at com.sun.org.apache.xerces.internal.util.ErrorHandlerWrapper.fatalError(ErrorHandlerWrapper.java:215)
  at com.sun.org.apache.xerces.internal.impl.XMLErrorReporter.reportError(XMLErrorReporter.java:386)
â¦</comment>
		<comment id="12" date="2006-08-23 13:33:12 EDT" author="Ron Bodkin">I was indeed referring to DocumentParser.resolveEntity. I believe you could trigger one warning by writing an aop.xml file with an unknown DTD (e.g., -//AspectJ//DTD 1.5.3//EN). The other one would be hard to test: you'd need a configuration where the weaving agent is unable to read the aspectj_1_5_0.dtd resource (which would be a broken one!)

I noticed these warnings from reviewing the code when you asked what other warnings might need to be supressed. But in general, neither of these two warnings should be suppressed. If we add another version of the DTD then the weaver should continue to be backwards-compatible and support the old ones...</comment>
		<comment id="13" date="2006-08-24 08:10:52 EDT" author="Matthew Webster">Leaving this one for now until after I have investigated the use of ajcore for FFDC.</comment>
      </comments>
    </buginformation>
    <fixedCommits>
      <commit Id="8549d861b124c20eba114b658e886bfbaf5d231c" author="mwebster" date="2006-08-23 08:52:22"/>
          <file name="loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java">
              <method name="defineClass" returnType="void" parameters="ClassLoader String byte[]"/>
          </file>
          <file name="loadtime/src/org/aspectj/weaver/loadtime/DefaultMessageHandler.java">
          </file>
          <file name="loadtime/src/org/aspectj/weaver/loadtime/Options.java">
          </file>
          <file name="tests/java5/ataspectj/ataspectj/TestHelper.java">
          </file>
          <file name="weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java">
              <method name="weaveClass" returnType="byte[]" parameters="String byte[]"/>
          </file>
      </commit>
    </fixedCommits>
  </bug>
</bugrepository>
